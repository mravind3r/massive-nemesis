<?xml version="1.0" encoding="utf-8"?>
<posthistory>
  <row Id="1" PostHistoryTypeId="2" PostId="1" RevisionGUID="900ec8dc-5b90-48ab-a242-db5b39d6e82c" CreationDate="2014-02-11T22:24:09.530" UserId="3" Text="I'm making a simple Arduino webserver and I want to make it turned on everytime. So it must endure to stay working all time. &#xD;&#xA;&#xD;&#xA;I'm using an Arduino Uno with a Ethernet Shield.&#xD;&#xA;It's powered with a simple outlet power supply 5V @ 1A.&#xD;&#xA;&#xD;&#xA;Have some problem to stay Arduino turned on all time? Maybe some other Arduino its better recommended? Have something that I need to take care about it?" />
  <row Id="2" PostHistoryTypeId="1" PostId="1" RevisionGUID="900ec8dc-5b90-48ab-a242-db5b39d6e82c" CreationDate="2014-02-11T22:24:09.530" UserId="3" Text="Is an Arduino capable of running 24/7?" />
  <row Id="3" PostHistoryTypeId="3" PostId="1" RevisionGUID="900ec8dc-5b90-48ab-a242-db5b39d6e82c" CreationDate="2014-02-11T22:24:09.530" UserId="3" Text="&lt;arduino-uno&gt;&lt;web-server&gt;&lt;ethernet&gt;" />
  <row Id="4" PostHistoryTypeId="2" PostId="2" RevisionGUID="85343acc-70b8-4fc5-960d-664fbbd659cf" CreationDate="2014-02-11T22:36:57.700" UserId="11" Text="You shouldn't have any issues keeping it on all the time, however, some thing to consider is any counters you may have, like the use of `millis()`.&#xD;&#xA;&#xD;&#xA;From the [Arduino docs on millis][1]:&#xD;&#xA;&#xD;&#xA;&gt; This number will overflow (go back to zero), after approximately 50 days.&#xD;&#xA;&#xD;&#xA;So for projects that are on for long periods of time, you may not see an issue immediately but something like this could pop up and cause errors down the road.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/millis" />
  <row Id="5" PostHistoryTypeId="2" PostId="3" RevisionGUID="1f0d8aa4-3917-4800-a130-c22ce13df7b6" CreationDate="2014-02-11T22:40:22.503" UserId="13" Text="A couple of things to keep in mind (outside of @Sachleen's mention of Milli's): &#xD;&#xA;&#xD;&#xA;- Like any electronics, heat can be disruptive. The micro-controller itself isn't likely going to be a huge issue from the perspective of heat, but other components like the power supply might cause issues. &#xD;&#xA;&#xD;&#xA;- If your code uses [EEPROMWrite](http://arduino.cc/en/Reference/EEPROMWrite), be aware that the EEPROM is only rated for something in the neighbourhood of 100,000k writes. " />
  <row Id="6" PostHistoryTypeId="2" PostId="4" RevisionGUID="fc30cf76-4827-47c5-9c42-bf9681707f97" CreationDate="2014-02-11T22:43:08.173" UserId="8" Text="Put plainly: is there a way to get an HTTPS connection on the Arduino?&#xD;&#xA;&#xD;&#xA; I have been looking in to it, and I have found it is impossible with the standard library and the Ethernet shield, but is there a custom library that can do it? &#xD;&#xA;&#xD;&#xA;What about a coprocessor, i.e. like the WiFi shield has? Anyone know if the Arduino yún has ssl?" />
  <row Id="7" PostHistoryTypeId="1" PostId="4" RevisionGUID="fc30cf76-4827-47c5-9c42-bf9681707f97" CreationDate="2014-02-11T22:43:08.173" UserId="8" Text="How to get HTTPS on Arduino?" />
  <row Id="8" PostHistoryTypeId="3" PostId="4" RevisionGUID="fc30cf76-4827-47c5-9c42-bf9681707f97" CreationDate="2014-02-11T22:43:08.173" UserId="8" Text="&lt;ethernet&gt;&lt;web&gt;&lt;arduino-yun&gt;&lt;http&gt;" />
  <row Id="9" PostHistoryTypeId="2" PostId="5" RevisionGUID="8d270dc9-73e7-4f46-a8b8-a606e62f85ba" CreationDate="2014-02-11T22:47:07.610" UserId="24" Text="Running the Arduino 24/7 Shouldn't be a problem.&#xD;&#xA;&#xD;&#xA;But be sure that you have a case that allows for ventilation and you keep it in a well ventilated area. Just like computers, if you do not keep them in an environment that can keep them cool, they will not stay cool. &#xD;&#xA;&#xD;&#xA;Server load also should be a thing to consider, the more load there is on the server the more processing it has to do, and the more heat it will generate." />
  <row Id="10" PostHistoryTypeId="2" PostId="6" RevisionGUID="b348a45f-6312-498e-b4ab-798af66cce81" CreationDate="2014-02-11T22:48:30.837" UserId="11" Text="For solar &amp; battery powered projects, decreasing power consumption is a necessity.&#xD;&#xA;&#xD;&#xA;I know a little bit about using a timer and interrupt to put the microcontroller into sleep when it isn't doing anything.&#xD;&#xA;&#xD;&#xA;I have also read that you can disable some peripherals to further save power.&#xD;&#xA;&#xD;&#xA;Here is a page explaining these: [Power Saving Techniques][1]&#xD;&#xA;&#xD;&#xA;My question:&#xD;&#xA;&#xD;&#xA;* What other techniques are there to save power?&#xD;&#xA;* Are there any libraries that make using these AVR features easier?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino720.wikispaces.com/Power+Saving+Techniques" />
  <row Id="11" PostHistoryTypeId="1" PostId="6" RevisionGUID="b348a45f-6312-498e-b4ab-798af66cce81" CreationDate="2014-02-11T22:48:30.837" UserId="11" Text="What are (or how do I use) the power saving options of the Arduino to extend battery life?" />
  <row Id="12" PostHistoryTypeId="3" PostId="6" RevisionGUID="b348a45f-6312-498e-b4ab-798af66cce81" CreationDate="2014-02-11T22:48:30.837" UserId="11" Text="&lt;power&gt;&lt;battery&gt;" />
  <row Id="13" PostHistoryTypeId="2" PostId="7" RevisionGUID="e98177df-2d97-4191-aba1-119397071f72" CreationDate="2014-02-11T22:50:23.247" UserId="28" Text="Arduinos can run without issues for a really long time, though depending on local conditions and the intensity of computation you may have to attach heat sinks.&#xD;&#xA;&#xD;&#xA;In addition, keep it well ventilated.&#xD;&#xA;&#xD;&#xA;It depends on the program being used, too, if your server is serving a page every now and then, it shouldn't be an issue, but if you expect constant traffic then the Arduino may heat up quickly.&#xD;&#xA;&#xD;&#xA;You'll also want to ensure stability of power supply, when running benchtop experiments with an Arduino this isn't a big issue, bit it can become an issue if transforming power from the mains for a permanent fixture." />
  <row Id="14" PostHistoryTypeId="2" PostId="8" RevisionGUID="cdf2d71c-e6a8-4898-86f2-88f1cf6d2572" CreationDate="2014-02-11T22:53:10.947" UserId="24" Text="I don't think it is possible due to the size and complexity of the SSL Library, because the Arduino would most likely be under powered. That being said you could make the requests to a regular server and use some sort of PHP script to proxy the request to the HTTPS server. Not sure how well it would work though.&#xD;&#xA;&#xD;&#xA;You may be interested into looking at [this][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.abdulqabiz.com/blog/archives/2007/05/31/php-proxy-script-for-cross-domain-requests/" />
  <row Id="15" PostHistoryTypeId="2" PostId="9" RevisionGUID="5bce1aec-89c6-480a-bd1f-4d1c97c15d35" CreationDate="2014-02-11T22:54:56.157" UserId="8" Text="Keep in mind that the  flash and EEPROM have limited lifetimes (about 10,000 read/write cycles) so if you're doing a lot of reading and writing to those, they may become corrupted. In a test I did, an external EEPROM took about 3 days to start becoming corrupted." />
  <row Id="16" PostHistoryTypeId="2" PostId="10" RevisionGUID="d8555363-5adc-47a7-873d-7dcc50a024b2" CreationDate="2014-02-11T23:00:13.753" UserId="8" Text="You could read through the 200-page datasheet, and then mess with some confusing bit shifts and registers, but I recommend this library: http://playground.arduino.cc/Code/Enerlib" />
  <row Id="17" PostHistoryTypeId="2" PostId="11" RevisionGUID="40cd4111-b71b-4d89-9a1c-f7962a5b040f" CreationDate="2014-02-11T23:00:44.073" UserId="27" Text="MCU mounted on Arduinos don't have the horse power to handle https connections.&#xD;&#xA;&#xD;&#xA;Yún does handle https **on the linux side**, with software like curl, wget or python. Your sketch can just delegate the task to the linux side.&#xD;&#xA;&#xD;&#xA;While curl works fine, despite having python preinstalled, you need to manually install python-openssl, since it's not available out of the box (due to disk space constraints)" />
  <row Id="19" PostHistoryTypeId="5" PostId="10" RevisionGUID="f821131e-d007-4c89-a32d-4a1d662152c5" CreationDate="2014-02-11T23:06:51.677" UserId="8" Comment="added suggestion about disabling usb-serial chip" Text="You could read through the 200-page datasheet, and then mess with some confusing bit shifts and registers, but I recommend this library: http://playground.arduino.cc/Code/Enerlib&#xD;&#xA;&#xD;&#xA;Also, if you're using an Uno or any one with a usb-to-serial chip, you could disable that or remove it." />
  <row Id="20" PostHistoryTypeId="5" PostId="11" RevisionGUID="bf51dc3d-0515-450e-a78a-5b51e5ea9246" CreationDate="2014-02-11T23:08:21.117" UserId="27" Comment="added 1 characters in body" Text="MCUs mounted on Arduinos don't have the horse power to handle https connections.&#xD;&#xA;&#xD;&#xA;Yún does handle https **on the linux side**, with software like curl, wget or python. Your sketch can just delegate the task to the linux side.&#xD;&#xA;&#xD;&#xA;While curl works fine, despite having python preinstalled, you need to manually install python-openssl, since it's not available out of the box (due to disk space constraints)" />
  <row Id="21" PostHistoryTypeId="2" PostId="12" RevisionGUID="b48e2f86-5581-4294-866e-67a3c31bfc41" CreationDate="2014-02-11T23:10:53.907" UserId="24" Text="Is it possible to upgrade the firmware on an Arduino so that it can do more things such as change undervolting/ overvolting in order to provide more processing power. To do this you would have to most likely re flash the chip itself, so how would that be accomplished?" />
  <row Id="22" PostHistoryTypeId="1" PostId="12" RevisionGUID="b48e2f86-5581-4294-866e-67a3c31bfc41" CreationDate="2014-02-11T23:10:53.907" UserId="24" Text="Installing a different firmware on Arduino" />
  <row Id="23" PostHistoryTypeId="3" PostId="12" RevisionGUID="b48e2f86-5581-4294-866e-67a3c31bfc41" CreationDate="2014-02-11T23:10:53.907" UserId="24" Text="&lt;arduino-uno&gt;&lt;firmware&gt;" />
  <row Id="24" PostHistoryTypeId="2" PostId="13" RevisionGUID="90d8e658-3f62-4092-8028-c53e063b2257" CreationDate="2014-02-11T23:44:46.803" UserId="36" Text="Is it possible to run Linux on Arduino? If yes, what steps and limitations need to be considered? If not, what are the limitations that prevent this?" />
  <row Id="25" PostHistoryTypeId="1" PostId="13" RevisionGUID="90d8e658-3f62-4092-8028-c53e063b2257" CreationDate="2014-02-11T23:44:46.803" UserId="36" Text="What does it take to compile linux on arduino, if at all possible?" />
  <row Id="26" PostHistoryTypeId="3" PostId="13" RevisionGUID="90d8e658-3f62-4092-8028-c53e063b2257" CreationDate="2014-02-11T23:44:46.803" UserId="36" Text="&lt;linux&gt;" />
  <row Id="27" PostHistoryTypeId="2" PostId="14" RevisionGUID="a09d6147-b4c9-486e-84fd-bacfa5d735b1" CreationDate="2014-02-11T23:57:39.350" UserId="8" Text="I have an Arduino Yún, and it only has 16mb flash onboard for the Linux. I was wondering of it is possible to put a bootloader on the flash that uses the sd card as a rootfs? i want to be able to do more projects on it than those that can fit in 16 MB flash." />
  <row Id="28" PostHistoryTypeId="1" PostId="14" RevisionGUID="a09d6147-b4c9-486e-84fd-bacfa5d735b1" CreationDate="2014-02-11T23:57:39.350" UserId="8" Text="Yún boot from SD card" />
  <row Id="29" PostHistoryTypeId="3" PostId="14" RevisionGUID="a09d6147-b4c9-486e-84fd-bacfa5d735b1" CreationDate="2014-02-11T23:57:39.350" UserId="8" Text="&lt;arduino-yun&gt;&lt;linux&gt;&lt;bootloader&gt;" />
  <row Id="30" PostHistoryTypeId="2" PostId="15" RevisionGUID="511624ac-b7cd-4ea6-9646-7307c5206d40" CreationDate="2014-02-12T00:01:07.400" UserId="-1" Text="" />
  <row Id="31" PostHistoryTypeId="2" PostId="16" RevisionGUID="a7b2cc2a-56c3-42a3-a411-6f148cc70c24" CreationDate="2014-02-12T00:01:07.400" UserId="-1" Text="" />
  <row Id="33" PostHistoryTypeId="2" PostId="17" RevisionGUID="6ddea056-7d90-4b2c-b1a0-e4d128efd857" CreationDate="2014-02-12T00:08:14.933" UserId="37" Text="Whenever I try to upload a program to my Arduino, I get this error message:&#xD;&#xA;&#xD;&#xA;&gt; avrdude: stk500_getsync(): not in sync: resp=0x00&#xD;&#xA;&#xD;&#xA;What does this mean, and how can I fix it?" />
  <row Id="34" PostHistoryTypeId="1" PostId="17" RevisionGUID="6ddea056-7d90-4b2c-b1a0-e4d128efd857" CreationDate="2014-02-12T00:08:14.933" UserId="37" Text="&quot;avrdude: stk500_getsync(): not in sync: resp=0x00&quot; when attempting to upload" />
  <row Id="35" PostHistoryTypeId="3" PostId="17" RevisionGUID="6ddea056-7d90-4b2c-b1a0-e4d128efd857" CreationDate="2014-02-12T00:08:14.933" UserId="37" Text="&lt;uploading&gt;&lt;connection&gt;" />
  <row Id="36" PostHistoryTypeId="2" PostId="18" RevisionGUID="8a5bf82c-7b1d-4b5a-b076-38af4f29307c" CreationDate="2014-02-12T00:08:14.933" UserId="37" Text="This is caused by a connection error between your computer and the Arduino, and can result from many different specific problems. Here are some things that can fix this error:&#xD;&#xA;&#xD;&#xA; - Disconnect and reconnect the USB cable.&#xD;&#xA; - Use a different USB cable.&#xD;&#xA; - Press the reset button on the board.&#xD;&#xA; - Make sure you select the right board in `Tools ► Board ►`, e.g. If you are using the Duemilanove 328, select that instead of Duemilanove 128. The board should say what version it is on the microchip.&#xD;&#xA; - Make sure you selected the right port in `Tools ► Serial Port ►`. In extreme cases, you may need to burn the bootloader. There is a good guide on how to do that here: http://arduino.cc/en/Hacking/Bootloader?from=Main.Bootloader.&#xD;&#xA; - Restart the Arduino IDE." />
  <row Id="37" PostHistoryTypeId="2" PostId="19" RevisionGUID="238d34df-9366-4098-9e8b-b57bfc053965" CreationDate="2014-02-12T00:11:57.577" UserId="8" Text="Linux is a very complex operating system, but it may be able to fit on an arduino. things to consider:&#xD;&#xA;&#xD;&#xA;* There is no current AVR port of the source code&#xD;&#xA;* You would have no graphics, instead access the terminal over UART.&#xD;&#xA;* The filesystem driver would have to be rewritten to access internal flash or an external SD card&#xD;&#xA;* It would be _extremely_ slow! the AtMega328 would run at 16mHz, or about 20mHz max (overclocked)&#xD;&#xA;* You would probably need some extra ram, probably a good idea to use an AtMega2650 (the one in the mega) which has 16x the ram of the Uno. You could also use a Due (6x as fast as the Uno, more ram)&#xD;&#xA;* You may have to write special USB drivers for OTG (on the due) or MAX3421EE (Mega ADK, USB host shield)&#xD;&#xA;&#xD;&#xA;In short, it would take _a lot_ of time and effort, and probably would be too slo for everyday use. If you really want Arduino Linux, check out the Yún." />
  <row Id="38" PostHistoryTypeId="2" PostId="20" RevisionGUID="a376d618-c06a-4e42-854e-075872aea4fd" CreationDate="2014-02-12T00:12:59.517" UserId="28" Text="It just doesn't have enough RAM. You'd also need to teach it to boot from flash memory, which would involve rewriting the bootloader.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;You can instead use an [Arduino Yun][1] or a [PCDuino][2]; while not &quot;standard&quot; Ardunios these support Arduino shields and run Linux.&#xD;&#xA;&#xD;&#xA;Or there's always the [Raspberry Pi][3].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardYun?from=Main.ArduinoYUN&#xD;&#xA;  [2]: http://www.pcduino.com/&#xD;&#xA;  [3]: http://www.raspberrypi.org/" />
  <row Id="39" PostHistoryTypeId="2" PostId="21" RevisionGUID="5da1382a-f128-448c-a4b8-504a1f30953c" CreationDate="2014-02-12T00:15:36.627" UserId="8" Text="If none of the above steps work, try reinstalling Avrdude and the avr-gcc compiler. I had to do this after my Mega started suffering from this.&#xD;&#xA;&#xD;&#xA;If you installed Avrdude and avr-gcc separately, simply uninstall them. if not, you may have to reinstall the Arduino IDE. These steps will depend on your operating system." />
  <row Id="40" PostHistoryTypeId="2" PostId="22" RevisionGUID="39ac8dc2-c948-424a-a225-fa2a98851ad0" CreationDate="2014-02-12T00:20:15.987" UserId="46" Text="Unfortunately, it can also mean that you burned your microcontroller. Were you doing anything dangerous right before you tried to upload a new sketch? Is the microcontroller still working, with its previously loaded sketch?" />
  <row Id="41" PostHistoryTypeId="5" PostId="15" RevisionGUID="ac12b29c-67b2-4e22-83f2-b4391015089c" CreationDate="2014-02-12T00:22:56.180" UserId="8" Comment="added 689 characters in body" Text="The Arduino Uno is a microcontroller board based on the ATmega328. It has 14 digital input/output pins (of which 6 can be used as PWM outputs), 6 analog inputs, a 16 MHz ceramic resonator, a USB connection, a power jack, an ICSP header, and a reset button. It contains everything needed to support the microcontroller; simply connect it to a computer with a USB cable or power it with a AC-to-DC adapter or battery to get started.&#xD;&#xA;The Uno differs from all preceding boards in that it does not use the FTDI USB-to-serial driver chip. Instead, it features the Atmega16U2 (Atmega8U2 up to version R2) programmed as a USB-to-serial converter.&#xD;&#xA;&#xD;&#xA;From http://arduino.cc/en/Main/ArduinoBoardUno" />
  <row Id="42" PostHistoryTypeId="24" PostId="15" RevisionGUID="ac12b29c-67b2-4e22-83f2-b4391015089c" CreationDate="2014-02-12T00:22:56.180" Comment="Proposed by 8 approved by 48 edit id of 1" />
  <row Id="43" PostHistoryTypeId="2" PostId="23" RevisionGUID="56ad15ed-6104-4f63-bc9e-1420c4999eeb" CreationDate="2014-02-12T00:25:43.427" UserId="-1" Text="" />
  <row Id="44" PostHistoryTypeId="2" PostId="24" RevisionGUID="29a0687f-847c-47ae-8631-16e996a24d16" CreationDate="2014-02-12T00:25:43.427" UserId="-1" Text="" />
  <row Id="45" PostHistoryTypeId="5" PostId="3" RevisionGUID="52f8cca8-eaa5-4af1-ae2d-4d1d56bfa0a5" CreationDate="2014-02-12T00:37:44.657" UserId="13" Comment="Removed kilo--- is 100K writes, or 100,000, not 100,000k! " Text="A couple of things to keep in mind (outside of @Sachleen's mention of Milli's): &#xD;&#xA;&#xD;&#xA;- Like any electronics, heat can be disruptive. The micro-controller itself isn't likely going to be a huge issue from the perspective of heat, but other components like the power supply might cause issues. &#xD;&#xA;&#xD;&#xA;- If your code uses [EEPROMWrite](http://arduino.cc/en/Reference/EEPROMWrite), be aware that the EEPROM is only rated for something in the neighbourhood of 100,000 writes. " />
  <row Id="46" PostHistoryTypeId="5" PostId="23" RevisionGUID="6733594f-9bb8-4a71-9cf9-a75035fe8e65" CreationDate="2014-02-12T00:37:50.360" UserId="8" Comment="added 493 characters in body" Text="The Arduino Yún is a microcontroller board based on the ATmega32u4 and the Atheros AR9331. The Atheros processor supports a Linux distribution based on OpenWRT named Linino. The board has built-in Ethernet and WiFi support, a USB-A port, micro-SD card slot, 20 digital input/output pins (of which 7 can be used as PWM outputs and 12 as analog inputs), a 16 MHz crystal oscillator, a micro USB connection, an ICSP header, and a 3 reset buttons.&#xD;&#xA;&#xD;&#xA;From http://arduino.cc/en/Main/ArduinoBoardYun" />
  <row Id="47" PostHistoryTypeId="24" PostId="23" RevisionGUID="6733594f-9bb8-4a71-9cf9-a75035fe8e65" CreationDate="2014-02-12T00:37:50.360" Comment="Proposed by 8 approved by 48 edit id of 3" />
  <row Id="48" PostHistoryTypeId="2" PostId="25" RevisionGUID="6e7acb87-633f-42da-ba90-c19901a28ccf" CreationDate="2014-02-12T00:49:24.257" UserId="46" Text="I have an original Arduino UNO R3 that I bought and an [Arduino Severino (S3V3)](http://arduino.cc/en/Main/ArduinoBoardSerialSingleSided3) that I've built.&#xD;&#xA;&#xD;&#xA;I have no problems uploading sketches to the UNO, but sometimes, when uploading to the Severino board, I have to hard reset it at a specific time during the upload process, when the IDE says something like this below:&#xD;&#xA;&#xD;&#xA;	avrdude: Version 5.11, compiled on Sep  2 2011 at 19:38:36&#xD;&#xA;			 Copyright (c) 2000-2005 Brian Dean, http://www.bdmicro.com/&#xD;&#xA;			 Copyright (c) 2007-2009 Joerg Wunsch&#xD;&#xA;&#xD;&#xA;			 System wide configuration file is &quot;C:\Users\Larissa\Documents\Ricardo\Eletronica\arduino-1.0.3\hardware/tools/avr/etc/avrdude.conf&quot;&#xD;&#xA;&#xD;&#xA;			 Using Port                    : \\.\COM1&#xD;&#xA;			 Using Programmer              : arduino&#xD;&#xA;			 Overriding Baud Rate          : 115200&#xD;&#xA;	avrdude: Send: 0 [30]   [20] &#xD;&#xA;	avrdude: Send: 0 [30]   [20] &#xD;&#xA;	avrdude: Send: 0 [30]   [20] &#xD;&#xA;&#xD;&#xA;If I don't reset it when one of the `Send` messages are being displayed, I get the `not in sync` message, as below:&#xD;&#xA;&#xD;&#xA;	avrdude: Recv: &#xD;&#xA;	avrdude: stk500_getsync(): not in sync: resp=0x00&#xD;&#xA;&#xD;&#xA;Other times, if I'm lucky, I can upload to the Severino board without having to reset it.&#xD;&#xA;&#xD;&#xA;So, my questions are:&#xD;&#xA;&#xD;&#xA;1. **Why does that happen? Why Severino needs a hard reset during upload?**&#xD;&#xA;&#xD;&#xA;1. **Why is the problem intermitent?** Why does it happen sometimes and others it doesn't?&#xD;&#xA;&#xD;&#xA;1. **How can I fix that problem?** Is there a simple change to the Severino design that would fix that?&#xD;&#xA;" />
  <row Id="49" PostHistoryTypeId="1" PostId="25" RevisionGUID="6e7acb87-633f-42da-ba90-c19901a28ccf" CreationDate="2014-02-12T00:49:24.257" UserId="46" Text="Why Arduino Severino (S3V3) sometimes needs reseting when uploading a sketch?" />
  <row Id="50" PostHistoryTypeId="3" PostId="25" RevisionGUID="6e7acb87-633f-42da-ba90-c19901a28ccf" CreationDate="2014-02-12T00:49:24.257" UserId="46" Text="&lt;severino&gt;&lt;reset&gt;" />
  <row Id="51" PostHistoryTypeId="2" PostId="26" RevisionGUID="9bf5fb67-f40f-40b4-8fbd-af90d4576584" CreationDate="2014-02-12T01:10:46.997" UserId="46" Text="The strangest thing is happening to a standalone Arduino board that I designed and built. The board (whose schematics are below) has the following features:&#xD;&#xA;&#xD;&#xA;1. It has a ATmega328P with a 5V voltage regulator and usual circuitry when set up as a standalone controller. &#xD;&#xA;1. It controls a scoreboard with several 7-display digits linked through the connectors on the right (JP1 through JP12). &#xD;&#xA;1. It has cursor buttons decoded using a voltage ladder through ANALOG_0 (A0).&#xD;&#xA;1. It has a Real Time Clock to keep time when it's turned off.&#xD;&#xA;1. It has an RF receiver module.&#xD;&#xA;1. It has a UART header (JP17) so I can program the board using a serial port.&#xD;&#xA;1. It has a speaker attached to digital pin 3 (D3). &#xD;&#xA;&#xD;&#xA;![Controller schematics][1]&#xD;&#xA;&#xD;&#xA;I upload sketches to it using a RS232-to-TTL adapter that I've also built (schematics also below) and a Serial-to-USB cable. When programming it, the board behaves much like a [Severino board](http://arduino.cc/en/Main/ArduinoBoardSerialSingleSided3).&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;What's strange is that, when I upload a sketch, the process is paused in the middle and then the speaker starts to beep continually. When I press reset on the board, the beep stops, the upload continues and the sketch is uploaded successfully to the board.&#xD;&#xA;&#xD;&#xA;So, my questions are:&#xD;&#xA;&#xD;&#xA;1. **What is making the upload process pause?**&#xD;&#xA;2. **Why is the buzzer beeping when the process pauses?**&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/21kgT.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/h3HJq.png" />
  <row Id="52" PostHistoryTypeId="1" PostId="26" RevisionGUID="9bf5fb67-f40f-40b4-8fbd-af90d4576584" CreationDate="2014-02-12T01:10:46.997" UserId="46" Text="Custom Arduino board beeps and process freezes while I'm uploading a sketch to it. Why?" />
  <row Id="53" PostHistoryTypeId="3" PostId="26" RevisionGUID="9bf5fb67-f40f-40b4-8fbd-af90d4576584" CreationDate="2014-02-12T01:10:46.997" UserId="46" Text="&lt;severino&gt;&lt;serial&gt;" />
  <row Id="54" PostHistoryTypeId="2" PostId="27" RevisionGUID="8c71de7a-1abd-46c3-8633-9032d453342e" CreationDate="2014-02-12T01:34:28.287" UserId="59" Text="I've made a clock using an Arduino, but the time seems to drift.  I am aware of the [rollover](https://arduino.stackexchange.com/questions/1/is-an-arduino-capable-of-running-24-7/2#2) issue; the clock seems to drift by about 15 minutes over the course of a week.&#xD;&#xA;&#xD;&#xA;I'm using a custom PCB with [this resonator](http://www.digikey.com/product-search/en/crystals-and-oscillators/resonators/852887?k=x908-nd) from Digi-key.  The code reads the millis() function at the beginning of each loop, and works from that value.&#xD;&#xA;&#xD;&#xA;My question is:  How can I measure time with an Arduino, accurately enough to make a passable desk clock?" />
  <row Id="55" PostHistoryTypeId="1" PostId="27" RevisionGUID="8c71de7a-1abd-46c3-8633-9032d453342e" CreationDate="2014-02-12T01:34:28.287" UserId="59" Text="How do I get an accurate time?" />
  <row Id="56" PostHistoryTypeId="3" PostId="27" RevisionGUID="8c71de7a-1abd-46c3-8633-9032d453342e" CreationDate="2014-02-12T01:34:28.287" UserId="59" Text="&lt;time&gt;&lt;millis&gt;" />
  <row Id="57" PostHistoryTypeId="2" PostId="28" RevisionGUID="43aaf9ba-fc88-4905-be2a-e5fe273f2382" CreationDate="2014-02-12T01:37:23.670" UserId="25" Text="I have been able to connect MATLAB to my Arduino-uno with this line of code: `a = arduino('COM4');` through this package: [Matlab support package for Arduino][1].&#xD;&#xA;&#xD;&#xA;Right now, MATLAB is my main script that will synchronize all the components [like the `Arduino`].&#xD;&#xA;&#xD;&#xA;I am able to send pulses to my stepper-motor just by using:&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;        digitalWrite(2, HIGH);&#xD;&#xA;        delay(1);&#xD;&#xA;        digitalWrite(2, LOW);&#xD;&#xA;        delay(1);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This works fine, and will make the motor move about once every 2 milliseconds. My problem is that I cannot find a way to produce this same delay through MATLAB's interface. I do know that MATLAB has a `pause()` function, but when I set up a loop in MATLAB like this:&#xD;&#xA;&#xD;&#xA;    a = arduino('COM4');&#xD;&#xA;    for m = 1:400&#xD;&#xA;        a.digitalWrite(2, 1);&#xD;&#xA;        pause(0.001);&#xD;&#xA;        a.digitalWrite(2, 0);&#xD;&#xA;        pause(0.001);&#xD;&#xA;    end&#xD;&#xA;&#xD;&#xA;Each step takes WAY longer - about 200 milliseconds each.&#xD;&#xA;&#xD;&#xA;What are other options for creating the pause between digital High / Low being sent to the Arduino? It would be nice if I could control the outcome from Matlab, through Arduino.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.mathworks.com/matlabcentral/fileexchange/32374-matlab-support-package-for-arduino-aka-arduinoio-package" />
  <row Id="58" PostHistoryTypeId="1" PostId="28" RevisionGUID="43aaf9ba-fc88-4905-be2a-e5fe273f2382" CreationDate="2014-02-12T01:37:23.670" UserId="25" Text="How to pause Arduino for 1 millisecond through MATLAB?" />
  <row Id="59" PostHistoryTypeId="3" PostId="28" RevisionGUID="43aaf9ba-fc88-4905-be2a-e5fe273f2382" CreationDate="2014-02-12T01:37:23.670" UserId="25" Text="&lt;arduino-uno&gt;&lt;matlab&gt;" />
  <row Id="60" PostHistoryTypeId="2" PostId="29" RevisionGUID="28a61309-9220-4643-bdb8-4becfdd40e0c" CreationDate="2014-02-12T01:48:43.063" UserId="62" Text="I've never ran an Arduino for that long, but there shouldn't be a problem. One thing to watch out for is the input voltage.&#xD;&#xA;&#xD;&#xA;While an Arduino is capable of handling 7-20v as input anything over 12v can overheat after longer periods of time and cause board damage. As a quick recommendation to avoid any overheating of the Arduino I would keep the voltage as close to 7v as possible." />
  <row Id="61" PostHistoryTypeId="2" PostId="30" RevisionGUID="b63bb141-64fd-45b1-b26d-1c8829d2f829" CreationDate="2014-02-12T01:50:03.943" UserId="60" Text="Note the below chart, in regard to your under/over volting the device for different F_CPU, indicates the relationship. As a result you find most Arduino's run at 5V and a clock rate of 16MHz. While there are some 3.3V variants that run at 8MHz. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![Freq vs Vcc][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/qS5z1.png&#xD;&#xA;&#xD;&#xA;However, the core library provided with the IDE typically has specific #if's for both 8 and 16 MHz F_CPU speeds, not using a formula in most places.&#xD;&#xA;&#xD;&#xA;Hence it is possible to do what you ask. However, you will find the core library limitations affecting. Tipping the cost vs benefit ratio, to that of the very intent. And then likely one would leave the Stock IDE and core libraries to a more makefile method." />
  <row Id="62" PostHistoryTypeId="2" PostId="31" RevisionGUID="108f9a73-98f2-4fea-b16a-273e66ce1893" CreationDate="2014-02-12T01:53:50.100" UserId="46" Text="There are several techniques to make an Arduino save power. I'll list a few and then point you to a page that explains them all in more detail.&#xD;&#xA;&#xD;&#xA;1. While the controller isn't doing anything important (between one read of a sensor and the next, for example), you can put the controller into one of the sleep modes below, with the command `set_sleep_mode (SLEEP_MODE_PWR_DOWN)`. Next to each mode is the approximate power consumption of each mode. &#xD;&#xA;&#xD;&#xA;* SLEEP_MODE_IDLE: 15 mA&#xD;&#xA;* SLEEP_MODE_ADC: 6.5 mA&#xD;&#xA;* SLEEP_MODE_PWR_SAVE: 1.62 mA&#xD;&#xA;* SLEEP_MODE_EXT_STANDBY: 1.62 mA&#xD;&#xA;* SLEEP_MODE_STANDBY : 0.84 mA&#xD;&#xA;* SLEEP_MODE_PWR_DOWN : 0.36 mA&#xD;&#xA;&#xD;&#xA;1. Disable **brown-out detection** (the circuitry that turns off the controller when low voltage is detected).&#xD;&#xA;&#xD;&#xA;1. Turn off ADC (analog to digita conversion)&#xD;&#xA;&#xD;&#xA;1. Use the internal clock&#xD;&#xA;&#xD;&#xA;Then, when you put the controller to sleep, you need to use one or more mechanisms below to wake up the controller and do something with it:&#xD;&#xA;&#xD;&#xA;* Wake up with a signal&#xD;&#xA;&#xD;&#xA;* Wake up with a timer&#xD;&#xA;&#xD;&#xA;This is a summary I made from [this webpage](http://www.gammon.com.au/forum/?id=11497).&#xD;&#xA;&#xD;&#xA;That article applies mostly to ATmega328P, but the technique applies to other Arduino compatible controllers as well. As TheDoctor said well, you will need to check the datashet to make sure your controller suports any of those techniques and how to do it more precisely.&#xD;&#xA;" />
  <row Id="63" PostHistoryTypeId="2" PostId="32" RevisionGUID="16af62c8-5cdf-4511-a0d1-8d71cfe8639f" CreationDate="2014-02-12T02:07:08.230" UserId="46" Text="I've been quite successful in using the DS1307 Real Time Clock. Here's a link to its [datasheet][1].&#xD;&#xA;&#xD;&#xA;Below are some of its features:&#xD;&#xA;&#xD;&#xA;* It uses I&lt;super&gt;&lt;/super&gt;C interface for communication with Arduino, making it easy to program using the right libraries (available on the Net).&#xD;&#xA;&#xD;&#xA;* It is connected to Arduino through the SCL and SDA pins (analog A4 and A5 respectively), thus only using 2 pins.&#xD;&#xA;&#xD;&#xA;* It requires very little external components to run.&#xD;&#xA;&#xD;&#xA;* IT can be connected to a coin cell battery so it will keep time even while the Arduino is turned off. In its low power mode, the coin cell battery lasts for years.&#xD;&#xA;&#xD;&#xA;* It drifts very little (in my case it only drifts a few seconds per week).&#xD;&#xA;&#xD;&#xA;* It's not very expensive.&#xD;&#xA;&#xD;&#xA;If you don't intend to use an RTC, you can replace the crystal that is commonly used to provide clock to arduino for a **crystal oscillator module** like [this one from Farnel][1] or [this other one][2]. They come in 4 pin packages like in the images below. They will generate a much more precise clock for your arduino.&#xD;&#xA;&#xD;&#xA;![Crystal oscillator image][3]&#xD;&#xA;![Crystal oscillator image][4]&#xD;&#xA;![Crystal oscillator image][5]&#xD;&#xA;&#xD;&#xA;Both modules mentioned have tolerances of 50 ppm and operate at 5V.&#xD;&#xA;&#xD;&#xA;Again, just to be clear, these crystal oscillator modules are not to be confused with regular 2 pin **crystal** like this below. Those are part of the circuitry of external clocks for MCUs, for example.&#xD;&#xA;&#xD;&#xA;![Crystal oscillator][6]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://uk.farnell.com/epson/sg531p20mhz/crystal-oscillator-20mhz/dp/1216196&#xD;&#xA;  [2]: http://www.digikey.com/product-detail/en/ECS-2200BX-200/XC1188-ND/827295&#xD;&#xA;  [3]: http://i.stack.imgur.com/OjaoR.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/aTIAn.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/ay7KD.png&#xD;&#xA;  [6]: http://i.stack.imgur.com/a52VR.png&#xD;&#xA;&#xD;&#xA;  [1]: http://datasheets.maximintegrated.com/en/ds/DS1307.pdf" />
  <row Id="64" PostHistoryTypeId="2" PostId="33" RevisionGUID="4867a541-7107-40af-9011-a9407ea272a3" CreationDate="2014-02-12T02:24:06.803" UserId="60" Text="&#xD;&#xA;&#xD;&#xA;**Why does that happen?**&#xD;&#xA;&#xD;&#xA;When the serial port is opened by either monitor, avrdude or other it toggles the DTR pin of the serial port. Which in turn is AC coupled through C4 100nF. This toggling is converted to a up and down pulse on the ATmega(CPU)'s RESET pin. The subsequent reset starts initially with the boot loader, which typically in turn waits for a avrdude's semiphore (e.i. Send: 0 [30]   [20] ) and if seen then responds in turn and if not seen after a timeout period (typically 5s) it continues on with the application in flash space. &#xD;&#xA;&#xD;&#xA;You behavior is describing either; not hearing the response. Or the reset is not getting triggered. Since it does work some times I suspect its prior, but the later. &#xD;&#xA;&#xD;&#xA;**Why Severino needs a hard reset during upload?**&#xD;&#xA;&#xD;&#xA;This statement further supports the later.&#xD;&#xA;&#xD;&#xA;**Why is the problem intermitent?**&#xD;&#xA;&#xD;&#xA;the pulse is almost long and strong enough, where the DTR toggle is in code and likely has some significant inconsistency. &#xD;&#xA;&#xD;&#xA;**How can I fix that problem?**&#xD;&#xA;&#xD;&#xA;Yes, change the value of C4 100nF and or R11 10K, to better pass the toggle. I could derive some EE explanation of what value to pick. But I would suggest some trial and error.&#xD;&#xA;&#xD;&#xA;It should also have 5V clamping, as the RS232 levels can reach +/-12V (typically +/-9V) where the AC coupling prevents the DC and burn out. but the AC will stress it." />
  <row Id="65" PostHistoryTypeId="2" PostId="34" RevisionGUID="30b3a01d-4f84-4111-a887-6910af0b6679" CreationDate="2014-02-12T02:37:28.697" UserId="60" Text="The resonator you specified has a 0.3% stability, where the crystal or crystal oscillator (as mentioned by Ricardo) is 50ppm. Many times more stable. Not to even mention the temperature drift of resonator is horrible. Heating by sunlight will change it. Hence a resonator should not be used for keeping time over long periods. &#xD;&#xA;&#xD;&#xA;Hence using either a crystal or crystal oscillator will get what you want. Either using it on the ATmega and set the fuses respectively or us one connected to an RTC." />
  <row Id="67" PostHistoryTypeId="2" PostId="35" RevisionGUID="a7ff18cb-46d7-40c1-a08e-7b9ecb7675a9" CreationDate="2014-02-12T02:51:06.470" UserId="60" Text="The increased in observed delay is due to the time it takes to send the command from MATLAB to the Arduino have its code execute the requested command. In your case the a.digitalWrite. So actual time between pulses using MATLAB's delay is 0.001 pause plus the time of baud rate times the packet size and decoding then execution.&#xD;&#xA;&#xD;&#xA;I would recommend not pursuing this solution of the MATLAB controlling the timing of Step Motors, remotely. As this latent coupling will be a frustrating limitation. Noting that for step motors the timing can not afford such latent execution. Hence all the 3D printers and many CNC with Step Motors use Arduino's which get G-Code (motor move commands with destinations) and the Real-time firmware handles the stepping, within tolerances.&#xD;&#xA;&#xD;&#xA;I would suggest using something like grbl firmware with step motor shield and then have the MATLAB send the needed G-code. Where there are others with much more features but tailored to 3d Printing. grbl is simpler and straight to the point of moving motors." />
  <row Id="68" PostHistoryTypeId="2" PostId="36" RevisionGUID="9b630124-4ac5-4a39-a062-14b3f22cc032" CreationDate="2014-02-12T02:59:15.323" UserId="69" Text="How do you post data to a JSON web service from an Arduino that's connected to the Internet?" />
  <row Id="69" PostHistoryTypeId="1" PostId="36" RevisionGUID="9b630124-4ac5-4a39-a062-14b3f22cc032" CreationDate="2014-02-12T02:59:15.323" UserId="69" Text="Post Data To a Web Service From Arduino" />
  <row Id="70" PostHistoryTypeId="3" PostId="36" RevisionGUID="9b630124-4ac5-4a39-a062-14b3f22cc032" CreationDate="2014-02-12T02:59:15.323" UserId="69" Text="&lt;web-service&gt;&lt;data-transfer&gt;" />
  <row Id="71" PostHistoryTypeId="2" PostId="37" RevisionGUID="57f57141-84f5-4bf5-b329-86d86625be4a" CreationDate="2014-02-12T03:05:17.680" UserId="60" Text="I would like my compiles to exclude some code depending upon the flash/program space available. To be used in the demo code of a library I support. Whereas my current solution is to use a #ifdef of processor type. But I would like to be more general and not have to specify all the various chips. Rather it would be nice if there was a pre-processor constant that stated the available size. &#xD;&#xA;&#xD;&#xA;Where I am not fluent enough in gcc and or avr-gcc I might expect to find some constants similar those that define the beginning and end of the heap.&#xD;&#xA;&#xD;&#xA;On case example. Is that both the UNO and Leo have 32K of Flash. But the Leo's core library uses 4K for USB support, resulting in only 28K available. My Library's demo is near max'ed out on the UNO and I would like to automatically trim out based on available program space. " />
  <row Id="72" PostHistoryTypeId="1" PostId="37" RevisionGUID="57f57141-84f5-4bf5-b329-86d86625be4a" CreationDate="2014-02-12T03:05:17.680" UserId="60" Text="Is there a preprocessor constant for memory size" />
  <row Id="73" PostHistoryTypeId="3" PostId="37" RevisionGUID="57f57141-84f5-4bf5-b329-86d86625be4a" CreationDate="2014-02-12T03:05:17.680" UserId="60" Text="&lt;compile&gt;&lt;memory&gt;" />
  <row Id="74" PostHistoryTypeId="5" PostId="20" RevisionGUID="ae820823-56e7-46ad-99ca-ee88b87d7e53" CreationDate="2014-02-12T03:19:32.823" UserId="28" Comment="edited body" Text="It just doesn't have enough RAM. You'd also need to teach it to boot from flash memory, which would involve rewriting the bootloader.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;You can instead use an [Arduino Yun][1] or a [PCDuino][2]; while not &quot;standard&quot; Arduinos these support Arduino shields and run Linux.&#xD;&#xA;&#xD;&#xA;Or there's always the [Raspberry Pi][3].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardYun?from=Main.ArduinoYUN&#xD;&#xA;  [2]: http://www.pcduino.com/&#xD;&#xA;  [3]: http://www.raspberrypi.org/" />
  <row Id="75" PostHistoryTypeId="2" PostId="38" RevisionGUID="f96932b7-1621-4693-b745-485b59a928b5" CreationDate="2014-02-12T04:08:51.807" UserId="65" Text="I am working on a real time application which is recording sensor data continuously. I need to process the data in realtime using R. Is there a way to connect and communicate with the uno board using RStudio via serial port?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="76" PostHistoryTypeId="1" PostId="38" RevisionGUID="f96932b7-1621-4693-b745-485b59a928b5" CreationDate="2014-02-12T04:08:51.807" UserId="65" Text="How do I communicate with the UNO using RStudio?" />
  <row Id="77" PostHistoryTypeId="3" PostId="38" RevisionGUID="f96932b7-1621-4693-b745-485b59a928b5" CreationDate="2014-02-12T04:08:51.807" UserId="65" Text="&lt;arduino-uno&gt;&lt;r&gt;&lt;rstudio&gt;" />
  <row Id="78" PostHistoryTypeId="2" PostId="39" RevisionGUID="3348588c-c1d8-4be4-8a42-0dd073d59d26" CreationDate="2014-02-12T04:10:06.223" UserId="33" Text="I bought an [Ethernet Shield R3][1] for my [Arduino Uno R2][2], but since R3 has extra pins it does not fit. Can I use the shield? Should I cut off the extra pins. What do I need to do to make it work?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoEthernetShield&#xD;&#xA;  [2]: http://startingelectronics.com/articles/arduino/uno-r3-r2-differences/" />
  <row Id="79" PostHistoryTypeId="1" PostId="39" RevisionGUID="3348588c-c1d8-4be4-8a42-0dd073d59d26" CreationDate="2014-02-12T04:10:06.223" UserId="33" Text="Arduino Uno R2 and Ethernet Shield R3 compatibility" />
  <row Id="80" PostHistoryTypeId="3" PostId="39" RevisionGUID="3348588c-c1d8-4be4-8a42-0dd073d59d26" CreationDate="2014-02-12T04:10:06.223" UserId="33" Text="&lt;arduino-uno&gt;&lt;ethernet&gt;" />
  <row Id="81" PostHistoryTypeId="2" PostId="40" RevisionGUID="68ba2a28-2fd4-49af-a767-ccef1b745c2a" CreationDate="2014-02-12T04:22:30.253" UserId="76" Text="When I program in languages such as Java or PHP, I usually use Netbeans and all the auto completion and stuff. Also, Netbeans compiles on save and shows errors whereas the Arduino IDE doesn't. So I was wondering if there is another IDE for Arduino that has the same auto completion, error checking etc.&#xD;&#xA;&#xD;&#xA;Thanks " />
  <row Id="82" PostHistoryTypeId="1" PostId="40" RevisionGUID="68ba2a28-2fd4-49af-a767-ccef1b745c2a" CreationDate="2014-02-12T04:22:30.253" UserId="76" Text="What are the other Arduino IDEs (if any)" />
  <row Id="83" PostHistoryTypeId="3" PostId="40" RevisionGUID="68ba2a28-2fd4-49af-a767-ccef1b745c2a" CreationDate="2014-02-12T04:22:30.253" UserId="76" Text="&lt;ide&gt;" />
  <row Id="84" PostHistoryTypeId="2" PostId="41" RevisionGUID="163b35b9-d5f1-4b54-bc9c-d43732e6dad2" CreationDate="2014-02-12T04:22:58.283" UserId="8" Text="The extra pins do not matter. Just leave them. If you really want, cut them off, but this will remove some compatibility with other products." />
  <row Id="85" PostHistoryTypeId="2" PostId="42" RevisionGUID="62b10238-2fbc-4830-ac21-a0c395cc1401" CreationDate="2014-02-12T04:24:33.670" UserId="52" Text="**Question:** What registers do I use to access the IO on the Arduino Uno when I am using assembly for programming?&#xD;&#xA;&#xD;&#xA;**Background:**  I was interested in practicing my assembly language skills on the Arduino (I thought it would be easier to turn LEDs on/off than to worry about console IO).  From doing a [preliminary search](http://electronics.stackexchange.com/q/12750/17375), I have found that the AVR toolchain can be used to program the Arduino.  Yet, I don't quite know how to find the corresponding registers for the IO pins." />
  <row Id="86" PostHistoryTypeId="1" PostId="42" RevisionGUID="62b10238-2fbc-4830-ac21-a0c395cc1401" CreationDate="2014-02-12T04:24:33.670" UserId="52" Text="Assembly on the Arduino: IO registers" />
  <row Id="87" PostHistoryTypeId="3" PostId="42" RevisionGUID="62b10238-2fbc-4830-ac21-a0c395cc1401" CreationDate="2014-02-12T04:24:33.670" UserId="52" Text="&lt;software&gt;&lt;avr-toolchain&gt;" />
  <row Id="88" PostHistoryTypeId="2" PostId="43" RevisionGUID="3ea87a1e-cd92-4b07-9170-bb4b534c1e5a" CreationDate="2014-02-12T04:25:27.440" UserId="77" Text="There is an [Arduino Eclipse plugin][1]! And Eclipse is an awesome cross-plateform open-source IDE!&#xD;&#xA;&#xD;&#xA;[Stino][2] is good. Requires [Sublime Text 2][3] which has an indefinite free trial.&#xD;&#xA;&#xD;&#xA;For More Go to [Office Site][4] &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Code/Eclipse&#xD;&#xA;  [2]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [3]: http://www.sublimetext.com/2&#xD;&#xA;  [4]: http://playground.arduino.cc/Main/DevelopmentTools" />
  <row Id="89" PostHistoryTypeId="2" PostId="44" RevisionGUID="8be3dc03-aff5-4177-8207-56aae27a6ddc" CreationDate="2014-02-12T04:28:52.263" UserId="-1" Text="" />
  <row Id="90" PostHistoryTypeId="2" PostId="45" RevisionGUID="0af66a7b-64be-406f-80db-b3a0086f516a" CreationDate="2014-02-12T04:28:52.263" UserId="-1" Text="" />
  <row Id="91" PostHistoryTypeId="2" PostId="46" RevisionGUID="fee8dd83-a6f4-45f1-8d0b-6c5aeb1863db" CreationDate="2014-02-12T04:28:53.093" UserId="-1" Text="" />
  <row Id="92" PostHistoryTypeId="2" PostId="47" RevisionGUID="2b6b4276-444c-464e-9a48-6d39cf15ad03" CreationDate="2014-02-12T04:28:53.093" UserId="-1" Text="" />
  <row Id="93" PostHistoryTypeId="2" PostId="48" RevisionGUID="2d20a84a-78db-4250-80b1-b7de5c1ebff7" CreationDate="2014-02-12T04:31:18.417" UserId="8" Text="Check this out: http://arduino.cc/en/Reference/PortManipulation&#xD;&#xA;&#xD;&#xA;Also: http://arduino.cc/en/Hacking/PinMapping168&#xD;&#xA;&#xD;&#xA;As for other ports and pins, check put the datasheet for your controller, they're really useful to people who can understand them! :)" />
  <row Id="94" PostHistoryTypeId="2" PostId="49" RevisionGUID="f4b896e8-97f0-4cf2-89dd-44c9e8f1e561" CreationDate="2014-02-12T04:35:03.777" UserId="65" Text="The only issue that may create an incompatibility seems to be the IOREF pin next the 5V output pin which is extra on Revision 3 but not in Revision 2.&#xD;&#xA;&#xD;&#xA;However, I just had a look at the board schematics and the shield does not use IOREF.&#xD;&#xA;&#xD;&#xA;![][1]&#xD;&#xA;&#xD;&#xA;Pin 2 is the one extending IOREF, but is not being used by the board.&#xD;&#xA;&#xD;&#xA;So, the shield should work correctly with the Uno Revision 2. As far as the extra pins are concerned, I would recommend not damaging them in any way. If you absolutely *need* to, then just try to bend them outwards very carefully.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/hOkcc.png" />
  <row Id="95" PostHistoryTypeId="5" PostId="49" RevisionGUID="63d28f86-ba8d-4dbd-a80c-2baf0838365d" CreationDate="2014-02-12T04:41:28.117" UserId="65" Comment="added 1 characters in body" Text="The only issue that may create an incompatibility seems to be the IOREF pin next the 5V output pin which is extra on Revision 3 but not in Revision 2.&#xD;&#xA;&#xD;&#xA;However, I just had a look at the board schematics and the shield does not use IOREF.&#xD;&#xA;&#xD;&#xA;&gt;![][1]&#xD;&#xA;&#xD;&#xA;Pin 2 is the one extending IOREF, but is not being used by the board.&#xD;&#xA;&#xD;&#xA;So, the shield should work correctly with the Uno Revision 2. As far as the extra pins are concerned, I would recommend not damaging them in any way. If you absolutely *need* to, then just try to bend them outwards very carefully.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/hOkcc.png" />
  <row Id="96" PostHistoryTypeId="5" PostId="40" RevisionGUID="25142905-0c0e-4474-a151-0e7c0190facc" CreationDate="2014-02-12T04:42:24.493" UserId="65" Comment="Rephrased question to be clearer" Text="The basic Arduino IDE lacks a lot of the sophistication present in other IDEs such as code completion, code collapsing, folder organisation, and more. Are there other IDEs that allow programming in C/C++ and improve on these aspects? " />
  <row Id="97" PostHistoryTypeId="4" PostId="40" RevisionGUID="25142905-0c0e-4474-a151-0e7c0190facc" CreationDate="2014-02-12T04:42:24.493" UserId="65" Comment="Rephrased question to be clearer" Text="What are the other IDEs for Arduino?" />
  <row Id="98" PostHistoryTypeId="24" PostId="40" RevisionGUID="25142905-0c0e-4474-a151-0e7c0190facc" CreationDate="2014-02-12T04:42:24.493" Comment="Proposed by 65 approved by 76 edit id of 12" />
  <row Id="99" PostHistoryTypeId="2" PostId="50" RevisionGUID="13732074-3bb1-492d-add3-8a5969e699b4" CreationDate="2014-02-12T04:43:09.393" UserId="79" Text="Majenko created and maintains [UECIDE][1]. His contributions are pretty epic; I've seen first hand his coding prowess as we [worked together][2] to get the [Adafruit 1.8&quot; TFT Joystick shield][3] working on the chipKIT platform.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://uecide.org/&#xD;&#xA;  [2]: http://www.chipkit.net/forum/viewtopic.php?f=18&amp;t=2530&#xD;&#xA;  [3]: http://www.adafruit.com/products/802" />
  <row Id="100" PostHistoryTypeId="5" PostId="41" RevisionGUID="6c079d91-d31f-433e-b1f3-137115b03e0a" CreationDate="2014-02-12T04:43:53.717" UserId="8" Comment="Added location description" Text="The extra pins do not matter. Just leave them. If you really want, cut them off, but this will remove some compatibility with other products.&#xD;&#xA;&#xD;&#xA;They should hang off the ends of the headers closest to the power/USB end of the board." />
  <row Id="101" PostHistoryTypeId="2" PostId="51" RevisionGUID="c5e1446c-63fd-4821-a033-7b97bf3ffea4" CreationDate="2014-02-12T04:48:40.460" UserId="79" Text="I understand a lot of the spirit with Arduino is being frugal and occasionally trudging through a problem. I use Arduino (and now chipKIT, since it's got 10x the RAM and 10x the clock speed) for my workplace and I need &quot;peripheral functions&quot; to be up to speed and working as quickly as possible.&#xD;&#xA;&#xD;&#xA;I use the sparkfun real time clock in one of my projects and am very happy with it. They also have a [&quot;Dead on&quot; variant][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sparkfun.com/products/10160" />
  <row Id="102" PostHistoryTypeId="5" PostId="19" RevisionGUID="affe7399-f5aa-4451-8563-32f1ce87967b" CreationDate="2014-02-12T04:54:28.127" UserId="8" Comment="Added linux abc speed" Text="Linux is a very complex operating system, but it may be able to fit on an arduino. things to consider:&#xD;&#xA;&#xD;&#xA;* There is no current AVR port of the source code&#xD;&#xA;* You would have no graphics, instead access the terminal over UART.&#xD;&#xA;* The filesystem driver would have to be rewritten to access internal flash or an external SD card&#xD;&#xA;* It would be _extremely_ slow! the AtMega328 would run at 16mHz, or about 20mHz max (overclocked). Most linux machines run at a minimum of 400mHz, and more with graphics.&#xD;&#xA;* You would probably need some extra ram, probably a good idea to use an AtMega2650 (the one in the mega) which has 16x the ram of the Uno. You could also use a Due (6x as fast as the Uno, more ram)&#xD;&#xA;* You may have to write special USB drivers for OTG (on the due) or MAX3421EE (Mega ADK, USB host shield)&#xD;&#xA;&#xD;&#xA;In short, it would take _a lot_ of time and effort, and probably would be too slo for everyday use. If you really want Arduino Linux, check out the Yún." />
  <row Id="103" PostHistoryTypeId="2" PostId="52" RevisionGUID="f8d0db79-50d0-4bda-b2ec-1bed2005fbce" CreationDate="2014-02-12T04:54:51.720" UserId="65" Text="I have a uno that I have been using for 3 years now. I will be using it again in a rather critical project in which failure on the part of the board could be rather expensive and dangerous. So, I would like to be sure that the board is not approaching end of life or going to fail anytime soon. Is there any reliable way to figure out how long the board will function without failing or reduction in performance?" />
  <row Id="104" PostHistoryTypeId="1" PostId="52" RevisionGUID="f8d0db79-50d0-4bda-b2ec-1bed2005fbce" CreationDate="2014-02-12T04:54:51.720" UserId="65" Text="How do I figure out if my board is approaching end of life?" />
  <row Id="105" PostHistoryTypeId="3" PostId="52" RevisionGUID="f8d0db79-50d0-4bda-b2ec-1bed2005fbce" CreationDate="2014-02-12T04:54:51.720" UserId="65" Text="&lt;arduino-uno&gt;&lt;safety&gt;&lt;reliability&gt;" />
  <row Id="106" PostHistoryTypeId="2" PostId="53" RevisionGUID="56703f83-7be6-4305-8ea5-c93f8b0b8874" CreationDate="2014-02-12T05:04:26.057" UserId="-1" Text="" />
  <row Id="107" PostHistoryTypeId="2" PostId="54" RevisionGUID="e3cadd93-c089-4db0-bdee-e9943e9662ad" CreationDate="2014-02-12T05:04:26.057" UserId="-1" Text="" />
  <row Id="108" PostHistoryTypeId="2" PostId="55" RevisionGUID="09c555c5-8815-4ecc-976b-9c3da776a404" CreationDate="2014-02-12T05:09:43.580" UserId="77" Text="Plug the board into a USB port on your computer and check that the green LED power indicator on the board illuminates. Standard Arduino boards (Uno, Duemilanove, and Mega) have a green LED power indicator located near the reset switch.&#xD;&#xA;&#xD;&#xA;An orange LED near the center of the board (labeled “Pin 13 LED” in the image below) should flash on and off when the board is powered up (boards come from the factory preloaded with software to flash the LED as a simple check that the board is working).&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;If the power LED does not illuminate when the board is connected to your computer, the board is probably not receiving power.&#xD;&#xA;&#xD;&#xA;The flashing LED (connected to digital output pin 13) is being controlled by code running on the board (new boards are preloaded with the Blink example sketch). If the pin 13 LED is flashing, the sketch is running correctly, which means the chip on the board is working. If the green power LED is on but the pin 13 LED is not flashing, it could be that the factory code is not on the chip. If you are not using a standard board, it may not have a built-in LED on pin 13, so check the documentation for details of your board.&#xD;&#xA;&#xD;&#xA;Online guides for getting started with Arduino are available at for [Windows][2],  for [Mac OS X][3], and for [Linux][4].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/gDEH4.png&#xD;&#xA;  [2]: http://arduino.cc/en/Guide/Windows&#xD;&#xA;  [3]: http://arduino.cc/en/Guide/MacOSX&#xD;&#xA;  [4]: http://www.arduino.cc/Learning/Linux" />
  <row Id="109" PostHistoryTypeId="2" PostId="56" RevisionGUID="b9aef95b-e963-4f43-a184-e84f79f7b1e9" CreationDate="2014-02-12T05:16:33.357" UserId="77" Text="I want to unit test my Arduino code. Ideally, I want to execute and test my code without upload it to the arduino board. What tools or libraries can help me with this?&#xD;&#xA;&#xD;&#xA;There is an [Arduino emulator][1] in development which could be useful, but it doesn't yet seem to be ready for use.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://radpartbrainmat.blogspot.in/search/label/arduemu" />
  <row Id="110" PostHistoryTypeId="1" PostId="56" RevisionGUID="b9aef95b-e963-4f43-a184-e84f79f7b1e9" CreationDate="2014-02-12T05:16:33.357" UserId="77" Text="What is the best way to do unit testing of my arduino code without controller?" />
  <row Id="111" PostHistoryTypeId="3" PostId="56" RevisionGUID="b9aef95b-e963-4f43-a184-e84f79f7b1e9" CreationDate="2014-02-12T05:16:33.357" UserId="77" Text="&lt;arduino-uno&gt;&lt;unit-test&gt;" />
  <row Id="112" PostHistoryTypeId="5" PostId="55" RevisionGUID="4fe8a862-eafb-420d-a227-56514c07b649" CreationDate="2014-02-12T05:21:26.487" UserId="77" Comment="added 200 characters in body" Text="&gt; **Edit :** People who down voted my answer, Ohh common don't be too much foolish&#xD;&#xA;&gt; ! for that you need to be an electron and go through the circuit&#xD;&#xA;&gt; itself to check everything is ok or not :)&#xD;&#xA;&#xD;&#xA;Plug the board into a USB port on your computer and check that the green LED power indicator on the board illuminates. Standard Arduino boards (Uno, Duemilanove, and Mega) have a green LED power indicator located near the reset switch.&#xD;&#xA;&#xD;&#xA;An orange LED near the center of the board (labeled “Pin 13 LED” in the image below) should flash on and off when the board is powered up (boards come from the factory preloaded with software to flash the LED as a simple check that the board is working).&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;If the power LED does not illuminate when the board is connected to your computer, the board is probably not receiving power.&#xD;&#xA;&#xD;&#xA;The flashing LED (connected to digital output pin 13) is being controlled by code running on the board (new boards are preloaded with the Blink example sketch). If the pin 13 LED is flashing, the sketch is running correctly, which means the chip on the board is working. If the green power LED is on but the pin 13 LED is not flashing, it could be that the factory code is not on the chip. If you are not using a standard board, it may not have a built-in LED on pin 13, so check the documentation for details of your board.&#xD;&#xA;&#xD;&#xA;Online guides for getting started with Arduino are available at for [Windows][2],  for [Mac OS X][3], and for [Linux][4].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/gDEH4.png&#xD;&#xA;  [2]: http://arduino.cc/en/Guide/Windows&#xD;&#xA;  [3]: http://arduino.cc/en/Guide/MacOSX&#xD;&#xA;  [4]: http://www.arduino.cc/Learning/Linux" />
  <row Id="113" PostHistoryTypeId="2" PostId="57" RevisionGUID="4d5679c9-a60c-421d-8fef-f0ec2fec0aa6" CreationDate="2014-02-12T05:21:37.753" UserId="78" Text="I'm not already started to try but I'm a good webmaster and I'm just asking wish way is more perfect for sending and keeping data from sensors and I/0 state in a database.&#xA;&#xA;Here are some points:&#xA;- Post versus get&#xA;- MySQL or others types&#xA;- Security layers&#xA;- Graphics render of data's (google API?)&#xA;- PHP, ruby, JavaScript...&#xA;- Able to send data request's to Arduino's&#xA;- Ethernet shield, wifi, I2c ???&#xA;- Access via Android app...&#xA;&#xA;Anyway, the goal here is to know pro's and cons of integrate all my Arduino through database." />
  <row Id="114" PostHistoryTypeId="1" PostId="57" RevisionGUID="4d5679c9-a60c-421d-8fef-f0ec2fec0aa6" CreationDate="2014-02-12T05:21:37.753" UserId="78" Text="What's the best way to put in a database sensors data's" />
  <row Id="115" PostHistoryTypeId="3" PostId="57" RevisionGUID="4d5679c9-a60c-421d-8fef-f0ec2fec0aa6" CreationDate="2014-02-12T05:21:37.753" UserId="78" Text="&lt;uploading&gt;&lt;connection&gt;&lt;data-transfer&gt;" />
  <row Id="117" PostHistoryTypeId="2" PostId="59" RevisionGUID="c8af7842-c78b-4335-8f7b-2d6651d03f17" CreationDate="2014-02-12T05:34:04.400" UserId="65" Text="One rather good IDE extension is the Arduino Mode for Emacs. It allows using a highly versatile and extensible IDE such as Emacs for writing, compiling and uploading code to the Arduino.&#xD;&#xA;&#xD;&#xA;The documentation and instructions can be found [here](http://www.emacswiki.org/emacs/ArduinoSupport)." />
  <row Id="118" PostHistoryTypeId="2" PostId="60" RevisionGUID="b4c425c3-5d3f-4f33-9130-7b3ebab6260f" CreationDate="2014-02-12T05:56:49.120" UserId="83" Text="What is the best practices to make my Arduino circuit more robust against prototyping mistakes (like shorting pins)? I don't want the controller to release its blue magic smoke while experimenting with it, what precautions can I make while designing a circuit?&#xD;&#xA;" />
  <row Id="119" PostHistoryTypeId="1" PostId="60" RevisionGUID="b4c425c3-5d3f-4f33-9130-7b3ebab6260f" CreationDate="2014-02-12T05:56:49.120" UserId="83" Text="How to prevent breaking my Arduino by mistake?" />
  <row Id="120" PostHistoryTypeId="3" PostId="60" RevisionGUID="b4c425c3-5d3f-4f33-9130-7b3ebab6260f" CreationDate="2014-02-12T05:56:49.120" UserId="83" Text="&lt;electronics&gt;" />
  <row Id="121" PostHistoryTypeId="6" PostId="28" RevisionGUID="28dfe22f-29a7-4b60-9157-0773b1fe03d5" CreationDate="2014-02-12T05:59:29.443" UserId="65" Comment="Arduino is redundant in tags. Every board name will be prefixed by Arduino, so no point putting it in tags" Text="&lt;matlab&gt;&lt;uno&gt;" />
  <row Id="122" PostHistoryTypeId="24" PostId="28" RevisionGUID="28dfe22f-29a7-4b60-9157-0773b1fe03d5" CreationDate="2014-02-12T05:59:29.443" Comment="Proposed by 65 approved by 25 edit id of 5" />
  <row Id="125" PostHistoryTypeId="2" PostId="61" RevisionGUID="87af69f3-58ce-48e3-b309-77ee341d13cf" CreationDate="2014-02-12T06:15:47.017" UserId="87" Text="I would like to start the development of some basic Arduino projects but I don't own an Arduino board yet. Is there a way I can write my code and emulate/test it using a desktop computer so after my board arrives I just have to upload and run my project on it?" />
  <row Id="126" PostHistoryTypeId="1" PostId="61" RevisionGUID="87af69f3-58ce-48e3-b309-77ee341d13cf" CreationDate="2014-02-12T06:15:47.017" UserId="87" Text="Can I program for Arduino without having a real board?" />
  <row Id="127" PostHistoryTypeId="3" PostId="61" RevisionGUID="87af69f3-58ce-48e3-b309-77ee341d13cf" CreationDate="2014-02-12T06:15:47.017" UserId="87" Text="&lt;emulation&gt;&lt;testing&gt;" />
  <row Id="129" PostHistoryTypeId="2" PostId="62" RevisionGUID="1ef78789-c546-4b6b-a664-582d79336f8c" CreationDate="2014-02-12T06:22:09.293" UserId="83" Text="If you don't want to use extra hardware like an Real Time Clock (eg. DSDS1307), you can significantly improve timing accuracy by disabling all unused interrupts. By default Arduino sketches come with various interrupt routines enabled and often they are not used for actually your sketch. Quickest way to find out if you can do without it to try and disable them by issuing [`noInterrupts();`](http://arduino.cc/en/Reference/Interrupts)&#xD;&#xA;&#xD;&#xA;" />
  <row Id="130" PostHistoryTypeId="2" PostId="63" RevisionGUID="1794b193-c606-4573-8222-3dfbac77ee94" CreationDate="2014-02-12T06:24:58.243" UserId="86" Text="The short answer is no.&#xD;&#xA;&#xD;&#xA;Basically, you would need LOTS more ram then even the biggest ATmega has natively.&#xD;&#xA;&#xD;&#xA;It *is* theoretically possible to add external hardware, and program the ATmega to emulate a more powerful CPU, and run linux on that. However, on a plain arduino, it is not possible.&#xD;&#xA;&#xD;&#xA;It would be much more realistic to run linux on a Arduino Due, which is basically a AT91SAM3X8E CPU. However, you'd still need to add some additional SRAM and storage. &#xD;&#xA;&#xD;&#xA;There are things like the Arduino Yun, but that is really a entirely separate linux module on the same PCB as a ATmega32U4, so I don't know if you can really count it as an arduino.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Possibly relevant: [What does it take to run embedded linux?](http://stackoverflow.com/questions/1522146/minimum-configuration-to-run-embedded-linux-on-an-arm-processor)" />
  <row Id="131" PostHistoryTypeId="5" PostId="49" RevisionGUID="086ed00b-b89c-4bba-a2e3-2135b961486c" CreationDate="2014-02-12T06:25:23.840" UserId="65" Comment="deleted 30 characters in body" Text="The only issue that may create an incompatibility seems to be the IOREF pin next the 5V output pin which is extra on Revision 3 but not in Revision 2.&#xD;&#xA;&#xD;&#xA;However, I just had a look at the board schematics and the shield does not use IOREF.&#xD;&#xA;&#xD;&#xA;&gt;![][1]&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;**Pin 2 is extending IOREF**&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;So, the shield should work correctly with the Uno Revision 2. As far as the extra pins are concerned, I would recommend not damaging them in any way. If you absolutely *need* to, then just try to bend them outwards very carefully.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/hOkcc.png" />
  <row Id="132" PostHistoryTypeId="2" PostId="64" RevisionGUID="857932c8-cc20-4c32-93f8-f02c9168e06b" CreationDate="2014-02-12T06:29:21.267" UserId="86" Text="Have you looked at the AVR simulator that's part of [Atmel Studio][1]? Considering Atmel designed the processor, the simulation may very well be running the HDL that was used to produce the MCU itself.&#xD;&#xA;&#xD;&#xA;I suspect if you're doing something involved enough to be using unit-testing, you should probably stop thinking of your device as an &quot;Arduino&quot;, but rather &quot;An ATmega MPU on a PCB&quot;. There are **much** more information and tools available about ATmega CPUs in general then Arduinos.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/microsite/atmel_studio6/debugging_simulation.aspx" />
  <row Id="133" PostHistoryTypeId="2" PostId="65" RevisionGUID="41ef997f-7d14-45e0-9378-f1b09f7eb90c" CreationDate="2014-02-12T06:34:29.143" UserId="83" Text="The datasheets for the AVR microcontrollers are reasonably good to read. Just Google for the exact controller on your Arduino (eg. ATmege328) and find the &quot;Complete&quot; datasheet on the *atmel.com* website. Don't download the &quot;Summary&quot;, it doesn't include a lot of information. Download the datasheet from atmel.com, that is the only location with the most recent documentation.&#xD;&#xA;&#xD;&#xA;There are three registers used in basic IO (check the chapter called &quot;I/O-Ports&quot;):&#xD;&#xA;&#xD;&#xA;Where *n* is a port identifier, a letter ranging from A, B, C, ... depending on the number of IO pins your controller has. Each bit in each register represents a single GPIO pin (yes, you need some basic knowledge on binary to fully understand this).&#xD;&#xA;&#xD;&#xA;- **DDR***n*, Data Direction Register: This basically configures a pin for either input (0) or output (1). &#xD;&#xA;- **PORT***n*, Port n Data Register: When a pin is set as output, the related bit toggles the output pin high (1) or low (0). When configured as input, this enables a weak pull up resistor on the output pin.&#xD;&#xA;- **PIN***n*,  Port n Input Register: Use this register to read the current level on a pin that is configured as input.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="134" PostHistoryTypeId="2" PostId="66" RevisionGUID="4ecc94b6-0f1f-4be7-8a38-b6465e8edbf9" CreationDate="2014-02-12T06:38:39.020" UserId="86" Text="Unfortunately, there isn't much way to really determine &quot;wear&quot; in the context of solid-state electronics.&#xD;&#xA;&#xD;&#xA;Probably the things that are most likely to fail are the electrolytic capacitors and the connectors.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;First, if you're using an ATmega CPU for something that could possibly injure someone **CONTACT ATMEL AND TALK ABOUT SAFETY PRECAUTIONS**. The ATmega CPU used in most of the arduino models is *not* rated for use in such situations.&#xD;&#xA;&#xD;&#xA;In EVERY datasheet:  &#xD;&#xA;&gt; Atmel products are not intended, authorized, or warranted for use as components in applications intended to support or sustain life.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Now, realistically, this is probably *mostly* lawyer repellent, but you should still take appropriate precautions.&#xD;&#xA;&#xD;&#xA;Really, while there isn't anything on a common arduino board that really wears out except the connectors, *why are you trying to save $30 at a potential huge cost?* Just buy a new board.&#xD;&#xA;&#xD;&#xA;I'd also strongly reccomend you chose a board with a SMT ATmega328P, since that removes the IC socket contacts from the list of concerns. If possible, also remove the pin-headers, and solder wires to the board directly. Try to minimize connectors, since they are frequent points of failure.&#xD;&#xA;" />
  <row Id="135" PostHistoryTypeId="2" PostId="67" RevisionGUID="d142458d-d4d8-4337-8a7b-d9875e0bba08" CreationDate="2014-02-12T06:43:38.013" UserId="83" Text="Find the `io__.h` file for your microcontroller, on Linux it is located in `/usr/lib/avr/include/avr`, on Windows it will be in a somewhat similar location.&#xD;&#xA;&#xD;&#xA;Scroll down to the part that says `/* Constants */`. There are couple interesting macros defined there, `FLASHEND` being the one you should be interested in. You can use it for example as follows:&#xD;&#xA;&#xD;&#xA;    #if FLASHEND &gt; 0x8000&#xD;&#xA;    /* Include some extra code when sufficient flash is available. */&#xD;&#xA;    &#xD;&#xA;    #endif" />
  <row Id="136" PostHistoryTypeId="2" PostId="68" RevisionGUID="99911982-588f-48d3-a31b-73e70ec6166f" CreationDate="2014-02-12T06:44:16.880" UserId="86" Text="You can use [AVR Studio][1] to write programs for Arduinos.&#xD;&#xA;&#xD;&#xA;There is a plugin that lets you link against and use the arduino libraries from [within Atmel Studio][2].&#xD;&#xA;&#xD;&#xA;If you've used Microsoft Visual Studio, Atmel Studio is basically a reskin of Visual studio with different compiler backends that target the ATmega series of devices, so you'll feel right at home.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/microsite/atmel_studio6/&#xD;&#xA;  [2]: https://arduinotemplateexpress.codeplex.com/" />
  <row Id="137" PostHistoryTypeId="2" PostId="69" RevisionGUID="d5d9ea1e-05cb-4aba-888f-ae11c0a05556" CreationDate="2014-02-12T07:01:23.777" UserId="86" Text="To answer the aspect of your question regarding the &quot;firmware&quot; on the ATmega328p MCU used in most of the Arduino boards:  &#xD;&#xA;&#xD;&#xA;There is no firmware on the ATmega at all aside from the bootloader. The programs you write are running *directly* on the hardware. &#xD;&#xA;&#xD;&#xA;There are certain &quot;fuse&quot; settings which are set with a [ISP programmer][1]. However, there are only 24 of them (three bytes), and they largely relate to low-level configuration, and are not what I think you're asking:  &#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;There is also the [Bootloader][3], which is a small program that sits in a separate segment of the MCU's program memory and allows it to update itself at startup (which is how all arduinos are programmed). However, it only runs for a short period of time at startup, and is completely removed from memory after the MCU has jumped to the main program.&#xD;&#xA;&#xD;&#xA;Lastly, there are auxiliary MCUs (ATmega16U2/8U2) on most arduino boards that are used as USB-serial interfaces, that *can* be updated to behave differently (e.g. emulate a keyboard/mouse), but again, this isn't actually a change to the core processor, so whether it counts as &quot;installing a different firmware&quot; depends on how you define the arduino.&#xD;&#xA;&#xD;&#xA;Really, I'd strongly reccomend reading the [ATmega328P datasheet][4]. This is the documentation for the MCU that basically forms the &quot;Arduino&quot;. It should address what seems to be misconceptions. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://store.atmel.com/PartDetail.aspx?q=p:10500054&#xD;&#xA;  [2]: http://i.stack.imgur.com/wEPF9.png&#xD;&#xA;  [3]: http://code.google.com/p/optiboot/&#xD;&#xA;  [4]: http://www.atmel.com/Images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet.pdf" />
  <row Id="138" PostHistoryTypeId="2" PostId="70" RevisionGUID="d7c82217-a3f6-48dc-957b-07ab6e23820c" CreationDate="2014-02-12T07:08:22.687" UserId="86" Text="If RStudio has serial support. Yes, it can talk to a Uno. If it does not. No.&#xD;&#xA;&#xD;&#xA;This is really a question about RStudio (and actually just pure [R][1]), not arduinos.&#xD;&#xA;&#xD;&#xA;Furthermore, RStudio is just an IDE. Therefore, no, *RStudio* can *not* communicate with an arduino, compile a program, or do much of all aside from edit source-code files. RStudio does not run your code at all. It uses an external interpreter to run your source files.&#xD;&#xA;&#xD;&#xA;*R*, on the other hand probably *can* talk to serial interfaces. The fact that you're using RStudio is entirely irrelevant.&#xD;&#xA;&#xD;&#xA;I'm not familliar with R, but a little googling leads me to think that R can talk to serial interfaces without *too* much trouble, though I have not been able to find any information about doing so on windows. What platform are you using?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/R_%28programming_language%29" />
  <row Id="139" PostHistoryTypeId="5" PostId="60" RevisionGUID="1b57f6e7-3e13-4f61-9533-05effbc8a0a9" CreationDate="2014-02-12T07:16:56.653" UserId="83" Comment="deleted 1 characters in body" Text="What is the best practice to make my Arduino circuit more robust against prototyping mistakes (like shorting pins)? I don't want the controller to release its blue magic smoke while experimenting with it, what precautions can I make while designing a circuit?&#xD;&#xA;" />
  <row Id="140" PostHistoryTypeId="2" PostId="71" RevisionGUID="afc583bb-56e5-4dd7-824d-7d0434c4d478" CreationDate="2014-02-12T07:22:41.363" UserId="94" Text="In a project I am using a Seeeduino v3.0 as an Arduino clone. On the seeeduino website it says that &#xD;&#xA;&#xD;&#xA;&gt;  It is based on the Duemilanove schematic, 100% compatible to its existing program, shield and IDEs.&#xD;&#xA;&#xD;&#xA;In fact I never had any problems with shields or the IDE.&#xD;&#xA;&#xD;&#xA;My question is now: Is the seeeduino and other clones really 100% compatible? The seeeduino board was considerable cheaper then an arduino." />
  <row Id="141" PostHistoryTypeId="1" PostId="71" RevisionGUID="afc583bb-56e5-4dd7-824d-7d0434c4d478" CreationDate="2014-02-12T07:22:41.363" UserId="94" Text="Compatibility between Arduino and Arduino clones" />
  <row Id="142" PostHistoryTypeId="3" PostId="71" RevisionGUID="afc583bb-56e5-4dd7-824d-7d0434c4d478" CreationDate="2014-02-12T07:22:41.363" UserId="94" Text="&lt;clones&gt;" />
  <row Id="143" PostHistoryTypeId="2" PostId="72" RevisionGUID="4386a88a-5258-4865-86ee-1853f213f2e3" CreationDate="2014-02-12T07:33:14.817" UserId="89" Text="I don't know if there's *one* best practice, but the following might be helpful:&#xD;&#xA;&#xD;&#xA; - Limit the voltage on input pins to 5.5 V maximum.&#xD;&#xA; - Do not shorten IO pins.&#xD;&#xA; - Use pullup or pulldown resistors when conecting switches or pushbuttons.&#xD;&#xA; - Respect the current limits (for each pin and in total). Use resistors.&#xD;&#xA; - The Arduino is just the brain, not the power station. If you have to drive higher loads, use simple transistors, Darlington arrays, etc.&#xD;&#xA;" />
  <row Id="147" PostHistoryTypeId="2" PostId="74" RevisionGUID="2d88760e-78c1-4674-9736-ebb575a7935e" CreationDate="2014-02-12T07:36:18.303" UserId="99" Text="I was looking at getting an enclosure to house my Arduino Uno R3, but I'm not sure if I should also attach a fan.  Does anyone have experience with this?  It doesn't look like much heat is being generated, but with no ventilation except some slits in the enclosure, there won't be much air circulation without a fan.  My concern with adding a fan was the fact that I'd need to power it." />
  <row Id="148" PostHistoryTypeId="1" PostId="74" RevisionGUID="2d88760e-78c1-4674-9736-ebb575a7935e" CreationDate="2014-02-12T07:36:18.303" UserId="99" Text="Does Arduino Uno R3 require cooling in a closure?" />
  <row Id="149" PostHistoryTypeId="3" PostId="74" RevisionGUID="2d88760e-78c1-4674-9736-ebb575a7935e" CreationDate="2014-02-12T07:36:18.303" UserId="99" Text="&lt;arduino-uno&gt;&lt;uno&gt;&lt;enclosure&gt;&lt;cooling&gt;&lt;uno-r3&gt;" />
  <row Id="150" PostHistoryTypeId="2" PostId="75" RevisionGUID="81ccf88c-e6e2-4698-a798-a1c25574d5b7" CreationDate="2014-02-12T07:41:33.683" UserId="83" Text="If you closely look at the Arduino circuit diagram, You'll notice that it is little more than power supply, a USB-serial interface and the microcontroller itself.&#xD;&#xA;&#xD;&#xA;The 'hard' part for compatibility is getting the board layout right (which connector goes where on the circuit board), and to load a compatible bootloader in the chip (which is free/open software, so why bother making your own?).&#xD;&#xA;&#xD;&#xA;I've used several el-cheapo Arduino clones and apart from apparent physical construction (one feels a bit flimsy), they all work just like the 'real thing'. I guess the major difference between original and clone is the quality of the board, the used components and quality of assembly." />
  <row Id="151" PostHistoryTypeId="2" PostId="76" RevisionGUID="ae59c8e4-cc9a-46b8-90d4-f2b1793a500e" CreationDate="2014-02-12T07:48:19.477" UserId="70" Text="Over the years I have used original Arduino boards as well as a multitude of clones of varying provenance, from the excellent [InduinoX][1] that is listed on [the Arduino site][2] as an official compatible board, to the very well-made Chinese [Meduino Nano Enhancement][3] (3.3 / 5 Volt switchable), to dirt-cheap clones from eBay that are sometimes better constructed than the official boards.&#xD;&#xA;&#xD;&#xA;There is nothing unique or sophisticated about the Arduino board: It's basically just the microcontroller (atMEGA328, atMEGA1280, SAM3X8E or others) and its minimal support hardware. Not much that can go wrong with that little, really. &#xD;&#xA;&#xD;&#xA;The two common elements that ensure compatibility across these boards are:&#xD;&#xA;&#xD;&#xA;1. The Arduino bootloader&#xD;&#xA;2. Support for the board within the official Arduino software distribution&#xD;&#xA;&#xD;&#xA;The bootloader can be replaced with a better or more up-to-date version if one is available for the microcontroller on your board.&#xD;&#xA;&#xD;&#xA;The support files can either be found online, or minor edits to the nearest similar board's files can provide the requisite support for the Arduino environment. &#xD;&#xA;&#xD;&#xA;In short: *Yes, clones typically work just as well as the original Arduino, and clones with enhanced features often work far better while retaining compatibility (e.g. InduinoX)*&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.simplelabs.co.in/content/induino-r3-low-cost-arduino-r3-usb-clone-board&#xD;&#xA;  [2]: http://playground.arduino.cc/Main/SimilarBoards#goArdComp&#xD;&#xA;  [3]: http://youtu.be/DXwezev713s" />
  <row Id="152" PostHistoryTypeId="2" PostId="77" RevisionGUID="08d9c26d-ca33-48f3-8f2d-36953cf2f3bd" CreationDate="2014-02-12T07:48:32.030" UserId="83" Text="The only times I had an AVR run hot was when I applied reverse power to it. You'll be fine without a fan for the Arduino board itself, as long as you don't run power hungry peripherals from it.&#xD;&#xA;&#xD;&#xA;Probably the only thing you really need to check (apart from absolute maximum ratings: 40mA max per IO pin and 200mA max for the whole microcontroller) is the on board voltage regulator (usually three pin device with a heat sink soldered down to the PCB) if you power it from a voltage &gt; 7V or so." />
  <row Id="153" PostHistoryTypeId="2" PostId="78" RevisionGUID="a3be7268-3b41-4e09-9be5-9e103fd912c2" CreationDate="2014-02-12T08:04:28.930" UserId="70" Text="There are a whole slew of Arduino simulators out there, many free, and some paid products as well. &#xD;&#xA;&#xD;&#xA; - The [CodeBlocks][1] Arduino development environment includes a free Arduino simulator, still under development but functional. &#xD;&#xA; - [Simuino][2] simulates the Arduino Uno and Mega pins - not a pretty-looking realistic simulator, but it works. &#xD;&#xA; - The Python based [Arduino Simulator][3] is another option, that plays well with the official IDE&#xD;&#xA; - Virtronics [Simulator for Arduino][4] looks promising, but I don't see why I would pay $14.99 for it, when I could buy one or more actual Arduino clones for that price&#xD;&#xA;&#xD;&#xA;Many other Arduino simulators are out there if you search, and new ones are being announced, even crowdfunded, all the time. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduinodev.com/codeblocks/&#xD;&#xA;  [2]: https://code.google.com/p/simuino/&#xD;&#xA;  [3]: http://sourceforge.net/projects/arduinosim/&#xD;&#xA;  [4]: http://www.virtronics.com.au/Simulator-for-Arduino.html" />
  <row Id="154" PostHistoryTypeId="2" PostId="79" RevisionGUID="b182c1ce-b6d5-456e-98b8-404e0fd4afe8" CreationDate="2014-02-12T08:21:43.107" UserId="70" Text="Realistically, the biggest power waster on an Arduino board is the linear voltage regulator on it. &#xD;&#xA;&#xD;&#xA; 1. As long as the microcontroller on the board, the LEDs, or any other peripherals, draw current, the linear regulator wastes power equal to `difference between supply and board voltage` x `current drawn`.&#xD;&#xA;&#xD;&#xA;    So, a first fix would be to disconnect the power indicator LED on the board, and not use any of the other LEDs as far as possible.&#xD;&#xA;    Second, supply the board with as low a voltage as possible that is just sufficient to power the on-board regulator.&#xD;&#xA;&#xD;&#xA; 2. On the original designs, the voltage regulators used do not boast low quiescent current. This means even with nothing drawing power within the board, the regulator itself wastes a fair bit of power all the time it is on. &#xD;&#xA;&#xD;&#xA;    An easy fix is to replace the on-board regulator with an LDO (low drop-out linear regulator) rated for extremely low quiescent current. Parametric searches on various vendor sites will yield likely substitutes.&#xD;&#xA;&#xD;&#xA; 3. Even with the above steps, the Arduino board does not provide a mechanism to set the LDO into low-power mode, if the LDO chosed supports this. Power efficient designs typically use a &quot;sleep mode&quot; pin on voltage regulators to save a fair bit of energy - not an option here.&#xD;&#xA;&#xD;&#xA;Even with all possible power saving modes and tricks applied at the microcontroller level, the Arduino simply is not designed to be an ultra-low-power device out of the box. Having experimented with several non-trivial applications, I have found that the best that is realistically achievable is some 10% to 30% power saving depending on application, since the voltage regulator and the LEDs are going to consume the rest anyway.&#xD;&#xA;" />
  <row Id="157" PostHistoryTypeId="2" PostId="80" RevisionGUID="ac98ff40-79c4-4b4d-aa76-75dbf008ac0b" CreationDate="2014-02-12T09:14:23.233" UserId="70" Text="Not best practices, but an alternative approach: &#xD;&#xA;&#xD;&#xA;Consider the [Ruggeduino][1] instead of a standard Arduino. At a price ($39.95) comparable with the equivalent Arduino, the Ruggeduino offers:&#xD;&#xA;&#xD;&#xA; - Resettable fuse on each GPIO pin, i.e. all GPIO pins are protected from short-circuit to ground or other pins&#xD;&#xA; - All GPIO pins withstand 24 Volts&#xD;&#xA; - Reverse voltage protection (-30 V) on V&lt;sub&gt;in&lt;/sub&gt;&#xD;&#xA; - Microcontroller overcurrent protection&#xD;&#xA; - 3.3V and 5V outputs on the board are over-current and short-circuit protected&#xD;&#xA;&#xD;&#xA;Besides the above points specific to the question, the boards are designed to survive harsh environments and various mistakes. Also, the clock is more precise than on the Arduino.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://ruggedcircuits.com/html/ruggeduino.html" />
  <row Id="158" PostHistoryTypeId="2" PostId="81" RevisionGUID="2d980bbf-8f73-4234-8757-a4de9c7efc77" CreationDate="2014-02-12T09:28:35.477" UserId="102" Text="Expanding on @Fake Name's answer, there is also [Visual Micro's Arduino plugin][1] for Atmel Studio / Visual Studio.&#xD;&#xA;&#xD;&#xA;Cheers,&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.visualmicro.com/" />
  <row Id="159" PostHistoryTypeId="5" PostId="81" RevisionGUID="a57d23de-4ba1-4c11-b779-e6e0baf5c054" CreationDate="2014-02-12T09:35:23.503" UserId="102" Comment="added 133 characters in body" Text="Expanding on @Fake Name's answer, there is also [Visual Micro's Arduino plugin][1] for Atmel Studio / Visual Studio. It shares the tools, sources and libs with the Arduino IDE but provides all the code completion and other niceness of Visual Studio.&#xD;&#xA;&#xD;&#xA;Cheers,&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.visualmicro.com/" />
  <row Id="161" PostHistoryTypeId="2" PostId="83" RevisionGUID="b4366615-353d-4d6a-a1b1-5c87b994eaf1" CreationDate="2014-02-12T09:54:54.233" UserId="103" Text="Yes you can, try using **Proteus ISIS** for simulating your code...   &#xD;&#xA;For full emulation of Arduino, there is shareware program called **VBB**, I tried it too and it was nice. You can find it [here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.virtualbreadboard.com/" />
  <row Id="162" PostHistoryTypeId="2" PostId="84" RevisionGUID="36af81ee-2d92-4946-904e-3dcafb70b730" CreationDate="2014-02-12T09:55:52.400" UserId="82" Text="It depends on your skills and what you have in your Arduino &quot;box&quot;.&#xD;&#xA;Let's assume you have an ethernet or WiFi shield.&#xD;&#xA;&#xD;&#xA;I would go with a PHP script (I'm a PHP dev, but any language will fit) that accepts POST requests sent by the board and store them in a SQLite db.&#xD;&#xA;&#xD;&#xA;**Why SQLite instead of MySQL?** Well, it's just a matter of data portability. You copy the SQLite file or send it via email and you're done: there are plenty of clients out there to read your db, in *nix based machines is frequently integrated in the OS. &#xD;&#xA;&#xD;&#xA;MySQL requires a sort of &quot;infrastructure&quot; to be written/read." />
  <row Id="164" PostHistoryTypeId="5" PostId="64" RevisionGUID="899baccf-36ea-4de6-a620-1c36149c04fb" CreationDate="2014-02-12T10:05:16.950" UserId="86" Comment="edited body" Text="Have you looked at the AVR simulator that's part of [Atmel Studio][1]? Considering Atmel designed the processor, the simulation may very well be running the HDL that was used to produce the MCU itself.&#xD;&#xA;&#xD;&#xA;I suspect if you're doing something involved enough to be using unit-testing, you should probably stop thinking of your device as an &quot;Arduino&quot;, but rather &quot;An ATmega MCU on a PCB&quot;. There are **much** more information and tools available about ATmega CPUs in general then Arduinos.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/microsite/atmel_studio6/debugging_simulation.aspx" />
  <row Id="165" PostHistoryTypeId="2" PostId="85" RevisionGUID="e04e5ee1-c2e3-4a1f-b59a-a943ded33584" CreationDate="2014-02-12T10:22:23.107" UserId="42" Text="I wanted to make a fairly simple circuit which would flash a series of LEDs in sequence, using my Arduino Uno (more specifically, a SainSmart clone). I wrote my sketch and it compiled fine. After that, I connected 8 LEDS+resistors to pins 0 through 7, and then connected the Uno to my computer via USB.&#xD;&#xA;&#xD;&#xA;I've uploaded sketches successfully in the past, so I'm sure my settings and drivers etc. are correct. However, when I tried to upload my sketch this time, it didn't work.&#xD;&#xA;&#xD;&#xA;I tried removing everything I'd connected to the Arduino's pins, and suddenly the upload worked again.&#xD;&#xA;&#xD;&#xA;Why does this happen? Does it mean I have to disconnect everything from the board every time I upload a sketch?" />
  <row Id="166" PostHistoryTypeId="1" PostId="85" RevisionGUID="e04e5ee1-c2e3-4a1f-b59a-a943ded33584" CreationDate="2014-02-12T10:22:23.107" UserId="42" Text="Why can't I upload a sketch while other components/devices are connected to my Uno?" />
  <row Id="167" PostHistoryTypeId="3" PostId="85" RevisionGUID="e04e5ee1-c2e3-4a1f-b59a-a943ded33584" CreationDate="2014-02-12T10:22:23.107" UserId="42" Text="&lt;arduino-uno&gt;&lt;uploading&gt;&lt;serial&gt;&lt;gpio&gt;" />
  <row Id="168" PostHistoryTypeId="2" PostId="86" RevisionGUID="e842f9c6-ab70-4f9e-85fd-836cccb24971" CreationDate="2014-02-12T10:22:23.107" UserId="42" Text="The problem is specifically pins 0 and 1. Although they can be used as regular digital IO pins, they also serve as the RX and TX pins for the Uno's serial port. The USB connection (for uploading sketches etc.) is routed to the same pins internally. Unfortunately that means anything connected on pins 0 and 1 can interfere with the serial connection, preventing communication via USB.&#xD;&#xA;&#xD;&#xA;In short, it's not necessary to disconnect *everything* when uploading a sketch. It should only be necessary to disconnect anything from pins 0 and 1. Rather than going through that hassle every time a sketch is uploaded though, it may be best just to avoid using those pins unless necessary (e.g. you run out of other pins, or your project needs a serial connection to another device)." />
  <row Id="170" PostHistoryTypeId="2" PostId="87" RevisionGUID="95d8a79d-c4a1-4fdf-8da4-65d887e36373" CreationDate="2014-02-12T11:39:41.963" UserId="107" Text="I need to simulate my Arduino project with other circuit components before implementing the project. Is there a decent simulator that runs on Mac platform?" />
  <row Id="171" PostHistoryTypeId="1" PostId="87" RevisionGUID="95d8a79d-c4a1-4fdf-8da4-65d887e36373" CreationDate="2014-02-12T11:39:41.963" UserId="107" Text="Is there an Arduino simulator that runs on Mac OS X?" />
  <row Id="172" PostHistoryTypeId="3" PostId="87" RevisionGUID="95d8a79d-c4a1-4fdf-8da4-65d887e36373" CreationDate="2014-02-12T11:39:41.963" UserId="107" Text="&lt;mac-os&gt;&lt;simulator&gt;" />
  <row Id="173" PostHistoryTypeId="2" PostId="88" RevisionGUID="d1557c52-6fe2-4145-a623-c9852129152b" CreationDate="2014-02-12T11:40:08.950" UserId="42" Text="I've been experimenting with an 8x8 LED matrix controlled by an Arduino Uno. As I think is typical, the matrix uses a common anode for each row, and a common cathode for each column. &#xD;&#xA;&#xD;&#xA;At the moment, I've got all the matrix pins connected directly to IO pins on the Uno, and I haven't had any problems lighting the LEDs one-by-one. Going through the whole matrix like this makes updates a little slow though, meaning the LEDs aren't as bright as I'd like.&#xD;&#xA;&#xD;&#xA;As far as I know, I can't safely light up an entire row at once, because an individual pin on the Uno isn't capable of sourcing enough current to drive 8 separate LEDs at the same time (requiring at least 10mA each to be bright enough).&#xD;&#xA;&#xD;&#xA;It occurred to me that the reverse might be safer. If I light up an entire column at a time, then each pin only has to source enough current for one LED, which should be no problem. However, it relies on one pin potentially sinking the current from all 8, totalling at least 80mA.&#xD;&#xA;&#xD;&#xA;Is this possible, or am I going to fry my board?" />
  <row Id="174" PostHistoryTypeId="1" PostId="88" RevisionGUID="d1557c52-6fe2-4145-a623-c9852129152b" CreationDate="2014-02-12T11:40:08.950" UserId="42" Text="Is there a limit on how much current a pin can sink?" />
  <row Id="175" PostHistoryTypeId="3" PostId="88" RevisionGUID="d1557c52-6fe2-4145-a623-c9852129152b" CreationDate="2014-02-12T11:40:08.950" UserId="42" Text="&lt;arduino-uno&gt;&lt;gpio&gt;&lt;sink&gt;&lt;current&gt;&lt;limits&gt;" />
  <row Id="176" PostHistoryTypeId="2" PostId="89" RevisionGUID="1778d46a-3a04-4227-b486-cfd147d61a35" CreationDate="2014-02-12T12:00:32.087" UserId="70" Text="&gt; am I going to fry my board?&#xD;&#xA;&#xD;&#xA;Pretty likely outcome. Here's why:&#xD;&#xA;&#xD;&#xA;The Arduino Uno uses the atMEGA328 microcontroller, which has an absolute maximum rating of 40 mA source or sink per GPIO. Also, the total current through the supply or ground rails (i.e. the total of all current OP wants the GPIO pins to sink, or source) is rated to a maximum of 150 mA. &#xD;&#xA;&#xD;&#xA;Realistically, the current graphs in the atMEGA328 datasheet do not even go all the way to 40 mA, hence it is safest to restrict the current to perhaps 20 mA total per GPIO.&#xD;&#xA;&#xD;&#xA;In other words, whether a GPIO is used as source or sink, the limits remain pretty low, and in practice, should be kept much lower than the absolute maximum ratings. Even below absolute maximum, running a microcontroller to too high a temperature reduces its life expectancy.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Solution**: &#xD;&#xA;&#xD;&#xA;Use either BJTs, MOSFETs, or some driver IC such as the [ULN2003][1] to actually drive the current through the LEDs.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.ti.com/lit/ds/symlink/uln2003a.pdf" />
  <row Id="177" PostHistoryTypeId="2" PostId="90" RevisionGUID="351e15ee-b083-45e9-93b8-1bbf8ea2cca2" CreationDate="2014-02-12T12:36:32.577" UserId="32" Text="Check twice ! &#xD;&#xA;&#xD;&#xA;Most clones are exact clones with copies of the flaws that original Arduino board had. Like for example Arduino Nano not having proper RESET and TEST pin connection of FT232RL USB-serial bridge. This flaw may lead to FT232RL not responding to PC and was eventually fixed in later revisions of Arduino Nano board. Some clones were not updated.&#xD;&#xA;&#xD;&#xA;Another &quot;not exactly Arduino clones&quot; example are numerous boards with CP2102 USB to serial bridge instead of FT232RL. This may pass unnoticed, but may give frustration when one clone board connects and works with your PC, but another generates system complains on missing drivers.&#xD;&#xA;&#xD;&#xA;So again - be prepared !" />
  <row Id="178" PostHistoryTypeId="2" PostId="91" RevisionGUID="d0ba06e8-36f7-4f20-9b2a-a1a9318da487" CreationDate="2014-02-12T12:43:33.707" UserId="114" Text="I currently have a Mega2560 with the LCD4884 Shield. The Shield is good for putting out text and simple pixel images. But I am wondering if there is something that has a full range of colours that would work with the Arduino? The screen size would only have to be a few inches in size." />
  <row Id="179" PostHistoryTypeId="1" PostId="91" RevisionGUID="d0ba06e8-36f7-4f20-9b2a-a1a9318da487" CreationDate="2014-02-12T12:43:33.707" UserId="114" Text="Is there a color LCD display for an arduino?" />
  <row Id="180" PostHistoryTypeId="3" PostId="91" RevisionGUID="d0ba06e8-36f7-4f20-9b2a-a1a9318da487" CreationDate="2014-02-12T12:43:33.707" UserId="114" Text="&lt;lcd&gt;&lt;shields&gt;" />
  <row Id="181" PostHistoryTypeId="5" PostId="18" RevisionGUID="41cf06e2-6db6-4bf3-8299-755b649994e1" CreationDate="2014-02-12T12:56:47.850" UserId="37" Comment="added 321 characters in body" Text="This is caused by a connection error between your computer and the Arduino, and can result from many different specific problems. Here are some things that can fix this error:&#xD;&#xA;&#xD;&#xA; - Disconnect and reconnect the USB cable.&#xD;&#xA; - Use a different USB cable.&#xD;&#xA; - Press the reset button on the board.&#xD;&#xA; - Restart the Arduino IDE.&#xD;&#xA; - Make sure you select the right board in `Tools ► Board ►`, e.g. If you are using the Duemilanove 328, select that instead of Duemilanove 128. The board should say what version it is on the microchip.&#xD;&#xA; - Make sure you selected the right port in `Tools ► Serial Port ►`. One way to figure out which port it is on is by following these steps:&#xD;&#xA; 1. Disconnect the USB cable.&#xD;&#xA; 2. Go to `Tools ► Serial Port ►` and see which ports are listed (e.g. COM4 COM5 COM14).&#xD;&#xA; 3. Reconnect the USB cable.&#xD;&#xA; 4. Go back to `Tools ► Serial Port ►`, and see which port appeared that wasn't there before.&#xD;&#xA; - In extreme cases, you may need to burn the bootloader. There is a good guide on how to do that here: http://arduino.cc/en/Hacking/Bootloader?from=Main.Bootloader." />
  <row Id="182" PostHistoryTypeId="6" PostId="12" RevisionGUID="e2d7ead8-12c7-49ca-abab-60c910a9029c" CreationDate="2014-02-12T12:58:35.800" UserId="65" Comment="Arduino is redundant on the site. " Text="&lt;firmware&gt;&lt;uno&gt;" />
  <row Id="183" PostHistoryTypeId="24" PostId="12" RevisionGUID="e2d7ead8-12c7-49ca-abab-60c910a9029c" CreationDate="2014-02-12T12:58:35.800" Comment="Proposed by 65 approved by 24 edit id of 7" />
  <row Id="184" PostHistoryTypeId="2" PostId="92" RevisionGUID="413efd17-402d-4269-bad3-c30f4cefd78b" CreationDate="2014-02-12T13:06:14.843" UserId="24" Text="There are actually several shields that have color screens on them. Many of the shields are just regular mini TFT displays, however there are also touch screen ones.&#xD;&#xA;&#xD;&#xA;[Here is one][1] from Adafruit that includes a MicroSD holder and a Joystick.&#xD;&#xA;&#xD;&#xA;[Here is one][2] from Radio Shack that features a 2.8 inch screen with touch capabilities &#xD;&#xA;&#xD;&#xA;As far as screen size, many of the screens are only about an 1 inch across, however the biggest I have ever been able to find are 2.8 in.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.adafruit.com/products/802?gclid=CK3Mk63SxrwCFedlOgodA3IABQ&#xD;&#xA;  [2]: http://www.radioshack.com/product/index.jsp?productId=12688460&amp;CAWELAID=120125420000001702&amp;catargetid=120125420000031766&amp;cadevice=c&amp;cagpspn=pla&amp;gclid=CMbdyJ_TxrwCFW1nOgodHF4AGg" />
  <row Id="185" PostHistoryTypeId="2" PostId="93" RevisionGUID="238e2637-73d9-4f37-b463-296c7afcfe84" CreationDate="2014-02-12T13:12:07.613" UserId="24" Text="There is a decent program called [Simulator for Arduino][1] made by Virtronics. Although it is made to run only in windows, you could run it in a [WINE environment][2]. WINE allows windows programs to be ran in Mac and Linux OS.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://virtronics.com.au/Simulator-for-Arduino.html&#xD;&#xA;  [2]: http://wiki.winehq.org/MacOSX#head-43b0651931c700b0f796ab7d5280a08eb58d51e0" />
  <row Id="187" PostHistoryTypeId="2" PostId="95" RevisionGUID="4f4e0939-6da0-4fd7-93ba-ed2e07e9ad18" CreationDate="2014-02-12T13:27:35.770" UserId="113" Text="There's also a [2.2&quot; Adafruit TFT][1].&#xD;&#xA;&#xD;&#xA;The nice things about the Adafruit displays are:&#xD;&#xA;i) library support for both the [display][2] and the [graphics core library][3]. So it's easy to get it up and running.&#xD;&#xA;&#xD;&#xA;The built in frame buffer reduces resource requirements on Arduino.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.adafruit.com/products/1480&#xD;&#xA;  [2]: https://github.com/adafruit/Adafruit_ILI9340&#xD;&#xA;  [3]: https://github.com/adafruit/Adafruit-GFX-Library" />
  <row Id="188" PostHistoryTypeId="5" PostId="89" RevisionGUID="af681313-1148-4b0c-ae2a-e82b50b1df46" CreationDate="2014-02-12T13:39:41.790" UserId="70" Comment="added 11 characters in body" Text="&gt; am I going to fry my board?&#xD;&#xA;&#xD;&#xA;Pretty likely outcome. Here's why:&#xD;&#xA;&#xD;&#xA;The Arduino Uno uses the atMEGA328 microcontroller, which has an absolute maximum rating of 40 mA source or sink per GPIO. Also, the total current through the supply or ground rails (i.e. the total of all current OP wants the GPIO pins to sink, or source) is rated to a maximum of &lt;s&gt;150&lt;/s&gt; 200 mA. &#xD;&#xA;&#xD;&#xA;Realistically, the current graphs in the atMEGA328 datasheet do not even go all the way to 40 mA, hence it is safest to restrict the current to perhaps 20 mA total per GPIO.&#xD;&#xA;&#xD;&#xA;In other words, whether a GPIO is used as source or sink, the limits remain pretty low, and in practice, should be kept much lower than the absolute maximum ratings. Even below absolute maximum, running a microcontroller to too high a temperature reduces its life expectancy.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Solution**: &#xD;&#xA;&#xD;&#xA;Use either BJTs, MOSFETs, or some driver IC such as the [ULN2003][1] to actually drive the current through the LEDs.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.ti.com/lit/ds/symlink/uln2003a.pdf" />
  <row Id="189" PostHistoryTypeId="2" PostId="96" RevisionGUID="bf9d2455-3c13-4969-b971-1a0bf0390e6e" CreationDate="2014-02-12T13:41:46.053" UserId="118" Text="We have an LED strip connected to output 6 and is powered by the Uno board itself.  Shouldn't be drawing too much current, only have 10 elements on the LED strip.  While this LED strip is connected to the Uno, I noticed that the regulator is getting very hot.&#xD;&#xA;&#xD;&#xA;One thing we haven't done yet is to power the LED strips from an external source, which will be necessary since there will be many strips.  At the moment, the students are simply trying to debug their program with the small strip." />
  <row Id="190" PostHistoryTypeId="1" PostId="96" RevisionGUID="bf9d2455-3c13-4969-b971-1a0bf0390e6e" CreationDate="2014-02-12T13:41:46.053" UserId="118" Text="Why is the regulator very hot?" />
  <row Id="191" PostHistoryTypeId="3" PostId="96" RevisionGUID="bf9d2455-3c13-4969-b971-1a0bf0390e6e" CreationDate="2014-02-12T13:41:46.053" UserId="118" Text="&lt;power&gt;&lt;heat&gt;" />
  <row Id="192" PostHistoryTypeId="2" PostId="97" RevisionGUID="54b3b8bb-019e-4902-a6f3-c00d9f2d9590" CreationDate="2014-02-12T13:47:34.540" UserId="113" Text="I like to use [123dcircuits.io][1] for this.&#xD;&#xA;&#xD;&#xA;It's cloud based and has some nice features including PCB design and collaboration.&#xD;&#xA;&#xD;&#xA;IMO the Arduino simulation and capability is impressive and intuitive.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://123d.circuits.io/" />
  <row Id="193" PostHistoryTypeId="2" PostId="98" RevisionGUID="115bf966-5e2d-4409-88ee-0ede2036fe9d" CreationDate="2014-02-12T13:49:35.820" UserId="65" Text="One of the sections of the Arduino that is likely to become unreliable over time is its memory. There are [three pools of memory][1] in the microcontroller used on avr-based Arduino boards:&#xD;&#xA;&#xD;&#xA;- Flash memory (program space), is where the Arduino sketch is stored.&#xD;&#xA;- SRAM (static random access memory) is where the sketch creates and manipulates variables when it runs.&#xD;&#xA;- EEPROM is memory space that programmers can use to store long-term information.&#xD;&#xA;&#xD;&#xA;The memory is one part of the board that can be checked and verified, and thus evaluated for reliability/health. A very basic way to check memory would be to write a certain 8-bit pattern (byte character) over every address in the memory and then read the value present from every address. If the value that was written matches the value that is read, then that specific 8 bit block in memory is functioning correctly at the present moment. &#xD;&#xA;&#xD;&#xA;Wear in ROM and Flash memory usually occurs in a blockwise pattern i.e. n*8-bit blocks become degraded and are not able to store data correctly. So, for a 2K byte ROM chip, the health of the chip can be estimated by writing and reading from every byte on the chip, and calculating the percentage of correctly functioning blocks. If the percentage of failed blocks is significant (15%-20%), that means that the memory is likely to fail soon.&#xD;&#xA;&#xD;&#xA;The test code can be written using separate methods for each of the memory sections.&#xD;&#xA;&#xD;&#xA;###SRAM&#xD;&#xA;Any variables declared statically or dynamically are allocated on the SRAM. So, we could declare a large integer array (1000+) and fill every element with 255 (all bits 1). Then, we could attempt to read each of those elements and see if the value being read is indeed 255. &#xD;&#xA;&#xD;&#xA;###EEPROM&#xD;&#xA;The EEPROM can be manipulated using the [EEPROM library][2]. The library provides functions to read and write from specific locations in the EEPROM. So, all memory addresses can be tested by simply looping over the entire memory space. *This operation will require 500 writes and reads.*&#xD;&#xA;&#xD;&#xA;###Flash&#xD;&#xA;Data can be stored on the flash memory using the [`PROGMEM`][3] directive. Similar to SRAM, a large array can be declared and initialized here. Then, values can be read and checked.&#xD;&#xA;&#xD;&#xA;Depending on the board usage, EEPROM is most likely to fail first but is not critical to board operation. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Tutorial/Memory&#xD;&#xA;  [2]: http://www.arduino.cc/en/Reference/EEPROM&#xD;&#xA;  [3]: http://www.arduino.cc/en/Reference/PROGMEM" />
  <row Id="194" PostHistoryTypeId="5" PostId="38" RevisionGUID="1f0edfa0-8845-4567-861a-0f8476c1fd3e" CreationDate="2014-02-12T13:55:27.613" UserId="65" Comment="deleted 2 characters in body; edited title" Text="I am working on a real time application which is recording sensor data continuously. I need to process the data in realtime using R. Is there a way to connect and communicate with the uno board through RStudio via serial port?" />
  <row Id="195" PostHistoryTypeId="4" PostId="38" RevisionGUID="1f0edfa0-8845-4567-861a-0f8476c1fd3e" CreationDate="2014-02-12T13:55:27.613" UserId="65" Comment="deleted 2 characters in body; edited title" Text="How do I communicate with the Uno using R through RStudio?" />
  <row Id="196" PostHistoryTypeId="2" PostId="99" RevisionGUID="8bdfa270-56fd-423a-b88d-8d8ac941522b" CreationDate="2014-02-12T14:08:24.913" UserId="3" Text="A regulator normally get hot when is driven a current near to the maximum that could be driven, and its a normal thing the regulator keep warm. &#xD;&#xA;&#xD;&#xA;A normal regulator like [LM7805][1] could work until 125 C°. &#xD;&#xA;&#xD;&#xA;If you try to drive more current that it can probably it will burn, so, maybe its time to you change your power supply to an external one to keep safe your Arduino board.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.fairchildsemi.com/ds/LM/LM7805.pdf" />
  <row Id="197" PostHistoryTypeId="2" PostId="100" RevisionGUID="887ca80a-f7bc-4d86-82ba-91569b50b636" CreationDate="2014-02-12T14:16:50.190" UserId="83" Text="If you power the Arduino with an external power supply the on board regulator has to *dissipate* the voltage difference between input and 5VDC at the total current you draw from the board. &#xD;&#xA;&#xD;&#xA;As Klaus Warzecha wrote in an [answer](http://arduino.stackexchange.com/questions/60/how-to-prevent-breaking-my-arduino-by-mistake/72#72) [to another question](http://arduino.stackexchange.com/questions/60/how-to-prevent-breaking-my-arduino-by-mistake) &#xD;&#xA;&#xD;&#xA;&gt; The Arduino is just the brain, not the power station.&#xD;&#xA;&#xD;&#xA;If the output voltage of your power supply is 12V, then the regulator will be dissipating 12-5V = 7 V at the total current drawn. Total dissipated power for eg. 150mA (just an estimate) would be P = V × I = 7 × 0.150 = 1W&#xD;&#xA;The regulator will be pretty hot from dissipating 1W. &#xD;&#xA;&#xD;&#xA;Mind you that the current is not limited to 150mA, enough LEDs can easily increase current and power. If the regulator is stressed (often) enough, sooner or later it will fail. It is better practice to power any load directly from the external power supply, taking the higher voltage into account." />
  <row Id="198" PostHistoryTypeId="5" PostId="100" RevisionGUID="c6593b72-bfd2-47ba-b8e4-e488efdc3226" CreationDate="2014-02-12T14:28:41.203" UserId="83" Comment="edited body" Text="If you power the Arduino with an external power supply the on board regulator has to *dissipate* the voltage difference between input and 5VDC at the total current you draw from the board. &#xD;&#xA;&#xD;&#xA;As Klaus Warzecha wrote in an [answer](http://arduino.stackexchange.com/questions/60/how-to-prevent-breaking-my-arduino-by-mistake/72#72) to [another question](http://arduino.stackexchange.com/questions/60/how-to-prevent-breaking-my-arduino-by-mistake) &#xD;&#xA;&#xD;&#xA;&gt; The Arduino is just the brain, not the power station.&#xD;&#xA;&#xD;&#xA;If the output voltage of your power supply is 12V, then the regulator will be dissipating 12-5V = 7 V at the total current drawn. Total dissipated power for eg. 150mA (just an estimate) would be P = V × I = 7 × 0.150 = 1W&#xD;&#xA;The regulator will be pretty hot from dissipating 1W. &#xD;&#xA;&#xD;&#xA;Mind you that the current is not limited to 150mA, enough LEDs can easily increase current and power. If the regulator is stressed (often) enough, sooner or later it will fail. It is better practice to power any load directly from the external power supply, taking the higher voltage into account." />
  <row Id="200" PostHistoryTypeId="5" PostId="53" RevisionGUID="ccd89cb3-85d7-4ce6-839d-9724576feb92" CreationDate="2014-02-12T14:39:25.280" UserId="65" Comment="added 284 characters in body" Text="Is a standard library function. It returns the number of milliseconds since the Arduino board began running the current program. This number will overflow (go back to zero), after approximately 50 days.&#xD;&#xA;&#xD;&#xA;For more, see the [standard reference](http://arduino.cc/en/Reference/millis)." />
  <row Id="201" PostHistoryTypeId="24" PostId="53" RevisionGUID="ccd89cb3-85d7-4ce6-839d-9724576feb92" CreationDate="2014-02-12T14:39:25.280" Comment="Proposed by 65 approved by -1 edit id of 13" />
  <row Id="202" PostHistoryTypeId="5" PostId="53" RevisionGUID="77e53299-f730-471c-ac3d-c01f71bfc3cf" CreationDate="2014-02-12T14:39:25.280" UserId="48" Comment="added 7 characters in body" Text="Millis is a standard library function. It returns the number of milliseconds since the Arduino board began running the current program. This number will overflow (go back to zero), after approximately 50 days.&#xD;&#xA;&#xD;&#xA;For more, see the [standard reference](http://arduino.cc/en/Reference/millis)." />
  <row Id="203" PostHistoryTypeId="5" PostId="43" RevisionGUID="94aee657-ad45-49b7-a5eb-5fd54b9a21f4" CreationDate="2014-02-12T14:39:49.660" UserId="103" Comment="Another important IDE for windows specially should be mentioned here, thanks for your answer." Text="There is an [Arduino Eclipse plugin][1]! And Eclipse is an awesome cross-plateform open-source IDE!&#xD;&#xA;&#xD;&#xA;[Stino][2] is good. Requires [Sublime Text 2][3] which has an indefinite free trial.&#xD;&#xA;&#xD;&#xA;For More Go to [Office Site][4] &#xD;&#xA;&#xD;&#xA;For development on Windows, there is a special edition from Arduino official IDE called [arduino-erw][5], This edition much better the last one because it fixed a lot of lagging and stability issues!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Code/Eclipse&#xD;&#xA;  [2]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [3]: http://www.sublimetext.com/2&#xD;&#xA;  [4]: http://playground.arduino.cc/Main/DevelopmentTools&#xD;&#xA;  [5]: https://code.google.com/p/arduino-erw/" />
  <row Id="204" PostHistoryTypeId="24" PostId="43" RevisionGUID="94aee657-ad45-49b7-a5eb-5fd54b9a21f4" CreationDate="2014-02-12T14:39:49.660" Comment="Proposed by 103 approved by 48 edit id of 15" />
  <row Id="206" PostHistoryTypeId="5" PostId="54" RevisionGUID="ccfe4064-75e7-4ff8-8913-9fcc3bdb4b20" CreationDate="2014-02-12T14:43:11.600" UserId="65" Comment="added 128 characters in body" Text="Is a standard library function. It returns the number of milliseconds since the Arduino board began running the current program." />
  <row Id="207" PostHistoryTypeId="24" PostId="54" RevisionGUID="ccfe4064-75e7-4ff8-8913-9fcc3bdb4b20" CreationDate="2014-02-12T14:43:11.600" Comment="Proposed by 65 approved by 48 edit id of 14" />
  <row Id="208" PostHistoryTypeId="5" PostId="45" RevisionGUID="537b283c-96cf-44ab-ae79-90afea0dd26f" CreationDate="2014-02-12T14:43:20.430" UserId="52" Comment="added 228 characters in body" Text="Use this tag for questions relating to computer software used for interaction with the Arduino.  For example, you could use this tag for questions about programming environments, or you could use it for PC/Arduino communication." />
  <row Id="209" PostHistoryTypeId="24" PostId="45" RevisionGUID="537b283c-96cf-44ab-ae79-90afea0dd26f" CreationDate="2014-02-12T14:43:20.430" Comment="Proposed by 52 approved by 48 edit id of 9" />
  <row Id="210" PostHistoryTypeId="2" PostId="101" RevisionGUID="4bbac7ad-2a01-4fc8-8547-7cc8e712455b" CreationDate="2014-02-12T14:57:09.747" UserId="4" Text="[vim][1] can be used for Arduino development, but it will take some configuration (as is the way of vim). You'll need the [syntax file][2] and [this plugin][3] that enables you to compile and deploy from vim.&#xD;&#xA;&#xD;&#xA;[Grant Lucas][4] produced a great write-up on getting your environment situation squared away:&#xD;&#xA;&#xD;&#xA;&gt; ## [Using Vim for Arduino development][5]&#xD;&#xA;&gt; &#xD;&#xA;&gt; Here's a quick post on setting up Vim for Arduino development instead&#xD;&#xA;&gt; of using the Arduino IDE. If you're a heavy Vim user, it can be a bit&#xD;&#xA;&gt; of a shock to go into a different editor. Thankfully the setup is&#xD;&#xA;&gt; pretty easy to get this all working with Vim. This post is assuming&#xD;&#xA;&gt; you are comfortable with how Vim is setup and ideally already have an&#xD;&#xA;&gt; environment that works for you.&#xD;&#xA;&gt; &#xD;&#xA;&gt; ### Install the Arduino IDE&#xD;&#xA;&gt; &#xD;&#xA;&gt; _Wait. What?!?_ I hear you say. I know, I know. We're not actually using the Arduino IDE but we need it for some configuration and the&#xD;&#xA;&gt; files it installs. The Vim plugin we'll be using ties into what the&#xD;&#xA;&gt; IDE installs and configures so it's needed. You can download the IDE&#xD;&#xA;&gt; from the [Arduino site][6].&#xD;&#xA;&gt; &#xD;&#xA;&gt; ### Install vim-arduino plugin&#xD;&#xA;&gt; &#xD;&#xA;&gt; To get the main goodness of compiling, monitoring and deploying to an&#xD;&#xA;&gt; Arduino, grab the latest version of [vim-arduino][7]. Install it in&#xD;&#xA;&gt; your .vim folder using what ever method you use to manage your Vim&#xD;&#xA;&gt; plugins. **Hint:** I'd recommend [Pathogen][8] as it makes installing&#xD;&#xA;&gt; as simple as dropping the plugin folder into a bundle folder.&#xD;&#xA;&gt; &#xD;&#xA;&gt; ### Vim syntax file&#xD;&#xA;&gt; &#xD;&#xA;&gt; Next up is to get the syntax file so we can have nice colour coding&#xD;&#xA;&gt; for .pde and .ino files. Download the latest [arduino.vim][9] and&#xD;&#xA;&gt; install it in your Vim syntax folder. To get the syntax to apply to&#xD;&#xA;&gt; the correct file types add the following to your vimrc file&#xD;&#xA;&gt; &#xD;&#xA;&gt;     au BufRead,BufNewFile *.pde set filetype=arduino&#xD;&#xA;&gt;     au BufRead,BufNewFile *.ino set filetype=arduino&#xD;&#xA;&gt; &#xD;&#xA;&gt; ### Configuring the Arduino IDE&#xD;&#xA;&gt; &#xD;&#xA;&gt; Before trying to compile and deploy with Vim, get it all working with&#xD;&#xA;&gt; the Arduino IDE first as the Vim plugin just calls from the settings&#xD;&#xA;&gt; saved by the IDE. If it's working in the IDE, it should work in Vim.&#xD;&#xA;&gt; Make sure you select the right tty.usbmodem* serial port from Tools &gt;&#xD;&#xA;&gt; Serial Port in the IDE. **Note:** This will only show when the Arduino&#xD;&#xA;&gt; is plugged in.&#xD;&#xA;&gt; &#xD;&#xA;&gt; ### Working from Vim&#xD;&#xA;&gt; &#xD;&#xA;&gt; Once you can communicate with your Arduino from the IDE you should be&#xD;&#xA;&gt; fully good to go with Vim. You shouldn't have to open the IDE unless&#xD;&#xA;&gt; you want some example code. Open up your sketch file in Vim and use&#xD;&#xA;&gt; `&lt;Leader&gt;ac` to compile a sketch, `&lt;Leader&gt;ad` to compile and then&#xD;&#xA;&gt; deploy to the connected Arduino and `&lt;Leader&gt;as` to open a new window&#xD;&#xA;&gt; with `screen` to monitor the serial output from the Arduino.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Vim_%28text_editor%29&#xD;&#xA;  [2]: http://www.vim.org/scripts/script.php?script_id=2654 &quot;Syntax file for Arduino .PDE files &quot;&#xD;&#xA;  [3]: https://github.com/tclem/vim-arduino &quot;GitHub: tclem / vim-arduino&quot;&#xD;&#xA;  [4]: https://twitter.com/grantlucas&#xD;&#xA;  [5]: http://grantlucas.com/posts/2012/09/using-vim-arduino-development&#xD;&#xA;  [6]: http://arduino.cc/en/Main/Software&#xD;&#xA;  [7]: https://github.com/tclem/vim-arduino&#xD;&#xA;  [8]: https://github.com/tpope/vim-pathogen&#xD;&#xA;  [9]: http://www.vim.org/scripts/script.php?script_id=2654" />
  <row Id="211" PostHistoryTypeId="6" PostId="88" RevisionGUID="9637eb2a-6236-4b4f-8dca-f1dffe543370" CreationDate="2014-02-12T15:00:09.540" UserId="37" Comment="changed &quot;arduion-uno&quot; to &quot;uno&quot;, see meta.arduino.stackexchange.com/questions/3" Text="&lt;uno&gt;&lt;gpio&gt;&lt;sink&gt;&lt;current&gt;&lt;limits&gt;" />
  <row Id="212" PostHistoryTypeId="24" PostId="88" RevisionGUID="9637eb2a-6236-4b4f-8dca-f1dffe543370" CreationDate="2014-02-12T15:00:09.540" Comment="Proposed by 37 approved by 42 edit id of 16" />
  <row Id="213" PostHistoryTypeId="6" PostId="85" RevisionGUID="d342cf43-4a54-4aaa-a385-82bf9e44415d" CreationDate="2014-02-12T15:00:19.307" UserId="37" Comment="changed &quot;arduino-uno&quot; to &quot;uno&quot;, see meta.arduino.stackexchange.com/questions/3" Text="&lt;uno&gt;&lt;uploading&gt;&lt;serial&gt;&lt;gpio&gt;" />
  <row Id="214" PostHistoryTypeId="24" PostId="85" RevisionGUID="d342cf43-4a54-4aaa-a385-82bf9e44415d" CreationDate="2014-02-12T15:00:19.307" Comment="Proposed by 37 approved by 42 edit id of 17" />
  <row Id="215" PostHistoryTypeId="6" PostId="39" RevisionGUID="2fb7517d-5b2e-412c-b8ad-a9cb8ef4e28b" CreationDate="2014-02-12T15:11:54.230" UserId="37" Comment="changed &quot;arduino-uno&quot; to &quot;uno&quot;, see meta.arduino.stackexchange.com/questions/3" Text="&lt;uno&gt;&lt;ethernet&gt;" />
  <row Id="216" PostHistoryTypeId="24" PostId="39" RevisionGUID="2fb7517d-5b2e-412c-b8ad-a9cb8ef4e28b" CreationDate="2014-02-12T15:11:54.230" Comment="Proposed by 37 approved by 33 edit id of 19" />
  <row Id="221" PostHistoryTypeId="2" PostId="104" RevisionGUID="420a0836-0b74-41ca-8769-3ee78936e105" CreationDate="2014-02-12T15:31:08.343" UserId="123" Text="Is there any easy way to upload program / sketch from ipad/ Android tablet without adding extra shield (blue tooth or wifi).&#xD;&#xA;&#xD;&#xA;If no, can it be done using shield? which shield is preferred?&#xD;&#xA;&#xD;&#xA;Also what are the IDE options available?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="222" PostHistoryTypeId="1" PostId="104" RevisionGUID="420a0836-0b74-41ca-8769-3ee78936e105" CreationDate="2014-02-12T15:31:08.343" UserId="123" Text="Uploading program from tablet" />
  <row Id="223" PostHistoryTypeId="3" PostId="104" RevisionGUID="420a0836-0b74-41ca-8769-3ee78936e105" CreationDate="2014-02-12T15:31:08.343" UserId="123" Text="&lt;uploading&gt;&lt;ipad-support&gt;" />
  <row Id="224" PostHistoryTypeId="2" PostId="105" RevisionGUID="b6183ece-36c1-4418-a163-ebeac8ab9f07" CreationDate="2014-02-12T15:31:17.143" UserId="24" Text="I am not very skilled with the C Language and I was wondering if there is a way in which python could be used to program an Arduino. This would most likely require a different IDE in order to be able to debug the scripts them self. " />
  <row Id="225" PostHistoryTypeId="1" PostId="105" RevisionGUID="b6183ece-36c1-4418-a163-ebeac8ab9f07" CreationDate="2014-02-12T15:31:17.143" UserId="24" Text="Can other programming languages be used with an arduino?" />
  <row Id="226" PostHistoryTypeId="3" PostId="105" RevisionGUID="b6183ece-36c1-4418-a163-ebeac8ab9f07" CreationDate="2014-02-12T15:31:17.143" UserId="24" Text="&lt;programming&gt;" />
  <row Id="229" PostHistoryTypeId="10" PostId="57" RevisionGUID="b7a9786b-e057-4f48-8a23-39e25710c7da" CreationDate="2014-02-12T15:40:23.073" UserId="-1" Comment="104" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:13,&quot;DisplayName&quot;:&quot;Matthew G.&quot;},{&quot;Id&quot;:84,&quot;DisplayName&quot;:&quot;jfpoilpret&quot;},{&quot;Id&quot;:65,&quot;DisplayName&quot;:&quot;AsheeshR&quot;},{&quot;Id&quot;:37,&quot;DisplayName&quot;:&quot;Ryan Carlson&quot;},{&quot;Id&quot;:4,&quot;DisplayName&quot;:&quot;JohnB&quot;}]}" />
  <row Id="230" PostHistoryTypeId="4" PostId="105" RevisionGUID="26132dc7-071c-4558-aa20-df2dee3af3b4" CreationDate="2014-02-12T15:41:23.757" UserId="24" Comment="edited title" Text="Programming an Arduino using Python, rather than C/C++" />
  <row Id="231" PostHistoryTypeId="2" PostId="106" RevisionGUID="7bb47e16-ff56-4f2b-a5b3-79e27e87a40f" CreationDate="2014-02-12T15:46:09.823" UserId="24" Text="Unfortunately Apple doesn't allow apps that implement programming languages. This being said, it is unclear why they would not allow an app that has to do with the Arduino IDE due to the fact that the code doesn't actually run on the Ipad itself. &#xD;&#xA;&#xD;&#xA;See [here][1] for more Info.&#xD;&#xA;&#xD;&#xA;As far as an Android IDE, I have heard that there are a few people working on different IDEs that sends the code to the Arduino over the internet, although they have not been released yet, and the details are still a bit unclear.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.libertypages.com/clarktech/?p=1690" />
  <row Id="232" PostHistoryTypeId="2" PostId="107" RevisionGUID="6cf604c9-f368-42be-856a-ebe8a5edbd4a" CreationDate="2014-02-12T15:47:38.990" UserId="-1" Text="" />
  <row Id="233" PostHistoryTypeId="2" PostId="108" RevisionGUID="bf2eb450-7616-44fe-85fe-0225ec5b6f79" CreationDate="2014-02-12T15:47:38.990" UserId="-1" Text="" />
  <row Id="234" PostHistoryTypeId="2" PostId="109" RevisionGUID="3160f2c0-0e38-4faa-bf14-fa1ec0dc447b" CreationDate="2014-02-12T15:58:37.333" UserId="-1" Text="" />
  <row Id="235" PostHistoryTypeId="2" PostId="110" RevisionGUID="596644cc-f0eb-4b29-a5b6-2237ffbefdf6" CreationDate="2014-02-12T15:58:37.333" UserId="-1" Text="" />
  <row Id="236" PostHistoryTypeId="5" PostId="1" RevisionGUID="6bc6bb42-3374-4baa-9f96-a11b1bb7294f" CreationDate="2014-02-12T15:58:51.040" UserId="4" Comment="I reworded a lot of this to try and correct some grammar issues but did my best to maintain the original question." Text="I'm making a simple Arduino web server and I want to keep it turned on all the time. So it must endure to stay working continuously. &#xD;&#xA;&#xD;&#xA;I'm using an Arduino Uno with a Ethernet Shield.&#xD;&#xA;It's powered with a simple outlet power supply 5V @ 1A.&#xD;&#xA;&#xD;&#xA;My Questions:&#xD;&#xA;&#xD;&#xA; - Will I have any problems leaving the Arduino turned on all the time?&#xD;&#xA; - Is there some other Arduino board better recommended for this?&#xD;&#xA; - Are there any precautions that I need to heed regarding this?" />
  <row Id="237" PostHistoryTypeId="24" PostId="1" RevisionGUID="6bc6bb42-3374-4baa-9f96-a11b1bb7294f" CreationDate="2014-02-12T15:58:51.040" Comment="Proposed by 4 approved by 3 edit id of 28" />
  <row Id="238" PostHistoryTypeId="6" PostId="105" RevisionGUID="8feb58cf-3356-47a7-b0e0-bdf88ddbee55" CreationDate="2014-02-12T15:59:32.043" UserId="65" Comment="Language tag added" Text="&lt;programming&gt;&lt;python&gt;" />
  <row Id="239" PostHistoryTypeId="24" PostId="105" RevisionGUID="8feb58cf-3356-47a7-b0e0-bdf88ddbee55" CreationDate="2014-02-12T15:59:32.043" Comment="Proposed by 65 approved by 24 edit id of 29" />
  <row Id="240" PostHistoryTypeId="5" PostId="98" RevisionGUID="cce06c2e-3f6d-4627-9da7-b045c872cde6" CreationDate="2014-02-12T16:00:39.920" UserId="65" Comment="deleted 41 characters in body" Text="One of the sections of the Arduino that is likely to become unreliable over time is its memory. There are [three pools of memory][1] in the microcontroller used on avr-based Arduino boards:&#xD;&#xA;&#xD;&#xA;- Flash memory (program space), is where the Arduino sketch is stored.&#xD;&#xA;- SRAM (static random access memory) is where the sketch creates and manipulates variables when it runs.&#xD;&#xA;- EEPROM is memory space that programmers can use to store long-term information.&#xD;&#xA;&#xD;&#xA;The memory is one part of the board that can be checked and verified, and thus evaluated for reliability/health. A very basic way to check memory would be to write a certain 8-bit pattern (byte character) over every address in the memory and then read the value present from every address. If the value that was written matches the value that is read, then that specific 8 bit block in memory is functioning correctly at the present moment. &#xD;&#xA;&#xD;&#xA;Wear in ROM memory usually occurs in a blockwise pattern i.e. n*8-bit blocks become degraded over time. So, for a 2K byte ROM chip, the health of the chip can be estimated by writing and reading from every byte on the chip, and calculating the percentage of correctly functioning blocks. If the percentage of failed blocks is significant (15%-20%), that means that the memory is likely to fail soon.&#xD;&#xA;&#xD;&#xA;The test code can be written using separate methods for each of the memory sections.&#xD;&#xA;&#xD;&#xA;###SRAM&#xD;&#xA;Any variables declared statically or dynamically are allocated on the SRAM. So, we could declare a large integer array (1000+) and fill every element with 255 (all bits 1). Then, we could attempt to read each of those elements and see if the value being read is indeed 255. &#xD;&#xA;&#xD;&#xA;###EEPROM&#xD;&#xA;The EEPROM can be manipulated using the [EEPROM library][2]. The library provides functions to read and write from specific locations in the EEPROM. So, all memory addresses can be tested by simply looping over the entire memory space. *This operation will require 500 writes and reads.*&#xD;&#xA;&#xD;&#xA;###Flash&#xD;&#xA;Data can be stored on the flash memory using the [`PROGMEM`][3] directive. Similar to SRAM, a large array can be declared and initialized here. Then, values can be read and checked.&#xD;&#xA;&#xD;&#xA;Depending on the board usage, EEPROM is most likely to fail first but is not critical to board operation. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Tutorial/Memory&#xD;&#xA;  [2]: http://www.arduino.cc/en/Reference/EEPROM&#xD;&#xA;  [3]: http://www.arduino.cc/en/Reference/PROGMEM" />
  <row Id="241" PostHistoryTypeId="2" PostId="111" RevisionGUID="fc928204-2e45-4b2e-a94d-1ab33e6fe716" CreationDate="2014-02-12T16:02:26.177" UserId="-1" Text="" />
  <row Id="242" PostHistoryTypeId="2" PostId="112" RevisionGUID="e0e74c2b-e0e6-4231-bfd1-cdf742cd43e8" CreationDate="2014-02-12T16:02:26.177" UserId="-1" Text="" />
  <row Id="243" PostHistoryTypeId="2" PostId="113" RevisionGUID="21574530-3286-49b1-a7fc-c107121bbc20" CreationDate="2014-02-12T16:04:13.967" UserId="65" Text="The function `millis` would be running in the span of 100+ microseconds or less. Is there a reliable way to go about measuring the time taken by a single millis call?&#xD;&#xA;&#xD;&#xA;One approach that comes to mind is using `micros`, however, a call to `micros` will include the time taken by the function call of `micros` itself as well, so depending on how long micros takes, the measurement for `millis` may be off.&#xD;&#xA;&#xD;&#xA;I need to find this as an application I am working on requires accurate time measurements for every step taken in the code, including `millis`." />
  <row Id="244" PostHistoryTypeId="1" PostId="113" RevisionGUID="21574530-3286-49b1-a7fc-c107121bbc20" CreationDate="2014-02-12T16:04:13.967" UserId="65" Text="Is it possible to find the time taken by millis?" />
  <row Id="245" PostHistoryTypeId="3" PostId="113" RevisionGUID="21574530-3286-49b1-a7fc-c107121bbc20" CreationDate="2014-02-12T16:04:13.967" UserId="65" Text="&lt;time&gt;&lt;millis&gt;" />
  <row Id="246" PostHistoryTypeId="5" PostId="106" RevisionGUID="41aaf351-c69d-4b55-8355-3c08c4ebba1b" CreationDate="2014-02-12T16:11:44.437" UserId="24" Comment="Forgot to include source of answer" Text="Unfortunately Apple doesn't allow apps that implement programming languages. This being said, it is unclear why they would not allow an app that has to do with the Arduino IDE due to the fact that the code doesn't actually run on the Ipad itself. &#xD;&#xA;&#xD;&#xA;See [here][1] for more Info.&#xD;&#xA;&#xD;&#xA;As far as an Android IDE, I have heard that there are a few people working on different IDEs that sends the code to the Arduino over the internet, although they have not been released yet, and the details are still a bit unclear.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.libertypages.com/clarktech/?p=1690&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Source:&#xD;&#xA;http://forum.arduino.cc/index.php?topic=61305.0" />
  <row Id="247" PostHistoryTypeId="2" PostId="114" RevisionGUID="c630847b-be2e-473c-951f-22273640460c" CreationDate="2014-02-12T16:18:01.803" UserId="65" Text="Yes, it is (somewhat) possible to program the Arduino using Python. One such project on Github is the [Python Arduino Prototyping API v2][1]. It provides very basic functionality such as digital I/O and analog I/O.&#xD;&#xA;&#xD;&#xA;This can be used for very simple projects.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;*This project is a bit of a hack at &quot;programming&quot; the board using the serial connection. It passes the commands over the serial connection to a sketch running on the board which then &quot;executes&quot; the Python command.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://github.com/vascop/Python-Arduino-Proto-API-v2" />
  <row Id="248" PostHistoryTypeId="2" PostId="115" RevisionGUID="b380f4f2-aa21-47a3-bbf8-5a133c37ca26" CreationDate="2014-02-12T16:19:51.607" UserId="13" Text="I can't seem to figure out directly how to read from a serial port using R; While there does seem to have been at least [one attempt](https://biostatmatt.com/archives/112) to provide this, it's not clear that it ever graduated to something supported or easily installable. &#xD;&#xA;&#xD;&#xA;Having said that, R does have [`read.socket` and `write.socket`](http://stat.ethz.ch/R-manual/R-patched/library/utils/html/read.socket.html), which I believe would make it easy enough to use through [`ser2net`](http://ser2net.sourceforge.net), which exposes a serial-port as a socket. " />
  <row Id="249" PostHistoryTypeId="2" PostId="116" RevisionGUID="c0550cdf-1a9f-49b5-bc25-217d467d20c5" CreationDate="2014-02-12T16:28:12.037" UserId="42" Text="It's going to be extremely difficult to get any kind of Python script running directly on the Arduino. The reason is that it's an interpreted language, so you would need the interpreter on-board in addition to the plain text script. There's probably not going to be enough memory for all of that.&#xD;&#xA;&#xD;&#xA;Your best bet would probably be finding a way to compile a Python script to native machine code (which is how C/C++ works). I believe there are projects around to do something like that for other platforms, but (as far as I know) none which does it successfully for Arduino yet.&#xD;&#xA;&#xD;&#xA;You might find some more useful information on this question at Stack Overflow: [Is there a way to &quot;compile&quot; Python code onto an Arduino (Uno)][1].&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/8114916/is-there-a-way-to-compile-python-code-onto-an-arduino-uno" />
  <row Id="250" PostHistoryTypeId="6" PostId="56" RevisionGUID="6638a811-3e5d-43cd-ba2c-fb2379d6d299" CreationDate="2014-02-12T16:34:11.010" UserId="37" Comment="changed &quot;arduino-uno&quot; to &quot;uno&quot;, see meta.arduino.stackexchange.com/questions/3" Text="&lt;uno&gt;&lt;unit-test&gt;" />
  <row Id="251" PostHistoryTypeId="24" PostId="56" RevisionGUID="6638a811-3e5d-43cd-ba2c-fb2379d6d299" CreationDate="2014-02-12T16:34:11.010" Comment="Proposed by 37 approved by 77 edit id of 21" />
  <row Id="252" PostHistoryTypeId="2" PostId="117" RevisionGUID="4f8c12e9-cbdd-42fe-9873-329d55ebab9d" CreationDate="2014-02-12T16:42:31.307" UserId="24" Text="Is it possible to have more than 13 output pins on the Arduino, I am working on a project in which I need to light up several LEDs individually. I only have an Arduino Uno, and I don't want to get a Mega. " />
  <row Id="253" PostHistoryTypeId="1" PostId="117" RevisionGUID="4f8c12e9-cbdd-42fe-9873-329d55ebab9d" CreationDate="2014-02-12T16:42:31.307" UserId="24" Text="Is there a way to have more than 13 Output pins on arduino?" />
  <row Id="254" PostHistoryTypeId="3" PostId="117" RevisionGUID="4f8c12e9-cbdd-42fe-9873-329d55ebab9d" CreationDate="2014-02-12T16:42:31.307" UserId="24" Text="&lt;uno&gt;" />
  <row Id="255" PostHistoryTypeId="2" PostId="118" RevisionGUID="f192b555-f32b-4c6b-9f6d-4ec3be585654" CreationDate="2014-02-12T16:42:31.307" UserId="24" Text="There are two ways you can get more pins out of an arduino.&#xD;&#xA;&#xD;&#xA;The first way is by using the Analog pins as digital output pins, which is really easy to do. All you need to do is refer to A0-A5 as pins 14,15,16,17,18,19. For example to write high to pin A0 just use digitalWrite(14, HIGH).&#xD;&#xA;&#xD;&#xA;The other way to get more pins out of the Arduino is by using a Shift Register. To do this I recommend using the [EZ-Expander Shield][1], which allows you to use digitalWrite([20-35], HIGH) when you import the EZ-Expander Library. This shield however only allows the pins to be used as outputs only and uses pins 8,12 and 13 to control the shift registers. &#xD;&#xA;&#xD;&#xA;The great thing is, is that you can use both of the two methods above together, without any problems.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://nootropicdesign.com/ez-expander/" />
  <row Id="256" PostHistoryTypeId="2" PostId="119" RevisionGUID="224d0f39-bd5e-4582-a88b-fee67ff3fc67" CreationDate="2014-02-12T16:54:59.757" UserId="46" Text="A common way to expand the set of available output pins on the Arduino is to use shift registers like the 74HC595 IC ([link to datasheet](http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf))." />
  <row Id="257" PostHistoryTypeId="5" PostId="109" RevisionGUID="c9fb82d0-fe44-4941-b7b6-06a7da36eaf1" CreationDate="2014-02-12T16:57:38.163" UserId="37" Comment="added 455 characters in body" Text="Ethernet can be used for communication between an Arduino and a computer. It is defined as _a system for connecting a number of computer systems to form a local area network, with protocols to control the passing of information and to avoid simultaneous transmission by two or more systems_&#xD;&#xA;&#xD;&#xA;There is also an [Arduino Ethernet board][1], for which you should use the tag [tag:arduino-ethernet].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardEthernet" />
  <row Id="258" PostHistoryTypeId="24" PostId="109" RevisionGUID="c9fb82d0-fe44-4941-b7b6-06a7da36eaf1" CreationDate="2014-02-12T16:57:38.163" Comment="Proposed by 37 approved by 48 edit id of 30" />
  <row Id="259" PostHistoryTypeId="5" PostId="107" RevisionGUID="e261a3ba-0b5c-4db1-8d02-14fb59c367be" CreationDate="2014-02-12T16:57:42.883" UserId="37" Comment="added 725 characters in body" Text="The Arduino Uno is the most common and one of the newest Arduino boards. It has 14 digital I/O pins and 6 Analog input pins. There are three different versions of the Uno: R1, R2, and R3.&#xD;&#xA;&#xD;&#xA; - Microcontroller: ATmega328&#xD;&#xA; - Operating Voltage: 5V&#xD;&#xA; - Input Voltage (recommended): 7-12V&#xD;&#xA; - Input Voltage (limits): 6-20V&#xD;&#xA; - Digital I/O Pins: 14 (of which 6 provide PWM output)&#xD;&#xA; - Analog Input Pins: 6&#xD;&#xA; - DC Current per I/O Pin: 40 mA&#xD;&#xA; - DC Current for 3.3V Pin: 50 mA&#xD;&#xA; - Flash Memory: 32 KB (ATmega328) of which 0.5 KB used by bootloader&#xD;&#xA; - SRAM: 2 KB (ATmega328)&#xD;&#xA; - EEPROM: 1 KB (ATmega328)&#xD;&#xA; - Clock Speed: 16 MHz&#xD;&#xA;&#xD;&#xA;Here is the page for the Uno on the official Arduino site: http://arduino.cc/en/Main/ArduinoBoardUno" />
  <row Id="260" PostHistoryTypeId="24" PostId="107" RevisionGUID="e261a3ba-0b5c-4db1-8d02-14fb59c367be" CreationDate="2014-02-12T16:57:42.883" Comment="Proposed by 37 approved by 48 edit id of 25" />
  <row Id="261" PostHistoryTypeId="5" PostId="110" RevisionGUID="fb1d056a-89a3-435e-8002-c38b39930df0" CreationDate="2014-02-12T16:58:08.493" UserId="37" Comment="added 165 characters in body" Text="Ethernet can be used for communication between an Arduino and a computer. For question concerning the Arduino Ethernet board, use the tag &quot;arduino-ethernet&quot; instead." />
  <row Id="262" PostHistoryTypeId="24" PostId="110" RevisionGUID="fb1d056a-89a3-435e-8002-c38b39930df0" CreationDate="2014-02-12T16:58:08.493" Comment="Proposed by 37 approved by 48 edit id of 31" />
  <row Id="263" PostHistoryTypeId="6" PostId="40" RevisionGUID="a339bd82-8965-4fc7-88e3-dd0422e9be09" CreationDate="2014-02-12T16:58:17.293" UserId="65" Comment="Added language tag" Text="&lt;ide&gt;&lt;c++&gt;" />
  <row Id="264" PostHistoryTypeId="24" PostId="40" RevisionGUID="a339bd82-8965-4fc7-88e3-dd0422e9be09" CreationDate="2014-02-12T16:58:17.293" Comment="Proposed by 65 approved by 48 edit id of 22" />
  <row Id="265" PostHistoryTypeId="5" PostId="57" RevisionGUID="e50cb1c2-96c7-49e8-bfb7-6769457959f1" CreationDate="2014-02-12T16:59:30.470" UserId="4" Comment="Fix markdown, minor grammar" Text="I have not already started to try but I'm a good webmaster and I'm just asking which way is more suitable for sending and keeping data from sensors and I/0 state in a database.&#xD;&#xA;&#xD;&#xA;Here are some points:&#xD;&#xA;&#xD;&#xA; -  Post versus get&#xD;&#xA; - MySQL or others types&#xD;&#xA; - Security layers&#xD;&#xA; - Graphics render of data's (google API?)&#xD;&#xA; - PHP, ruby, JavaScript...&#xD;&#xA; - Able to send data request's to Arduino's&#xD;&#xA; - Ethernet shield, wifi, I2c ???&#xD;&#xA; - Access via Android app...&#xD;&#xA;&#xD;&#xA;Anyway, the goal here is to know pros and cons of integrate all my Arduino through database." />
  <row Id="266" PostHistoryTypeId="24" PostId="57" RevisionGUID="e50cb1c2-96c7-49e8-bfb7-6769457959f1" CreationDate="2014-02-12T16:59:30.470" Comment="Proposed by 4 approved by 48 edit id of 23" />
  <row Id="267" PostHistoryTypeId="5" PostId="104" RevisionGUID="72169b6d-67c8-41ed-bb9c-91c6b0fb6c7e" CreationDate="2014-02-12T17:00:54.183" UserId="4" Comment="Make title a question, grammar, better tags" Text="Is there any easy way to upload a program/sketch from an iPad or Android tablet without adding extra an shield (Bluetooth or Wi-Fi)?&#xD;&#xA;&#xD;&#xA;If not, can it be done using shield? Which shield is preferred?&#xD;&#xA;&#xD;&#xA;Also what are the IDE options available?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="268" PostHistoryTypeId="4" PostId="104" RevisionGUID="72169b6d-67c8-41ed-bb9c-91c6b0fb6c7e" CreationDate="2014-02-12T17:00:54.183" UserId="4" Comment="Make title a question, grammar, better tags" Text="Is it possible to upload a program from a tablet?" />
  <row Id="269" PostHistoryTypeId="6" PostId="104" RevisionGUID="72169b6d-67c8-41ed-bb9c-91c6b0fb6c7e" CreationDate="2014-02-12T17:00:54.183" UserId="4" Comment="Make title a question, grammar, better tags" Text="&lt;uploading&gt;&lt;ide&gt;&lt;ipad&gt;&lt;android&gt;" />
  <row Id="270" PostHistoryTypeId="24" PostId="104" RevisionGUID="72169b6d-67c8-41ed-bb9c-91c6b0fb6c7e" CreationDate="2014-02-12T17:00:54.183" Comment="Proposed by 4 approved by 48 edit id of 24" />
  <row Id="271" PostHistoryTypeId="2" PostId="120" RevisionGUID="14119e54-e7cf-4cb3-a586-fc6bbfe94e0c" CreationDate="2014-02-12T17:01:24.530" UserId="83" Text="Write a sketch that millis 1000 times, not by making a loop, but by copy and paste. Measure that and compare it to the actual expected time. Mind you that that the results may vary with different versions of the IDE (and its compiler in particular).&#xD;&#xA;&#xD;&#xA;Another option is to toggle an IO pin before and after the millis call, then measure the time for a very small value and a somewhat larger value. Compare the measured timings and calculate the overhead.&#xD;&#xA;&#xD;&#xA;The most accurate way is to take a look at the disassembly listing, the generated code. But that is not for the faint of heart. You'll have to carefully study the datasheet how long each instruction cycle takes.&#xD;&#xA;&#xD;&#xA;General note: millis(); is pretty accurate and well optimized, but if you don't disable your interrupts, the timing will be a fair bit off." />
  <row Id="272" PostHistoryTypeId="5" PostId="119" RevisionGUID="d7f06b41-0a93-40bb-825e-dbf7d6869023" CreationDate="2014-02-12T17:03:00.620" UserId="46" Comment="added 1020 characters in body" Text="A common way to expand the set of available output pins on the Arduino is to use shift registers like the 74HC595 IC ([link to datasheet](http://www.nxp.com/documents/data_sheet/74HC_HCT595.pdf)).&#xD;&#xA;&#xD;&#xA;You need 3 pins to control these chips: &#xD;&#xA;&#xD;&#xA;1. Clock&#xD;&#xA;2. Latch&#xD;&#xA;3. Data&#xD;&#xA;&#xD;&#xA;In a program, you pass on the data one bit at a time to the shift register using the [shiftOut() command][1], like so:&#xD;&#xA;&#xD;&#xA;    shiftOut(dataPin, clockPin, data); &#xD;&#xA;&#xD;&#xA;With that command, you set each of the 8 outputs on the 595 IC with the 8 bits in the `data` variable.&#xD;&#xA;&#xD;&#xA;With one 595, you gain 5 pins (8 on the IC, but you spend 3 to talk to it). To get more outputs, you can daisy-chain a series of 595 together, by connecting its serial-out pin, to the data pin of the next one. You also must connect together the clock and latch pins of all of the 595 ICs.&#xD;&#xA;&#xD;&#xA;The resulting circuit (using one 595) would look like this:&#xD;&#xA;&#xD;&#xA;![Circuit using 595 shift register][2]&#xD;&#xA;&#xD;&#xA;The figure above was taken from this [codeproject.com](http://codeproject.com) webpage:&#xD;&#xA;&#xD;&#xA;http://www.codeproject.com/Articles/144606/Arduino-Platform-Working-with-Shift-Registers&#xD;&#xA;&#xD;&#xA;The latch pin is used to keep the 595 outputs steady while you are shifting out data into it, like so:&#xD;&#xA;&#xD;&#xA;    digitalWrite(latchPin, LOW);&#xD;&#xA;    shiftOut(dataPin, clockPin, data); &#xD;&#xA;    digitalWrite(latchPin, HIGH);&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/tutorial/ShiftOut&#xD;&#xA;  [2]: http://i.stack.imgur.com/mUyUl.jpg" />
  <row Id="273" PostHistoryTypeId="2" PostId="121" RevisionGUID="a556e93e-8a4c-4eaf-91ed-f7fd58ca12b6" CreationDate="2014-02-12T17:26:22.720" UserId="24" Text="No, You shouldn't need any type of cooling device such as a fan as long as the case has a few holes in order to allow the heat to rise out of the case. I do not recommend using cases that are completely sealed, unless you are using it in an environment that has things that could hard the Arduino such as  ROVs or Nuclear waste facility (although I don't know why you would be at one in the first place)." />
  <row Id="274" PostHistoryTypeId="2" PostId="122" RevisionGUID="a6bfd8f2-bb36-4fed-873b-a17bbe27acb1" CreationDate="2014-02-12T17:28:00.757" UserId="113" Text="I want to use the [Adafruit CC3000][1] and its [Arduino libraries][2] on another platform. In this case it's the Arduino pin compatible [PSOC4 Pioneer Kit][3]. This is an ARM Cortex M0 based platform.&#xD;&#xA;&#xD;&#xA;My question is: How would I go about porting a library like this? What are the steps, key files etc?&#xD;&#xA;&#xD;&#xA;One obvious issue is that PSOC Creator does not readily support C++.&#xD;&#xA;&#xD;&#xA;One positive might be that the Arduino Due board is based on the Atmel SAM3X8E ARM Cortex-M3 CPU.&#xD;&#xA;&#xD;&#xA;NOTE: If you think this question is off topic; please head over to [this question][4] on Arduino Meta to voice your opinion on whether questions on Arduino Compatible devices are appropriate for this list.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://learn.adafruit.com/adafruit-cc3000-wifi&#xD;&#xA;  [2]: https://github.com/adafruit/Adafruit_CC3000_Library&#xD;&#xA;  [3]: http://www.cypress.com/?rID=77780&#xD;&#xA;  [4]: http://meta.arduino.stackexchange.com/questions/22/is-it-ok-to-ask-questions-about-arduino-compatible-micros-not-clones" />
  <row Id="275" PostHistoryTypeId="1" PostId="122" RevisionGUID="a6bfd8f2-bb36-4fed-873b-a17bbe27acb1" CreationDate="2014-02-12T17:28:00.757" UserId="113" Text="What are the steps involved in porting an Arduino library?" />
  <row Id="276" PostHistoryTypeId="3" PostId="122" RevisionGUID="a6bfd8f2-bb36-4fed-873b-a17bbe27acb1" CreationDate="2014-02-12T17:28:00.757" UserId="113" Text="&lt;library&gt;" />
  <row Id="277" PostHistoryTypeId="2" PostId="123" RevisionGUID="c85b6691-e1f8-4401-8230-a8d902bcee80" CreationDate="2014-02-12T17:30:59.020" UserId="44" Text="What hardware and software solutions work and what are the tradeoffs for connecting an Arduino Due to the internet?  I gather the [ethernet hardware](http://arduino.cc/en/Main/ArduinoBoardEthernet) is much cheaper than [WiFi hardware](http://arduino.cc/en/Main/ArduinoWiFiShield) (€29 versus €69).  In either case (wired or wireless), what software stacks and drivers work under AtmelStudio?" />
  <row Id="278" PostHistoryTypeId="1" PostId="123" RevisionGUID="c85b6691-e1f8-4401-8230-a8d902bcee80" CreationDate="2014-02-12T17:30:59.020" UserId="44" Text="Internet connectivity for the Arduino Due using AtmelStudio?" />
  <row Id="279" PostHistoryTypeId="3" PostId="123" RevisionGUID="c85b6691-e1f8-4401-8230-a8d902bcee80" CreationDate="2014-02-12T17:30:59.020" UserId="44" Text="&lt;ethernet&gt;&lt;arduino-due&gt;&lt;atmel-studio&gt;&lt;wifi&gt;&lt;tcpip&gt;" />
  <row Id="283" PostHistoryTypeId="2" PostId="124" RevisionGUID="d928f39d-9a27-473e-9d4a-8cb04108593c" CreationDate="2014-02-12T19:26:18.917" UserId="52" Text="**Question:** How does one prepare clothing with embedded electronics for washing?&#xD;&#xA;&#xD;&#xA;**Background:** There are several Arduino boards/clones that are designed for &quot;wearable tech.&quot;  (For example, the [Lilypad][1].)  Wearable tech with LED light patterns, microphones, GPS, or other circuitry is an interesting concept, but water and electricity tend not to mix.&#xD;&#xA;&#xD;&#xA;To prepare wearable tech for washing, I would assume people make large circuitry removable.  Yet, inevitably, some electronics will be more-or-less permanently affixed to the cloth.  What, if anything, can be done to these electronics (e.g. sewn-in Arduino Lilypad) to make them washing-machine (preferred--hand wash could be done, but it's so much easier to machine wash) safe?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardLilyPad" />
  <row Id="284" PostHistoryTypeId="1" PostId="124" RevisionGUID="d928f39d-9a27-473e-9d4a-8cb04108593c" CreationDate="2014-02-12T19:26:18.917" UserId="52" Text="Washable, Wearable Tech with Arduino" />
  <row Id="285" PostHistoryTypeId="3" PostId="124" RevisionGUID="d928f39d-9a27-473e-9d4a-8cb04108593c" CreationDate="2014-02-12T19:26:18.917" UserId="52" Text="&lt;safety&gt;&lt;wearable-technology&gt;" />
  <row Id="286" PostHistoryTypeId="2" PostId="125" RevisionGUID="8c1205e0-4aca-4432-ad87-c15ecef8467e" CreationDate="2014-02-12T19:39:19.070" UserId="11" Text="I would use some sort of epoxy and cover up the exposed circuitry. The major concern would be where the wires connect to the board as flex over time can weaken it.&#xD;&#xA;&#xD;&#xA;Some options include:&#xD;&#xA;&#xD;&#xA;* [3M™ Scotchcast™ Wet-Niche Potting Kit][1]&#xD;&#xA;* [Hysol][2]&#xD;&#xA;&gt; US1150™—For electronics, telecommunications, and automotive&#xD;&#xA;&gt; components. Provides environmental hazard protection. US1152™—For&#xD;&#xA;&gt; electronic assemblies. Provides environmental hazard protection.&#xD;&#xA;&#xD;&#xA;Heat might play a factor if you cover up the boards in epoxy but you shouldn't be producing that much heat in a wearable device anyway, right?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.3m.com/product/information/Scotchcast-Wet-Niche-Potting-Kit.html&#xD;&#xA;  [2]: http://www.henkelna.com/product-search-1554.htm?nodeid=8797846732801" />
  <row Id="287" PostHistoryTypeId="2" PostId="126" RevisionGUID="495a4bda-e5a0-4c67-ba33-edab49c044ce" CreationDate="2014-02-12T19:41:02.147" UserId="84" Text="If you want to drive LEDs, then you can also use a MAX7219 that can drive 64 LEDs, without extra circuitry (no need for transistor to amplify signal).&#xD;&#xA;&#xD;&#xA;Driving a MAX7219 requires only 3 output pins on Arduino.&#xD;&#xA;Also, you can find a few libraries for it.&#xD;&#xA;&#xD;&#xA;You can also chain several of them if you need to power more than 64 LEDs.&#xD;&#xA;&#xD;&#xA;I have used it successfully for multiple 7-segment LED displays.&#xD;&#xA;&#xD;&#xA;Downside: it is expensive (about $10)." />
  <row Id="289" PostHistoryTypeId="2" PostId="127" RevisionGUID="1ba5ec27-198f-4d08-bde1-869e4b138c35" CreationDate="2014-02-12T19:42:37.623" UserId="24" Text="I would make it so the Board has velcro on it so that it can be un attached from the clothing, and then have all the wires have snap terminals that wires from the Arduino connect to. This way you un snap all the wires and remove the arduino. As far as components, I would cover them in an epoxy to protect them." />
  <row Id="290" PostHistoryTypeId="5" PostId="125" RevisionGUID="8ff66d64-7089-46bc-ab27-fb8ce8590b8b" CreationDate="2014-02-12T19:45:00.310" UserId="11" Comment="added 3 characters in body" Text="I would use some sort of epoxy and cover up the exposed circuitry. The major concern would be where the wires connect to the board as flex over time can weaken it.&#xD;&#xA;&#xD;&#xA;Some options include:&#xD;&#xA;&#xD;&#xA;* [3M™ Scotchcast™ Wet-Niche Potting Kit][1]&#xD;&#xA;* [Hysol][2]&#xD;&#xA;&gt; US1150™—For electronics, telecommunications, and automotive&#xD;&#xA;&gt; components. Provides environmental hazard protection.&#xD;&#xA;&gt;&#xD;&#xA;&gt; US1152™—For electronic assemblies. Provides environmental hazard protection.&#xD;&#xA;&#xD;&#xA;Heat might play a factor if you cover up the boards in epoxy but you shouldn't be producing that much heat in a wearable device anyway, right?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.3m.com/product/information/Scotchcast-Wet-Niche-Potting-Kit.html&#xD;&#xA;  [2]: http://www.henkelna.com/product-search-1554.htm?nodeid=8797846732801" />
  <row Id="295" PostHistoryTypeId="2" PostId="128" RevisionGUID="5beb0cf5-7508-45b1-af65-f4c36a7d6b2e" CreationDate="2014-02-12T20:32:53.883" UserId="79" Text="I did essentially the same thing with getting the Adafruit ST7735 library working in chipKIT. [I started a support thread here which can lead you through my process][1].&#xD;&#xA;&#xD;&#xA;I tackled it the same way I do general programming:&lt;br&gt;&#xD;&#xA;1-» Copy over Libraries, get it so your compiler can actually SEE them.&lt;br&gt;&#xD;&#xA;2-» Start trying to compile and then triage errors from the &quot;top level&quot; down:&lt;br&gt;&#xD;&#xA;3-» Look for stlib functions you recognize as should be working and fix those.&lt;br&gt;&#xD;&#xA;4-» Look for AVR specific code and comment those out. I normally also add my initials and a comment: `ckck - bitbanging SPI`, so I can search for these later.&lt;br&gt;&#xD;&#xA;Repeat 3 and 4 until it works or you quit. :)&#xD;&#xA;&#xD;&#xA;Reach out to the forums for your target; they might have been there done that -- or like in my case, you introduce them to something that they want, so they dive in and help.&#xD;&#xA;&#xD;&#xA;  [1]: http://forums.adafruit.com/viewtopic.php?f=47&amp;t=42966" />
  <row Id="296" PostHistoryTypeId="5" PostId="126" RevisionGUID="629c1da1-d7da-4ea9-937f-6974fa09643e" CreationDate="2014-02-12T21:03:50.000" UserId="84" Comment="Added links" Text="If you want to drive LEDs, then you can also use a MAX7219 that can drive 64 LEDs, without extra circuitry (no need for transistor to amplify signal).&#xD;&#xA;&#xD;&#xA;Driving a [MAX7219][1] requires only 3 output pins on Arduino.&#xD;&#xA;Also, you can find a few [Arduino libraries][2] for it.&#xD;&#xA;&#xD;&#xA;You can also chain several of them if you need to power more than 64 LEDs.&#xD;&#xA;&#xD;&#xA;I have used it successfully for multiple 7-segment LED displays.&#xD;&#xA;&#xD;&#xA;Downside: it is expensive (about $10).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.maximintegrated.com/datasheet/index.mvp/id/1339&#xD;&#xA;  [2]: http://playground.arduino.cc/Main/LedControl" />
  <row Id="297" PostHistoryTypeId="2" PostId="129" RevisionGUID="a96a9665-9760-4697-9a46-abde6cd92035" CreationDate="2014-02-12T21:54:44.307" UserId="37" Text="I was communicating between my computer and my Arduino Uno R3 through Bluetooth using [this Bluetooth module][1]. The connector I use has a red wire where it connects to GND, and a black wire where it connects to +5V. I forgot this one time when I connected the Bluetooth module to the Uno, so the polarity was reversed. This fried the Bluetooth module.&#xD;&#xA;&#xD;&#xA;After getting a new module, I discovered that the Uno was apparently fried too. Plugging a USB cable into the Uno made the little green integrated LED turn on, but that was all that happened; none of the pins put out any electricity. When I tried to upload a program, it gave the infamous `avrdude: stk500_getsync(): not in sync: resp=0x00` error. I could upload programs to my other Uno fine, and I could not upload to the broken Uno on my other computer.&#xD;&#xA;&#xD;&#xA;Two of the Arduino experts I know told me that the ATmega328 chip might be the only broken part. Is this likely to be the case? I have an Uno R2 with a working ATmega328. Would temporarily replacing the R3's ATmega with that R2's ATmega have a change of damaging anything?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.mdfly.com/index.php?main_page=product_info&amp;cPath=8_47&amp;products_id=769&amp;zenid=6f2b3946847b73b5ef2185e5e756e498" />
  <row Id="298" PostHistoryTypeId="1" PostId="129" RevisionGUID="a96a9665-9760-4697-9a46-abde6cd92035" CreationDate="2014-02-12T21:54:44.307" UserId="37" Text="Is my ATmega broken, and would replacing it with another break that one, too?" />
  <row Id="299" PostHistoryTypeId="3" PostId="129" RevisionGUID="a96a9665-9760-4697-9a46-abde6cd92035" CreationDate="2014-02-12T21:54:44.307" UserId="37" Text="&lt;uno&gt;&lt;atmega328&gt;" />
  <row Id="300" PostHistoryTypeId="6" PostId="74" RevisionGUID="8893c1b0-951f-400e-b09f-56d80de94fa8" CreationDate="2014-02-12T21:56:23.443" UserId="37" Comment="removed &quot;uno-r3&quot;, see http://meta.arduino.stackexchange.com/a/11" Text="&lt;uno&gt;&lt;enclosure&gt;&lt;cooling&gt;" />
  <row Id="301" PostHistoryTypeId="24" PostId="74" RevisionGUID="8893c1b0-951f-400e-b09f-56d80de94fa8" CreationDate="2014-02-12T21:56:23.443" Comment="Proposed by 37 approved by 99 edit id of 18" />
  <row Id="302" PostHistoryTypeId="2" PostId="130" RevisionGUID="2aa7c9c3-4635-448f-9506-29d54c6b2cf8" CreationDate="2014-02-12T22:08:04.703" UserId="84" Text="Besides breaking a pin while removing the IC from its socket, or static electricity during manipulation, I don't see what could fry the ATmega. &#xD;&#xA;&#xD;&#xA;However, it is possible that the R2 ATmega has a different bootloader and that may be an issue.&#xD;&#xA;&#xD;&#xA;If I was you I would just remove the ATmega from the R3 board and test it on a breadboard (don't need a lot of components to do that); at least that could tell you if it is fried or if it is the R3 board that is fried..." />
  <row Id="303" PostHistoryTypeId="5" PostId="17" RevisionGUID="7dbd69c1-fd2b-475a-acc0-5ad352a9ec08" CreationDate="2014-02-12T22:18:09.233" UserId="37" Comment="added 576 characters in body; edited title" Text="I made an awesome program the other day, and I wanted to upload it to my Arduino. After clicking the upload button, some _really_ mean dude named avr came along and stopped me. He told me:&#xD;&#xA;&#xD;&#xA;&gt; avrdude: stk500_getsync(): not in sync: resp=0x00&#xD;&#xA;&#xD;&#xA;_All_ I want to do is just upload my program, but avr won't let me. He's even unintelligible, so can someone tell me what the heck he's trying to say? Is there any way I can ban him, arrest him, or simply get rid of him and his stupid message?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;In case you couldn't tell from the above, what I'm saying is this:&#xD;&#xA;&#xD;&#xA;Whenever I try to upload a program to my Arduino, I get this error message: `avrdude: stk500_getsync(): not in sync: resp=0x00` What does this mean, and how can I fix it?" />
  <row Id="304" PostHistoryTypeId="4" PostId="17" RevisionGUID="7dbd69c1-fd2b-475a-acc0-5ad352a9ec08" CreationDate="2014-02-12T22:18:09.233" UserId="37" Comment="added 576 characters in body; edited title" Text="Some dude named avr won't let me upload my program, aka &quot;avrdude: stk500_getsync(): not in sync: resp=0x00&quot;" />
  <row Id="305" PostHistoryTypeId="2" PostId="131" RevisionGUID="5e71b06d-833d-49d6-af73-5908b5f721ab" CreationDate="2014-02-12T22:40:52.577" UserId="8" Text="I figured out a way to do this without having to port the compiler to iOS. It only works with the arduino Yún, but the Yún can send code to other arduinos with an spi cable.&#xD;&#xA;&#xD;&#xA;* Install an SSH app on your device so you can communicate with the arduino&#xD;&#xA;* Using that, install [Ino][1] on your Yún, a command line arduino compiler&#xD;&#xA;* Create a file, put your code in it, then save it&#xD;&#xA;* use [Ino][1] to upload your code!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;kind of confusing, but it could work!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://inotool.org &quot;Ino&quot;" />
  <row Id="306" PostHistoryTypeId="5" PostId="129" RevisionGUID="c7de40c1-15ff-44f6-9b12-71c01a0bf4f3" CreationDate="2014-02-12T22:52:50.020" UserId="37" Comment="added 195 characters in body" Text="I was communicating between my computer and my Arduino Uno R3 through Bluetooth using [this Bluetooth module][1]. The connector I use has a red wire where it connects to GND, and a black wire where it connects to +5V.&#xD;&#xA;&#xD;&#xA;&gt; ![enter image description here][2]&#xD;&#xA;&gt;&#xD;&#xA;&gt;                     ↓        ↓  to Uno ↓       ↓&#xD;&#xA;&gt;                    +5V      GND       pin 0  pin 1&#xD;&#xA;&#xD;&#xA;I forgot this one time when I connected the Bluetooth module to the Uno, so the polarity was reversed. This fried the Bluetooth module.&#xD;&#xA;&#xD;&#xA;After getting a new module, I discovered that the Uno was apparently fried too. Plugging a USB cable into the Uno made the little green integrated LED turn on, but that was all that happened; none of the pins put out any electricity. When I tried to upload a program, it gave the infamous `avrdude: stk500_getsync(): not in sync: resp=0x00` error. I could upload programs to my other Uno fine, and I could not upload to the broken Uno on my other computer.&#xD;&#xA;&#xD;&#xA;Two of the Arduino experts I know told me that the ATmega328 chip might be the only broken part. Is this likely to be the case? I have an Uno R2 with a working ATmega328. Would temporarily replacing the R3's ATmega with that R2's ATmega have a change of damaging anything?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.mdfly.com/index.php?main_page=product_info&amp;cPath=8_47&amp;products_id=769&amp;zenid=6f2b3946847b73b5ef2185e5e756e498&#xD;&#xA;  [2]: http://i.stack.imgur.com/upJ7C.png" />
  <row Id="307" PostHistoryTypeId="2" PostId="132" RevisionGUID="865ec7b3-c28a-4bba-9348-b621250ee6e4" CreationDate="2014-02-13T00:17:38.463" UserId="144" Text="There are some pins on the Arduino which I haven't been able to find out anything about:&#xD;&#xA;&#xD;&#xA; - `IOREF`&#xD;&#xA; - `AREF`&#xD;&#xA; - An unlabeled one next to `IOREF`&#xD;&#xA;&#xD;&#xA;What are they?" />
  <row Id="308" PostHistoryTypeId="1" PostId="132" RevisionGUID="865ec7b3-c28a-4bba-9348-b621250ee6e4" CreationDate="2014-02-13T00:17:38.463" UserId="144" Text="What are the AREF, IOREF, and the unlabeled pin next to IOREF on the Uno R3?" />
  <row Id="309" PostHistoryTypeId="3" PostId="132" RevisionGUID="865ec7b3-c28a-4bba-9348-b621250ee6e4" CreationDate="2014-02-13T00:17:38.463" UserId="144" Text="&lt;uno&gt;&lt;pins&gt;" />
  <row Id="310" PostHistoryTypeId="2" PostId="133" RevisionGUID="86baf29a-4ae9-4730-b09e-4068170a69a3" CreationDate="2014-02-13T00:21:17.303" UserId="8" Text="__AREF:__&#xD;&#xA;&#xD;&#xA;This is the analog voltage reference. It can be used in stead of the standard 5V reference for the top end of the analog spectrum.&#xD;&#xA;&#xD;&#xA;__IOREF:__&#xD;&#xA;&#xD;&#xA;This is a voltage corresponding to the i/o of that board, for example an Uno would supply 5v to this pin, but a Due would supply 3.3v&#xD;&#xA;&#xD;&#xA;__Unlabeled pin:__&#xD;&#xA;&#xD;&#xA;This pin is unused, but is there to ensure compatibility with future products. It is not connected to anything on any R3 boards I have seen." />
  <row Id="311" PostHistoryTypeId="2" PostId="134" RevisionGUID="178e7ec8-a5bf-4795-bd6c-b120fe31c093" CreationDate="2014-02-13T00:28:13.180" UserId="89" Text="As you wrote already already, you can use all pins, including TX and RX as digital output. I did that a while ago for a demonstrator and recorded a video - [20 LEDS on 20 pins][1] - of this rather nonsensical project. &#xD;&#xA;&#xD;&#xA;As described by *Peter R. Bloomfield* [here][2], you a have to disconnect TX and RX for upload. Moreover, you're out of pins to read sensors for possible interactivity and have to make sure that the total current limit isn't reached. Not to forget that you're limited to 5V leds if you drive them directly with your Arduino.&#xD;&#xA;&#xD;&#xA;The use of shift registers in general and the 595, described by *Ricardo* is therefore highly recommended. &#xD;&#xA;&#xD;&#xA; - They are cheap!&#xD;&#xA; - It's rather easy to cascade them.&#xD;&#xA; - A lot of speed can be gained when you use hardware-SPI.&#xD;&#xA;  &#xD;&#xA;I used them a while ago when I realized the soldering and programming part of [Kawaii me][3] (text of the link is in German) of the upcycling artist Dominik Jais.&#xD;&#xA;&#xD;&#xA;Here, just a bunch of **595** were used to drive a display of 8x11 leds. Since the leds were cut from a stripe of 12V SMD leds, an additional power supply and some **UDN2803A** Darlington arrays, hooked to the output pins of the shift registers, were necessary.&#xD;&#xA;&#xD;&#xA;Other general methods would include the use of PCF8574(A) 8bit port expanders, which are controlled via the I2C bus.&#xD;&#xA;&#xD;&#xA;Anyway, I'd give the 595 shift registers a try first.&#xD;&#xA;&#xD;&#xA;[1]:http://www.youtube.com/watch?v=ibhoqUkiSys&#xD;&#xA;[2]:http://arduino.stackexchange.com/questions/85/why-cant-i-upload-a-sketch-while-other-components-devices-are-connected-to-my-u&#xD;&#xA;[3]:http://www.heise.de/hardware-hacks/projekte/Kawaii-me-2073147.html&#xD;&#xA;" />
  <row Id="312" PostHistoryTypeId="2" PostId="135" RevisionGUID="620457bf-aba2-4f18-bc42-31f75d485d56" CreationDate="2014-02-13T00:33:14.047" UserId="89" Text="Concerning the `AREF` pin, you have to remember that the Arduino comes with a 10bit ADC (Analog-Digital-Converter), which converts incoming voltages between 0V and 5V to integer values between 0 and 1023. This results in a resolution of roughly 4.8 mV.&#xD;&#xA;&#xD;&#xA;If a sensor only delivers a lower maximum voltage, it is resonable to apply this voltage to the `AREF` pin, just in order to obtain a higher resolution.&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;" />
  <row Id="313" PostHistoryTypeId="5" PostId="134" RevisionGUID="e8bfdaff-dd8c-4d36-bfd6-20d7a8fad0fd" CreationDate="2014-02-13T00:42:02.540" UserId="89" Comment="Information on WS2812 RGB leds added." Text="As you wrote already already, you can use all pins, including TX and RX as digital output. I did that a while ago for a demonstrator and recorded a video - [20 LEDS on 20 pins][1] - of this rather nonsensical project. &#xD;&#xA;&#xD;&#xA;As described by *Peter R. Bloomfield* [here][2], you a have to disconnect TX and RX for upload. Moreover, you're out of pins to read sensors for possible interactivity and have to make sure that the total current limit isn't reached. Not to forget that you're limited to 5V leds if you drive them directly with your Arduino.&#xD;&#xA;&#xD;&#xA;The use of shift registers in general and the 595, described by *Ricardo* is therefore highly recommended. &#xD;&#xA;&#xD;&#xA; - They are cheap!&#xD;&#xA; - It's rather easy to cascade them.&#xD;&#xA; - A lot of speed can be gained when you use hardware-SPI.&#xD;&#xA;  &#xD;&#xA;I used them a while ago when I realized the soldering and programming part of [Kawaii me][3] (text of the link is in German) of the upcycling artist *Dominik Jais*.&#xD;&#xA;&#xD;&#xA;Here, just a bunch of **595** were used to drive a display of 8x11 leds. Since the leds were cut from a stripe of 12V SMD leds, an additional power supply and some **UDN2803A** Darlington arrays, hooked to the output pins of the shift registers, were necessary.&#xD;&#xA;&#xD;&#xA;Other general methods would include the use of PCF8574(A) 8bit port expanders, which are controlled via the I2C bus.&#xD;&#xA;&#xD;&#xA;Anyway, I'd give the 595 shift registers a try first.&#xD;&#xA;&#xD;&#xA;If you need to control a couple of RGB leds, however, you might want to look for more specialized solutions. Some RGB leds come with their own **WS2812**. These fine pieces can be cascaded (1-Wire bus) and are addressed via their position in the chain.&#xD;&#xA;&#xD;&#xA;[1]:http://www.youtube.com/watch?v=ibhoqUkiSys&#xD;&#xA;[2]:http://arduino.stackexchange.com/questions/85/why-cant-i-upload-a-sketch-while-other-components-devices-are-connected-to-my-u&#xD;&#xA;[3]:http://www.heise.de/hardware-hacks/projekte/Kawaii-me-2073147.html&#xD;&#xA;" />
  <row Id="314" PostHistoryTypeId="6" PostId="39" RevisionGUID="02129b78-8af0-4050-aa75-0070758a0752" CreationDate="2014-02-13T01:52:19.543" UserId="37" Comment="added [shields] tag" Text="&lt;uno&gt;&lt;ethernet&gt;&lt;shields&gt;" />
  <row Id="315" PostHistoryTypeId="24" PostId="39" RevisionGUID="02129b78-8af0-4050-aa75-0070758a0752" CreationDate="2014-02-13T01:52:19.543" Comment="Proposed by 37 approved by 33 edit id of 33" />
  <row Id="316" PostHistoryTypeId="2" PostId="136" RevisionGUID="bc5c5398-9f01-4da0-9ad1-1164aed40b7f" CreationDate="2014-02-13T02:04:23.007" UserId="33" Text="There are a three different revisions of the Arduino Uno. What changed in each revision?&#xD;&#xA;" />
  <row Id="317" PostHistoryTypeId="1" PostId="136" RevisionGUID="bc5c5398-9f01-4da0-9ad1-1164aed40b7f" CreationDate="2014-02-13T02:04:23.007" UserId="33" Text="What is the difference between the revisions of the Arduino Uno board?" />
  <row Id="318" PostHistoryTypeId="3" PostId="136" RevisionGUID="bc5c5398-9f01-4da0-9ad1-1164aed40b7f" CreationDate="2014-02-13T02:04:23.007" UserId="33" Text="&lt;uno&gt;" />
  <row Id="319" PostHistoryTypeId="2" PostId="137" RevisionGUID="8a865154-5922-428b-bc26-d0fcc7a66bd3" CreationDate="2014-02-13T02:10:54.823" UserId="37" Text="According to [the official site][1]:&#xD;&#xA;&#xD;&#xA;&gt; Revision 2 of the Uno board has a resistor pulling the 8U2 HWB line to&#xD;&#xA;&gt; ground, making it easier to put into DFU mode.&#xD;&#xA;&gt; &#xD;&#xA;&gt; Revision 3 of the board has the following new features:&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - 1.0 pinout: added SDA and SCL pins that are near to the AREF pin and two other new pins placed near to the RESET pin, the IOREF that&#xD;&#xA;&gt; allow the shields to adapt to the voltage provided from the board. In&#xD;&#xA;&gt; future, shields will be compatible with both the board that uses the&#xD;&#xA;&gt; AVR, which operates with 5V and with the Arduino Due that operates&#xD;&#xA;&gt; with 3.3V. The second one is a not connected pin, that is reserved for&#xD;&#xA;&gt; future purposes.&#xD;&#xA;&gt;  - Stronger RESET circuit.&#xD;&#xA;&gt;  - Atmega 16U2 replace the 8U2.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardUno" />
  <row Id="320" PostHistoryTypeId="2" PostId="138" RevisionGUID="b78d69f7-9fe6-4429-825a-a3adbe75d18e" CreationDate="2014-02-13T02:21:28.900" UserId="65" Text="###User Side Changes&#xD;&#xA;&#xD;&#xA;- Both revision 2 and 3 boards add four solder pads (JP2) connecting to pins PB4 to PB7 of the USB ATMEGA.&#xD;&#xA;- Revision 2 and 3 boards are both supplied with header pins in the USB ATMEGA ICSP header rather than just solder pads in the Arduino Uno.&#xD;&#xA;- The revision 3 board changes the 8 pin connector that contains Arduino pins 8 to 13, GND and AREF for a 10 pin connector. The extra 2 pins are connected to AD4/SDA and AD5/SCL. These are the two analog input pins that can be used for I2C. &#xD;&#xA;- Revision 3 boards change the 6 pin connector that has the reset pin connected to it to an 8 pin connector. One of the new pins on this header is the IOREF pin that allows shields connected to the board to adapt to the voltage of the board. The second pin is reserved for future use.&#xD;&#xA;&#xD;&#xA;###Electronics Based Changes&#xD;&#xA;- The Arduino Uno and Arduino Uno revision 2 both have an ATMEGA8U2 USB microcontroller on board – this is upgraded to an ATMEGA16U2 on the revision 3 board.&#xD;&#xA;- Revision 3 adds a diode across the USB ATMEGA reset pin pull-up resistor.&#xD;&#xA;- Both revision 2 and 3 boards add a 1k pull-down resistor to the DTR (HWB) line coming from the USB ATMEGA microcontroller – from the PD7 pin.&#xD;&#xA;- The Arduino Uno and Arduino Uno revision 2 both have a LED and resistor connected in series on Arduino pin 13. The revision 3 board buffers this LED/resistor through a unity gain op-amp. This is the spare op-amp that was unused on previous boards.&#xD;&#xA;&#xD;&#xA;###Sources:&#xD;&#xA;1. http://startingelectronics.com/articles/arduino/uno-r3-r2-differences/" />
  <row Id="321" PostHistoryTypeId="2" PostId="139" RevisionGUID="8e8e9697-143b-4e65-950d-f1afe9b74540" CreationDate="2014-02-13T02:24:28.673" UserId="87" Text="In addition to [Ricardo][1]'s answer, what Wikipedia states on [shift registers][2]:&#xD;&#xA;&#xD;&#xA;&gt; One of the most common uses of a shift register is to convert between serial and parallel interfaces. [...] SIPO registers are commonly attached to the output of microprocessors when more General Purpose Input/Output pins are required than are available. This allows several binary devices to be controlled using only two or three pins, but slower than parallel I/O.&#xD;&#xA;&#xD;&#xA;In the [article][3] Ricardo linked you can see the diagram of the shift register.&#xD;&#xA;&#xD;&#xA;![Shift register diagram][4]&#xD;&#xA;&#xD;&#xA;What happens here is that you put the data of the 8 pins in a sequence and for each clock tick the shift register will shift (move the binary data from each latch to the next one) until it &quot;makes a circle&quot; i.e. the first bit arrives to the last pin. Shift registers also have an input where you can turn on/off the shifting so the status can be kept after the data is shifted to the position. For a simple demonstration see the following animation.&#xD;&#xA;&#xD;&#xA;![Shift register animation][5]&#xD;&#xA;&#xD;&#xA;Here the red light is the serial input and the green ones are showing the state of the latches in this simplified [SIPO shift register][6]. After the data shifted to place shifting can be turned off and you can read the pins. In this example I shifted out `10101011`.&#xD;&#xA;&#xD;&#xA;From these examples you can realize that serial transfer will be slower than parallel, because you have to wait for the shift register to shift the bits to their place. You will have to wait the same amount of clock tick as many bits you want to load. This is one of the many reasons why you can't chain them indefinitely, because loading would take forever.&#xD;&#xA;&#xD;&#xA;  [1]: https://arduino.stackexchange.com/users/46/ricardo&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Shift_register#Uses&#xD;&#xA;  [3]: http://www.codeproject.com/Articles/144606/Arduino-Platform-Working-with-Shift-Registers&#xD;&#xA;  [4]: http://i.stack.imgur.com/fnNDa.png&#xD;&#xA;  [5]: http://i.stack.imgur.com/JgnIV.gif&#xD;&#xA;  [6]: http://en.wikipedia.org/wiki/Shift_register#Serial-in.2C_parallel-out_.28SIPO.29" />
  <row Id="322" PostHistoryTypeId="5" PostId="137" RevisionGUID="f3473b94-ee13-4a0f-8b33-810b3ab5e582" CreationDate="2014-02-13T02:44:21.900" UserId="37" Comment="added 1714 characters in body" Text="Here is a summary from [the official site][1]:&#xD;&#xA;&#xD;&#xA;&gt; Revision 2 of the Uno board has a resistor pulling the 8U2 HWB line to&#xD;&#xA;&gt; ground, making it easier to put into DFU mode.&#xD;&#xA;&gt; &#xD;&#xA;&gt; Revision 3 of the board has the following new features:&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - 1.0 pinout: added SDA and SCL pins that are near to the AREF pin and two other new pins placed near to the RESET pin, the IOREF that&#xD;&#xA;&gt; allow the shields to adapt to the voltage provided from the board. In&#xD;&#xA;&gt; future, shields will be compatible with both the board that uses the&#xD;&#xA;&gt; AVR, which operates with 5V and with the Arduino Due that operates&#xD;&#xA;&gt; with 3.3V. The second one is a not connected pin, that is reserved for&#xD;&#xA;&gt; future purposes.&#xD;&#xA;&gt;  - Stronger RESET circuit.&#xD;&#xA;&gt;  - Atmega 16U2 replace the 8U2.&#xD;&#xA;&#xD;&#xA;A more detailed list of changes can be found [here][2].&#xD;&#xA;&#xD;&#xA;##R2:&#xD;&#xA;&#xD;&#xA; - The rotation of the ATMEGA8U2 (the little chip near the USB port) was changed by 45 degrees. ![enter image description here][3]&#xD;&#xA;&#xD;&#xA; - Four solder pads (JP2) were added, connecting to pins PB4 to PB7 of the USB ATMEGA.&quot; ![enter image description here][4]&#xD;&#xA;&#xD;&#xA; - Instead of R1's solder pads, R2 adds header pins to the USB ATMEGA ICSP. ![enter image description here][5]&#xD;&#xA;&#xD;&#xA; - An LED connected to pin 13 was added. It turns on when pin 13 is `HIGH`, off when `LOW`.&#xD;&#xA; - The main microchip was changed from an ATmega168 to an ATmega328.&#xD;&#xA; - A resistor was added between the DTR (HWB) line and the ATMEGA PD7 pin.&#xD;&#xA;![enter image description here][8]&#xD;&#xA;&#xD;&#xA;##R3:&#xD;&#xA;&#xD;&#xA; - The rotation of the ATMEGA8U2 was changed back by 45 degrees.&#xD;&#xA; - The ATMEGA8U2 was changed to an ATMEGA16U2.&#xD;&#xA; - A diode was added, wired from +5vdc to the reset pin, cathode to +5vdc.&#xD;&#xA;![enter image description here][6]&#xD;&#xA; - The 8 pin connector that contains Arduino pins 8 was changed to 13, GND and AREF for a 10 pin connector. The extra 2 pins are connected to AD4/SDA and AD5/SCL. Also, the 6 pin connector that has the reset pin connected to it changed to an 8 pin connector. One of the new pins on this header is the IOREF pin that allows shields connected to the board to adapt to the voltage of the board. The second pin is not connected and reserved for future use.&#xD;&#xA;![enter image description here][7]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardUno&#xD;&#xA;  [2]: http://startingelectronics.com/articles/arduino/uno-r3-r2-differences/&#xD;&#xA;  [3]: http://i.stack.imgur.com/piYR2.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/mudBq.png&#xD;&#xA;  [5]: http://i.stack.imgur.com/zj258.png&#xD;&#xA;  [6]: http://i.stack.imgur.com/XneB4.jpg&#xD;&#xA;  [7]: http://i.stack.imgur.com/ay2Zt.png&#xD;&#xA;  [8]: http://i.stack.imgur.com/lzBuR.jpg" />
  <row Id="323" PostHistoryTypeId="2" PostId="140" RevisionGUID="2889e698-bfb7-4486-8f5f-ab7461d1ff11" CreationDate="2014-02-13T02:49:06.950" UserId="150" Text="I want to use sensors on an Arduino to control values in a Matlab program.  What are my options for communicating?&#xD;&#xA;&#xD;&#xA;I've used Processing to receive data sent via the serial cable, and that strategy has worked pretty well.  Is there something similar I can do using Matlab?  I'm something of a Matlab noob, so gentle guidance would be great.&#xD;&#xA;&#xD;&#xA;I'm not really looking for something like the arduinoio package -- I want to have separate computation executing on the Arduino and occasionally informing my Matlab program (which will occasionally poll the serial line, I suppose)." />
  <row Id="324" PostHistoryTypeId="1" PostId="140" RevisionGUID="2889e698-bfb7-4486-8f5f-ab7461d1ff11" CreationDate="2014-02-13T02:49:06.950" UserId="150" Text="How can I communicate Arduino to Matlab" />
  <row Id="325" PostHistoryTypeId="3" PostId="140" RevisionGUID="2889e698-bfb7-4486-8f5f-ab7461d1ff11" CreationDate="2014-02-13T02:49:06.950" UserId="150" Text="&lt;serial&gt;&lt;matlab&gt;" />
  <row Id="326" PostHistoryTypeId="2" PostId="141" RevisionGUID="930a2aa2-0eed-4d7b-999b-6ea9e39e64a0" CreationDate="2014-02-13T02:53:07.690" UserId="33" Text="Can I program my Arduino using any other programming languages than C++? If so, which programming languages. What software would I need to compile and load code to the Arduino." />
  <row Id="327" PostHistoryTypeId="1" PostId="141" RevisionGUID="930a2aa2-0eed-4d7b-999b-6ea9e39e64a0" CreationDate="2014-02-13T02:53:07.690" UserId="33" Text="Programming options other than C++" />
  <row Id="328" PostHistoryTypeId="3" PostId="141" RevisionGUID="930a2aa2-0eed-4d7b-999b-6ea9e39e64a0" CreationDate="2014-02-13T02:53:07.690" UserId="33" Text="&lt;programming&gt;" />
  <row Id="329" PostHistoryTypeId="2" PostId="142" RevisionGUID="38b9af26-e8b4-4901-a70d-31f3b62c4e4e" CreationDate="2014-02-13T02:56:18.943" UserId="52" Text="**Question:** Where do I put code if I want it to execute only once per Arduino startup?&#xD;&#xA;&#xD;&#xA;**Background:** I tend to use my Arduino to perform tasks that should be executed once per power cycle.  (For example, my robot should only drive forward *once* every time I turn it on--more than that, and it might fall off the table.)&#xD;&#xA;&#xD;&#xA;The standard Arduino IDE &quot;template&quot; consists of a `loop()` and a `setup()` function.  The `setup` code is run once per power cycle, and the `loop` is re-started every time it finishes.&#xD;&#xA;&#xD;&#xA;I see two approaches to code &quot;1 time tasks:&quot;&#xD;&#xA;&#xD;&#xA;Method 1: &quot;Loop once&quot;&#xD;&#xA;--&#xD;&#xA;    void setup() {&#xD;&#xA;      //do setup stuff&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      //do task&#xD;&#xA;      &#xD;&#xA;      while(1) ; //Repeat forever, preventing function from re-starting&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Method 2: &quot;Setup only&quot;&#xD;&#xA;--&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      //do setup stuff&#xD;&#xA;&#xD;&#xA;      //do task&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      //do nothing&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**More detailed form of question:**  Is one of these methods &quot;better&quot; from a hardware/software sense?  (e.g. is there anything &quot;special&quot; about the `setup` function, like it can only run for so much time?)  &#xD;&#xA;And, if they are the same from a hardware/software perspective, is there a &quot;best practice&quot; or standard way of writing code for these situations in the Arduino community?" />
  <row Id="330" PostHistoryTypeId="1" PostId="142" RevisionGUID="38b9af26-e8b4-4901-a70d-31f3b62c4e4e" CreationDate="2014-02-13T02:56:18.943" UserId="52" Text="Code for one-time execution in Arduino" />
  <row Id="331" PostHistoryTypeId="3" PostId="142" RevisionGUID="38b9af26-e8b4-4901-a70d-31f3b62c4e4e" CreationDate="2014-02-13T02:56:18.943" UserId="52" Text="&lt;programming&gt;" />
  <row Id="332" PostHistoryTypeId="2" PostId="143" RevisionGUID="ea08386b-8a29-4c2d-ab40-0963f234b597" CreationDate="2014-02-13T03:14:23.623" UserId="87" Text="Before you start to mess with a computer there are many recommendation like turn the power off or watch out for statical electricity. What are the things I should be aware when I work with an Arduino board if I don't want to harm neither myself nor the board. Some example situations:&#xD;&#xA;&#xD;&#xA;- Setting up wire, component layout or breadboard.&#xD;&#xA;- Debugging a running setup.&#xD;&#xA;- Moving, mounting up the board somewhere.&#xD;&#xA;- Kids, animals around the board." />
  <row Id="333" PostHistoryTypeId="1" PostId="143" RevisionGUID="ea08386b-8a29-4c2d-ab40-0963f234b597" CreationDate="2014-02-13T03:14:23.623" UserId="87" Text="What I should be aware before I touch my Arduino?" />
  <row Id="334" PostHistoryTypeId="3" PostId="143" RevisionGUID="ea08386b-8a29-4c2d-ab40-0963f234b597" CreationDate="2014-02-13T03:14:23.623" UserId="87" Text="&lt;safety&gt;" />
  <row Id="335" PostHistoryTypeId="2" PostId="144" RevisionGUID="5f652c0f-7243-49d3-95b4-2123f38b4f96" CreationDate="2014-02-13T03:41:07.750" UserId="13" Text="I would strongly prefer Method 2. If you ever plan to add code to handle input, output, etc,  it's easy with Method 2 -- just fill in `loop()`, but requires reworking/refactoring in Method 1. " />
  <row Id="336" PostHistoryTypeId="2" PostId="145" RevisionGUID="f9d1a992-309a-4406-af53-f1a570e08635" CreationDate="2014-02-13T03:56:04.810" UserId="13" Text="In theory, any compiler which outputs AVR assembly could be used (modulo limitations on code size, ram usage etc). &#xD;&#xA;&#xD;&#xA;AVR backends exist for both [LLVM](http://sourceforge.net/projects/avr-llvm/) and  [GCC](http://gcc.gnu.org/wiki/avr-gcc) -- so in theory, with some effort, most languages which are supported by LLVM and GCC's front-ends could be compiled to AVR. A big question will be library support, etc. &#xD;&#xA;&#xD;&#xA;Never the less, here's a couple of odd choices for the spirit of the question, rather than its letter [1]. &#xD;&#xA;&#xD;&#xA;- [AMForth](http://amforth.sourceforge.net/TG/recipes/Arduino-HelloWorld.html), a forth dialect can be flashed onto an Arduino. &#xD;&#xA;- [AVR-Ada](http://sourceforge.net/projects/avr-ada/): [Ada](http://en.wikipedia.org/wiki/Ada_(programming_language)) for AVR micro-controllers. &#xD;&#xA;- [BASIC](http://www.mikroe.com/mikrobasic/avr/): Bring back the Goto!&#xD;&#xA;&#xD;&#xA;Oh, and you could write raw [AVR Assembly](http://www.atmel.ca/Images/doc0856.pdf)! &#xD;&#xA;&#xD;&#xA;[1]- I Haven't tried these though! &#xD;&#xA;" />
  <row Id="337" PostHistoryTypeId="2" PostId="146" RevisionGUID="ba3b452e-b066-4c49-8b56-608a92a3d27e" CreationDate="2014-02-13T04:01:09.127" UserId="8" Text="There is no time limit on the setup function. I prefer method 2 because the loop can be filled with whatever you need to later." />
  <row Id="338" PostHistoryTypeId="2" PostId="147" RevisionGUID="a0fcf0f9-9724-43de-9b9c-a55ae8378c66" CreationDate="2014-02-13T04:23:36.643" UserId="11" Text="Definitely go with method two. That's what the setup function is there for. It's much easier to read as well. Anything in the `loop()` implies it will be run in a loop." />
  <row Id="339" PostHistoryTypeId="2" PostId="148" RevisionGUID="41de3367-0859-48d7-ad5f-2c11278289ce" CreationDate="2014-02-13T04:40:07.563" UserId="62" Text="I usually go with Method 2, but end up doing this:&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      //do setup stuff&#xD;&#xA;    &#xD;&#xA;      //do task&#xD;&#xA;      init(); //Do start-up initialization steps&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void init() {&#xD;&#xA;      // do tasks on startup&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      //do looping code&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;With the above setup it allows my code to be even more organized." />
  <row Id="341" PostHistoryTypeId="2" PostId="149" RevisionGUID="c65f8268-013b-4d41-9147-a0185413d80f" CreationDate="2014-02-13T05:11:43.680" UserId="40" Text="Turning the power off and taking proper static precautions also applies to Arduinos.  Anorton's tip about not resting it on a conductive surface is also useful.  Some other things to keep in mind:&#xD;&#xA;&#xD;&#xA; - Double check the polarities of any connections you make.&#xD;&#xA; - Keep a consistent wiring color code.  Use red for power and black for ground.&#xD;&#xA; - Calculate the expected current through all components before you apply power.  Check the datasheet to make sure it's within safe limits.&#xD;&#xA; - Calculate the heat dissipation for higher power components like power supplies and motor drivers.&#xD;&#xA; - Connect and test one small part at a time, instead of in one big bang.&#xD;&#xA; - Make sure the parts you buy expect the same voltage, or perform the appropriate conversion.&#xD;&#xA;&#xD;&#xA;For keeping people safe:&#xD;&#xA;&#xD;&#xA; - Know where the fire extinguisher is.&#xD;&#xA; - Don't put cords where people can trip on them.&#xD;&#xA; - Use a proper stand to hold your soldering iron, and keep pets and small children away.&#xD;&#xA; - If your project has a propeller or something physically dangerous, build failsafes and kill switches into the system.&#xD;&#xA; - Be careful to charge any batteries properly, and not let them overheat.&#xD;&#xA; - Be careful what you touch while troubleshooting.  Arduinos usually don't deal with very high voltages, but inductors and capacitors can build up higher charges than you expect, and hold it after power is removed." />
  <row Id="342" PostHistoryTypeId="2" PostId="150" RevisionGUID="c8c59ae2-3283-4a2e-9f77-3581900b3855" CreationDate="2014-02-13T05:21:46.223" UserId="62" Text="You can always upload to the Arduino via Bluetooth.&#xD;&#xA;&#xD;&#xA; 1. You must have a bluetooth chip/shield (any should do) and a PC that has bluetooth (or a table that can compile, most likely an Android tablet)&#xD;&#xA; 2. You must change the BT baud rate to the same as normal arduino upload, which is 19200 (default BT baud is 9600).&#xD;&#xA; 3. Connect the BT to Pin 0 and 1 so act the same as having a USB cord connected&#xD;&#xA; 4. Connect a wire to the reset pin to allow remote resetting the arduino to statup the bootloader&#xD;&#xA; - There must be a delay before&#xD;&#xA;    hitting the reset pin as the bootloader must be active when hitting&#xD;&#xA;    the upload button.&#xD;&#xA; 5. Enjoy&#xD;&#xA;&#xD;&#xA;For a more detailed description please read: http://ame2.asu.edu/staff/kidane/ArdWilessBtProg.pdf" />
  <row Id="343" PostHistoryTypeId="5" PostId="120" RevisionGUID="ae347816-645c-494d-aa36-f482f7a1998c" CreationDate="2014-02-13T06:11:15.470" UserId="83" Comment="deleted 141 characters in body" Text="Write a sketch that millis 1000 times, not by making a loop, but by copy and paste. Measure that and compare it to the actual expected time. Mind you that that the results may vary with different versions of the IDE (and its compiler in particular).&#xD;&#xA;&#xD;&#xA;Another option is to toggle an IO pin before and after the millis call, then measure the time for a very small value and a somewhat larger value. Compare the measured timings and calculate the overhead.&#xD;&#xA;&#xD;&#xA;The most accurate way is to take a look at the disassembly listing, the generated code. But that is not for the faint of heart. You'll have to carefully study the datasheet how long each instruction cycle takes.&#xD;&#xA;" />
  <row Id="344" PostHistoryTypeId="2" PostId="151" RevisionGUID="48ac1b92-6e1f-42cb-8199-bfc0240a7522" CreationDate="2014-02-13T06:24:45.360" UserId="84" Text="As most other answers, I would go for method 2.&#xD;&#xA;&#xD;&#xA;But I would avoid an empty `loop()` that makes the Atmel consume &quot;a lot&quot; of current for nothing and put `delay()` inside `loop()` just to limit current consumption.&#xD;&#xA;&#xD;&#xA;Disclaimer: I am not sure that would dramatically reduce curent usage, but it is worth trying.&#xD;&#xA;&#xD;&#xA;Also, at the end of setup(), I would put the Atmel into one of its numerous sleep modes (choice depending on what you need after `setup()`)." />
  <row Id="345" PostHistoryTypeId="2" PostId="152" RevisionGUID="48631b84-1852-435d-8b99-991cd3d9bd1d" CreationDate="2014-02-13T06:58:14.893" UserId="77" Text="Some commonly known ones:&#xD;&#xA;&#xD;&#xA; * [Ada](http://sourceforge.net/apps/mediawiki/avr-ada/index.php?title=AVR-Ada)&#xD;&#xA; * [Basic](http://www.mcselec.com/)&#xD;&#xA; * [Forth](http://claymore.engineer.gvsu.edu/~steriana/Python/pfavr/rationale.html), [alt](http://www.forth.com/embedded/index.html), [alt](http://www.forth.com/embedded/index.html)&#xD;&#xA; * [Java](http://www.harbaum.org/till/nanovm/index.shtml)&#xD;&#xA; * [Pascal](http://www.e-lab.de/AVRco/index_en.html)&#xD;&#xA; * [Python](http://wiki.python.org/moin/PyMite)&#xD;&#xA; * [C](http://www.ladyada.net/learn/avr/setup-mac.html) (mac) and [C](http://winavr.sourceforge.net/) (Windows)&#xD;&#xA;&#xD;&#xA;In theory you should be able to extend avr-gcc to support other languages, though this is no small undertaking. I should also caveat that support for languages other than C typically comes with some fairly weighty restrictions on language components -- for instance, even with C++ it's discouraged to be instantiating new objects as `malloc` and `free` are extremely expensive in both memory space and cycles.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Besides using Google, the following references are applicable [Click Here.][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.piclist.com/techref/atmel/avr/languages.htm" />
  <row Id="346" PostHistoryTypeId="2" PostId="153" RevisionGUID="818f45b7-b883-4cff-bb32-f18d8a1b237c" CreationDate="2014-02-13T07:05:23.627" UserId="77" Text="When you have a board in your hand but don't know is it working or not? How to verify its working or dead?" />
  <row Id="347" PostHistoryTypeId="1" PostId="153" RevisionGUID="818f45b7-b883-4cff-bb32-f18d8a1b237c" CreationDate="2014-02-13T07:05:23.627" UserId="77" Text="How to check my Arduino board is working or dead?" />
  <row Id="348" PostHistoryTypeId="3" PostId="153" RevisionGUID="818f45b7-b883-4cff-bb32-f18d8a1b237c" CreationDate="2014-02-13T07:05:23.627" UserId="77" Text="&lt;uno&gt;&lt;testing&gt;" />
  <row Id="349" PostHistoryTypeId="2" PostId="154" RevisionGUID="97630098-5639-4082-a55b-0131c617f7ef" CreationDate="2014-02-13T07:05:23.627" UserId="77" Text="&gt; **Note :** After the @Ricardo's comment on my last post, I am posting this !&#xD;&#xA;&#xD;&#xA;Plug the board into a USB port on your computer and check that the green LED power indicator on the board illuminates. Standard Arduino boards (Uno, Duemilanove, and Mega) have a green LED power indicator located near the reset switch.&#xD;&#xA;&#xD;&#xA;An orange LED near the center of the board (labeled “Pin 13 LED” in the image below) should flash on and off when the board is powered up (boards come from the factory preloaded with software to flash the LED as a simple check that the board is working).&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;If the power LED does not illuminate when the board is connected to your computer, the board is probably not receiving power.&#xD;&#xA;&#xD;&#xA;The flashing LED (connected to digital output pin 13) is being controlled by code running on the board (new boards are preloaded with the Blink example sketch). If the pin 13 LED is flashing, the sketch is running correctly, which means the chip on the board is working. If the green power LED is on but the pin 13 LED is not flashing, it could be that the factory code is not on the chip. If you are not using a standard board, it may not have a built-in LED on pin 13, so check the documentation for details of your board.&#xD;&#xA;&#xD;&#xA;Online guides for getting started with Arduino are available at for [Windows][2],  for [Mac OS X][3], and for [Linux][4].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/gDEH4.png&#xD;&#xA;  [2]: http://arduino.cc/en/Guide/Windows&#xD;&#xA;  [3]: http://arduino.cc/en/Guide/MacOSX&#xD;&#xA;  [4]: http://www.arduino.cc/Learning/Linux" />
  <row Id="350" PostHistoryTypeId="2" PostId="155" RevisionGUID="e335393f-25de-41db-84b3-026ac7666f3c" CreationDate="2014-02-13T07:37:20.493" UserId="89" Text="&lt;!-- language: lang-bash --&gt;&#xD;&#xA;Supposed one owns a USB programmer, there's another way to inspect the Arduino.&#xD;&#xA;&#xD;&#xA;Connect the programmer to the ICSP pins of the Arduino and call `avrdude` with the right parameters to read the fuses of your Arduino.&#xD;&#xA;&#xD;&#xA;    avrdude -c programmer-id -p partno -P port&#xD;&#xA;&#xD;&#xA;For an Arduino Uno, `partno` is `m328p`. `Programmer-id` depends on the device used. In my case (mySmartUSB light) `stk500v2` is a supported and `port` is `/dev/ttyUSB0`. Here&#xD;&#xA;&#xD;&#xA;    avrdude -c stk500v2 -p m328p -P /dev/ttyUSB0&#xD;&#xA;&#xD;&#xA;gives the following output&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    avrdude: AVR device initialized and ready to accept instructions&#xD;&#xA;    Reading | ################################################## | 100% 0.01s&#xD;&#xA;    avrdude: Device signature = 0x1e950f&#xD;&#xA;    avrdude: safemode: Fuses OK&#xD;&#xA;    avrdude done.  Thank you.&#xD;&#xA;&#xD;&#xA;The UNO board responds with the correct signature and is ready for some action :)&#xD;&#xA;" />
  <row Id="351" PostHistoryTypeId="2" PostId="156" RevisionGUID="5ce4329a-aaa3-47d4-a5fc-b32219dec45e" CreationDate="2014-02-13T08:19:39.940" UserId="157" Text="I'm using a DigiX (Arduino Due based) board to connect to a GPRS/GSM SIM908 breakout board. The board has the following pins on its RS232![RS232 pinout][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.imgur.com/muN5cZA.png&#xD;&#xA;&#xD;&#xA;. I've got all three UART TX lines hooked up to the RX Lines (and RX to TX) on my arduino but the board keeps resetting, which I would guess is some sort of voltage issue (I turned the board off immediately). However there are three MAX3232s on the underside of the board, which I thought would have made it so I could just connect the lines directly to the arduino. Any idea why this is happening or how to properly connect these two devices?  Any help is much appreciated, thank you." />
  <row Id="352" PostHistoryTypeId="1" PostId="156" RevisionGUID="5ce4329a-aaa3-47d4-a5fc-b32219dec45e" CreationDate="2014-02-13T08:19:39.940" UserId="157" Text="Connecting breakout board to Arduino with UART?" />
  <row Id="353" PostHistoryTypeId="3" PostId="156" RevisionGUID="5ce4329a-aaa3-47d4-a5fc-b32219dec45e" CreationDate="2014-02-13T08:19:39.940" UserId="157" Text="&lt;serial&gt;&lt;safety&gt;&lt;connection&gt;&lt;arduino-due&gt;" />
  <row Id="354" PostHistoryTypeId="5" PostId="156" RevisionGUID="af7317d1-9cc1-481e-8856-2add2031a29b" CreationDate="2014-02-13T08:46:42.640" UserId="136" Comment="Add link to DigiX and formatting." Text="I'm using a [DigiX][1] (Arduino Due based 3.3V) board to connect to a GPRS/GSM SIM908 breakout board. The board has the following pins on its RS232![RS232 pinout][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I've got all three UART TX lines hooked up to the RX Lines (and RX to TX) on my Arduino but the board keeps resetting, which I would guess is some sort of voltage issue (I turned the board off immediately). However there are three MAX3232s on the underside of the board, which I thought would have made it so I could just connect the lines directly to the arduino. Any idea why this is happening or how to properly connect these two devices?  Any help is much appreciated, thank you.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://digistump.com/wiki/digix&#xD;&#xA;  [2]: http://i.imgur.com/muN5cZA.png" />
  <row Id="355" PostHistoryTypeId="24" PostId="156" RevisionGUID="af7317d1-9cc1-481e-8856-2add2031a29b" CreationDate="2014-02-13T08:46:42.640" Comment="Proposed by 136 approved by 157 edit id of 34" />
  <row Id="356" PostHistoryTypeId="5" PostId="156" RevisionGUID="7bebf638-e30e-4b37-b018-7350f9e0153a" CreationDate="2014-02-13T08:49:49.657" UserId="157" Comment="Added additional info and clarity " Text="I'm using a [DigiX][1] (Arduino Due based 3.3V) board to connect to a GPRS/GSM SIM908 breakout board. The SIM908 EVB board has the following pins on its RS232![RS232 pinout][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I've got all three UART TX lines hooked up to the RX Lines (and RX to TX) on my Arduino but the board keeps resetting, which I would guess is some sort of voltage issue (I turned the board off immediately). However there are three MAX3232s on the underside of the board, which I thought would have made it so I could just connect the lines directly to the arduino. Any idea why this is happening or how to properly connect these two devices?  Any help is much appreciated, thank you.&#xD;&#xA;&#xD;&#xA;Additional info:&#xD;&#xA;&#xD;&#xA;Pinout of the DigiX http://digistump.com/wiki/digix/tutorials/pinout&#xD;&#xA;&#xD;&#xA;Schematic of the DigiX http://digispark.s3.amazonaws.com/DigiX-V1-Final-Production.pdf&#xD;&#xA;&#xD;&#xA;Sorry these links are in chinese:&#xD;&#xA;Here is a SIM908 Hardware guide http://pan.baidu.com/share/link?shareid=1471365276&amp;uk=4130796101&amp;third=15&#xD;&#xA;&#xD;&#xA;Here is the full schematic of the breakout board http://pan.baidu.com/share/link?shareid=1470501867&amp;uk=4130796101&amp;third=15&#xD;&#xA;&#xD;&#xA;  [1]: http://digistump.com/wiki/digix&#xD;&#xA;  [2]: http://i.imgur.com/muN5cZA.png" />
  <row Id="357" PostHistoryTypeId="2" PostId="157" RevisionGUID="644ba5dd-1f6c-4318-995a-585cd160a4e9" CreationDate="2014-02-13T09:27:34.227" UserId="136" Text="Both the DigiX and the SIM908 are natively 3.3V boards. They should be able to connect to each other directly.&#xD;&#xA;&#xD;&#xA;For some reason, the SIM908 breakout seems to only offer RS232 level serial outputs for the GPRS and GPS. On U3 (the SIM908 module itself) Pins 68/71 offer 3.3V levels for the GPRS (GPRS-TXD and GPRS-RXD) and 15/16 offer 3.3V levels for the GPS (GPS-TXD and GPS-RXD).&#xD;&#xA;&#xD;&#xA;These are converted to RS232 levels by the MAX3232 and presented on J3 and J13. I can't see any point where the 3.3V signals are presented on a connector.&#xD;&#xA;&#xD;&#xA;You could either:&#xD;&#xA;&#xD;&#xA; - Breakout the 3.3V signals onto connectors by modifying the SIM908&#xD;&#xA;   breakout board. &#xD;&#xA; - Build a level converter to take the 3.3V signals from&#xD;&#xA;   the DigiX to RS232 and then connect them as before.&#xD;&#xA;&#xD;&#xA;You may have damaged the DigiX board connecting RS232 levels directly to it however. The ARM based Arduinos are far less tolerant of voltage abuse than the ATmega based Arduinos." />
  <row Id="360" PostHistoryTypeId="2" PostId="158" RevisionGUID="efdbf324-238d-459e-8c25-5d4f6fb6917d" CreationDate="2014-02-13T10:08:53.917" UserId="42" Text="I have a few useful I2C components, such as a 16-bit port expander (MCP23017), which I'd like to use in various projects.&#xD;&#xA;&#xD;&#xA;What do I need to do to make these work with Arduino? Will it work with any Arduino, or do I need a specific board or shield?" />
  <row Id="361" PostHistoryTypeId="1" PostId="158" RevisionGUID="efdbf324-238d-459e-8c25-5d4f6fb6917d" CreationDate="2014-02-13T10:08:53.917" UserId="42" Text="How do I use I2C devices with Arduino?" />
  <row Id="362" PostHistoryTypeId="3" PostId="158" RevisionGUID="efdbf324-238d-459e-8c25-5d4f6fb6917d" CreationDate="2014-02-13T10:08:53.917" UserId="42" Text="&lt;connection&gt;&lt;i2c&gt;" />
  <row Id="363" PostHistoryTypeId="2" PostId="159" RevisionGUID="69ff9299-6adc-4675-b6ed-b15df71d269e" CreationDate="2014-02-13T10:14:06.827" UserId="89" Text="Additional shields are not needed.&#xD;&#xA;&#xD;&#xA;You only need the Wire library and a couple of wires to connect the device to **SDA** and **SCL**.&#xD;&#xA;&#xD;&#xA;The position of these pins is different on the various Arduinos, please have a look [here][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;[1]:http://arduino.cc/de/Reference/Wire&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="364" PostHistoryTypeId="2" PostId="160" RevisionGUID="3d4a3b45-f478-466e-8b8b-452f5bfda46e" CreationDate="2014-02-13T10:23:06.987" UserId="3" Text="&#xD;&#xA;Arduino have the [Wire Library][1] that communicate with I2C.&#xD;&#xA;&#xD;&#xA;&gt; This library allows you to communicate with I2C / TWI devices. On the&#xD;&#xA;&gt; Arduino boards with the R3 layout (1.0 pinout), the SDA (data line)&#xD;&#xA;&gt; and SCL (clock line) are on the pin headers close to the AREF pin. The&#xD;&#xA;&gt; Arduino Due has two I2C / TWI interfaces SDA1 and SCL1 are near to the&#xD;&#xA;&gt; AREF pin and the additional one is on pins 20 and 21. As a reference&#xD;&#xA;&gt; the table below shows where TWI pins are located on various Arduino&#xD;&#xA;&gt; boards.&#xD;&#xA;&#xD;&#xA;Board	I2C / TWI pins&#xD;&#xA;&#xD;&#xA; - Uno, Ethernet	A4 (SDA), A5 (SCL)&#xD;&#xA; - Mega2560	20 (SDA), 21 (SCL)&#xD;&#xA; - Leonardo	2 (SDA), 3 (SCL)&#xD;&#xA; - Due	20 (SDA), 21 (SCL), SDA1, SCL1&#xD;&#xA;&#xD;&#xA;You can take a look at [this][2], [this][3] examples.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.arduino.cc/en/Reference/Wire&#xD;&#xA;  [2]: http://blog.digtro.com/arduino-uno-tea5767-fm-receiver-i2c/&#xD;&#xA;  [3]: http://www.instructables.com/id/I2C-between-Arduinos/" />
  <row Id="365" PostHistoryTypeId="2" PostId="161" RevisionGUID="809c6b42-916c-4ee1-a236-280b0257366f" CreationDate="2014-02-13T10:41:34.937" UserId="160" Text="I second calling millis repeatedly and then comparing actual vs. expected.   &#xD;&#xA;   &#xD;&#xA;There will be some minimal overhead, but it will diminish in significance the more times you call millis(). &#xD;&#xA;&#xD;&#xA;If you look at &#xD;&#xA;C:\Program Files (x86)\Arduino\Arduino ERW 1.0.5\hardware\arduino\cores\arduino\wiring.c&#xD;&#xA;&#xD;&#xA;You can see that millis() is very tiny at only 4 instructions (cli is simply # define cli()  \__asm__ \__volatile__ (&quot;cli&quot; ::)) and a return. &#xD;&#xA;&#xD;&#xA;I'd call it about 10 million times using a FOR loop which has a volatile as the conditional. The volatile keyword will prevent the compiler from attempting any optimization on the loop itself. &#xD;&#xA;&#xD;&#xA;I don't guarantee the following to be syntactically perfect..&#xD;&#xA;&#xD;&#xA;    int temp1,temp2;&#xD;&#xA;    temp1=millis();&#xD;&#xA;    for (volatile unsigned int j=0;j&lt;1000000;++j){&#xD;&#xA;    temp2=millis();}&#xD;&#xA;    Serial.print(&quot;Execution time = &quot;);&#xD;&#xA;    Serial.print((temp2-temp1,DEC);&#xD;&#xA;    Serial.print(&quot;ms&quot;);&#xD;&#xA;&#xD;&#xA;my guess is that takes ~900ms or about 56us per call to millis. ( I don't have an aruduino handy ATM." />
  <row Id="366" PostHistoryTypeId="2" PostId="162" RevisionGUID="d0fe260c-dc9c-4b22-9148-159a043f3b78" CreationDate="2014-02-13T12:26:29.550" UserId="86" Text="If you want to know *exactly* how long something will take, there is only one solution: Look at the disassembly!&#xD;&#xA;&#xD;&#xA;Starting with the minimal code: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup(){};&#xD;&#xA;    &#xD;&#xA;    volatile uint16_t x;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      x = millis();&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;This code compiled and then fed into `avr-objdump -S` produces a documented disassembly. Here are the interesting excerpts:&#xD;&#xA;&#xD;&#xA;`void loop()` produces:  &#xD;&#xA;&#xD;&#xA;    000000a8 &lt;loop&gt;:&#xD;&#xA;      a8:	0e 94 a7 00 	call	0x14e	; 0x14e &lt;millis&gt;&#xD;&#xA;      ac:	60 93 00 01 	sts	0x0100, r22&#xD;&#xA;      b0:	70 93 01 01 	sts	0x0101, r23&#xD;&#xA;      b4:	80 93 02 01 	sts	0x0102, r24&#xD;&#xA;      b8:	90 93 03 01 	sts	0x0103, r25&#xD;&#xA;      bc:	08 95       	ret&#xD;&#xA;&#xD;&#xA;Which is a function call (`call`), four copies (which copy each of the bytes in the `uint32_t` return value of `millis()` (note that the arduino docs call this a `long`, but they are incorrect to not be explicitly specifying the variable sizes)), and finally the function return.&#xD;&#xA;&#xD;&#xA;`call` requires 4 clock cycles, and each `sts` requires 2 clock cycles, so we have a minimum of 12 clock cycles just for function call overhead.&#xD;&#xA;&#xD;&#xA;Now, lets look at the disassembly of the `&lt;millis&gt;` function, which is located at `0x14e`:  &#xD;&#xA;&#xD;&#xA;unsi&#xD;&#xA;&#xD;&#xA;    gned long millis()&#xD;&#xA;    {&#xD;&#xA;    	unsigned long m;&#xD;&#xA;    	uint8_t oldSREG = SREG;&#xD;&#xA;     14e:	8f b7       	in	r24, 0x3f	; 63&#xD;&#xA;    &#xD;&#xA;    	// disable interrupts while we read timer0_millis or we might get an&#xD;&#xA;    	// inconsistent value (e.g. in the middle of a write to timer0_millis)&#xD;&#xA;    	cli();&#xD;&#xA;     150:	f8 94       	cli&#xD;&#xA;    	m = timer0_millis;&#xD;&#xA;     152:	20 91 08 01 	lds	r18, 0x0108&#xD;&#xA;     156:	30 91 09 01 	lds	r19, 0x0109&#xD;&#xA;     15a:	40 91 0a 01 	lds	r20, 0x010A&#xD;&#xA;     15e:	50 91 0b 01 	lds	r21, 0x010B&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;     162:	8f bf       	out	0x3f, r24	; 63&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;     164:	b9 01       	movw	r22, r18&#xD;&#xA;     166:	ca 01       	movw	r24, r20&#xD;&#xA;     168:	08 95       	ret&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;As you can see, the `millis()` function is fairly simple:&#xD;&#xA;&#xD;&#xA;1. `in` saves the interrupt register settings (1 cycle)&#xD;&#xA;2. `cli` turns off the interrupts (1 cycle)&#xD;&#xA;3. `lds` copy one of the 4 bytes of the current value of the milli counter into a temporary register (2 clock cycles)&#xD;&#xA;4. `lds` Byte 2 (2 clock cycles)&#xD;&#xA;5. `lds` Byte 3 (2 clock cycles)&#xD;&#xA;6. `lds` Byte 4 (2 clock cycles)&#xD;&#xA;7. `out` restore interrupt settings (1 clock cycle)&#xD;&#xA;8. `movw` shuffle registers around (1 clock cycle)&#xD;&#xA;9. `movw` and again (1 clock cycle)&#xD;&#xA;10. `ret` return from subroutine  (4 cycles)&#xD;&#xA;&#xD;&#xA;So, if we add them all up, we have a total of 17 clock cycles in the `millis()` function itself, plus a call overhead of 12, for a total of 29 clock cycles.&#xD;&#xA;&#xD;&#xA;Assuming a 16 Mhz clock rate (most arduinos), each clock cycle is $1/16e6$ seconds, or 0.0000000625 seconds, which is 62.5 nanoseconds. 62.5 ns * 29 = 1.812 microseconds.&#xD;&#xA;&#xD;&#xA;Therefore, the total execution time for a single `millis()` call on *most* arduinos will be **1.812 microseconds**.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;[AVR Assembly reference][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/images/doc0856.pdf%E2%80%8E" />
  <row Id="367" PostHistoryTypeId="5" PostId="155" RevisionGUID="5db75f6f-91ca-4705-8391-768bce6c0a34" CreationDate="2014-02-13T12:28:36.660" UserId="89" Comment="added 526 characters in body" Text="&lt;!-- language: lang-bash --&gt;&#xD;&#xA;Supposed one owns a USB programmer, there's another way to inspect the Arduino.&#xD;&#xA;&#xD;&#xA;Connect the programmer to the ICSP pins of the Arduino and call `avrdude` with the right parameters to read the fuses of your Arduino.&#xD;&#xA;&#xD;&#xA;    avrdude -c programmer-id -p partno -P port&#xD;&#xA;&#xD;&#xA;For an Arduino Uno, `partno` is `m328p`. `Programmer-id` depends on the device used. In my case (mySmartUSB light) `stk500v2` is a supported and `port` is `/dev/ttyUSB0`. Here&#xD;&#xA;&#xD;&#xA;    avrdude -c stk500v2 -p m328p -P /dev/ttyUSB0&#xD;&#xA;&#xD;&#xA;gives the following output&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    avrdude: AVR device initialized and ready to accept instructions&#xD;&#xA;    Reading | ################################################## | 100% 0.01s&#xD;&#xA;    avrdude: Device signature = 0x1e950f&#xD;&#xA;    avrdude: safemode: Fuses OK&#xD;&#xA;    avrdude done.  Thank you.&#xD;&#xA;&#xD;&#xA;The UNO board responds with the correct signature and is ready for some action :)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;### How to connect?&#xD;&#xA;&#xD;&#xA;My USB programmer came with a 6-wire ribbon cable with 2x3 female connectors on both sides. As usual, the wire for **pin 1** is marked red. Due to a notch in at the 2x3 male connector of the programmer, the cable only fits here in one direction.&#xD;&#xA;&#xD;&#xA;If you lot at the Arduino UNO, the ICSP header is right to the reset button. &#xD;&#xA;&#xD;&#xA;The pinout is as follows.&#xD;&#xA;&#xD;&#xA;&lt;pre&gt;&#xD;&#xA;MISO  1    2 VCC&#xD;&#xA;SCK   3    4 MOSI&#xD;&#xA;RESET 5    6 GND&#xD;&#xA;&lt;/pre&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**NOTE** Pin 1 is the top left one, marked with a white dot!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="368" PostHistoryTypeId="5" PostId="162" RevisionGUID="6eef1846-0175-4e3f-8dc1-0a2f0b919511" CreationDate="2014-02-13T12:31:35.450" UserId="86" Comment="added 383 characters in body" Text="If you want to know *exactly* how long something will take, there is only one solution: Look at the disassembly!&#xD;&#xA;&#xD;&#xA;Starting with the minimal code: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup(){};&#xD;&#xA;    &#xD;&#xA;    volatile uint16_t x;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      x = millis();&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;This code compiled and then fed into `avr-objdump -S` produces a documented disassembly. Here are the interesting excerpts:&#xD;&#xA;&#xD;&#xA;`void loop()` produces:  &#xD;&#xA;&#xD;&#xA;    000000a8 &lt;loop&gt;:&#xD;&#xA;      a8:	0e 94 a7 00 	call	0x14e	; 0x14e &lt;millis&gt;&#xD;&#xA;      ac:	60 93 00 01 	sts	0x0100, r22&#xD;&#xA;      b0:	70 93 01 01 	sts	0x0101, r23&#xD;&#xA;      b4:	80 93 02 01 	sts	0x0102, r24&#xD;&#xA;      b8:	90 93 03 01 	sts	0x0103, r25&#xD;&#xA;      bc:	08 95       	ret&#xD;&#xA;&#xD;&#xA;Which is a function call (`call`), four copies (which copy each of the bytes in the `uint32_t` return value of `millis()` (note that the arduino docs call this a `long`, but they are incorrect to not be explicitly specifying the variable sizes)), and finally the function return.&#xD;&#xA;&#xD;&#xA;`call` requires 4 clock cycles, and each `sts` requires 2 clock cycles, so we have a minimum of 12 clock cycles just for function call overhead.&#xD;&#xA;&#xD;&#xA;Now, lets look at the disassembly of the `&lt;millis&gt;` function, which is located at `0x14e`:  &#xD;&#xA;&#xD;&#xA;unsi&#xD;&#xA;&#xD;&#xA;    gned long millis()&#xD;&#xA;    {&#xD;&#xA;    	unsigned long m;&#xD;&#xA;    	uint8_t oldSREG = SREG;&#xD;&#xA;     14e:	8f b7       	in	r24, 0x3f	; 63&#xD;&#xA;    &#xD;&#xA;    	// disable interrupts while we read timer0_millis or we might get an&#xD;&#xA;    	// inconsistent value (e.g. in the middle of a write to timer0_millis)&#xD;&#xA;    	cli();&#xD;&#xA;     150:	f8 94       	cli&#xD;&#xA;    	m = timer0_millis;&#xD;&#xA;     152:	20 91 08 01 	lds	r18, 0x0108&#xD;&#xA;     156:	30 91 09 01 	lds	r19, 0x0109&#xD;&#xA;     15a:	40 91 0a 01 	lds	r20, 0x010A&#xD;&#xA;     15e:	50 91 0b 01 	lds	r21, 0x010B&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;     162:	8f bf       	out	0x3f, r24	; 63&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;     164:	b9 01       	movw	r22, r18&#xD;&#xA;     166:	ca 01       	movw	r24, r20&#xD;&#xA;     168:	08 95       	ret&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;As you can see, the `millis()` function is fairly simple:&#xD;&#xA;&#xD;&#xA;1. `in` saves the interrupt register settings (1 cycle)&#xD;&#xA;2. `cli` turns off the interrupts (1 cycle)&#xD;&#xA;3. `lds` copy one of the 4 bytes of the current value of the milli counter into a temporary register (2 clock cycles)&#xD;&#xA;4. `lds` Byte 2 (2 clock cycles)&#xD;&#xA;5. `lds` Byte 3 (2 clock cycles)&#xD;&#xA;6. `lds` Byte 4 (2 clock cycles)&#xD;&#xA;7. `out` restore interrupt settings (1 clock cycle)&#xD;&#xA;8. `movw` shuffle registers around (1 clock cycle)&#xD;&#xA;9. `movw` and again (1 clock cycle)&#xD;&#xA;10. `ret` return from subroutine  (4 cycles)&#xD;&#xA;&#xD;&#xA;So, if we add them all up, we have a total of 17 clock cycles in the `millis()` function itself, plus a call overhead of 12, for a total of 29 clock cycles.&#xD;&#xA;&#xD;&#xA;Assuming a 16 Mhz clock rate (most arduinos), each clock cycle is $1/16e6$ seconds, or 0.0000000625 seconds, which is 62.5 nanoseconds. 62.5 ns * 29 = 1.812 microseconds.&#xD;&#xA;&#xD;&#xA;Therefore, the total execution time for a single `millis()` call on *most* arduinos will be **1.812 microseconds**.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;[AVR Assembly reference][1]&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;As a side-note, there is space for optimization here! If you update the `unsigned long millis(){}` function definition to be `inline unsigned long millis(){}`, you would remove the call overhead (at the cost of *slightly* larger code size). Furthermore, it looks like the compiler is doing two unnecessary moves (the two `movw` calls, but I haven't looked at it that closely).&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Really, considering the function call overhead is 5 instructions, and the actual *contents* of the `millis()` function is only 6 instructions, I think the `millis()` function should really be `inline` by default, but the arduino codebase is rather poorly optimized.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Here is the full disassemby for anyone interested:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    sketch_feb13a.cpp.elf:     file format elf32-avr&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Disassembly of section .text:&#xD;&#xA;    &#xD;&#xA;    00000000 &lt;__vectors&gt;:&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    unsigned long micros() {&#xD;&#xA;       0:	0c 94 34 00 	jmp	0x68	; 0x68 &lt;__ctors_end&gt;&#xD;&#xA;       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      40:	0c 94 5f 00 	jmp	0xbe	; 0xbe &lt;__vector_16&gt;&#xD;&#xA;      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;    &#xD;&#xA;    00000068 &lt;__ctors_end&gt;:&#xD;&#xA;      68:	11 24       	eor	r1, r1&#xD;&#xA;      6a:	1f be       	out	0x3f, r1	; 63&#xD;&#xA;      6c:	cf ef       	ldi	r28, 0xFF	; 255&#xD;&#xA;      6e:	d8 e0       	ldi	r29, 0x08	; 8&#xD;&#xA;      70:	de bf       	out	0x3e, r29	; 62&#xD;&#xA;      72:	cd bf       	out	0x3d, r28	; 61&#xD;&#xA;    &#xD;&#xA;    00000074 &lt;__do_copy_data&gt;:&#xD;&#xA;      74:	11 e0       	ldi	r17, 0x01	; 1&#xD;&#xA;      76:	a0 e0       	ldi	r26, 0x00	; 0&#xD;&#xA;      78:	b1 e0       	ldi	r27, 0x01	; 1&#xD;&#xA;      7a:	e2 e0       	ldi	r30, 0x02	; 2&#xD;&#xA;      7c:	f2 e0       	ldi	r31, 0x02	; 2&#xD;&#xA;      7e:	02 c0       	rjmp	.+4      	; 0x84 &lt;.do_copy_data_start&gt;&#xD;&#xA;    &#xD;&#xA;    00000080 &lt;.do_copy_data_loop&gt;:&#xD;&#xA;      80:	05 90       	lpm	r0, Z+&#xD;&#xA;      82:	0d 92       	st	X+, r0&#xD;&#xA;    &#xD;&#xA;    00000084 &lt;.do_copy_data_start&gt;:&#xD;&#xA;      84:	a0 30       	cpi	r26, 0x00	; 0&#xD;&#xA;      86:	b1 07       	cpc	r27, r17&#xD;&#xA;      88:	d9 f7       	brne	.-10     	; 0x80 &lt;.do_copy_data_loop&gt;&#xD;&#xA;    &#xD;&#xA;    0000008a &lt;__do_clear_bss&gt;:&#xD;&#xA;      8a:	11 e0       	ldi	r17, 0x01	; 1&#xD;&#xA;      8c:	a0 e0       	ldi	r26, 0x00	; 0&#xD;&#xA;      8e:	b1 e0       	ldi	r27, 0x01	; 1&#xD;&#xA;      90:	01 c0       	rjmp	.+2      	; 0x94 &lt;.do_clear_bss_start&gt;&#xD;&#xA;    &#xD;&#xA;    00000092 &lt;.do_clear_bss_loop&gt;:&#xD;&#xA;      92:	1d 92       	st	X+, r1&#xD;&#xA;    &#xD;&#xA;    00000094 &lt;.do_clear_bss_start&gt;:&#xD;&#xA;      94:	ad 30       	cpi	r26, 0x0D	; 13&#xD;&#xA;      96:	b1 07       	cpc	r27, r17&#xD;&#xA;      98:	e1 f7       	brne	.-8      	; 0x92 &lt;.do_clear_bss_loop&gt;&#xD;&#xA;      9a:	0e 94 f0 00 	call	0x1e0	; 0x1e0 &lt;main&gt;&#xD;&#xA;      9e:	0c 94 ff 00 	jmp	0x1fe	; 0x1fe &lt;_exit&gt;&#xD;&#xA;    &#xD;&#xA;    000000a2 &lt;__bad_interrupt&gt;:&#xD;&#xA;      a2:	0c 94 00 00 	jmp	0	; 0x0 &lt;__vectors&gt;&#xD;&#xA;    &#xD;&#xA;    000000a6 &lt;setup&gt;:&#xD;&#xA;      a6:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    000000a8 &lt;loop&gt;:&#xD;&#xA;      a8:	0e 94 a7 00 	call	0x14e	; 0x14e &lt;millis&gt;&#xD;&#xA;      ac:	60 93 00 01 	sts	0x0100, r22&#xD;&#xA;      b0:	70 93 01 01 	sts	0x0101, r23&#xD;&#xA;      b4:	80 93 02 01 	sts	0x0102, r24&#xD;&#xA;      b8:	90 93 03 01 	sts	0x0103, r25&#xD;&#xA;      bc:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    000000be &lt;__vector_16&gt;:&#xD;&#xA;    #if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)&#xD;&#xA;    ISR(TIM0_OVF_vect)&#xD;&#xA;    #else&#xD;&#xA;    ISR(TIMER0_OVF_vect)&#xD;&#xA;    #endif&#xD;&#xA;    {&#xD;&#xA;      be:	1f 92       	push	r1&#xD;&#xA;      c0:	0f 92       	push	r0&#xD;&#xA;      c2:	0f b6       	in	r0, 0x3f	; 63&#xD;&#xA;      c4:	0f 92       	push	r0&#xD;&#xA;      c6:	11 24       	eor	r1, r1&#xD;&#xA;      c8:	2f 93       	push	r18&#xD;&#xA;      ca:	3f 93       	push	r19&#xD;&#xA;      cc:	8f 93       	push	r24&#xD;&#xA;      ce:	9f 93       	push	r25&#xD;&#xA;      d0:	af 93       	push	r26&#xD;&#xA;      d2:	bf 93       	push	r27&#xD;&#xA;    	// copy these to local variables so they can be stored in registers&#xD;&#xA;    	// (volatile variables must be read from memory on every access)&#xD;&#xA;    	unsigned long m = timer0_millis;&#xD;&#xA;      d4:	80 91 08 01 	lds	r24, 0x0108&#xD;&#xA;      d8:	90 91 09 01 	lds	r25, 0x0109&#xD;&#xA;      dc:	a0 91 0a 01 	lds	r26, 0x010A&#xD;&#xA;      e0:	b0 91 0b 01 	lds	r27, 0x010B&#xD;&#xA;    	unsigned char f = timer0_fract;&#xD;&#xA;      e4:	30 91 0c 01 	lds	r19, 0x010C&#xD;&#xA;    &#xD;&#xA;    	m += MILLIS_INC;&#xD;&#xA;      e8:	01 96       	adiw	r24, 0x01	; 1&#xD;&#xA;      ea:	a1 1d       	adc	r26, r1&#xD;&#xA;      ec:	b1 1d       	adc	r27, r1&#xD;&#xA;    	f += FRACT_INC;&#xD;&#xA;      ee:	23 2f       	mov	r18, r19&#xD;&#xA;      f0:	2d 5f       	subi	r18, 0xFD	; 253&#xD;&#xA;    	if (f &gt;= FRACT_MAX) {&#xD;&#xA;      f2:	2d 37       	cpi	r18, 0x7D	; 125&#xD;&#xA;      f4:	20 f0       	brcs	.+8      	; 0xfe &lt;__vector_16+0x40&gt;&#xD;&#xA;    		f -= FRACT_MAX;&#xD;&#xA;      f6:	2d 57       	subi	r18, 0x7D	; 125&#xD;&#xA;    		m += 1;&#xD;&#xA;      f8:	01 96       	adiw	r24, 0x01	; 1&#xD;&#xA;      fa:	a1 1d       	adc	r26, r1&#xD;&#xA;      fc:	b1 1d       	adc	r27, r1&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	timer0_fract = f;&#xD;&#xA;      fe:	20 93 0c 01 	sts	0x010C, r18&#xD;&#xA;    	timer0_millis = m;&#xD;&#xA;     102:	80 93 08 01 	sts	0x0108, r24&#xD;&#xA;     106:	90 93 09 01 	sts	0x0109, r25&#xD;&#xA;     10a:	a0 93 0a 01 	sts	0x010A, r26&#xD;&#xA;     10e:	b0 93 0b 01 	sts	0x010B, r27&#xD;&#xA;    	timer0_overflow_count++;&#xD;&#xA;     112:	80 91 04 01 	lds	r24, 0x0104&#xD;&#xA;     116:	90 91 05 01 	lds	r25, 0x0105&#xD;&#xA;     11a:	a0 91 06 01 	lds	r26, 0x0106&#xD;&#xA;     11e:	b0 91 07 01 	lds	r27, 0x0107&#xD;&#xA;     122:	01 96       	adiw	r24, 0x01	; 1&#xD;&#xA;     124:	a1 1d       	adc	r26, r1&#xD;&#xA;     126:	b1 1d       	adc	r27, r1&#xD;&#xA;     128:	80 93 04 01 	sts	0x0104, r24&#xD;&#xA;     12c:	90 93 05 01 	sts	0x0105, r25&#xD;&#xA;     130:	a0 93 06 01 	sts	0x0106, r26&#xD;&#xA;     134:	b0 93 07 01 	sts	0x0107, r27&#xD;&#xA;    }&#xD;&#xA;     138:	bf 91       	pop	r27&#xD;&#xA;     13a:	af 91       	pop	r26&#xD;&#xA;     13c:	9f 91       	pop	r25&#xD;&#xA;     13e:	8f 91       	pop	r24&#xD;&#xA;     140:	3f 91       	pop	r19&#xD;&#xA;     142:	2f 91       	pop	r18&#xD;&#xA;     144:	0f 90       	pop	r0&#xD;&#xA;     146:	0f be       	out	0x3f, r0	; 63&#xD;&#xA;     148:	0f 90       	pop	r0&#xD;&#xA;     14a:	1f 90       	pop	r1&#xD;&#xA;     14c:	18 95       	reti&#xD;&#xA;    &#xD;&#xA;    0000014e &lt;millis&gt;:&#xD;&#xA;    &#xD;&#xA;    unsigned long millis()&#xD;&#xA;    {&#xD;&#xA;    	unsigned long m;&#xD;&#xA;    	uint8_t oldSREG = SREG;&#xD;&#xA;     14e:	8f b7       	in	r24, 0x3f	; 63&#xD;&#xA;    &#xD;&#xA;    	// disable interrupts while we read timer0_millis or we might get an&#xD;&#xA;    	// inconsistent value (e.g. in the middle of a write to timer0_millis)&#xD;&#xA;    	cli();&#xD;&#xA;     150:	f8 94       	cli&#xD;&#xA;    	m = timer0_millis;&#xD;&#xA;     152:	20 91 08 01 	lds	r18, 0x0108&#xD;&#xA;     156:	30 91 09 01 	lds	r19, 0x0109&#xD;&#xA;     15a:	40 91 0a 01 	lds	r20, 0x010A&#xD;&#xA;     15e:	50 91 0b 01 	lds	r21, 0x010B&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;     162:	8f bf       	out	0x3f, r24	; 63&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;     164:	b9 01       	movw	r22, r18&#xD;&#xA;     166:	ca 01       	movw	r24, r20&#xD;&#xA;     168:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    0000016a &lt;init&gt;:&#xD;&#xA;    &#xD;&#xA;    void init()&#xD;&#xA;    {&#xD;&#xA;    	// this needs to be called before setup() or some functions won't&#xD;&#xA;    	// work there&#xD;&#xA;    	sei();&#xD;&#xA;     16a:	78 94       	sei&#xD;&#xA;    	&#xD;&#xA;    	// on the ATmega168, timer 0 is also used for fast hardware pwm&#xD;&#xA;    	// (using phase-correct PWM would mean that timer 0 overflowed half as often&#xD;&#xA;    	// resulting in different millis() behavior on the ATmega8 and ATmega168)&#xD;&#xA;    #if defined(TCCR0A) &amp;&amp; defined(WGM01)&#xD;&#xA;    	sbi(TCCR0A, WGM01);&#xD;&#xA;     16c:	84 b5       	in	r24, 0x24	; 36&#xD;&#xA;     16e:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     170:	84 bd       	out	0x24, r24	; 36&#xD;&#xA;    	sbi(TCCR0A, WGM00);&#xD;&#xA;     172:	84 b5       	in	r24, 0x24	; 36&#xD;&#xA;     174:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     176:	84 bd       	out	0x24, r24	; 36&#xD;&#xA;    	// this combination is for the standard atmega8&#xD;&#xA;    	sbi(TCCR0, CS01);&#xD;&#xA;    	sbi(TCCR0, CS00);&#xD;&#xA;    #elif defined(TCCR0B) &amp;&amp; defined(CS01) &amp;&amp; defined(CS00)&#xD;&#xA;    	// this combination is for the standard 168/328/1280/2560&#xD;&#xA;    	sbi(TCCR0B, CS01);&#xD;&#xA;     178:	85 b5       	in	r24, 0x25	; 37&#xD;&#xA;     17a:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     17c:	85 bd       	out	0x25, r24	; 37&#xD;&#xA;    	sbi(TCCR0B, CS00);&#xD;&#xA;     17e:	85 b5       	in	r24, 0x25	; 37&#xD;&#xA;     180:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     182:	85 bd       	out	0x25, r24	; 37&#xD;&#xA;    &#xD;&#xA;    	// enable timer 0 overflow interrupt&#xD;&#xA;    #if defined(TIMSK) &amp;&amp; defined(TOIE0)&#xD;&#xA;    	sbi(TIMSK, TOIE0);&#xD;&#xA;    #elif defined(TIMSK0) &amp;&amp; defined(TOIE0)&#xD;&#xA;    	sbi(TIMSK0, TOIE0);&#xD;&#xA;     184:	ee e6       	ldi	r30, 0x6E	; 110&#xD;&#xA;     186:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     188:	80 81       	ld	r24, Z&#xD;&#xA;     18a:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     18c:	80 83       	st	Z, r24&#xD;&#xA;    	// this is better for motors as it ensures an even waveform&#xD;&#xA;    	// note, however, that fast pwm mode can achieve a frequency of up&#xD;&#xA;    	// 8 MHz (with a 16 MHz clock) at 50% duty cycle&#xD;&#xA;    &#xD;&#xA;    #if defined(TCCR1B) &amp;&amp; defined(CS11) &amp;&amp; defined(CS10)&#xD;&#xA;    	TCCR1B = 0;&#xD;&#xA;     18e:	e1 e8       	ldi	r30, 0x81	; 129&#xD;&#xA;     190:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     192:	10 82       	st	Z, r1&#xD;&#xA;    &#xD;&#xA;    	// set timer 1 prescale factor to 64&#xD;&#xA;    	sbi(TCCR1B, CS11);&#xD;&#xA;     194:	80 81       	ld	r24, Z&#xD;&#xA;     196:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     198:	80 83       	st	Z, r24&#xD;&#xA;    #if F_CPU &gt;= 8000000L&#xD;&#xA;    	sbi(TCCR1B, CS10);&#xD;&#xA;     19a:	80 81       	ld	r24, Z&#xD;&#xA;     19c:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     19e:	80 83       	st	Z, r24&#xD;&#xA;    	sbi(TCCR1, CS10);&#xD;&#xA;    #endif&#xD;&#xA;    #endif&#xD;&#xA;    	// put timer 1 in 8-bit phase correct pwm mode&#xD;&#xA;    #if defined(TCCR1A) &amp;&amp; defined(WGM10)&#xD;&#xA;    	sbi(TCCR1A, WGM10);&#xD;&#xA;     1a0:	e0 e8       	ldi	r30, 0x80	; 128&#xD;&#xA;     1a2:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1a4:	80 81       	ld	r24, Z&#xD;&#xA;     1a6:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     1a8:	80 83       	st	Z, r24&#xD;&#xA;    &#xD;&#xA;    	// set timer 2 prescale factor to 64&#xD;&#xA;    #if defined(TCCR2) &amp;&amp; defined(CS22)&#xD;&#xA;    	sbi(TCCR2, CS22);&#xD;&#xA;    #elif defined(TCCR2B) &amp;&amp; defined(CS22)&#xD;&#xA;    	sbi(TCCR2B, CS22);&#xD;&#xA;     1aa:	e1 eb       	ldi	r30, 0xB1	; 177&#xD;&#xA;     1ac:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1ae:	80 81       	ld	r24, Z&#xD;&#xA;     1b0:	84 60       	ori	r24, 0x04	; 4&#xD;&#xA;     1b2:	80 83       	st	Z, r24&#xD;&#xA;    &#xD;&#xA;    	// configure timer 2 for phase correct pwm (8-bit)&#xD;&#xA;    #if defined(TCCR2) &amp;&amp; defined(WGM20)&#xD;&#xA;    	sbi(TCCR2, WGM20);&#xD;&#xA;    #elif defined(TCCR2A) &amp;&amp; defined(WGM20)&#xD;&#xA;    	sbi(TCCR2A, WGM20);&#xD;&#xA;     1b4:	e0 eb       	ldi	r30, 0xB0	; 176&#xD;&#xA;     1b6:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1b8:	80 81       	ld	r24, Z&#xD;&#xA;     1ba:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     1bc:	80 83       	st	Z, r24&#xD;&#xA;    #if defined(ADCSRA)&#xD;&#xA;    	// set a2d prescale factor to 128&#xD;&#xA;    	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.&#xD;&#xA;    	// XXX: this will not work properly for other clock speeds, and&#xD;&#xA;    	// this code should use F_CPU to determine the prescale factor.&#xD;&#xA;    	sbi(ADCSRA, ADPS2);&#xD;&#xA;     1be:	ea e7       	ldi	r30, 0x7A	; 122&#xD;&#xA;     1c0:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1c2:	80 81       	ld	r24, Z&#xD;&#xA;     1c4:	84 60       	ori	r24, 0x04	; 4&#xD;&#xA;     1c6:	80 83       	st	Z, r24&#xD;&#xA;    	sbi(ADCSRA, ADPS1);&#xD;&#xA;     1c8:	80 81       	ld	r24, Z&#xD;&#xA;     1ca:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     1cc:	80 83       	st	Z, r24&#xD;&#xA;    	sbi(ADCSRA, ADPS0);&#xD;&#xA;     1ce:	80 81       	ld	r24, Z&#xD;&#xA;     1d0:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     1d2:	80 83       	st	Z, r24&#xD;&#xA;    &#xD;&#xA;    	// enable a2d conversions&#xD;&#xA;    	sbi(ADCSRA, ADEN);&#xD;&#xA;     1d4:	80 81       	ld	r24, Z&#xD;&#xA;     1d6:	80 68       	ori	r24, 0x80	; 128&#xD;&#xA;     1d8:	80 83       	st	Z, r24&#xD;&#xA;    	// here so they can be used as normal digital i/o; they will be&#xD;&#xA;    	// reconnected in Serial.begin()&#xD;&#xA;    #if defined(UCSRB)&#xD;&#xA;    	UCSRB = 0;&#xD;&#xA;    #elif defined(UCSR0B)&#xD;&#xA;    	UCSR0B = 0;&#xD;&#xA;     1da:	10 92 c1 00 	sts	0x00C1, r1&#xD;&#xA;    #endif&#xD;&#xA;    }&#xD;&#xA;     1de:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    000001e0 &lt;main&gt;:&#xD;&#xA;    #include &lt;Arduino.h&gt;&#xD;&#xA;    &#xD;&#xA;    int main(void)&#xD;&#xA;     1e0:	cf 93       	push	r28&#xD;&#xA;     1e2:	df 93       	push	r29&#xD;&#xA;    {&#xD;&#xA;    	init();&#xD;&#xA;     1e4:	0e 94 b5 00 	call	0x16a	; 0x16a &lt;init&gt;&#xD;&#xA;    &#xD;&#xA;    #if defined(USBCON)&#xD;&#xA;    	USBDevice.attach();&#xD;&#xA;    #endif&#xD;&#xA;    	&#xD;&#xA;    	setup();&#xD;&#xA;     1e8:	0e 94 53 00 	call	0xa6	; 0xa6 &lt;setup&gt;&#xD;&#xA;        &#xD;&#xA;    	for (;;) {&#xD;&#xA;    		loop();&#xD;&#xA;    		if (serialEventRun) serialEventRun();&#xD;&#xA;     1ec:	c0 e0       	ldi	r28, 0x00	; 0&#xD;&#xA;     1ee:	d0 e0       	ldi	r29, 0x00	; 0&#xD;&#xA;    #endif&#xD;&#xA;    	&#xD;&#xA;    	setup();&#xD;&#xA;        &#xD;&#xA;    	for (;;) {&#xD;&#xA;    		loop();&#xD;&#xA;     1f0:	0e 94 54 00 	call	0xa8	; 0xa8 &lt;loop&gt;&#xD;&#xA;    		if (serialEventRun) serialEventRun();&#xD;&#xA;     1f4:	20 97       	sbiw	r28, 0x00	; 0&#xD;&#xA;     1f6:	e1 f3       	breq	.-8      	; 0x1f0 &lt;main+0x10&gt;&#xD;&#xA;     1f8:	0e 94 00 00 	call	0	; 0x0 &lt;__vectors&gt;&#xD;&#xA;     1fc:	f9 cf       	rjmp	.-14     	; 0x1f0 &lt;main+0x10&gt;&#xD;&#xA;    &#xD;&#xA;    000001fe &lt;_exit&gt;:&#xD;&#xA;     1fe:	f8 94       	cli&#xD;&#xA;    &#xD;&#xA;    00000200 &lt;__stop_program&gt;:&#xD;&#xA;     200:	ff cf       	rjmp	.-2      	; 0x200 &lt;__stop_program&gt;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/images/doc0856.pdf%E2%80%8E&#xD;&#xA;" />
  <row Id="369" PostHistoryTypeId="2" PostId="163" RevisionGUID="f94852f7-ca19-4be2-a140-518083e999a3" CreationDate="2014-02-13T12:43:07.087" UserId="86" Text="I'm kind of confused by your question. You ask where you want to put once-per-startup setup functions, and then discuss the setup function. *That's what the setup function is for.*&#xD;&#xA;&#xD;&#xA;As such, one-time setup functionality goes in the setup function.&#xD;&#xA;&#xD;&#xA;FWIW, if you look in the file that *calls* the `setup` and `loop` functions:  &#xD;&#xA;&#xD;&#xA;    #include &lt;Arduino.h&gt;&#xD;&#xA;    &#xD;&#xA;    int main(void)&#xD;&#xA;    {&#xD;&#xA;    	init();&#xD;&#xA;    &#xD;&#xA;    #if defined(USBCON)&#xD;&#xA;    	USBDevice.attach();&#xD;&#xA;    #endif&#xD;&#xA;    	&#xD;&#xA;    	setup();&#xD;&#xA;    	for (;;) {&#xD;&#xA;    		loop();&#xD;&#xA;    		if (serialEventRun) serialEventRun();&#xD;&#xA;    	}&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;For all intents and purposes, the two options are completely identical. Either way, you get a empty busy-wait loop. Frankly, I'd expect the two different options to probably emit the same machine code anyways, so the whole thing is a non-issue." />
  <row Id="370" PostHistoryTypeId="5" PostId="163" RevisionGUID="8d76dad7-b5f5-4df0-8e7f-f6e88cde8214" CreationDate="2014-02-13T12:48:32.503" UserId="86" Comment="added 310 characters in body" Text="I'm kind of confused by your question. You ask where you want to put once-per-startup setup functions, and then discuss the setup function. *That's what the setup function is for.*&#xD;&#xA;&#xD;&#xA;As such, one-time setup functionality goes in the setup function.&#xD;&#xA;&#xD;&#xA;FWIW, if you look in the file that *calls* the `setup` and `loop` functions:  &#xD;&#xA;&#xD;&#xA;    #include &lt;Arduino.h&gt;&#xD;&#xA;    &#xD;&#xA;    int main(void)&#xD;&#xA;    {&#xD;&#xA;    	init();&#xD;&#xA;    &#xD;&#xA;    #if defined(USBCON)&#xD;&#xA;    	USBDevice.attach();&#xD;&#xA;    #endif&#xD;&#xA;    	&#xD;&#xA;    	setup();&#xD;&#xA;    	for (;;) {&#xD;&#xA;    		loop();&#xD;&#xA;    		if (serialEventRun) serialEventRun();&#xD;&#xA;    	}&#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;For all intents and purposes, the two options are completely identical. Either way, you get a empty busy-wait loop. Frankly, I'd expect the two different options to probably emit the same machine code anyways, so the whole thing is a non-issue.&#xD;&#xA;&#xD;&#xA;Note:  &#xD;&#xA;`if (serialEventRun) serialEventRun();` appears to be a facility to allow you to attach a function that is called upon reception of serial data, but if you do not define a function `void serialEvent(){}` in your code, it will compile out completely and not be present in the produced machine code." />
  <row Id="372" PostHistoryTypeId="5" PostId="160" RevisionGUID="0b31fb1d-3c20-4fdb-a86f-a7e238f1c540" CreationDate="2014-02-13T13:52:13.877" UserId="3" Comment="added comment to answer" Text="Arduino have the [Wire Library][1] that communicate with I2C.&#xD;&#xA;&#xD;&#xA;&gt; This library allows you to communicate with I2C / TWI devices. On the&#xD;&#xA;&gt; Arduino boards with the R3 layout (1.0 pinout), the SDA (data line)&#xD;&#xA;&gt; and SCL (clock line) are on the pin headers close to the AREF pin. The&#xD;&#xA;&gt; Arduino Due has two I2C / TWI interfaces SDA1 and SCL1 are near to the&#xD;&#xA;&gt; AREF pin and the additional one is on pins 20 and 21. As a reference&#xD;&#xA;&gt; the table below shows where TWI pins are located on various Arduino&#xD;&#xA;&gt; boards.&#xD;&#xA;&#xD;&#xA;Board	I2C / TWI pins&#xD;&#xA;&#xD;&#xA; - Uno, Ethernet	A4 (SDA), A5 (SCL)&#xD;&#xA; - Mega2560	20 (SDA), 21 (SCL)&#xD;&#xA; - Leonardo	2 (SDA), 3 (SCL)&#xD;&#xA; - Due	20 (SDA), 21 (SCL), SDA1, SCL1&#xD;&#xA;&#xD;&#xA;You can take a look at [this][2], [this][3] examples.&#xD;&#xA;&#xD;&#xA;Like @TheDoctor said:&#xD;&#xA;&gt; The I2C data lines both need resistors to 5V. This keeps them from&#xD;&#xA;&gt; drifting if they are disabled. Andy resistor value should work, but it&#xD;&#xA;&gt; is recommended to use one between 10k ohm and 47k ohm.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.arduino.cc/en/Reference/Wire&#xD;&#xA;  [2]: http://blog.digtro.com/arduino-uno-tea5767-fm-receiver-i2c/&#xD;&#xA;  [3]: http://www.instructables.com/id/I2C-between-Arduinos/" />
  <row Id="373" PostHistoryTypeId="2" PostId="164" RevisionGUID="d5dd107b-59b3-4d2f-986f-9bec1e9cf0ab" CreationDate="2014-02-13T14:01:38.190" UserId="46" Text="I strongly suggest that you get a DMM and measure the current drawn by the board when powering the led strip. Google for ways to measure current with a DMM, as it can be tricky if you never done it before. Then, compare the value to those specified by the voltage regulator datasheet. The current should be within those values shown in the &quot;Electrical Characteristics&quot;, and well below those from &quot;Absolute Maximum Ratings&quot;. " />
  <row Id="374" PostHistoryTypeId="2" PostId="165" RevisionGUID="d0104d3b-6ff0-4e0d-8efa-94a9f47f701c" CreationDate="2014-02-13T14:02:25.557" UserId="8" Text="I don't know a whole lot about MatLab, but I found some tutorials about reading and writing from the serial port&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    s = serial('COM1');&#xD;&#xA;    fopen(s)&#xD;&#xA;    fprintf(s,'*IDN?')&#xD;&#xA;    out = fscanf(s)&#xD;&#xA;&#xD;&#xA;out is now your received data&#xD;&#xA;&#xD;&#xA;    fclose(s)&#xD;&#xA;    delete(s)&#xD;&#xA;    clear s&#xD;&#xA;&#xD;&#xA;From http://www.mathworks.com/help/matlab/matlab_external/writing-and-reading-data.html" />
  <row Id="375" PostHistoryTypeId="5" PostId="164" RevisionGUID="acd3867c-8c22-4cef-87c4-3e36f416c813" CreationDate="2014-02-13T14:06:47.320" UserId="46" Comment="added 218 characters in body" Text="When a circuit is hot, it's very likely that it is drawing too much current. It may be a component that's getting more current than it's designed for, or a PCB track, or a wire.&#xD;&#xA;&#xD;&#xA;So, before you do anything else, I strongly suggest that you get a DMM and measure the current drawn by the board when powering the led strip. Google for ways to measure current with a DMM, as it can be tricky if you never done it before. &#xD;&#xA;&#xD;&#xA;Then, compare the value to those specified by the voltage regulator datasheet. The current should be within those values shown in the &quot;Electrical Characteristics&quot;, and well below those from &quot;Absolute Maximum Ratings&quot;. " />
  <row Id="376" PostHistoryTypeId="2" PostId="166" RevisionGUID="b2dcb322-557f-4af2-8f50-c71d6d823e47" CreationDate="2014-02-13T14:13:04.587" UserId="27" Text="Since your question is only about uploading, this will work with a Yun&#xD;&#xA;&#xD;&#xA;- compile your sketches with the IDE on your pc&#xD;&#xA;- for each hex file, copy it to the yun and run `merge-sketch-with-bootloader.lua PATH_TO_HEX_FILE`&#xD;&#xA;- manage to connect to the Yun from your tablet via SSH&#xD;&#xA;- once logged in, run `run-avrdude PATH_TO_HEX_FILE`&#xD;&#xA;" />
  <row Id="377" PostHistoryTypeId="5" PostId="98" RevisionGUID="a0f59731-255b-440e-87fd-16ee5d7dcf3a" CreationDate="2014-02-13T14:31:27.243" UserId="65" Comment="minor correction" Text="One of the sections of the Arduino that is likely to become unreliable over time is its memory. There are [three pools of memory][1] in the microcontroller used on avr-based Arduino boards:&#xD;&#xA;&#xD;&#xA;- Flash memory (program space), is where the Arduino sketch is stored.&#xD;&#xA;- SRAM (static random access memory) is where the sketch creates and manipulates variables when it runs.&#xD;&#xA;- EEPROM is memory space that programmers can use to store long-term information.&#xD;&#xA;&#xD;&#xA;The memory is one part of the board that can be checked and verified, and thus evaluated for reliability/health. A very basic way to check memory would be to write a certain 8-bit pattern (byte character) over every address in the memory and then read the value present from every address. If the value that was written matches the value that is read, then that specific 8 bit block in memory is functioning correctly at the present moment. &#xD;&#xA;&#xD;&#xA;Wear in ROM memory usually occurs in a blockwise pattern i.e. n*8-bit blocks become degraded over time. So, for a 2K byte ROM chip, the health of the chip can be estimated by writing and reading from every byte on the chip, and calculating the percentage of correctly functioning blocks. If the percentage of failed blocks is significant (15%-20%), that means that the memory is likely to fail soon.&#xD;&#xA;&#xD;&#xA;The test code can be written using separate methods for each of the memory sections.&#xD;&#xA;&#xD;&#xA;###SRAM&#xD;&#xA;Any variables declared statically or dynamically are allocated on the SRAM. So, we could declare a large character array (~2000) and fill every element with 255 (all bits 1). Then, we could attempt to read each of those elements and see if the value being read is indeed 255. &#xD;&#xA;&#xD;&#xA;###EEPROM&#xD;&#xA;The EEPROM can be manipulated using the [EEPROM library][2]. The library provides functions to read and write from specific locations in the EEPROM. So, all memory addresses can be tested by simply looping over the entire memory &#xD;&#xA;space. *This operation will require 500 writes and reads.*&#xD;&#xA;&#xD;&#xA;Depending on the board usage, EEPROM is most likely to fail first but is not critical to board operation. &#xD;&#xA;&#xD;&#xA;###Flash&#xD;&#xA;Data can be stored on the flash memory using the [`PROGMEM`][3] directive. Similar to SRAM, a large array can be declared and initialized here. Then, values can be read and checked.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Tutorial/Memory&#xD;&#xA;  [2]: http://www.arduino.cc/en/Reference/EEPROM&#xD;&#xA;  [3]: http://www.arduino.cc/en/Reference/PROGMEM" />
  <row Id="378" PostHistoryTypeId="2" PostId="167" RevisionGUID="ae53ffaa-6db7-4875-b348-439511113bb3" CreationDate="2014-02-13T14:48:24.573" UserId="13" Text="There is a project which brings a [Python virtual machine](https://code.google.com/p/python-on-a-chip/) to micro-controllers, including the [Arduino Mega](https://code.google.com/p/python-on-a-chip/source/browse/#hg%2Fsrc%2Fplatform%2Farduino_mega).&#xD;&#xA;&#xD;&#xA;Here's a quote from the Ardunio Mega [README](https://code.google.com/p/python-on-a-chip/source/browse/src/platform/arduino_mega/README), which gives a feel for what this could be like (though, I've not tested this!): &#xD;&#xA;&#xD;&#xA;&gt; The following is an example session using ipm::&#xD;&#xA;&gt; &#xD;&#xA;&gt;     ipm&gt; import avr, sys&#xD;&#xA;&gt;     ipm&gt; avr.ddrA(0xff)&#xD;&#xA;&gt;     ipm&gt; avr.portA(0)       # Pins 22-29 all at 0 V&#xD;&#xA;&gt;     ipm&gt; avr.portA(0xa5)&#xD;&#xA;&gt;     ipm&gt; sys.heap()&#xD;&#xA;&gt;     (2622, 7424)&#xD;&#xA;&gt; &#xD;&#xA;" />
  <row Id="379" PostHistoryTypeId="2" PostId="168" RevisionGUID="5c6d6d18-a5a5-46ce-966f-6463c93bb084" CreationDate="2014-02-13T15:03:20.657" UserId="42" Text="I wanted to move some of my code out into a second tab in the Arduino IDE, to keep things better organised. At first, I only tried moving a function, and it seemed to work fine. I could call the function from the `setup()` function in my main tab, and there were no problems compiling or uploading.&#xD;&#xA;&#xD;&#xA;However, I tried putting a whole class into the second tab, and suddenly it didn't work any more. For example:&#xD;&#xA;&#xD;&#xA;**Tab 1:**&#xD;&#xA;&lt;!-- language: cpp --&gt;&#xD;&#xA;&#xD;&#xA;    TestClass obj;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        obj.init();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        //...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Tab 2:**&#xD;&#xA;    &#xD;&#xA;    class TestClass&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        void init()&#xD;&#xA;        {&#xD;&#xA;            //...&#xD;&#xA;        }&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;When I tried to compile this, it gave me the following errors:&#xD;&#xA;&#xD;&#xA;    tab1:1: error: 'TestClass' does not name a type&#xD;&#xA;    tab1.ino: In function 'void setup()':&#xD;&#xA;    tab1:5: error: 'obj' was not declared in this scope&#xD;&#xA;&#xD;&#xA;Why does it recognise a function in another tab, but not a class? Is there a way to make it work in the Arduino IDE, or do I need to use an alternative like Eclipse?" />
  <row Id="380" PostHistoryTypeId="1" PostId="168" RevisionGUID="5c6d6d18-a5a5-46ce-966f-6463c93bb084" CreationDate="2014-02-13T15:03:20.657" UserId="42" Text="Why can't I declare a class in another tab in Arduino IDE?" />
  <row Id="381" PostHistoryTypeId="3" PostId="168" RevisionGUID="5c6d6d18-a5a5-46ce-966f-6463c93bb084" CreationDate="2014-02-13T15:03:20.657" UserId="42" Text="&lt;programming&gt;&lt;compile&gt;&lt;arduino-ide&gt;&lt;tabs&gt;" />
  <row Id="382" PostHistoryTypeId="2" PostId="169" RevisionGUID="81a994fe-ebf5-4a99-922f-506cf847c70f" CreationDate="2014-02-13T15:25:07.000" UserId="118" Text="At least for prototyping, is there a semi-permanent way to attach wires to the Nano posts?&#xD;&#xA;&#xD;&#xA;http://arduino.cc/en/uploads/Main/ArduinoNanoBack_3_lg.jpg&#xD;&#xA;&#xD;&#xA;And yes, usually the Nano is hanging in free space by its wires (yes I know, quick and dirty, should be using something cleaner, even for prototypes).  So I'm hoping for the best of both worlds, sturdy &quot;enough&quot; to stay attached, yet possible to remove and switch around.  Having no luck finding such advice on the internet, perhaps searching for the wrong terms." />
  <row Id="383" PostHistoryTypeId="1" PostId="169" RevisionGUID="81a994fe-ebf5-4a99-922f-506cf847c70f" CreationDate="2014-02-13T15:25:07.000" UserId="118" Text="Is there a semi-permanent way to attach wires to the Nano?" />
  <row Id="384" PostHistoryTypeId="3" PostId="169" RevisionGUID="81a994fe-ebf5-4a99-922f-506cf847c70f" CreationDate="2014-02-13T15:25:07.000" UserId="118" Text="&lt;prototype&gt;&lt;wires&gt;&lt;arduino-nano&gt;" />
  <row Id="385" PostHistoryTypeId="2" PostId="170" RevisionGUID="473abb4b-3c5a-4ce3-8618-bd4d1c020a5e" CreationDate="2014-02-13T16:21:09.890" UserId="65" Text="One workaround is to make the second file into a C++ source file (`.cpp`) and then add a `#include &quot;&lt;filename&gt;&quot;` directive in the beginning of the first file.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;This code compiles correctly:&#xD;&#xA;&#xD;&#xA;Tab 1:&#xD;&#xA;&#xD;&#xA;    #include &quot;test.cpp&quot;&#xD;&#xA;    &#xD;&#xA;    TestClass obj;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        obj.init();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        //...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;test.cpp :&#xD;&#xA;&#xD;&#xA;    class TestClass&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        void init()&#xD;&#xA;        {&#xD;&#xA;            //...&#xD;&#xA;        }&#xD;&#xA;    };" />
  <row Id="386" PostHistoryTypeId="2" PostId="171" RevisionGUID="a2380050-7e17-4604-b11e-2f699fa7faa9" CreationDate="2014-02-13T16:21:34.743" UserId="10" Text="The way the Arduino IDE works is that it compiles your code (the code you write in the IDE) as the &quot;main&quot; code. Then it pulls code from all of the libraries you have imported and compiles that along with the main code. To do what you are suggesting would require you to create a library for Arduino.&#xD;&#xA;&#xD;&#xA;###Here is some more information on Arduino libraries:&#xD;&#xA;http://arduino.cc/en/Guide/Libraries&#xD;&#xA;&#xD;&#xA;###And here is some on how to create a library:&#xD;&#xA;http://arduino.cc/en/Hacking/LibraryTutorial //this one is the easiest to understand imo&lt;br /&gt;&#xD;&#xA;http://playground.arduino.cc/Code/Library &lt;br /&gt;&#xD;&#xA;http://www.divilabs.com/2013/03/write-your-own-arduino-library.html# &lt;br /&gt;&#xD;&#xA;" />
  <row Id="387" PostHistoryTypeId="5" PostId="170" RevisionGUID="4db87907-16b4-4407-8e28-b07bda971da7" CreationDate="2014-02-13T16:29:45.463" UserId="65" Comment="added 129 characters in body" Text="It is not possible to declare and use classes declared in one `.pde` file in another `.pde` file from within the Arduino IDE.&#xD;&#xA;&#xD;&#xA;One workaround is to make the second file into a C++ source file (`.cpp`) and then add a `#include &quot;&lt;filename&gt;&quot;` directive in the beginning of the first file.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;This code compiles correctly:&#xD;&#xA;&#xD;&#xA;Tab 1:&#xD;&#xA;&#xD;&#xA;    #include &quot;test.cpp&quot;&#xD;&#xA;    &#xD;&#xA;    TestClass obj;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        obj.init();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        //...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;test.cpp :&#xD;&#xA;&#xD;&#xA;    class TestClass&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        void init()&#xD;&#xA;        {&#xD;&#xA;            //...&#xD;&#xA;        }&#xD;&#xA;    };" />
  <row Id="388" PostHistoryTypeId="5" PostId="171" RevisionGUID="d5068d02-48a3-4659-9945-3920c70da4d9" CreationDate="2014-02-13T16:37:29.477" UserId="10" Comment="added 229 characters in body" Text="The way the Arduino IDE works is that it compiles your code (the code you write in the IDE) as the &quot;main&quot; code. Then it pulls code from all of the libraries you have imported and compiles that along with the main code. To do what you are suggesting would require you to create a library for Arduino.&#xD;&#xA;&#xD;&#xA;###Here is some more information on Arduino libraries:&#xD;&#xA;http://arduino.cc/en/Guide/Libraries&#xD;&#xA;&#xD;&#xA;###And here is some on how to create a library:&#xD;&#xA;http://arduino.cc/en/Hacking/LibraryTutorial //this one is the easiest to understand imo&lt;br /&gt;&#xD;&#xA;http://playground.arduino.cc/Code/Library &lt;br /&gt;&#xD;&#xA;http://www.divilabs.com/2013/03/write-your-own-arduino-library.html# &lt;br /&gt;&#xD;&#xA;&#xD;&#xA;Here is an example library I wrote https://github.com/jamolnng/Arduino/tree/master/libraries/ShiftRegister as you can see there is no problem with calling Arduino functions from the .cpp file (I know, I've tested the library)&#xD;&#xA;" />
  <row Id="389" PostHistoryTypeId="2" PostId="172" RevisionGUID="e95a3012-8585-4fb3-b629-d3227b33d37f" CreationDate="2014-02-13T16:39:08.530" UserId="8" Text="There are jumper wires that have a female header on one end and a male header on the other. Example: https://www.sparkfun.com/products/9140 &#xD;&#xA;&#xD;&#xA;You could also attatch several wired to a strip of breakaway female headers, such as https://www.sparkfun.com/products/115" />
  <row Id="390" PostHistoryTypeId="5" PostId="165" RevisionGUID="b93ba28a-ec41-4af2-b28e-57e93feccfa5" CreationDate="2014-02-13T16:43:36.593" UserId="8" Comment="better example" Text="I don't know a whole lot about MatLab, but I found some tutorials about reading and writing from the serial port&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    s = serial('COM1');&#xD;&#xA;    fopen(s)&#xD;&#xA;    fprintf(s,'your serial data goes here')&#xD;&#xA;    out = fscanf(s)&#xD;&#xA;&#xD;&#xA;out is now your received data, you can do whatever you want with it.&#xD;&#xA;&#xD;&#xA;to close:&#xD;&#xA;&#xD;&#xA;    fclose(s)&#xD;&#xA;    delete(s)&#xD;&#xA;    clear s&#xD;&#xA;&#xD;&#xA;From http://www.mathworks.com/help/matlab/matlab_external/writing-and-reading-data.html&#xD;&#xA;&#xD;&#xA;From your question i assume you know about the arduino side of things (using `Serial`)" />
  <row Id="391" PostHistoryTypeId="10" PostId="87" RevisionGUID="1276d6eb-cbf9-41b4-b038-07bc52c41429" CreationDate="2014-02-13T17:01:02.770" UserId="-1" Comment="101" Text="{&quot;OriginalQuestionIds&quot;:[61],&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;},{&quot;Id&quot;:37,&quot;DisplayName&quot;:&quot;The Guy with The Hat&quot;},{&quot;Id&quot;:3,&quot;DisplayName&quot;:&quot;Butzke&quot;},{&quot;Id&quot;:33,&quot;DisplayName&quot;:&quot;user2202326&quot;},{&quot;Id&quot;:65,&quot;DisplayName&quot;:&quot;AsheeshR&quot;}]}" />
  <row Id="393" PostHistoryTypeId="2" PostId="173" RevisionGUID="1f9f224e-0832-42e3-b238-c264ca9a12d1" CreationDate="2014-02-13T17:05:49.667" UserId="168" Text="One of the most common bad things I have seen is connecting LEDs directly to addition pins without a current limiting resistor.&#xD;&#xA;&#xD;&#xA;Basically, in electronics there are a few main sources of problems. Too much current, too much voltage, overheating, and physical damage.&#xD;&#xA;&#xD;&#xA;Too much current usually comes from shorting things, too much voltage(or reversed polarity) usually comes from not paying attention to what is being connected, overheating comes from too much current or not using a heatsink when you should be.&#xD;&#xA;&#xD;&#xA;Basically, just think before you connect things and you'll be fine. Learn some basic circuit theory if you haven't already, get in the habit of knowing the ratings of the parts you want to use, and double check stuff before turning it on.&#xD;&#xA;&#xD;&#xA;I like this list here of things not to do: http://ruggedcircuits.com/html/ancp01.html" />
  <row Id="394" PostHistoryTypeId="5" PostId="143" RevisionGUID="3b1c577a-711d-4d8c-9025-858c91e27dcf" CreationDate="2014-02-13T17:34:18.977" UserId="87" Comment="Narrowed the question topic." Text="Before you start to mess with a computer there are many recommendation like turn the power off or watch out for statical electricity. What are the things I should be aware when I work with an Arduino board if I don't want to harm neither myself nor the board. The three kind of activity that requires touching the Arduino and what I'm asking about:&#xD;&#xA;&#xD;&#xA;- Setting up wire, component layout or breadboard.&#xD;&#xA;- Debugging a running setup.&#xD;&#xA;- Moving, mounting up the board somewhere." />
  <row Id="395" PostHistoryTypeId="5" PostId="169" RevisionGUID="661e9b7d-ee98-4289-998f-8332faa8671f" CreationDate="2014-02-13T18:07:30.147" UserId="87" Comment="Added picture." Text="At least for prototyping, is there a semi-permanent way to attach wires to the Nano posts?&#xD;&#xA;&#xD;&#xA;![Arduino nano][1]&#xD;&#xA;&#xD;&#xA;And yes, usually the Nano is hanging in free space by its wires (yes I know, quick and dirty, should be using something cleaner, even for prototypes).  So I'm hoping for the best of both worlds, sturdy &quot;enough&quot; to stay attached, yet possible to remove and switch around.  Having no luck finding such advice on the internet, perhaps searching for the wrong terms.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/0n9s9.jpg" />
  <row Id="396" PostHistoryTypeId="24" PostId="169" RevisionGUID="661e9b7d-ee98-4289-998f-8332faa8671f" CreationDate="2014-02-13T18:07:30.147" Comment="Proposed by 87 approved by 118 edit id of 36" />
  <row Id="397" PostHistoryTypeId="5" PostId="169" RevisionGUID="15d1fd1c-702d-4be5-9eb1-88e85ccff074" CreationDate="2014-02-13T18:19:55.183" UserId="118" Comment="Added one more detail about wires." Text="At least for prototyping, is there a semi-permanent way to attach wires to the Nano posts?&#xD;&#xA;&#xD;&#xA;![Arduino nano][1]&#xD;&#xA;&#xD;&#xA;And yes, usually the Nano is hanging in free space by its wires (yes I know, quick and dirty, should be using something cleaner, even for prototypes).  So I'm hoping for the best of both worlds, sturdy &quot;enough&quot; to stay attached, yet possible to remove and switch around.  Having no luck finding such advice on the internet, perhaps searching for the wrong terms.&#xD;&#xA;&#xD;&#xA;**EDIT:**  I neglected one important point, each wire is attached individually just like the SparkFun wires with the female header as mentioned in @TheDoctor's answer below.  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/0n9s9.jpg&#xD;&#xA;&#xD;&#xA;" />
  <row Id="398" PostHistoryTypeId="5" PostId="151" RevisionGUID="0a0e2dd0-5ba7-43b1-922d-c8fe015240f9" CreationDate="2014-02-13T18:29:09.117" UserId="84" Comment="removed incorrect info about delay() and power consumption." Text="As most other answers, I would go for method 2.&#xD;&#xA;&#xD;&#xA;But I would try to avoid the call, by Arduino library, to an an empty `loop()` that makes the Atmel consume &quot;a lot&quot; of current for nothing.&#xD;&#xA;&#xD;&#xA;Edit:&#xD;&#xA;&#xD;&#xA;As some comments pointed out though, using `delay()` in `loop()` will change nothing to power consumption.&#xD;&#xA;&#xD;&#xA;Hence, if you would like to reduce power consumption once your `setup()` has run, you will have to play with Atmel sleep modes.&#xD;&#xA;You can take a look at [this article][1] that shows how to deal with sleep modes from your Arduino sketches; it does more than just putting the Atmel to sleep but it is a good (and simple) read if you want to play with sleep modes.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Learning/arduinoSleepCode" />
  <row Id="400" PostHistoryTypeId="2" PostId="174" RevisionGUID="96189865-e533-4349-b13d-9b13f05b025f" CreationDate="2014-02-13T19:15:23.713" UserId="11" Text="There is the [aJson][1] library that allows you to work with JSON objects in Arduino.&#xD;&#xA;&#xD;&#xA;However, depending on the complexity of your program, I would just do it manually to save memory. You may be able to just copy the functions you want out of the library.&#xD;&#xA;&#xD;&#xA;Then check out the [WebClient][2] library which has an example for making a POST request at the bottom.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/interactive-matter/aJson&#xD;&#xA;  [2]: http://playground.arduino.cc/Code/WebClient" />
  <row Id="401" PostHistoryTypeId="2" PostId="175" RevisionGUID="a4ecb190-b66f-4992-a8e2-b3b1a6ca0778" CreationDate="2014-02-13T19:16:04.687" UserId="103" Text="You can easily simulate your Arduino code using the famous Proteus ISIS.   &#xD;&#xA;You just will have to search for the specific Arduino simulation library for Proteus.&#xD;&#xA;&#xD;&#xA;*Here you a small **tutorial** of how to make this thing done:*  &#xD;&#xA; &#xD;&#xA;**First**, identify the path the Arduino IDE generates the hex file to?   &#xD;&#xA;for example if you are using the official IDE you will find the hex file location in the &quot;arduino IDE path/lib/preferences.txt&quot;  &#xD;&#xA;Or if you are using Arduino ERW which I recommended the most on windows! So you can simply open the output folder by &quot;Sketch &gt; Copy HEX file as path&quot;.   &#xD;&#xA;&#xD;&#xA;**Second**, download the Arduino library from [Here][1]. Then copy `ARDUINO.LIB` and `ARDUINO.IDX` to folder &quot;library&quot; in the install directory Proteus.   &#xD;&#xA;&#xD;&#xA;**Third**, open ISIS and you should be able to find the component.   &#xD;&#xA;&#xD;&#xA;Please find this image of the worksheet after finishing the above steps, and simulation works just fine!&#xD;&#xA;![Simulating Arduino Uno on Proteus ISIS][2]&#xD;&#xA;&#xD;&#xA;And as a head start for you, please find this small memo I prepared for the **Arduino Uno Pins Layout**: &#xD;&#xA;&#xD;&#xA;    0-14: I/O&#xD;&#xA;    A0-A5: Analog&#xD;&#xA;    &#xD;&#xA;    We can use analog as digital:&#xD;&#xA;    =============================&#xD;&#xA;    Pinout:&#xD;&#xA;    00: Rx		| Can't be used as I/O if I wrote in the code Serial.begin&#xD;&#xA;    01: TX		|&#xD;&#xA;    02: Interrupt&#xD;&#xA;    03: Interrupt &amp; PWM&#xD;&#xA;    04: &#xD;&#xA;    05: PWM&#xD;&#xA;    06: PWM&#xD;&#xA;    07: &#xD;&#xA;    08:&#xD;&#xA;    09: PWM&#xD;&#xA;    10: PWM &amp; SPI&#xD;&#xA;    11: PWM &amp; SPI&#xD;&#xA;    12: SPI&#xD;&#xA;    13:	SPI&#xD;&#xA;    A0:	&#xD;&#xA;    A1:&#xD;&#xA;    A2:&#xD;&#xA;    A3:&#xD;&#xA;    A4: TWI&#xD;&#xA;    A5: TWI&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.mediafire.com/?q2g7la3dfftfk2r&#xD;&#xA;  [2]: http://i.stack.imgur.com/moWEA.png" />
  <row Id="402" PostHistoryTypeId="16" PostId="175" RevisionGUID="bd7bdfd9-68d3-4588-856c-ec2a1f6c5f3f" CreationDate="2014-02-13T19:16:04.687" UserId="103" />
  <row Id="403" PostHistoryTypeId="2" PostId="176" RevisionGUID="401b53f5-f8fb-4f8f-8409-df1e7a9c64d1" CreationDate="2014-02-13T19:22:59.960" UserId="11" Text="Say I have some variables that I want to print out to the terminal, what's the easiest way to print them in a string?&#xD;&#xA;&#xD;&#xA;Currently I do something like this:&#xD;&#xA;&#xD;&#xA;    Serial.print(&quot;Var 1:&quot;);Serial.println(var1);&#xD;&#xA;    Serial.print(&quot; Var 2:&quot;);Serial.println(var2);&#xD;&#xA;    Serial.print(&quot; Var 3:&quot;);Serial.println(var3);&#xD;&#xA;&#xD;&#xA;Is there a better way to do this?" />
  <row Id="404" PostHistoryTypeId="1" PostId="176" RevisionGUID="401b53f5-f8fb-4f8f-8409-df1e7a9c64d1" CreationDate="2014-02-13T19:22:59.960" UserId="11" Text="How do I print multiple variables in a string?" />
  <row Id="405" PostHistoryTypeId="3" PostId="176" RevisionGUID="401b53f5-f8fb-4f8f-8409-df1e7a9c64d1" CreationDate="2014-02-13T19:22:59.960" UserId="11" Text="&lt;serial&gt;&lt;string&gt;&lt;terminal&gt;" />
  <row Id="407" PostHistoryTypeId="2" PostId="177" RevisionGUID="dda88a20-e79b-49d8-9c32-75b0e3adf81e" CreationDate="2014-02-13T20:41:19.023" UserId="89" Text="&lt;!-- language: lang-c --&gt;&#xD;&#xA;This is probably not better, just different.&#xD;&#xA;You can use the **String** object for output. These objects allow concatenation and support automatic typecasting.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    Serial.begin(9600);&#xD;&#xA;    String label = &quot;Var&quot;;&#xD;&#xA;    const byte nValues = 3;&#xD;&#xA;    int var[nValues] = {36, 72, 49};&#xD;&#xA;&#xD;&#xA;    for (int i = 0; i &lt; nValues; i++) {&#xD;&#xA;        String stuff = label + i + &quot;: &quot;;&#xD;&#xA;        Serial.println(stuff + var[i]);&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="408" PostHistoryTypeId="2" PostId="178" RevisionGUID="de99c6a6-c0da-4d18-a989-2c09042156a3" CreationDate="2014-02-13T20:45:47.473" UserId="11" Text="[MATLAB Support Package for Arduino (aka ArduinoIO Package)][1] allows you to do it fairly easily.&#xD;&#xA;&#xD;&#xA;&gt; Sample usage:&#xD;&#xA;&gt; &#xD;&#xA;&gt; %-- connect to the board &#xD;&#xA;&gt; &#xD;&#xA;&gt; `a = arduino('COM9')`&#xD;&#xA;&gt; &#xD;&#xA;&gt; %-- specify pin mode &#xD;&#xA;&gt; &#xD;&#xA;&gt; `a.pinMode(4,'input'); `&#xD;&#xA;&gt; &#xD;&#xA;&gt; `a.pinMode(13,'output');`&#xD;&#xA;&gt; &#xD;&#xA;&gt; %-- digital i/o &#xD;&#xA;&gt; &#xD;&#xA;&gt; `a.digitalRead(4) % read pin 4 `&#xD;&#xA;&gt; &#xD;&#xA;&gt; `a.digitalWrite(13,0) % write 0 to pin 13`&#xD;&#xA;&gt; &#xD;&#xA;&gt; %-- analog i/o &#xD;&#xA;&gt; &#xD;&#xA;&gt; `a.analogRead(5) % read analog pin 5 `&#xD;&#xA;&gt; &#xD;&#xA;&gt; `a.analogWrite(9, 155) % write 155 to analog pin 9`&#xD;&#xA;&#xD;&#xA;  [1]: http://www.mathworks.com/matlabcentral/fileexchange/32374-matlab-support-package-for-arduino-aka-arduinoio-package" />
  <row Id="410" PostHistoryTypeId="2" PostId="179" RevisionGUID="2262e90f-e215-4fef-afba-c49b32a20f8f" CreationDate="2014-02-13T21:23:36.390" UserId="37" Text="I coded a program, but then I lost it. However, I uploaded it to the Arduino before losing it. Is there any way I can get it back?" />
  <row Id="411" PostHistoryTypeId="1" PostId="179" RevisionGUID="2262e90f-e215-4fef-afba-c49b32a20f8f" CreationDate="2014-02-13T21:23:36.390" UserId="37" Text="Is there any way to download a program from an Arduino?" />
  <row Id="412" PostHistoryTypeId="3" PostId="179" RevisionGUID="2262e90f-e215-4fef-afba-c49b32a20f8f" CreationDate="2014-02-13T21:23:36.390" UserId="37" Text="&lt;connection&gt;&lt;program&gt;" />
  <row Id="413" PostHistoryTypeId="2" PostId="180" RevisionGUID="8286cb38-9a8a-4943-a8fe-9fc5789e1461" CreationDate="2014-02-13T21:25:48.473" UserId="11" Text="Should be possible as long as the security bit isn't set. This question was asked on EE a while back. &#xD;&#xA;&#xD;&#xA;[Is it possible to extract code from an arduino board?][1]&#xD;&#xA;&#xD;&#xA;But you won't get the Arduino code you wrote back. the code is compiled into assembly and you'll have to convert that back to C yourself.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://electronics.stackexchange.com/questions/61079/is-it-possible-to-extract-code-from-an-arduino-board" />
  <row Id="414" PostHistoryTypeId="2" PostId="181" RevisionGUID="539d26a5-b533-4778-aa45-fe96005ecae1" CreationDate="2014-02-13T21:34:32.477" UserId="8" Text="You can download the hex dump of the file, but there is no easy way to get all the C++ code and comments. If you can understand assembly, you could recreate the program, but that would take a while. There are dissasemblers available for some devices, i don't know about arduino." />
  <row Id="415" PostHistoryTypeId="2" PostId="182" RevisionGUID="cf2820e0-9908-4108-b223-d46c3c755c89" CreationDate="2014-02-13T22:32:43.623" UserId="87" Text="I'm planning an Arduino system that consists of several Arduino boards. The maximum distance between the boards is about 50 meters. I want to send basic data between these, like short strings or integers. I know I could send data through ethernet cables but that requires an ethernet shield or the Arduino Ethernet board that doubles the costs. Is there a low budget way I could connect the boards using only the most basic boards (like Uno) and some other components but not a full shield?" />
  <row Id="416" PostHistoryTypeId="1" PostId="182" RevisionGUID="cf2820e0-9908-4108-b223-d46c3c755c89" CreationDate="2014-02-13T22:32:43.623" UserId="87" Text="How to connect two Arduino without shields?" />
  <row Id="417" PostHistoryTypeId="3" PostId="182" RevisionGUID="cf2820e0-9908-4108-b223-d46c3c755c89" CreationDate="2014-02-13T22:32:43.623" UserId="87" Text="&lt;arduino-uno&gt;&lt;networking&gt;&lt;system-design&gt;" />
  <row Id="418" PostHistoryTypeId="2" PostId="183" RevisionGUID="381eef7c-d345-448e-bda3-77f0456c8000" CreationDate="2014-02-13T22:42:53.227" UserId="8" Text="There are two categories i can think of to classify comminucation features of the Arduino boards:&#xD;&#xA;&#xD;&#xA;__Between 2 devices:__&#xD;&#xA;&#xD;&#xA;* Serial: Easy to use and only requires 2 data lines.&#xD;&#xA;* OneWire: Harder to use and slow, but uses only one data line&#xD;&#xA;&#xD;&#xA;__Between more than 2 devices__&#xD;&#xA;&#xD;&#xA;* I2C: You can have up to 128 devices on a network, individually addressable, but requires a master device, uses 2 data lines. this is know also as Wire.&#xD;&#xA;* SPI: difficult to use, but very fast and easy device selection. uses a lot of data lines (3 + num of devices)&#xD;&#xA;* OneWire: using addressed oneWire is even slower than regular oneWire, still only one data line&#xD;&#xA;* SoftwareSerial: You can have several devices connected by different Serial lines, but it is slower.&#xD;&#xA;* CAN: only available on the Due, and addressable&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;There are other methods available, but these listed only require a minimum of external hardware." />
  <row Id="419" PostHistoryTypeId="5" PostId="36" RevisionGUID="e936ebcb-1cdd-4638-8c15-2563e8be222a" CreationDate="2014-02-13T22:57:01.480" UserId="69" Comment="added clarification on why this is needed" Text="If you want to submit sensor data such as temperature to a remote server/database somewhere you need to use some kind of call to a web server since it isn't possible to connect directly to a database from the Arduino.&#xD;&#xA;&#xD;&#xA;How do you post data to a JSON web service from an Arduino that's connected to the Internet?&#xD;&#xA;" />
  <row Id="420" PostHistoryTypeId="2" PostId="184" RevisionGUID="1899d71e-cfb4-4f22-ab86-157248a1cd8c" CreationDate="2014-02-13T22:59:03.273" UserId="11" Text="For long distance wired communication, look at [RS-485][1].&#xD;&#xA;&#xD;&#xA;&gt; Since it uses a differential balanced line over twisted pair (like&#xD;&#xA;&gt; RS-422), it can span relatively large distances (up to 4,000 feet&#xD;&#xA;&gt; (1,200 m)). A rule of thumb is that the speed in bit/s multiplied by&#xD;&#xA;&gt; the length in meters should not exceed 108. Thus a 50 meter cable&#xD;&#xA;&gt; should not signal faster than 2 Mbit/s&#xD;&#xA;&#xD;&#xA;You can use the MAX485 chip. It's pretty easy to work with but there's a good library as well:&#xD;&#xA;&#xD;&#xA;https://github.com/Protoneer/RS485-Arduino-Library&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/RS-485" />
  <row Id="421" PostHistoryTypeId="2" PostId="185" RevisionGUID="a919acf1-8591-4f39-9134-56336318f582" CreationDate="2014-02-13T23:01:48.250" UserId="69" Text="Freakduino makes some Arduino boards with built in wireless. Their long range wireless is 900 MHz and their shorter range is 2.4GHz. I think they are actually XBee radios and for programming you would use a library called chibiArduino, which is available (and documented) on the Freakduino website. When communicating wirelessly with another radio you can use Broadcast or specify a radio by it's ID which is a value you need to set in the EEPROM of the Freakduino.&#xD;&#xA;" />
  <row Id="422" PostHistoryTypeId="5" PostId="183" RevisionGUID="161ef217-1608-4e60-bc78-20c9adf7d7c8" CreationDate="2014-02-13T23:09:49.190" UserId="8" Comment="added distance ratings" Text="There are two categories i can think of to classify comminucation features of the Arduino boards:&#xD;&#xA;&#xD;&#xA;__Between 2 devices:__&#xD;&#xA;&#xD;&#xA;* Serial: Easy to use and only requires 2 data lines.&#xD;&#xA;* OneWire: Harder to use and slow, but uses only one data line&#xD;&#xA;&#xD;&#xA;__Between more than 2 devices__&#xD;&#xA;&#xD;&#xA;* I2C: You can have up to 128 devices on a network, individually addressable, but requires a master device, uses 2 data lines. this is know also as Wire.&#xD;&#xA;* SPI: difficult to use, but very fast and easy device selection. uses a lot of data lines (3 + num of devices)&#xD;&#xA;* OneWire: using addressed oneWire is even slower than regular oneWire, still only one data line&#xD;&#xA;* SoftwareSerial: You can have several devices connected by different Serial lines, but it is slower.&#xD;&#xA;* CAN: only available on the Due, and addressable&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;There are other methods available, but these listed only require a minimum of external hardware.&#xD;&#xA;&#xD;&#xA;For distance ratings, see http://forum.arduino.cc/index.php?topic=82937.0 and http://www.tldp.org/HOWTO/Remote-Serial-Console-HOWTO/serial-distance.html&#xD;&#xA;&#xD;&#xA;These data rates are directly controlled in Serial and can be tweaked in many others." />
  <row Id="423" PostHistoryTypeId="5" PostId="185" RevisionGUID="4990ecf7-efc0-4cbf-8482-bc716f5991c1" CreationDate="2014-02-13T23:12:28.980" UserId="69" Comment="added quote from freakduino site" Text="Freakduino makes some Arduino boards with built in wireless. Their long range wireless is 900 MHz and their shorter range is 2.4GHz. I think they are actually XBee radios and for programming you would use a library called chibiArduino, which is available (and documented) on the Freakduino website. When communicating wirelessly with another radio you can use Broadcast or specify a radio by it's ID which is a value you need to set in the EEPROM of the Freakduino.&#xD;&#xA;&#xD;&#xA;Taken directly from the Freakduino site:&#xD;&#xA;&#xD;&#xA;&gt; The addition of an integrated wireless radio based on the IEEE 802.15.4 protocol (same radio protocol as the XBee) allows for wireless control of devices or wireless sensor data collection. Optional battery circuitry was added so that it could function as a true wireless node without any external power cables. The board is also designed to fit a ruggedized enclosure so that the design can be transported safely or deployed in an actual usage scenario without worrying about damaging the circuitry.&#xD;&#xA;&#xD;&#xA;&gt;This 900 MHz radio is a personal favorite of mine. I use it all the time because 900 MHz offers much better range compared to 2.4 GHz. The radio can output up to 10 mW of transmit power which can get a surprising amount of range. With direct line of sight, a few hundred meters would not be surprising. If additional range is needed, the modulation mode can also be changed from OQPSK to BPSK. This results in additional range at the expense of data rate, with the max going from 250 kbps to 40 kbps in standard mode. &#xD;&#xA;&#xD;&#xA;" />
  <row Id="424" PostHistoryTypeId="5" PostId="161" RevisionGUID="56fa83d9-19c7-4727-a088-6ecb87e79db7" CreationDate="2014-02-14T00:05:50.570" UserId="11" Comment="added 8 characters in body" Text="I second calling millis repeatedly and then comparing actual vs. expected.   &#xD;&#xA;   &#xD;&#xA;There will be some minimal overhead, but it will diminish in significance the more times you call millis(). &#xD;&#xA;&#xD;&#xA;If you look at &#xD;&#xA;&#xD;&#xA;    C:\Program Files (x86)\Arduino\Arduino ERW 1.0.5\hardware\arduino\cores\arduino\wiring.c&#xD;&#xA;&#xD;&#xA;You can see that millis() is very tiny at only 4 instructions `(cli is simply # define cli()  \__asm__ \__volatile__ (&quot;cli&quot; ::))` and a return. &#xD;&#xA;&#xD;&#xA;I'd call it about 10 million times using a FOR loop which has a volatile as the conditional. The volatile keyword will prevent the compiler from attempting any optimization on the loop itself. &#xD;&#xA;&#xD;&#xA;I don't guarantee the following to be syntactically perfect..&#xD;&#xA;&#xD;&#xA;    int temp1,temp2;&#xD;&#xA;    temp1=millis();&#xD;&#xA;    for (volatile unsigned int j=0;j&lt;1000000;++j){&#xD;&#xA;    temp2=millis();}&#xD;&#xA;    Serial.print(&quot;Execution time = &quot;);&#xD;&#xA;    Serial.print((temp2-temp1,DEC);&#xD;&#xA;    Serial.print(&quot;ms&quot;);&#xD;&#xA;&#xD;&#xA;my guess is that takes ~900ms or about 56us per call to millis. ( I don't have an aruduino handy ATM." />
  <row Id="426" PostHistoryTypeId="2" PostId="186" RevisionGUID="26f02ce6-c593-471a-9d25-6f91015b0601" CreationDate="2014-02-14T01:01:04.640" UserId="11" Text="I have a push button wired to my Arduino but it seems to be triggering randomly.&#xD;&#xA;&#xD;&#xA;I have one pin of the button connected to pin 2 on the arduino and the other connected to ground.&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;        &#xD;&#xA;        pinMode(2, INPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        Serial.println(digitalRead(2));&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I expect it to print 1 continuously and go to 0 when I press the button down but sometimes it shows 0 even when I don't touch it." />
  <row Id="427" PostHistoryTypeId="1" PostId="186" RevisionGUID="26f02ce6-c593-471a-9d25-6f91015b0601" CreationDate="2014-02-14T01:01:04.640" UserId="11" Text="Button state changing randomly" />
  <row Id="428" PostHistoryTypeId="3" PostId="186" RevisionGUID="26f02ce6-c593-471a-9d25-6f91015b0601" CreationDate="2014-02-14T01:01:04.640" UserId="11" Text="&lt;button&gt;" />
  <row Id="429" PostHistoryTypeId="2" PostId="187" RevisionGUID="7a4266e2-7277-4707-8a3c-3d97473ef413" CreationDate="2014-02-14T01:01:04.640" UserId="11" Text="When a button is connected in that configuration, the input is what's called *floating*, meaning it's not a 0 or a 1. When the button is pressed, it is connected to ground, so that's definitely a 0, but when it's not pressed down, we don't know the value of the pin.&#xD;&#xA;&#xD;&#xA;## Pull Up Resistor&#xD;&#xA;We need to include what's called a &quot;pull-up&quot; resistor to pull the signal up to a logic 1 when the button is not pressed.&#xD;&#xA;&#xD;&#xA;![pull up resistor][1]&#xD;&#xA;&#xD;&#xA;[Image from Sparkfun][2]&#xD;&#xA;&#xD;&#xA;What this means is when the button is not pressed, the Arduino reads a logic 1. When the button is pressed, the current flows through the resistor to ground and the Arduino reads a logic 0.&#xD;&#xA;&#xD;&#xA;## Internal Pull Up Resistor&#xD;&#xA;The Arduino also has internal pull up resistors so you don't necessarily have to add an extra component to your circuit. There are a couple of ways to use this.&#xD;&#xA;&#xD;&#xA;You used to have to do it like this:&#xD;&#xA;&#xD;&#xA;    pinMode(pin, INPUT);           // set pin to input&#xD;&#xA;    digitalWrite(pin, HIGH);       // turn on pullup resistors&#xD;&#xA;&#xD;&#xA;Now we can do it simply in one line:&#xD;&#xA;&#xD;&#xA;    pinMode(pin, INPUT_PULLUP);&#xD;&#xA;&#xD;&#xA;This enables the 20k pull up resistor on that pin. The input will no longer be floating when the button is not pressed.&#xD;&#xA;&#xD;&#xA;**Note:** This only works when the other end is connected to ground.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/h9oX1.jpg&#xD;&#xA;  [2]: https://learn.sparkfun.com/tutorials/pull-up-resistors/what-is-a-pull-up-resistor" />
  <row Id="430" PostHistoryTypeId="2" PostId="188" RevisionGUID="1ca89a44-5be0-47ef-abe6-a707442a62b9" CreationDate="2014-02-14T01:28:32.887" UserId="65" Text="In either of `setup` or `loop`, if I were to add an `exit(0)` call, where would control be passed to? What would the next state of the microcontroller be? Would it stop execution and power down?&#xD;&#xA;&#xD;&#xA;I am using a revision 2 Arduino Uno." />
  <row Id="431" PostHistoryTypeId="1" PostId="188" RevisionGUID="1ca89a44-5be0-47ef-abe6-a707442a62b9" CreationDate="2014-02-14T01:28:32.887" UserId="65" Text="What happens when I call exit() from my program?" />
  <row Id="432" PostHistoryTypeId="3" PostId="188" RevisionGUID="1ca89a44-5be0-47ef-abe6-a707442a62b9" CreationDate="2014-02-14T01:28:32.887" UserId="65" Text="&lt;uno&gt;&lt;programming&gt;" />
  <row Id="433" PostHistoryTypeId="2" PostId="189" RevisionGUID="9ae226d2-46ef-4878-b09d-dec38e61410d" CreationDate="2014-02-14T01:33:03.127" UserId="37" Text="What happens if there is a runtime error in a program? Will execution of the program just stop? Is there some way I get get the Arduino to tell me what the error is?" />
  <row Id="434" PostHistoryTypeId="1" PostId="189" RevisionGUID="9ae226d2-46ef-4878-b09d-dec38e61410d" CreationDate="2014-02-14T01:33:03.127" UserId="37" Text="What happens if there is a runtime error?" />
  <row Id="435" PostHistoryTypeId="3" PostId="189" RevisionGUID="9ae226d2-46ef-4878-b09d-dec38e61410d" CreationDate="2014-02-14T01:33:03.127" UserId="37" Text="&lt;program&gt;&lt;communication&gt;" />
  <row Id="436" PostHistoryTypeId="2" PostId="190" RevisionGUID="660a3ca7-1ada-4034-92cd-0f2ca5023827" CreationDate="2014-02-14T01:42:56.427" UserId="10" Text="Well I just tested it with my Arduino Uno and it just completely stopped the code and left all the outputs as they were when the code stopped running (so it left an LED I had on on). This was what I expected because the Arduino IDE provides the setup and loop functions, if you program the ATMEGA*28 with with any other AVR IDE you start with the main function like all C/C++ programs. The setup and loop functions are not standard on AVR MCU's&#xD;&#xA;&#xD;&#xA;**Note:** The press of the reset button restarts the code, if you were wondering." />
  <row Id="437" PostHistoryTypeId="2" PostId="191" RevisionGUID="6b64cff8-eb9c-4bf1-b139-7f74676d46fd" CreationDate="2014-02-14T01:47:13.680" UserId="11" Text="You'd need a hardware debugger for something like this. But usually you'll see the program not behaving as you expect it to and will have to look at that section of the code to identify the problem.&#xD;&#xA;&#xD;&#xA;A common/quick/easy way to do this is to add print statements to print out the values of variables or just anything so you know the program gets to that point in the code without a problem. This will help you isolate the problem further.&#xD;&#xA;&#xD;&#xA;I believe [VisualMicro][1] has some debugging functionality built in.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.visualmicro.com/" />
  <row Id="438" PostHistoryTypeId="5" PostId="190" RevisionGUID="b447b086-11be-43bf-82f4-716c6800a7b4" CreationDate="2014-02-14T01:48:26.633" UserId="10" Comment="added 42 characters in body; added 13 characters in body" Text="Well I just tested it with my Arduino Uno and it just completely stopped the code and left all the outputs as they were when the code stopped running (so it left an LED I had on on). There seems to not be a IO cleanup when you call exit. This was what I expected because the Arduino IDE provides the setup and loop functions, if you program the ATMEGA*28 with with any other AVR IDE you start with the main function like all C/C++ programs. The setup and loop functions are not standard on AVR MCU's.&#xD;&#xA;&#xD;&#xA;**Note:** The press of the reset button restarts the code, if you were wondering." />
  <row Id="439" PostHistoryTypeId="2" PostId="192" RevisionGUID="779b2510-1e75-433a-9f1a-be4963b4399e" CreationDate="2014-02-14T01:50:31.773" UserId="8" Text="I would assume the AVR CPU doesn't have any error detection or recovery tools. It may just stop, or keep going ignoring the error and the consequences. Like sachleen said, you should add some debug statements in your program that print out data in the middle of an operation, to test if it's working. If you use an emulaor and set breakpoints, you could easily find a problem." />
  <row Id="440" PostHistoryTypeId="2" PostId="193" RevisionGUID="c2b4ef81-132e-4d53-a13d-3530f827dad5" CreationDate="2014-02-14T01:59:18.783" UserId="8" Text="I want to make a sketch that is as small as possible, for test purposes. The problem is, when i compile the BareMinimum sketch (with an empty setup and loop), i get 466 bytes for the Uno and a whopping 4,242 for the Leonardo. Is there any way to write your own code that has no extra functions (namely Timer0 for `millis()` and `delay()`). I would also like to be able to disable the keyboard/mouse functions for the Leonardo." />
  <row Id="441" PostHistoryTypeId="1" PostId="193" RevisionGUID="c2b4ef81-132e-4d53-a13d-3530f827dad5" CreationDate="2014-02-14T01:59:18.783" UserId="8" Text="How to really shrink a sketch" />
  <row Id="442" PostHistoryTypeId="3" PostId="193" RevisionGUID="c2b4ef81-132e-4d53-a13d-3530f827dad5" CreationDate="2014-02-14T01:59:18.783" UserId="8" Text="&lt;uno&gt;&lt;programming&gt;&lt;blink&gt;&lt;sketch&gt;" />
  <row Id="444" PostHistoryTypeId="6" PostId="193" RevisionGUID="d1f99fd0-2180-4734-abbc-4645c4f27cdb" CreationDate="2014-02-14T02:20:49.190" UserId="8" Comment="Asheeshr, if it really makes you feel better" Text="&lt;uno&gt;&lt;programming&gt;&lt;blink&gt;&lt;sketch&gt;&lt;arduino-leonardo&gt;" />
  <row Id="445" PostHistoryTypeId="2" PostId="194" RevisionGUID="19954bbc-43b5-4d1f-ad3b-b74c84342815" CreationDate="2014-02-14T02:24:35.130" UserId="-1" Text="" />
  <row Id="446" PostHistoryTypeId="2" PostId="195" RevisionGUID="9b07deec-0a2f-43c5-a7b8-c37ad461414b" CreationDate="2014-02-14T02:24:35.130" UserId="-1" Text="" />
  <row Id="447" PostHistoryTypeId="2" PostId="196" RevisionGUID="f67467b1-9a65-457f-be2b-e5305f11c6e3" CreationDate="2014-02-14T03:01:47.440" UserId="8" Text="There are several different types in the Arduino programming language. When and why should i use each?" />
  <row Id="448" PostHistoryTypeId="1" PostId="196" RevisionGUID="f67467b1-9a65-457f-be2b-e5305f11c6e3" CreationDate="2014-02-14T03:01:47.440" UserId="8" Text="When to use different variable types?" />
  <row Id="449" PostHistoryTypeId="3" PostId="196" RevisionGUID="f67467b1-9a65-457f-be2b-e5305f11c6e3" CreationDate="2014-02-14T03:01:47.440" UserId="8" Text="&lt;programming&gt;&lt;variables&gt;" />
  <row Id="450" PostHistoryTypeId="2" PostId="197" RevisionGUID="6bd3fe25-af6d-4171-80c0-47ba6e75a375" CreationDate="2014-02-14T03:01:47.440" UserId="8" Text="An overview of the most commonly used variables:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;* __byte__: uses one byte (8 bits), holds numbers from 0 to 255&#xD;&#xA;* __char__: a signed byte&#xD;&#xA;* __boolean__: uses 1 byte, but only holds a value of `true` or `false`&#xD;&#xA;* __int__: uses 2 bytes, holds numbers from -32768 to 32767, mostly used in general programming. an `int` is what is known as a signed variable, where the last bit controls if it is negative or positive&#xD;&#xA;* __long__: uses 4 bytes, holds numbers from -2147483647 to 217283648, it is also signed&#xD;&#xA;* __long long__: uses 8 bytes, can hold -9223372036854775808 to 9223372036854775807, signed&#xD;&#xA;* __float__: uses 4 bytes, holds decimals from -3.4028235E+38 to 3.4028235E+38.&#xD;&#xA;* __double__: almost identical to `float`&#xD;&#xA;* __string__: an array of chars that represent text&#xD;&#xA;* __String__: not to be confused with `string`, this is a class that holds text data with extra [functions](http://arduino.cc/en/Reference/StringObject)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Most variable declarations can be prefixed with `signed` or `unsigned` to change the function of the sigh bit. For example, `unsigned int x = 0;` would create a variable that holds numbers from 0 to 65535 because the sign bit is used as an extra data bit." />
  <row Id="451" PostHistoryTypeId="2" PostId="198" RevisionGUID="8ff653ad-c54d-45b6-ad56-507f1edd00d4" CreationDate="2014-02-14T03:27:43.943" UserId="60" Text="You should be able to create your own board definition with a custom boards.txt file as per https://github.com/arduino/Arduino/wiki/Arduino-IDE-1.5---3rd-party-Hardware-specification. As I see there are several usb features in the leonardo's definition. I would hope that the compiles inclusion of the 4K is based off of these flags and not the processor type.&#xD;&#xA;&#xD;&#xA;Where the boards.txt would use the upload, bootloader sections from the Leonardo and the build from the uno.&#xD;&#xA;&#xD;&#xA;This is all assuming the core library build does not use processor specific flags to include USB functions.&#xD;&#xA;&#xD;&#xA;*If you get such working. post back, I am sure others would be interested in such.*&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;I recently ran into this 4K used limitation on a library demo that actually maxed out the UNO and had to put in a&#xD;&#xA;&#xD;&#xA;    #if !defined(__AVR_ATmega32U4__)&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;around a large chunk of extra features in the sketch to fit on the Leonardo.&#xD;&#xA;&#xD;&#xA;I had assume (wrong) that this 4K was because I still included Serial.print which when over the USB's CDC on the Leo. But I see after a memory dump of an empty sketch they are still there.&#xD;&#xA;&#xD;&#xA;    C:\Users\mflaga\AppData\Local\Temp\build8958339595868119500.tmp&gt;avr-objdump -d sketch_feb13a.cpp.elf &gt; sketch_feb13a.cpp.elf.lst&#xD;&#xA;&#xD;&#xA;Disappointing..." />
  <row Id="452" PostHistoryTypeId="2" PostId="199" RevisionGUID="fde79e06-41d7-45ee-83ae-e091b5cb6276" CreationDate="2014-02-14T03:47:50.560" UserId="60" Text="One should appreciate that the Arduino is an Embedded Processor. *Specifically that it has limited resources of RAM and ROM(aka Flash/program space).* &#xD;&#xA;&#xD;&#xA;Often is the case I see coding use the &quot;int&quot; defaultly. Almost sloppily. If that works great.&#xD;&#xA;&#xD;&#xA;BUT!!!!&#xD;&#xA;You can run out of room REAL FAST with only 2K of RAM.&#xD;&#xA;&#xD;&#xA;I would recommend that you size down your type to the minimum of what it needs to be describing it. One also gets a better understanding of what it really is and its limitations. There is no need for an array of int(16bits) from bytes that were recieved from the SPI, UART or I2C. Or a matrix of RGB's that consume 3 bytes each, being int's. You cut your capacity in half.&#xD;&#xA;&#xD;&#xA;The pro/con: PRO: using default int everywhere makes it more inter changeable. The CON is that such interchangeability can lead to unintentional casting errors. &#xD;&#xA;&#xD;&#xA;I would also recommend using C99 type def's which can be found at &quot;http://www.nongnu.org/avr-libc/user-manual/group__avr__stdint.html&quot; and elsewhere. It makes things vivid, regards to this aspect. Hence a &quot;int&quot; would be a &quot;int16_t&quot;, &quot;unsigned long&quot; be &quot;uint32_t&quot; etc...&#xD;&#xA;&#xD;&#xA;It is worth knowing that in some cases a byte or char can not be replaced with int8_t, as such when used with string array functions. But they are still just as vivid." />
  <row Id="453" PostHistoryTypeId="2" PostId="200" RevisionGUID="cc47929d-a407-42bf-b764-0dbbd0fbf4b2" CreationDate="2014-02-14T04:00:10.480" UserId="60" Text="My initial guess is wrong. I would have thought it would simply return from loop and the core library would just call loop() again. However, is see the following code was created. Noticing that __stop_program is a hard loop...&#xD;&#xA;&#xD;&#xA;An extract of Blink.ino's listing:&#xD;&#xA;&#xD;&#xA;    00000100 &lt;loop&gt;:&#xD;&#xA;     100:	80 91 00 01 	lds	r24, 0x0100&#xD;&#xA;     104:	61 e0       	ldi	r22, 0x01	; 1&#xD;&#xA;     106:	0e 94 ca 01 	call	0x394	; 0x394 &lt;digitalWrite&gt;&#xD;&#xA;     10a:	68 ee       	ldi	r22, 0xE8	; 232&#xD;&#xA;     10c:	73 e0       	ldi	r23, 0x03	; 3&#xD;&#xA;     10e:	80 e0       	ldi	r24, 0x00	; 0&#xD;&#xA;     110:	90 e0       	ldi	r25, 0x00	; 0&#xD;&#xA;     112:	0e 94 23 01 	call	0x246	; 0x246 &lt;delay&gt;&#xD;&#xA;     116:	80 91 00 01 	lds	r24, 0x0100&#xD;&#xA;     11a:	60 e0       	ldi	r22, 0x00	; 0&#xD;&#xA;     11c:	0e 94 ca 01 	call	0x394	; 0x394 &lt;digitalWrite&gt;&#xD;&#xA;     120:	68 ee       	ldi	r22, 0xE8	; 232&#xD;&#xA;     122:	73 e0       	ldi	r23, 0x03	; 3&#xD;&#xA;     124:	80 e0       	ldi	r24, 0x00	; 0&#xD;&#xA;     126:	90 e0       	ldi	r25, 0x00	; 0&#xD;&#xA;     128:	0e 94 23 01 	call	0x246	; 0x246 &lt;delay&gt;&#xD;&#xA;     12c:	80 e0       	ldi	r24, 0x00	; 0&#xD;&#xA;     12e:	90 e0       	ldi	r25, 0x00	; 0&#xD;&#xA;     130:	0e 94 2e 02 	call	0x45c	; 0x45c &lt;_exit&gt;&#xD;&#xA;&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;    0000045c &lt;_exit&gt;:&#xD;&#xA;     45c:	f8 94       	cli&#xD;&#xA;&#xD;&#xA;    0000045e &lt;__stop_program&gt;:&#xD;&#xA;     45e:	ff cf       	rjmp	.-2      	; 0x45e &lt;__stop_program&gt;&#xD;&#xA;&#xD;&#xA;Note that if _exit had not called cli, interrupts would be able to do stuff. But that is not the case.&#xD;&#xA;" />
  <row Id="454" PostHistoryTypeId="2" PostId="201" RevisionGUID="f028b75a-1c07-4685-a16d-04686e3c05b5" CreationDate="2014-02-14T04:16:45.377" UserId="65" Text="Here is a short function that I hacked together that simulates `printf` over the serial connection. This code can be pasted in the beginning of the files where it needs to be referenced. It should not create any conflicts.&#xD;&#xA;&#xD;&#xA;The function prototype is:&#xD;&#xA;&#xD;&#xA;    int ardprintf(char *, ...);&#xD;&#xA;&#xD;&#xA;It returns the number of arguments detected in the function call. &#xD;&#xA;&#xD;&#xA;It can be called similar to `printf`. See it in action in this example:&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      int l=2;&#xD;&#xA;      char *j = &quot;test&quot;;&#xD;&#xA;      long k = 123456789;&#xD;&#xA;      char s = 'g';&#xD;&#xA;      float f = 2.3;&#xD;&#xA;    &#xD;&#xA;      ardprintf(&quot;test %d %l %c %s %f&quot;, l, k, s, j, f);&#xD;&#xA;    &#xD;&#xA;      delay(5000);&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The output as expected is:&#xD;&#xA;&#xD;&#xA;    test 2 123456789 g test 2.30&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;This is the function definition:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #ifndef ARDPRINTF&#xD;&#xA;    #define ARDPRINTF&#xD;&#xA;    #define ARDBUFFER 16&#xD;&#xA;    #include &lt;stdarg.h&gt;&#xD;&#xA;&#xD;&#xA;    int ardprintf(char *str, ...)&#xD;&#xA;    {&#xD;&#xA;      int i, count=0, j=0, flag=0;&#xD;&#xA;      char temp[ARDBUFFER+1];&#xD;&#xA;      for(i=0; str[i]!='\0';i++)  if(str[i]=='%')  count++;&#xD;&#xA;      &#xD;&#xA;      va_list argv;&#xD;&#xA;      va_start(argv, count);&#xD;&#xA;      for(i=0,j=0; str[i]!='\0';i++)&#xD;&#xA;      {&#xD;&#xA;        if(str[i]=='%')&#xD;&#xA;        {&#xD;&#xA;          temp[j] = '\0';&#xD;&#xA;          Serial.print(temp);&#xD;&#xA;          j=0;&#xD;&#xA;          temp[0] = '\0';&#xD;&#xA;          &#xD;&#xA;          switch(str[++i])&#xD;&#xA;          {&#xD;&#xA;            case 'd': Serial.print(va_arg(argv, int));&#xD;&#xA;                      break;&#xD;&#xA;            case 'l': Serial.print(va_arg(argv, long));&#xD;&#xA;                      break;&#xD;&#xA;            case 'f': Serial.print(va_arg(argv, double));&#xD;&#xA;                      break;&#xD;&#xA;            case 'c': Serial.print((char)va_arg(argv, int));&#xD;&#xA;                      break;&#xD;&#xA;            case 's': Serial.print(va_arg(argv, char *));&#xD;&#xA;                      break;&#xD;&#xA;            default:  ;&#xD;&#xA;          };&#xD;&#xA;        }&#xD;&#xA;        else &#xD;&#xA;        {&#xD;&#xA;          temp[j] = str[i];&#xD;&#xA;          j = (j+1)%ARDBUFFER;&#xD;&#xA;          if(j==0) &#xD;&#xA;          {&#xD;&#xA;            temp[ARDBUFFER] = '\0';&#xD;&#xA;            Serial.print(temp);&#xD;&#xA;            temp[0]='\0';&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      };&#xD;&#xA;      Serial.println();&#xD;&#xA;      return count + 1;&#xD;&#xA;    }&#xD;&#xA;    #undef ARDBUFFER&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;**To print the `%` character, use `%%`." />
  <row Id="455" PostHistoryTypeId="5" PostId="201" RevisionGUID="f4d47029-f57a-43c2-939c-8f31d30632a2" CreationDate="2014-02-14T04:26:02.260" UserId="65" Comment="reorganized" Text="`ardprintf` is a short function that I hacked together that simulates `printf` over the serial connection. This code (given below) can be pasted in the beginning of the files where the function is needed. It should not create any conflicts.&#xD;&#xA;&#xD;&#xA;It can be called similar to `printf`. See it in action in this example:&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      int l=2;&#xD;&#xA;      char *j = &quot;test&quot;;&#xD;&#xA;      long k = 123456789;&#xD;&#xA;      char s = 'g';&#xD;&#xA;      float f = 2.3;&#xD;&#xA;    &#xD;&#xA;      ardprintf(&quot;test %d %l %c %s %f&quot;, l, k, s, j, f);&#xD;&#xA;    &#xD;&#xA;      delay(5000);&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The output as expected is:&#xD;&#xA;&#xD;&#xA;    test 2 123456789 g test 2.30&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;The function prototype is:&#xD;&#xA;&#xD;&#xA;    int ardprintf(char *, ...);&#xD;&#xA;&#xD;&#xA;It returns the number of arguments detected in the function call. &#xD;&#xA;&#xD;&#xA;This is the function definition:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #ifndef ARDPRINTF&#xD;&#xA;    #define ARDPRINTF&#xD;&#xA;    #define ARDBUFFER 16&#xD;&#xA;    #include &lt;stdarg.h&gt;&#xD;&#xA;&#xD;&#xA;    int ardprintf(char *str, ...)&#xD;&#xA;    {&#xD;&#xA;      int i, count=0, j=0, flag=0;&#xD;&#xA;      char temp[ARDBUFFER+1];&#xD;&#xA;      for(i=0; str[i]!='\0';i++)  if(str[i]=='%')  count++;&#xD;&#xA;      &#xD;&#xA;      va_list argv;&#xD;&#xA;      va_start(argv, count);&#xD;&#xA;      for(i=0,j=0; str[i]!='\0';i++)&#xD;&#xA;      {&#xD;&#xA;        if(str[i]=='%')&#xD;&#xA;        {&#xD;&#xA;          temp[j] = '\0';&#xD;&#xA;          Serial.print(temp);&#xD;&#xA;          j=0;&#xD;&#xA;          temp[0] = '\0';&#xD;&#xA;          &#xD;&#xA;          switch(str[++i])&#xD;&#xA;          {&#xD;&#xA;            case 'd': Serial.print(va_arg(argv, int));&#xD;&#xA;                      break;&#xD;&#xA;            case 'l': Serial.print(va_arg(argv, long));&#xD;&#xA;                      break;&#xD;&#xA;            case 'f': Serial.print(va_arg(argv, double));&#xD;&#xA;                      break;&#xD;&#xA;            case 'c': Serial.print((char)va_arg(argv, int));&#xD;&#xA;                      break;&#xD;&#xA;            case 's': Serial.print(va_arg(argv, char *));&#xD;&#xA;                      break;&#xD;&#xA;            default:  ;&#xD;&#xA;          };&#xD;&#xA;        }&#xD;&#xA;        else &#xD;&#xA;        {&#xD;&#xA;          temp[j] = str[i];&#xD;&#xA;          j = (j+1)%ARDBUFFER;&#xD;&#xA;          if(j==0) &#xD;&#xA;          {&#xD;&#xA;            temp[ARDBUFFER] = '\0';&#xD;&#xA;            Serial.print(temp);&#xD;&#xA;            temp[0]='\0';&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      };&#xD;&#xA;      Serial.println();&#xD;&#xA;      return count + 1;&#xD;&#xA;    }&#xD;&#xA;    #undef ARDBUFFER&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;**To print the `%` character, use `%%`." />
  <row Id="456" PostHistoryTypeId="2" PostId="202" RevisionGUID="e4226127-596e-47a9-bd2c-712a9b3ee3a6" CreationDate="2014-02-14T07:19:56.173" UserId="62" Text="I usually used Tabs to make things line up better in the Serial. Having things line up like I do allow the arduino to fire as fast as possible while being able to notice certain changes in the variables.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Try something like this:&#xD;&#xA;&#xD;&#xA;    Serial.println(&quot;Var 1:\tVar 2tVar 3:&quot;);&#xD;&#xA;    Serial.print(&quot;\t&quot;);&#xD;&#xA;    Serial.print(var1);&#xD;&#xA;    Serial.print(&quot;\t&quot;);&#xD;&#xA;    Serial.print(var2);&#xD;&#xA;    Serial.print(&quot;\t&quot;);&#xD;&#xA;    Serial.print(var3);&#xD;&#xA;    Serial.println();&#xD;&#xA;&#xD;&#xA;Or something like this:&#xD;&#xA;&#xD;&#xA;    Serial.print(&quot;Var 1:&quot;);Serial.println(var1);&#xD;&#xA;    Serial.print(&quot;\tVar 2:&quot;);Serial.println(var2);&#xD;&#xA;    Serial.print(&quot;\tVar 3:&quot;);Serial.println(var3);" />
  <row Id="457" PostHistoryTypeId="2" PostId="203" RevisionGUID="cae8ad91-1eb9-4e93-aab5-d6c74d2ed917" CreationDate="2014-02-14T07:58:54.977" UserId="62" Text="So in the fields of robotics sometimes you need multiple boards and or computers linked together to share information or save statistical data. Currently I need to send a few different variables over a serial connection and was wondering what was the best way to go about doing such?&#xD;&#xA;&#xD;&#xA;So far I've determined that sending structures would probably be the easier way to send data. Does anyone know of any other way that might be more efficient?&#xD;&#xA;&#xD;&#xA;Please keep in mind that I will essentially be having to send the data for 4 motors, compressor, different temperatures, random things, and the 3 sections of the arm." />
  <row Id="458" PostHistoryTypeId="1" PostId="203" RevisionGUID="cae8ad91-1eb9-4e93-aab5-d6c74d2ed917" CreationDate="2014-02-14T07:58:54.977" UserId="62" Text="Sending Large Amounts of Serial Data" />
  <row Id="459" PostHistoryTypeId="3" PostId="203" RevisionGUID="cae8ad91-1eb9-4e93-aab5-d6c74d2ed917" CreationDate="2014-02-14T07:58:54.977" UserId="62" Text="&lt;serial&gt;&lt;data-transfer&gt;" />
  <row Id="460" PostHistoryTypeId="2" PostId="204" RevisionGUID="2bb99863-95dc-443a-86ac-34b81d042195" CreationDate="2014-02-14T07:58:54.977" UserId="62" Text="With my personal thoughts on Structs being the most efficient way to send many different variables I've constructed a library to help make it easier to send structs and variables over serial.  [Source Code][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &quot;Arduino.h&quot;&#xD;&#xA;    &#xD;&#xA;    #ifndef STREAMSEND_H&#xD;&#xA;    #define STREAMSEND_H&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    #define PACKET_NOT_FOUND 0&#xD;&#xA;    #define BAD_PACKET 1&#xD;&#xA;    #define GOOD_PACKET 2&#xD;&#xA;    &#xD;&#xA;    #define MAX_SIZE 64&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    class StreamSend {&#xD;&#xA;      private:&#xD;&#xA;        static int getWrapperSize() { return sizeof(char)*2; }&#xD;&#xA;        static byte receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize, unsigned int loopSize);&#xD;&#xA;        static byte receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize, unsigned int loopSize, char prefixChar, char suffixChar);&#xD;&#xA;        static char _prefixChar; //s&#xD;&#xA;        static char _suffixChar; //e&#xD;&#xA;        static int _maxLoopsToWait;&#xD;&#xA;    &#xD;&#xA;      public:&#xD;&#xA;        static void sendObject(Stream &amp;ostream, void* ptr, unsigned int objSize);&#xD;&#xA;        static void sendObject(Stream &amp;ostream, void* ptr, unsigned int objSize, char prefixChar, char suffixChar);&#xD;&#xA;        static byte receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize);&#xD;&#xA;        static byte receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize, char prefixChar, char suffixChar);&#xD;&#xA;        static boolean isPacketNotFound(const byte packetStatus);&#xD;&#xA;        static boolean isPacketCorrupt(const byte packetStatus);&#xD;&#xA;        static boolean isPacketGood(const byte packetStatus);&#xD;&#xA;    &#xD;&#xA;        static void setPrefixChar(const char value) { _prefixChar = value; }&#xD;&#xA;        static void setSuffixChar(const char value) { _suffixChar = value; }&#xD;&#xA;        static void setMaxLoopsToWait(const int value) { _maxLoopsToWait = value; }&#xD;&#xA;        static const char getPrefixChar() { return _prefixChar; }&#xD;&#xA;        static const char getSuffixChar() { return _suffixChar; }&#xD;&#xA;        static const int getMaxLoopsToWait() { return _maxLoopsToWait; }&#xD;&#xA;    &#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    //Preset Some Default Variables&#xD;&#xA;    //Can be modified when seen fit&#xD;&#xA;    char StreamSend::_prefixChar = 's';&#xD;&#xA;    char StreamSend::_suffixChar = 'e';&#xD;&#xA;    int StreamSend::_maxLoopsToWait = -1; //Set to -1 for size of current Object and wrapper&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    /**&#xD;&#xA;      * sendObject&#xD;&#xA;      *&#xD;&#xA;      * Converts the Object to bytes and sends it to the stream&#xD;&#xA;      *&#xD;&#xA;      * @param Stream to send data to&#xD;&#xA;      * @param ptr to struct to fill&#xD;&#xA;      * @param size of struct&#xD;&#xA;      */&#xD;&#xA;    void StreamSend::sendObject(Stream &amp;ostream, void* ptr, unsigned int objSize) {&#xD;&#xA;      sendObject(ostream, ptr, objSize, _prefixChar, _suffixChar);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void StreamSend::sendObject(Stream &amp;ostream, void* ptr, unsigned int objSize, char prefixChar, char suffixChar) {&#xD;&#xA;      if(MAX_SIZE &gt;= objSize+getWrapperSize()) { //make sure the object isn't too large&#xD;&#xA;        byte * b = (byte *) ptr; //Create a ptr array of the bytes to send&#xD;&#xA;        ostream.write((byte)prefixChar);&#xD;&#xA;        for(unsigned int i = 0; i&lt;objSize; i++) {&#xD;&#xA;          ostream.write(b[i]); //Write each byte to the stream&#xD;&#xA;        }&#xD;&#xA;        ostream.write((byte)suffixChar);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /**&#xD;&#xA;      * receiveObject&#xD;&#xA;      *&#xD;&#xA;      * Gets the data from the stream and stores to supplied object&#xD;&#xA;      *&#xD;&#xA;      * @param Stream to read data from&#xD;&#xA;      * @param ptr to struct to fill&#xD;&#xA;      * @param size of struct&#xD;&#xA;      */&#xD;&#xA;    byte StreamSend::receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize) {&#xD;&#xA;        return receiveObject(ostream, ptr, objSize, _prefixChar, _suffixChar);&#xD;&#xA;    }&#xD;&#xA;    byte StreamSend::receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize, char prefixChar, char suffixChar) {&#xD;&#xA;      return receiveObject(ostream, ptr, objSize, 0, prefixChar, suffixChar);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    byte StreamSend::receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize, unsigned int loopSize, char prefixChar, char suffixChar) {&#xD;&#xA;      int maxLoops = (_maxLoopsToWait == -1) ? (objSize+getWrapperSize()) : _maxLoopsToWait;&#xD;&#xA;      if(loopSize &gt;= maxLoops) {&#xD;&#xA;    	  return PACKET_NOT_FOUND;&#xD;&#xA;      }&#xD;&#xA;      if(ostream.available() &gt;= (objSize+getWrapperSize())) { //Packet meets minimum size requirement&#xD;&#xA;    	if(ostream.read() != (byte)prefixChar) {&#xD;&#xA;    	  //Prefix character is not found&#xD;&#xA;    	  //Loop through the code again reading the next char&#xD;&#xA;    	  return receiveObject(ostream, ptr, objSize, loopSize+1, prefixChar, suffixChar);&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	char data[objSize]; //Create a tmp char array of the data from Stream&#xD;&#xA;    	ostream.readBytes(data, objSize); //Read the # of bytes&#xD;&#xA;    	memcpy(ptr, data, objSize); //Copy the bytes into the struct&#xD;&#xA;    &#xD;&#xA;    	if(ostream.read() != (byte)suffixChar) {&#xD;&#xA;    	  //Suffix character is not found&#xD;&#xA;    	  return BAD_PACKET;&#xD;&#xA;    	}&#xD;&#xA;    	return GOOD_PACKET;&#xD;&#xA;      }&#xD;&#xA;      return PACKET_NOT_FOUND; //Prefix character wasn't found so no packet detected&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    boolean StreamSend::isPacketNotFound(const byte packetStatus) {&#xD;&#xA;    	return (packetStatus == PACKET_NOT_FOUND);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    boolean StreamSend::isPacketCorrupt(const byte packetStatus) {&#xD;&#xA;    	return (packetStatus == BAD_PACKET);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    boolean StreamSend::isPacketGood(const byte packetStatus) {&#xD;&#xA;    	return (packetStatus == GOOD_PACKET);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Sending Examples:&#xD;&#xA;    &#xD;&#xA;    char charVariable = 'c';&#xD;&#xA;    StreamSend::sendObject(Serial, &amp;charVariable, sizeof(charVariable));&#xD;&#xA;    StreamSend::sendObject(Serial, &amp;charVariable, sizeof(charVariable), 'a', 'z');&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int intVariable = 13496;&#xD;&#xA;    StreamSend::sendObject(xbeeSerial, &amp;intVariable, sizeof(intVariable));&#xD;&#xA;    StreamSend::sendObject(xbeeSerial, &amp;intVariable, sizeof(intVariable), 'j', 'p');&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    struct SIMPLE_STRUCT {&#xD;&#xA;      char charVariable;&#xD;&#xA;      int intVariable[7];&#xD;&#xA;      boolean boolVariable;&#xD;&#xA;    };&#xD;&#xA;    SIMPLE_STRUCT simpleStruct;&#xD;&#xA;    simpleStruct.charVariable = 'z';&#xD;&#xA;    for(int i=0; i&lt;7; i++) {&#xD;&#xA;      simpleStruct.intVariable[i] = i;&#xD;&#xA;    }&#xD;&#xA;    StreamSend::sendObject(xbeeSerial, &amp;simpleStruct, sizeof(simpleStruct));&#xD;&#xA;    StreamSend::sendObject(xbeeSerial, &amp;simpleStruct, sizeof(simpleStruct), '3', 'u');&#xD;&#xA;    &#xD;&#xA;Receiving Examples:&#xD;&#xA;&#xD;&#xA;    char charVariable;&#xD;&#xA;    byte packetResults = StreamSend::receiveObject(Serial, &amp;charVariable, sizeof(charVariable));&#xD;&#xA;    byte packetResults = StreamSend::receiveObject(Serial, &amp;charVariable, sizeof(charVariable), 'a', 'z');&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int intVariable;&#xD;&#xA;    byte packetResults = StreamSend::receiveObject(xbeeSerial, &amp;intVariable, sizeof(intVariable));&#xD;&#xA;    byte packetResults = StreamSend::receiveObject(xbeeSerial, &amp;intVariable, sizeof(intVariable), 'j', 'p');&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    struct SIMPLE_STRUCT {&#xD;&#xA;      char charVariable;&#xD;&#xA;      int intVariable[7];&#xD;&#xA;      boolean boolVariable;&#xD;&#xA;    };&#xD;&#xA;    SIMPLE_STRUCT simpleStruct;&#xD;&#xA;    byte packetResults = StreamSend::receiveObject(xbeeSerial, &amp;simpleStruct, sizeof(simpleStruct));&#xD;&#xA;    byte packetResults = StreamSend::receiveObject(xbeeSerial, &amp;simpleStruct, sizeof(simpleStruct), '3', 'p');&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;Testing Validity of Data:&#xD;&#xA;    &#xD;&#xA;    if(StreamSend::isPacketGood(packetResults)) {&#xD;&#xA;      //The Packet was Good&#xD;&#xA;    } else {&#xD;&#xA;      //The Packet was Bad&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    if(StreamSend::isPacketCorrupt(packetResults)) {&#xD;&#xA;      //The Packet was Corrupt&#xD;&#xA;    } else {&#xD;&#xA;      //The Packet wasn't found or it was Good&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    if(StreamSend::isPacketNotFound(packetResults)) {&#xD;&#xA;      //The Packet was not found after Max # of Tries&#xD;&#xA;    } else {&#xD;&#xA;      //The Packet was Found, but can be corrupt&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;  [1]: http://paste.strictfp.com/39933" />
  <row Id="461" PostHistoryTypeId="2" PostId="205" RevisionGUID="bfeb40dd-c136-4092-a09b-8f8da83a9804" CreationDate="2014-02-14T11:36:15.367" UserId="42" Text="Shift registers have been mentioned in other answers, and they are definitely an excellent choice for many projects. They are cheap, simple, moderately fast, and can typically be chained together to add more outputs. However, they have the downside that they usually need exclusive use of several pins (between 2 and 4, depending on how you set them up).&#xD;&#xA;&#xD;&#xA;An alternative is to use more advanced port expanders, such as the [16-bit MCP23017 and MCP23S17][1]. These support I2C and SPI respectively, which means you can place them on a bus with several other devices (potentially of different types). Each device on the bus can be individually addressed, meaning you only need 2 or 3 pins to talk to all them. The update speeds are typically extremely fast, so you're unlikely to experience significant latency (i.e. transmission delays) in an Arduino project.&#xD;&#xA;&#xD;&#xA;At a low level, using I2C or SPI is substantially more complicated than a simple shift register. However, there is library code for Arduino to take care of that for you. See this question, for example: [How do I use I2C devices with Arduino?][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://ww1.microchip.com/downloads/en/DeviceDoc/21952b.pdf&#xD;&#xA;  [2]: http://arduino.stackexchange.com/questions/158/how-do-i-use-i2c-devices-with-arduino" />
  <row Id="462" PostHistoryTypeId="5" PostId="205" RevisionGUID="325a9722-1ada-4f5e-a866-60586d19d68f" CreationDate="2014-02-14T11:41:42.937" UserId="42" Comment="added 3 characters in body" Text="Shift registers have been mentioned in other answers, and they are definitely an excellent choice for many projects. They are cheap, simple, moderately fast, and can typically be chained together to add more outputs. However, they have the downside that they usually need exclusive use of several pins (between 2 and 4, depending on how you set them up).&#xD;&#xA;&#xD;&#xA;An alternative is to use more advanced port expanders, such as the [16-bit MCP23017 and MCP23S17][1]. These support I2C and SPI respectively, which means you can place them on a bus with several other devices (potentially of different types). Each device on the bus can be individually addressed, meaning you only need 2 or 3 pins to talk to all of them. The update speeds are typically extremely fast, so you're unlikely to experience significant latency (i.e. transmission delays) in an Arduino project.&#xD;&#xA;&#xD;&#xA;At a low level, using I2C or SPI is substantially more complicated than a simple shift register. However, there is library code for Arduino to take care of that for you. See this question, for example: [How do I use I2C devices with Arduino?][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://ww1.microchip.com/downloads/en/DeviceDoc/21952b.pdf&#xD;&#xA;  [2]: http://arduino.stackexchange.com/questions/158/how-do-i-use-i2c-devices-with-arduino" />
  <row Id="463" PostHistoryTypeId="2" PostId="206" RevisionGUID="0e133e6d-e632-4c6c-aa2d-06240e0bb15c" CreationDate="2014-02-14T12:06:10.727" UserId="42" Text="Making a blinking light seems to be one of the most common beginner projects with Arduino. A typical approach is to connect an LED + resistor (in series) to an IO pin, and connect the other end to ground. In code, you make the pin an output, and bring it `HIGH` and `LOW` repeatedly to flash the LED.&#xD;&#xA;&#xD;&#xA;What happens if you leave that resistor out? Obviously you're going to wreck the LED, but will it also damage the Arduino in some way?" />
  <row Id="464" PostHistoryTypeId="1" PostId="206" RevisionGUID="0e133e6d-e632-4c6c-aa2d-06240e0bb15c" CreationDate="2014-02-14T12:06:10.727" UserId="42" Text="What happens to the Arduino if you don't use a resistor with an LED?" />
  <row Id="465" PostHistoryTypeId="3" PostId="206" RevisionGUID="0e133e6d-e632-4c6c-aa2d-06240e0bb15c" CreationDate="2014-02-14T12:06:10.727" UserId="42" Text="&lt;safety&gt;&lt;gpio&gt;&lt;led&gt;&lt;resistor&gt;" />
  <row Id="466" PostHistoryTypeId="10" PostId="196" RevisionGUID="1082c2e2-78ac-4d3b-9e11-d8994f396800" CreationDate="2014-02-14T12:30:47.000" UserId="-1" Comment="102" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:65,&quot;DisplayName&quot;:&quot;AsheeshR&quot;},{&quot;Id&quot;:3,&quot;DisplayName&quot;:&quot;Butzke&quot;},{&quot;Id&quot;:46,&quot;DisplayName&quot;:&quot;Ricardo&quot;},{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;},{&quot;Id&quot;:37,&quot;DisplayName&quot;:&quot;The Guy with The Hat&quot;}]}" />
  <row Id="467" PostHistoryTypeId="2" PostId="207" RevisionGUID="93dc0bc4-aaa1-4a2c-a443-68104a097b32" CreationDate="2014-02-14T13:02:11.400" UserId="136" Text="From page 411 of the [ATmega328P data sheet][1], we have a graph of the output current vs voltage. &#xD;&#xA;&#xD;&#xA;![Output current graph][2]&#xD;&#xA;&#xD;&#xA;We can see over the the 20mA range of output currents, we drop ~0.5V, giving an approximate internal resistance of 25Ω.&#xD;&#xA;&#xD;&#xA;A typical LED has a forward voltage of about 2V. Therefore, we end up in the situation where we will drop 3V over the 25Ω internal resistance of the ATmega328P, giving an output current of 120mA.&#xD;&#xA;&#xD;&#xA;I = (5-2)V / 25Ω = 120mA &#xD;&#xA;&#xD;&#xA;This is a simplification, but this 120mA is far larger than the recommended maximum current per pin of 40mA of the microcontroller, and far in excess of what a normal LED should take.&#xD;&#xA;&#xD;&#xA;That said, most LEDs and the ATmega328P seem to survive this kind of abuse, especially for short periods. In general, if the pin continues to work after this is done, it should be fine.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/Images/doc8161.pdf&#xD;&#xA;  [2]: http://i.stack.imgur.com/w5V5U.png" />
  <row Id="468" PostHistoryTypeId="2" PostId="208" RevisionGUID="fda09cd5-2971-4989-b8ad-5b4ce426b9bd" CreationDate="2014-02-14T13:30:43.520" UserId="83" Text="Leaving series resistors out will definitely greatly (exponentially) shorten lifetime of both the controller and the LED. Absolute maximum ratings for most AVRs are (a.o.):&#xD;&#xA;&#xD;&#xA;- max. 40mA per GPIO pin&#xD;&#xA;- max. 200mA per package.&#xD;&#xA;&#xD;&#xA;A new Arduino sets you back $20 or more, a fist full 220 ohm resistors sets you back 1$. When treated within spec, an Arduino (and LEDs for that matter) can survive a lifetime." />
  <row Id="469" PostHistoryTypeId="5" PostId="196" RevisionGUID="70568533-4168-4a18-8fa5-aef84a097bed" CreationDate="2014-02-14T14:07:42.860" UserId="8" Comment="trying to make it viable for this SE" Text="There are several different types in the Arduino programming language. They each have different applications that can use up the limited RAM in the Arduino. When should i use each." />
  <row Id="471" PostHistoryTypeId="2" PostId="209" RevisionGUID="af9ccc33-cf5f-44f3-a7fa-55aadc5c5414" CreationDate="2014-02-14T14:20:14.733" UserId="8" Text="If you really wanted to send it _fast_, i recommend Full Duplex Serial (FDX). It's the same protocol that USB and ethernet use, and it's a lot faster than UART. The downside is that it usually requires external hardware to facilitate the high data rates. I've heard that the new [softwareSreial](http://arduiniana.org/libraries/NewSoftSerial/) supports FDX, but this may be slower even than hardware UART. For more on communication protocols, see http://arduino.stackexchange.com/questions/182/how-to-connect-two-arduino-without-shields" />
  <row Id="472" PostHistoryTypeId="5" PostId="196" RevisionGUID="ff473def-c98c-4a32-a423-1c40e1feaa79" CreationDate="2014-02-14T14:21:28.193" UserId="8" Comment="edited body" Text="There are several different types in the Arduino programming language. They each have different applications that can use up the limited RAM in the Arduino. When should i use each?" />
  <row Id="473" PostHistoryTypeId="5" PostId="198" RevisionGUID="ac891f78-17bd-4d19-855e-e4b726819a54" CreationDate="2014-02-14T14:51:46.077" UserId="60" Comment="updated as to why 4K is still needed" Text="You should be able to create your own board definition with a custom boards.txt file as per https://github.com/arduino/Arduino/wiki/Arduino-IDE-1.5---3rd-party-Hardware-specification. As I see there are several usb features in the leonardo's definition. I would hope that the compiles inclusion of the 4K is based off of these flags and not the processor type.&#xD;&#xA;&#xD;&#xA;Where the boards.txt would use the upload, bootloader sections from the Leonardo and the build from the uno.&#xD;&#xA;&#xD;&#xA;This is all assuming the core library build does not use processor specific flags to include USB functions.&#xD;&#xA;&#xD;&#xA;*If you get such working. post back, I am sure others would be interested in such.*&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;I recently ran into this 4K used limitation on a library demo that actually maxed out the UNO and had to put in a&#xD;&#xA;&#xD;&#xA;    #if !defined(__AVR_ATmega32U4__)&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;around a large chunk of extra features in the sketch to fit on the Leonardo.&#xD;&#xA;&#xD;&#xA;I had assume (wrong) that this 4K was because I still included Serial.print which when over the USB's CDC on the Leo. But I see after a memory dump of an empty sketch they are still there.&#xD;&#xA;&#xD;&#xA;    C:\Users\mflaga\AppData\Local\Temp\build8958339595868119500.tmp&gt;avr-objdump -d sketch_feb13a.cpp.elf &gt; sketch_feb13a.cpp.elf.lst&#xD;&#xA;&#xD;&#xA;Which makes sense. As the Leonardo still requires the USB-CDC client (the 4K) as to detect the 1200 Baud connect from AVR-DUDE as to stroke the remote reboot.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Hence making a custom boards.txt without USB in the build, also needs to have&#xD;&#xA;&#xD;&#xA;    leonardo.upload.use_1200bps_touch=true&#xD;&#xA;&#xD;&#xA;removed.&#xD;&#xA;&#xD;&#xA;Once loaded on the target, this would require the upload to be synchronized with a manual reset of the target. As the ability to remote reboot is lost." />
  <row Id="474" PostHistoryTypeId="2" PostId="210" RevisionGUID="c80488a2-eaf7-46c7-a91e-7adc1d10a6dd" CreationDate="2014-02-14T15:08:09.547" UserId="42" Text="According to the [Arduino reference for `analogWrite()`][1], the PWM frequency on most pins is ~490 Hz. However, it's ~980 Hz for pins 5 and 6 on the Uno, and for pins 3 and 11 on the Leonardo.&#xD;&#xA;&#xD;&#xA;Why are these different? Is it a deliberate design feature, or is it somehow dictated by the hardware?&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/AnalogWrite" />
  <row Id="475" PostHistoryTypeId="1" PostId="210" RevisionGUID="c80488a2-eaf7-46c7-a91e-7adc1d10a6dd" CreationDate="2014-02-14T15:08:09.547" UserId="42" Text="Why do some pins have a different PWM frequency?" />
  <row Id="476" PostHistoryTypeId="3" PostId="210" RevisionGUID="c80488a2-eaf7-46c7-a91e-7adc1d10a6dd" CreationDate="2014-02-14T15:08:09.547" UserId="42" Text="&lt;uno&gt;&lt;arduino-leonardo&gt;&lt;pwm&gt;&lt;analogwrite&gt;" />
  <row Id="477" PostHistoryTypeId="2" PostId="211" RevisionGUID="2cbedae9-a2a8-4bcf-90cb-803dbaa9f7f3" CreationDate="2014-02-14T15:57:57.027" UserId="83" Text="I am not aware of the design considerations, but if you check the datasheet for the microcontroller on your Arduino, you will notice that PWM pins are grouped together and per group connected to a timer. The speed at which this timer is increased varies by the configured prescaler. If you change the prescaler for a certain timer, you change the PWM frequency for the related PWM pins. I believe some timers double for other purposes like the `millis();` function. If you change the prescaler for that timer, values returned by `millis()` will be off by the same factor.&#xD;&#xA;&#xD;&#xA;You can calculate the setting for the prescaler as follows:&#xD;&#xA;&#xD;&#xA;$$\text{prescaler} = \dfrac{f_{CPU}}{PWMresolution × f_{PWM}} = \dfrac{16\text{MHz}}{256×490} \approx 128$$&#xD;&#xA;&#xD;&#xA;Check the datasheet and you'll find that 128 is indeed one of the prescaler values you can select." />
  <row Id="478" PostHistoryTypeId="2" PostId="212" RevisionGUID="65b9f6a5-6250-4dd8-a768-eb601a56f655" CreationDate="2014-02-14T16:00:19.090" UserId="46" Text="Considering the Uno, each of the 3 pairs of PWM pins is tied to one timer, as follows:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 are paired on timer0&#xD;&#xA;* Pins 9 and 10 are paired on timer1&#xD;&#xA;* Pins 3 and 11 are paired on timer2&#xD;&#xA;&#xD;&#xA;Timer2 has a different set of prescaling (divisors) than the other two. That's why the PWM frequency achieved with it is different than the other two pairs.&#xD;&#xA;&#xD;&#xA;My sources:&#xD;&#xA;&#xD;&#xA;http://playground.arduino.cc/Code/PwmFrequency&#xD;&#xA;http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM&#xD;&#xA;http://arduino.cc/en/Tutorial/PWM&#xD;&#xA;" />
  <row Id="479" PostHistoryTypeId="12" PostId="212" RevisionGUID="7bcc1ffc-adcd-48dd-a907-4ebbda55afcb" CreationDate="2014-02-14T16:01:51.927" UserId="46" Comment="via Vote" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:46,&quot;DisplayName&quot;:&quot;Ricardo&quot;}]}" />
  <row Id="480" PostHistoryTypeId="13" PostId="212" RevisionGUID="9e9fd066-4204-4225-b77e-27e6f9ef19b2" CreationDate="2014-02-14T16:02:19.770" UserId="46" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:46,&quot;DisplayName&quot;:&quot;Ricardo&quot;}]}" />
  <row Id="481" PostHistoryTypeId="5" PostId="211" RevisionGUID="eb631f2b-207f-4e14-a3aa-a9f09723bb5c" CreationDate="2014-02-14T16:09:15.693" UserId="83" Comment="added 83 characters in body" Text="I am not aware of the design considerations, but if you check the datasheet for the microcontroller on your Arduino, you will notice that PWM pins are grouped together and per group connected to a timer. The speed at which this timer is increased varies by the configured prescaler. If you change the prescaler for a certain timer, you change the PWM frequency for the related PWM pins. I believe some timers double for other purposes like the `millis();` function. If you change the prescaler for that timer, values returned by `millis()` will be off by the same factor.&#xD;&#xA;&#xD;&#xA;You can calculate the setting for the prescaler as follows:&#xD;&#xA;&#xD;&#xA;$$\text{prescaler} = \dfrac{f_{CPU}}{PWMresolution × f_{PWM}} = \dfrac{16\text{MHz}}{256×490} \approx 128$$&#xD;&#xA;&#xD;&#xA;&gt; prescaler = f[CPU]/(PWMresolution×f[PWM]) = 16000000/(256×490) = approx 128. &#xD;&#xA;&#xD;&#xA;Check the datasheet and you'll find that 128 is indeed one of the prescaler values you can select." />
  <row Id="482" PostHistoryTypeId="5" PostId="212" RevisionGUID="e6efb402-120f-46a2-91e4-4889aa64354d" CreationDate="2014-02-14T16:11:25.717" UserId="46" Comment="added 652 characters in body" Text="I don't think these are the only frequencies you can set for the PWM signals. It's a bit more complex than that.&#xD;&#xA;&#xD;&#xA;I don't know exactly, but here is my attempt at it. From what I can gather from the sources at the end of this message, each of the 3 pairs of PWM pins is tied to one timer, each of which has its own base frequency, as follows:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 are paired on timer0, with base frequency of 62500Hz&#xD;&#xA;* Pins 9 and 10 are paired on timer1, with base frequency of 31250Hz&#xD;&#xA;* Pins 3 and 11 are paired on timer2, with base frequency of 31250Hz&#xD;&#xA;&#xD;&#xA;Then each set of pins have a number of prescaler values that can be chosen, that will divide the base frequency of that pair of pins. The prescaler values available are:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 have prescaler values of 1, 8, 64, 256, and 1024&#xD;&#xA;* Pins 9 and 10 have prescaler values of 1, 8, 64, 256, and 1024&#xD;&#xA;* Pins 3 and 11 have prescaler values of 1, 8, 32, 64, 128, 256, and 1024&#xD;&#xA;&#xD;&#xA;The different combinations yield different frequencies in a given PWM pin. Notice that timer 2 (tied to pins 3 and 11) have ore prescaler values available, thus answering the OP's question.&#xD;&#xA;&#xD;&#xA;Now, why timer 2 is different, that's a separate question.&#xD;&#xA;&#xD;&#xA;My sources:&#xD;&#xA;&#xD;&#xA;* http://playground.arduino.cc/Code/PwmFrequency&#xD;&#xA;* http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM&#xD;&#xA;* http://arduino.cc/en/Tutorial/PWM&#xD;&#xA;" />
  <row Id="483" PostHistoryTypeId="5" PostId="212" RevisionGUID="9dd90710-feae-497f-9194-408d01f86114" CreationDate="2014-02-14T16:20:04.300" UserId="46" Comment="added 8 characters in body" Text="I don't think these are the only frequencies you can set for the PWM signals. It's a bit more complex than that.&#xD;&#xA;&#xD;&#xA;I don't know exactly, but here is my attempt at it. From what I can gather from the sources at the end of this message, each of the 3 pairs of PWM pins is tied to one timer, each of which has its own base frequency, as follows:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 are paired on timer0, with base frequency of 62500Hz&#xD;&#xA;* Pins 9 and 10 are paired on timer1, with base frequency of 31250Hz&#xD;&#xA;* Pins 3 and 11 are paired on timer2, with base frequency of 31250Hz&#xD;&#xA;&#xD;&#xA;Then each set of pins have a number of prescaler values that can be chosen, that will divide the base frequency of that pair of pins. The prescaler values available are:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 have prescaler values of 1, 8, 64, 256, and 1024&#xD;&#xA;* Pins 9 and 10 have prescaler values of 1, 8, 64, 256, and 1024&#xD;&#xA;* Pins 3 and 11 have prescaler values of 1, 8, 32, 64, 128, 256, and 1024&#xD;&#xA;&#xD;&#xA;The different combinations yield different frequencies in a given PWM pin. Notice that timer 2 (tied to pins 3 and 11) have more prescaler values available, resulting in more frequencies available.&#xD;&#xA;&#xD;&#xA;Now, why timer 2 is different, that's a separate question.&#xD;&#xA;&#xD;&#xA;My sources:&#xD;&#xA;&#xD;&#xA;* http://playground.arduino.cc/Code/PwmFrequency&#xD;&#xA;* http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM&#xD;&#xA;* http://arduino.cc/en/Tutorial/PWM&#xD;&#xA;" />
  <row Id="484" PostHistoryTypeId="5" PostId="212" RevisionGUID="76bd85d6-cb87-423d-a5e6-443aa79958c5" CreationDate="2014-02-14T16:50:22.300" UserId="46" Comment="deleted 2 characters in body" Text="I don't think these are the only frequencies you can set for the PWM signals. Those seem to be the defaults. &#xD;&#xA;&#xD;&#xA;I don't know for sure, but here is my attempt at it. From what I can gather from the sources at the end of this message, each of the 3 pairs of PWM pins is tied to one timer, each of which has its own base frequency, as follows:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 are paired on timer0, with base frequency of 62500Hz&#xD;&#xA;* Pins 9 and 10 are paired on timer1, with base frequency of 31250Hz&#xD;&#xA;* Pins 3 and 11 are paired on timer2, with base frequency of 31250Hz&#xD;&#xA;&#xD;&#xA;Then each set of pins have a number of prescaler values that can be chosen, that will divide the base frequency of that pair of pins. The prescaler values available are:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 have prescaler values of 1, 8, 64, 256, and 1024&#xD;&#xA;* Pins 9 and 10 have prescaler values of 1, 8, 64, 256, and 1024&#xD;&#xA;* Pins 3 and 11 have prescaler values of 1, 8, 32, 64, 128, 256, and 1024&#xD;&#xA;&#xD;&#xA;The different combinations yield different frequencies in a given PWM pin. Notice that timer 2 (tied to pins 3 and 11) have more prescaler values available, resulting in more frequencies available.&#xD;&#xA;&#xD;&#xA;Now, why timer 2 is different, that's a separate question.&#xD;&#xA;&#xD;&#xA;My sources:&#xD;&#xA;&#xD;&#xA;* http://playground.arduino.cc/Code/PwmFrequency&#xD;&#xA;* http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM&#xD;&#xA;* http://arduino.cc/en/Tutorial/PWM&#xD;&#xA;" />
  <row Id="485" PostHistoryTypeId="5" PostId="212" RevisionGUID="5baeba46-1d8b-492a-a141-5a7ea2ce5d74" CreationDate="2014-02-14T17:00:16.123" UserId="46" Comment="deleted 2 characters in body" Text="I don't think these are the only frequencies you can set for the PWM signals. Those seem to be the defaults. &#xD;&#xA;&#xD;&#xA;I don't know for sure, but here is my attempt at it. From what I can gather from the sources at the end of this message, each of the 3 pairs of PWM pins is tied to one timer, each of which has its own base frequency, as follows:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 are paired on timer0, with base frequency of 62500Hz&#xD;&#xA;* Pins 9 and 10 are paired on timer1, with base frequency of 31250Hz&#xD;&#xA;* Pins 3 and 11 are paired on timer2, with base frequency of 31250Hz&#xD;&#xA;&#xD;&#xA;Then each set of pins have a number of prescaler values that can be chosen, that will divide the base frequency of that pair of pins. The prescaler values available are:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 have prescaler values of 1, 8, 64, 256, and 1024&#xD;&#xA;* Pins 9 and 10 have prescaler values of 1, 8, 64, 256, and 1024&#xD;&#xA;* Pins 3 and 11 have prescaler values of 1, 8, 32, 64, 128, 256, and 1024&#xD;&#xA;&#xD;&#xA;The different combinations yield different frequencies in a given PWM pin. Notice that timer 2 (tied to pins 3 and 11) have more prescaler values available, resulting in more frequencies available.&#xD;&#xA;&#xD;&#xA;Now, why timer 2 is different, that's a separate question.&#xD;&#xA;&#xD;&#xA;Edit: Here's a list of possible PWM frequencies per pin (from [this article](http://arduino-info.wikispaces.com/Arduino-PWM-Frequency)):&#xD;&#xA;&#xD;&#xA;&gt; For pins 6 and 5 (OC0A and OC0B):&#xD;&#xA;&#xD;&#xA;&gt; * If TCCR0B = xxxxx001, frequency is 64kHz&#xD;&#xA;&gt; * If TCCR0B = xxxxx010, frequency is 8 kHz&#xD;&#xA;&gt; * If TCCR0B = xxxxx011, frequency is 1kHz (this is the default from the Diecimila bootloader)&#xD;&#xA;&gt; * If TCCR0B = xxxxx100, frequency is 250Hz&#xD;&#xA;&gt; * If TCCR0B = xxxxx101, frequency is 62.5 Hz&#xD;&#xA; &#xD;&#xA;&gt; For pins 9, 10, 11 and 3 (OC1A, OC1B, OC2A, OC2B):&#xD;&#xA;&#xD;&#xA;&gt; * If TCCRnB = xxxxx001, frequency is 32kHz&#xD;&#xA;&gt; * If TCCRnB = xxxxx010, frequency is 4 kHz&#xD;&#xA;&gt; * If TCCRnB = xxxxx011, frequency is 500Hz (this is the default from the Diecimila bootloader)&#xD;&#xA;&gt; * If TCCRnB = xxxxx100, frequency is 125Hz&#xD;&#xA;&gt; * If TCCRnB = xxxxx101, frequency is 31.25 Hz &#xD;&#xA;&#xD;&#xA;`TCCRnB` is where you set the prescaler bits for timer `n`, replacing `n` by 0, 1 or 2, depending on the timer you want it set. If you still have now clue what that means, read this [bit math tutorial](http://playground.arduino.cc/Code/BitMath).&#xD;&#xA;&#xD;&#xA;My sources:&#xD;&#xA;&#xD;&#xA;* http://playground.arduino.cc/Code/PwmFrequency&#xD;&#xA;* http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM&#xD;&#xA;* http://arduino.cc/en/Tutorial/PWM&#xD;&#xA;* http://arduino-info.wikispaces.com/Arduino-PWM-Frequency&#xD;&#xA;" />
  <row Id="486" PostHistoryTypeId="5" PostId="201" RevisionGUID="c2e97430-d35b-4226-9304-c0188cee43e1" CreationDate="2014-02-14T17:01:19.930" UserId="65" Comment="Code correction; Github link added" Text="`ardprintf` is a function that I hacked together which simulates `printf` over the serial connection. This function (given at the bottom) can be pasted in the beginning of the files where the function is needed. It should not create any conflicts.&#xD;&#xA;&#xD;&#xA;It can be called similar to `printf`. See it in action in this example:&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      int l=2;&#xD;&#xA;      char *j = &quot;test&quot;;&#xD;&#xA;      long k = 123456789;&#xD;&#xA;      char s = 'g';&#xD;&#xA;      float f = 2.3;&#xD;&#xA;    &#xD;&#xA;      ardprintf(&quot;test %d %l %c %s %f&quot;, l, k, s, j, f);&#xD;&#xA;    &#xD;&#xA;      delay(5000);&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The output as expected is:&#xD;&#xA;&#xD;&#xA;    test 2 123456789 g test 2.30&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;The function prototype is:&#xD;&#xA;&#xD;&#xA;    int ardprintf(char *, ...);&#xD;&#xA;&#xD;&#xA;It returns the number of arguments detected in the function call. &#xD;&#xA;&#xD;&#xA;This is the function definition:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #ifndef ARDPRINTF&#xD;&#xA;    #define ARDPRINTF&#xD;&#xA;    #define ARDBUFFER 16&#xD;&#xA;    #include &lt;stdarg.h&gt;&#xD;&#xA;    #include &lt;Arduino.h&gt;&#xD;&#xA;&#xD;&#xA;    int ardprintf(char *str, ...)&#xD;&#xA;    {&#xD;&#xA;      int i, count=0, j=0, flag=0;&#xD;&#xA;      char temp[ARDBUFFER+1];&#xD;&#xA;      for(i=0; str[i]!='\0';i++)  if(str[i]=='%')  count++;&#xD;&#xA;      &#xD;&#xA;      va_list argv;&#xD;&#xA;      va_start(argv, count);&#xD;&#xA;      for(i=0,j=0; str[i]!='\0';i++)&#xD;&#xA;      {&#xD;&#xA;        if(str[i]=='%')&#xD;&#xA;        {&#xD;&#xA;          temp[j] = '\0';&#xD;&#xA;          Serial.print(temp);&#xD;&#xA;          j=0;&#xD;&#xA;          temp[0] = '\0';&#xD;&#xA;          &#xD;&#xA;          switch(str[++i])&#xD;&#xA;          {&#xD;&#xA;            case 'd': Serial.print(va_arg(argv, int));&#xD;&#xA;                      break;&#xD;&#xA;            case 'l': Serial.print(va_arg(argv, long));&#xD;&#xA;                      break;&#xD;&#xA;            case 'f': Serial.print(va_arg(argv, double));&#xD;&#xA;                      break;&#xD;&#xA;            case 'c': Serial.print((char)va_arg(argv, int));&#xD;&#xA;                      break;&#xD;&#xA;            case 's': Serial.print(va_arg(argv, char *));&#xD;&#xA;                      break;&#xD;&#xA;            default:  ;&#xD;&#xA;          };&#xD;&#xA;        }&#xD;&#xA;        else &#xD;&#xA;        {&#xD;&#xA;          temp[j] = str[i];&#xD;&#xA;          j = (j+1)%ARDBUFFER;&#xD;&#xA;          if(j==0) &#xD;&#xA;          {&#xD;&#xA;            temp[ARDBUFFER] = '\0';&#xD;&#xA;            Serial.print(temp);&#xD;&#xA;            temp[0]='\0';&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      };&#xD;&#xA;      Serial.println();&#xD;&#xA;      return count + 1;&#xD;&#xA;    }&#xD;&#xA;    #undef ARDBUFFER&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;**To print the `%` character, use `%%`.*&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Now, available on [Github gists][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://gist.github.com/AsheeshR/9004783" />
  <row Id="488" PostHistoryTypeId="5" PostId="212" RevisionGUID="3a3f2feb-6c1a-4b76-bc52-0c71529d167d" CreationDate="2014-02-14T17:07:03.013" UserId="46" Comment="deleted 2 characters in body" Text="These aren't the only frequencies for the PWM signals. Those are just the defaults set by the bootloader.&#xD;&#xA;&#xD;&#xA;Each of the 3 pairs of PWM pins is tied to one timer, each of which has its own base frequency, as follows:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 are paired on timer0, with base frequency of 62500Hz&#xD;&#xA;* Pins 9 and 10 are paired on timer1, with base frequency of 31250Hz&#xD;&#xA;* Pins 3 and 11 are paired on timer2, with base frequency of 31250Hz&#xD;&#xA;&#xD;&#xA;Then each set of pins have a number of prescaler values that can be chosen, that will divide the base frequency of that pair of pins. The prescaler values available are:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 have prescaler values of 1, 8, 64, 256, and 1024&#xD;&#xA;* Pins 9 and 10 have prescaler values of 1, 8, 64, 256, and 1024&#xD;&#xA;* Pins 3 and 11 have prescaler values of 1, 8, 32, 64, 128, 256, and 1024&#xD;&#xA;&#xD;&#xA;The different combinations yield different frequencies in a given PWM pin. Notice that timer 2 (tied to pins 3 and 11) have more prescaler values available, resulting in more frequencies available.&#xD;&#xA;&#xD;&#xA;Now, why timer 2 is different, that's a separate question.&#xD;&#xA;&#xD;&#xA;Edit: Here's a list of possible PWM frequencies per pin (from [this article](http://arduino-info.wikispaces.com/Arduino-PWM-Frequency)):&#xD;&#xA;&#xD;&#xA;&gt; For pins 6 and 5 (OC0A and OC0B):&#xD;&#xA;&#xD;&#xA;&gt; * If TCCR0B = xxxxx001, frequency is 64kHz&#xD;&#xA;&gt; * If TCCR0B = xxxxx010, frequency is 8 kHz&#xD;&#xA;&gt; * If TCCR0B = xxxxx011, frequency is 1kHz (this is the default from the Diecimila bootloader)&#xD;&#xA;&gt; * If TCCR0B = xxxxx100, frequency is 250Hz&#xD;&#xA;&gt; * If TCCR0B = xxxxx101, frequency is 62.5 Hz&#xD;&#xA; &#xD;&#xA;&gt; For pins 9, 10, 11 and 3 (OC1A, OC1B, OC2A, OC2B):&#xD;&#xA;&#xD;&#xA;&gt; * If TCCRnB = xxxxx001, frequency is 32kHz&#xD;&#xA;&gt; * If TCCRnB = xxxxx010, frequency is 4 kHz&#xD;&#xA;&gt; * If TCCRnB = xxxxx011, frequency is 500Hz (this is the default from the Diecimila bootloader)&#xD;&#xA;&gt; * If TCCRnB = xxxxx100, frequency is 125Hz&#xD;&#xA;&gt; * If TCCRnB = xxxxx101, frequency is 31.25 Hz &#xD;&#xA;&#xD;&#xA;`TCCRnB` is where you set the prescaler bits for timer `n`, replacing `n` by 0, 1 or 2, depending on the timer you want it set. If you still have now clue what that means, read this [bit math tutorial](http://playground.arduino.cc/Code/BitMath).&#xD;&#xA;&#xD;&#xA;My sources:&#xD;&#xA;&#xD;&#xA;* http://playground.arduino.cc/Code/PwmFrequency&#xD;&#xA;* http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM&#xD;&#xA;* http://arduino.cc/en/Tutorial/PWM&#xD;&#xA;* http://arduino-info.wikispaces.com/Arduino-PWM-Frequency&#xD;&#xA;&#xD;&#xA;Note that there seems to be divergence in those sources about whether pins 9 and 10 have the same behavior as 5 and 6 or 3 and 11, but you get the idea anyway. I'm reading the datashet to try and figure out which is correct, or whether this is a difference between boards.&#xD;&#xA;" />
  <row Id="492" PostHistoryTypeId="2" PostId="213" RevisionGUID="8f2691df-b5d7-4d57-afa6-6e8a09448d3b" CreationDate="2014-02-14T19:15:02.077" UserId="-1" Text="" />
  <row Id="493" PostHistoryTypeId="2" PostId="214" RevisionGUID="17fc9496-c352-4c3b-abe7-be8dad1531d7" CreationDate="2014-02-14T19:15:02.077" UserId="-1" Text="" />
  <row Id="494" PostHistoryTypeId="2" PostId="215" RevisionGUID="0081e5d4-60bb-4e70-86e7-404ecda94fe2" CreationDate="2014-02-14T21:24:19.817" UserId="46" Text="First, a caveat. I'm a bit of a begginner in Arduino and AVR MCUs, so there is probably something innacurate in what I'll say. If that's the case, feel free to just edit, criticize or downvote. In any case, I wanted to go into a little more detail than others have gone with their ansewers.&#xD;&#xA;&#xD;&#xA;So, let's see a few examples of what can go wrong.&#xD;&#xA;&#xD;&#xA;# Uninitialized variables #&#xD;&#xA;&#xD;&#xA;    int status;&#xD;&#xA;    pinMode(13, OUTPUT);&#xD;&#xA;    digitalWrite(13, status);&#xD;&#xA;&#xD;&#xA;This problem is pretty harmless, but nobody knows whether the LED will light up or not. The value of variable `status` will be whatever happens to be the value that memory position was initialized with. But it's not defined in your program.&#xD;&#xA;&#xD;&#xA;# Memory overflow #&#xD;&#xA;&#xD;&#xA;    int array[10];&#xD;&#xA;    int v = array[100];&#xD;&#xA;    array[-100] = 10;&#xD;&#xA;&#xD;&#xA;The first problem here is that you don't know what will be assigned to v, but worse is that you don't know what you messed up with the assignment to position -100 of `array`. The good news is that you only messed up with RAM and not with the EEPROM, thus your program is safe.&#xD;&#xA;&#xD;&#xA;# Jump to an illegal instruction #&#xD;&#xA;&#xD;&#xA;    void doSomething( void ) { &#xD;&#xA;        for (int i = 0; i &lt; 1000; i++); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void setup () &#xD;&#xA;    {&#xD;&#xA;        void (*funcPtr)( void );&#xD;&#xA;&#xD;&#xA;        funcPtr = &amp;doSomething;&#xD;&#xA;        funcPtr(); // calls doSomething();&#xD;&#xA;&#xD;&#xA;        funcPtr = NULL;&#xD;&#xA;        funcPtr(); // undefined behavior&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The first call to `funcPtr()` will actually be a call to `doSomething()`. The second one will lead to undefined behavior. It will probably continue execution from memory address 0. What's there? The bootloader begins there? I don't know, need to read the compiler fine print. But certainly it is not the intended behavior. &#xD;&#xA;&#xD;&#xA;# Other bad things that may happen #&#xD;&#xA;&#xD;&#xA;Well, you can run out of RAM, for example. What else. In any case, I think your program will keep running, probably not the way you intended it to.&#xD;&#xA;&#xD;&#xA;# Summary #&#xD;&#xA;&#xD;&#xA;In computer systems, problems like these are usually dealt with at various levels:&#xD;&#xA;&#xD;&#xA;1. By the compiler&#xD;&#xA;1. By the programming language runtime (as in Java for example). &#xD;&#xA;1. By the operating system or the processor (if your memory access a position outside the boundaries of the address space reserved to your program, the OS or the processor may have safety mechanisms to prevent that)&#xD;&#xA;&#xD;&#xA;Arduinos only have only limited protection of the compiler, and probably nothing else. The good news is that they aren't multi-tasked, so the only program being affected is yours. In any case, any of those bugs will lead to erratic behavior.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="495" PostHistoryTypeId="2" PostId="216" RevisionGUID="512c911c-4bcd-4871-84b5-7f1b847b5f59" CreationDate="2014-02-14T21:32:13.740" UserId="-1" Text="" />
  <row Id="496" PostHistoryTypeId="2" PostId="217" RevisionGUID="53012f31-278b-4f94-94ba-a19b9c8e3acc" CreationDate="2014-02-14T21:32:13.740" UserId="-1" Text="" />
  <row Id="497" PostHistoryTypeId="5" PostId="215" RevisionGUID="4cf8c9a0-8c34-422b-94bf-8aea48790e48" CreationDate="2014-02-14T22:12:24.110" UserId="46" Comment="Added answers more clearly." Text="First, a caveat. I'm a bit of a begginner in Arduino and AVR MCUs, so there is probably something innacurate in what I'll say. If that's the case, feel free to just edit, criticize or downvote. In any case, I wanted to go into a little more detail than others have gone with their ansewers.&#xD;&#xA;&#xD;&#xA;So, let's see a few examples of what can go wrong.&#xD;&#xA;&#xD;&#xA;# Uninitialized variables #&#xD;&#xA;&#xD;&#xA;    int status;&#xD;&#xA;    pinMode(13, OUTPUT);&#xD;&#xA;    digitalWrite(13, status);&#xD;&#xA;&#xD;&#xA;This problem is pretty harmless, but nobody knows whether the LED will light up or not. The value of variable `status` will be whatever happens to be the value that memory position was initialized with. But it's not defined in your program.&#xD;&#xA;&#xD;&#xA;# Memory overflow #&#xD;&#xA;&#xD;&#xA;    int array[10];&#xD;&#xA;    int v = array[100];&#xD;&#xA;    array[-100] = 10;&#xD;&#xA;&#xD;&#xA;The first problem here is that you don't know what will be assigned to v, but worse is that you don't know what you messed up with the assignment to position -100 of `array`. The good news is that you only messed up with RAM and not with the EEPROM, thus your program is safe.&#xD;&#xA;&#xD;&#xA;# Jump to an illegal instruction #&#xD;&#xA;&#xD;&#xA;    void doSomething( void ) { &#xD;&#xA;        for (int i = 0; i &lt; 1000; i++); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void setup () &#xD;&#xA;    {&#xD;&#xA;        void (*funcPtr)( void );&#xD;&#xA;&#xD;&#xA;        funcPtr = &amp;doSomething;&#xD;&#xA;        funcPtr(); // calls doSomething();&#xD;&#xA;&#xD;&#xA;        funcPtr = NULL;&#xD;&#xA;        funcPtr(); // undefined behavior&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The first call to `funcPtr()` will actually be a call to `doSomething()`. The second one will lead to undefined behavior. It will probably continue execution from memory address 0. What's there? The bootloader begins there? I don't know, need to read the compiler fine print. But certainly it is not the intended behavior. &#xD;&#xA;&#xD;&#xA;# Other bad things that may happen #&#xD;&#xA;&#xD;&#xA;Well, you can run out of RAM, for example. What else. In any case, I think your program will keep running, probably not the way you intended it to.&#xD;&#xA;&#xD;&#xA;# Kinds of Protection #&#xD;&#xA;&#xD;&#xA;In computer systems, problems like these are usually dealt with at various levels:&#xD;&#xA;&#xD;&#xA;1. By the compiler&#xD;&#xA;1. By the programming language runtime (as in Java for example). &#xD;&#xA;1. By the operating system or the processor (if your memory access a position outside the boundaries of the address space reserved to your program, the OS or the processor may have safety mechanisms to prevent that)&#xD;&#xA;&#xD;&#xA;Arduinos only have only limited protection of the compiler, and probably nothing else. The good news is that they aren't multi-tasked, so the only program being affected is yours. In any case, any of those bugs will lead to erratic behavior.&#xD;&#xA;&#xD;&#xA;# The Answers #&#xD;&#xA;&#xD;&#xA;The assumptions are the all of the problems I stated above are runtime problems.&#xD;&#xA;&#xD;&#xA;&gt; What happens if there is a runtime error in a program? &#xD;&#xA;&#xD;&#xA;The program will continue and what will happen depends on the side-effects of the runtime error. A call to the null function pointer will probably (yes, I'm guessing) make the program jump to an unknown location. The assignment of an undetermined value to a variable will cause your program to use that value as a valid one, and gosh knows what it will do with that.&#xD;&#xA;&#xD;&#xA;&gt; Will execution of the program just stop?&#xD;&#xA;&#xD;&#xA;No, it will keep going, probably doing what you didn't intend it to do. It may reset or act erractically. It may turn some inputs into outputs and burn a sensor or two (well, that may be a bit unlikely, admittedly).&#xD;&#xA;&#xD;&#xA;&gt; Is there some way I get get the Arduino to tell me what the error is?&#xD;&#xA;&#xD;&#xA;I don't think so. As I said earlier, the protection mechanisms aren't there. You have to be careful with your program. You must set your own safety nets. The reason is probably because Arduino controllers are too cheap, have too little memory, and should not run anything too important for that (yes, there seems to be a disclaimer by AVR for you not to use those particular MCUs in life support systems).&#xD;&#xA;&#xD;&#xA;" />
  <row Id="498" PostHistoryTypeId="5" PostId="215" RevisionGUID="a5af9566-0955-472b-9f84-17d6a180256f" CreationDate="2014-02-14T22:20:15.790" UserId="46" Comment="Added answers more clearly." Text="First, a caveat. I'm a bit of a begginner in Arduino and AVR MCUs, so there is probably something innacurate in what I'll say. If that's the case, feel free to just edit, criticize or downvote. In any case, I wanted to go into a little more detail than others have gone with their ansewers.&#xD;&#xA;&#xD;&#xA;So, let's see a few examples of what can go wrong.&#xD;&#xA;&#xD;&#xA;# Uninitialized variables #&#xD;&#xA;&#xD;&#xA;    int status;&#xD;&#xA;    pinMode(13, OUTPUT);&#xD;&#xA;    digitalWrite(13, status);&#xD;&#xA;&#xD;&#xA;This problem is pretty harmless, but nobody knows whether the LED will light up or not. The value of variable `status` will be whatever happens to be the value that memory position was initialized with. But it's not defined in your program.&#xD;&#xA;&#xD;&#xA;# Memory overflow #&#xD;&#xA;&#xD;&#xA;    int array[10];&#xD;&#xA;    int v = array[100];&#xD;&#xA;    array[-100] = 10;&#xD;&#xA;&#xD;&#xA;The first problem here is that you don't know what will be assigned to v, but worse is that you don't know what you messed up with the assignment to position -100 of `array`. The good news is that you only messed up with RAM and not with the EEPROM, thus your program is safe.&#xD;&#xA;&#xD;&#xA;# Jump to an illegal instruction #&#xD;&#xA;&#xD;&#xA;    void doSomething( void ) { &#xD;&#xA;        for (int i = 0; i &lt; 1000; i++); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void setup () &#xD;&#xA;    {&#xD;&#xA;        void (*funcPtr)( void );&#xD;&#xA;&#xD;&#xA;        funcPtr = &amp;doSomething;&#xD;&#xA;        funcPtr(); // calls doSomething();&#xD;&#xA;&#xD;&#xA;        funcPtr = NULL;&#xD;&#xA;        funcPtr(); // undefined behavior&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The first call to `funcPtr()` will actually be a call to `doSomething()`. The second one will lead to undefined behavior. It will probably continue execution from memory address 0. What's there? The bootloader begins there? I don't know, need to read the compiler fine print. But certainly it is not the intended behavior. &#xD;&#xA;&#xD;&#xA;# Other bad things that may happen #&#xD;&#xA;&#xD;&#xA;Well, you can run out of RAM, for example. What else. In any case, I think your program will keep running, probably not the way you intended it to.&#xD;&#xA;&#xD;&#xA;# Kinds of Protection #&#xD;&#xA;&#xD;&#xA;In computer systems, problems like these are usually dealt with at various levels:&#xD;&#xA;&#xD;&#xA;1. By the compiler&#xD;&#xA;1. By the programming language runtime (as in Java for example). &#xD;&#xA;1. By the operating system or the processor (if your memory access a position outside the boundaries of the address space reserved to your program, the OS or the processor may have safety mechanisms to prevent that)&#xD;&#xA;&#xD;&#xA;Arduinos only have only limited protection of the compiler, and probably nothing else. The good news is that they aren't multi-tasked, so the only program being affected is yours. In any case, any of those bugs will lead to erratic behavior.&#xD;&#xA;&#xD;&#xA;# The Answers #&#xD;&#xA;&#xD;&#xA;The assumptions are the all of the problems I stated above are runtime problems.&#xD;&#xA;&#xD;&#xA;&gt; What happens if there is a runtime error in a program? &#xD;&#xA;&#xD;&#xA;The program will continue and what happens will depend on the side-effects of the runtime error. A call to the null function pointer will probably (yes, I'm guessing) make the program jump to an unknown location. The assignment of an undetermined value to a variable will cause your program to use that value as a valid one, and gosh knows what it will do with that.&#xD;&#xA;&#xD;&#xA;&gt; Will execution of the program just stop?&#xD;&#xA;&#xD;&#xA;No, it will keep going as if nothing extraordinary happened, probably doing what you didn't intend it to do. It may reset or act erractically. It may turn some inputs into outputs and burn a sensor or two (well, that may be a bit unlikely, admittedly).&#xD;&#xA;&#xD;&#xA;&gt; Is there some way I get the Arduino to tell me what the error is?&#xD;&#xA;&#xD;&#xA;I don't think so. As I said earlier, the protection mechanisms aren't there. There's no runtime support from the language, no OS, no hardware checks for out-of-bounds memory access (the bootloader doesn't count as either). You just have to be careful with your program and probably set your own safety nets. &#xD;&#xA;&#xD;&#xA;The reason for the lack of protection is probably because Arduino controllers are too cheap, have too little memory, and should not run anything too important (yes, there seems to be a disclaimer by AVR somewhere for you not to use the MCUs normally used by Arduino in life support systems).&#xD;&#xA;&#xD;&#xA;" />
  <row Id="500" PostHistoryTypeId="5" PostId="172" RevisionGUID="71eb9524-0a8d-4895-be88-03a99ac20aed" CreationDate="2014-02-14T22:24:08.177" UserId="8" Comment="added images" Text="There are jumper wires that have a female header on one end and a male header on the other. Example: https://www.sparkfun.com/products/9140&#xD;&#xA;&#xD;&#xA;![jumper wires][1]&#xD;&#xA;&#xD;&#xA;You could also attatch several wired to a strip of breakaway female headers, such as https://www.sparkfun.com/products/115&#xD;&#xA;&#xD;&#xA;![headers][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/lyllM.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/cdMeO.png" />
  <row Id="501" PostHistoryTypeId="2" PostId="218" RevisionGUID="36576b19-d0d6-4e86-9215-57ba33f42737" CreationDate="2014-02-14T22:44:35.220" UserId="46" Text="This is a [cross-post from EE.SE][1]. I posted this question there but didn't attract much attention, so I wanted to see if anyone from our community had a similar experience.&#xD;&#xA;&#xD;&#xA;Sometime in the past, I was burning bootloaders on a fresh batch of four **ATmega328-PU** using the Arduino IDE (notice there's no **P** after 328 - it's the slightly cheaper non-picopower version of the MCU, not to be confused with the **ATmega328P-PU** with a **P**), and was surprised with the following message from avrdude:&#xD;&#xA;&#xD;&#xA;    avrdude: Device signature = 0x1e950F &#xD;&#xA;    avrdude: Expected signature for ATMEGA328 is 1E 95 14 &#xD;&#xA;    Double check chip, or use -F to override this check. &#xD;&#xA;&#xD;&#xA;That means avrdude thought the chip was not what its label said.&#xD;&#xA;&#xD;&#xA;Then I changed the chip type on my Arduino IDE to **ATmega328P-PU** and avrdude burned the bootloader without complaints.&#xD;&#xA;&#xD;&#xA;What that means is that the chip was lebelled as one MCU and internally it responded as another, slightly different.&#xD;&#xA;&#xD;&#xA;So, my question is: **how rare this event is? Has anyone had a similar experience?** Please report it in your answer.&#xD;&#xA;&#xD;&#xA;Some folks at EE.SE thought it could be a counterfeit, but I disagree, because I got a more expensive MCU for less money. How would that be lucrative?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://electronics.stackexchange.com/questions/90692/mislabelled-atmega328-pu" />
  <row Id="502" PostHistoryTypeId="1" PostId="218" RevisionGUID="36576b19-d0d6-4e86-9215-57ba33f42737" CreationDate="2014-02-14T22:44:35.220" UserId="46" Text="Mislabelled ATmega328-PU. How rare is that?" />
  <row Id="503" PostHistoryTypeId="3" PostId="218" RevisionGUID="36576b19-d0d6-4e86-9215-57ba33f42737" CreationDate="2014-02-14T22:44:35.220" UserId="46" Text="&lt;atmega328&gt;" />
  <row Id="504" PostHistoryTypeId="2" PostId="219" RevisionGUID="6d59a1a9-640d-417b-ae92-54219e5111c9" CreationDate="2014-02-14T23:26:18.400" UserId="86" Text="There are no runtime exceptions. There is only undefined behaviour.&#xD;&#xA;&#xD;&#xA;Really, there are no exceptions *at all*. If you try to perform an invalid operation, it's results will be unknown.&#xD;&#xA;&#xD;&#xA;There is no runtime checking at all, except what **you** implement. Your program is running on bare-metal hardware. It's the Desktop equivalent of running in ring-0 all the time, because the ATmega *doesn't have rings*. " />
  <row Id="505" PostHistoryTypeId="2" PostId="220" RevisionGUID="2b52865b-7d94-48ed-9d82-5135372b01a1" CreationDate="2014-02-14T23:31:13.463" UserId="8" Text="While browsing sparkfun, i have found several news posts that show their struggle with mislabeled chips. Here are a few:&#xD;&#xA;&#xD;&#xA;* https://www.sparkfun.com/news/350&#xD;&#xA;* https://www.sparkfun.com/news/384&#xD;&#xA;* https://www.sparkfun.com/news/364" />
  <row Id="506" PostHistoryTypeId="2" PostId="221" RevisionGUID="328c8ed7-f6be-497d-aa48-b5d70b45c876" CreationDate="2014-02-15T01:09:33.157" UserId="42" Text="According to the Arduino documentation, the ATmega328 has 32KB of Flash memory for the bootloader + uploaded sketch, and only 2KB SRAM for runtime data. The ATmega2560 has quite a bit more, totalling 256KB and 8KB respectively.&#xD;&#xA;&#xD;&#xA;In either case, those limits seem rather small, especially when compared to similarly sized consumer devices, such as smartphones.&#xD;&#xA;&#xD;&#xA;What can you do if you run out? E.g. if your sketch is too big, or you need to process a lot of data (such as strings) at runtime? Is there any way to expand the Flash or SRAM?" />
  <row Id="507" PostHistoryTypeId="1" PostId="221" RevisionGUID="328c8ed7-f6be-497d-aa48-b5d70b45c876" CreationDate="2014-02-15T01:09:33.157" UserId="42" Text="What can I do if I run out of Flash memory or SRAM?" />
  <row Id="508" PostHistoryTypeId="3" PostId="221" RevisionGUID="328c8ed7-f6be-497d-aa48-b5d70b45c876" CreationDate="2014-02-15T01:09:33.157" UserId="42" Text="&lt;memory&gt;&lt;flash&gt;&lt;sram&gt;&lt;expansion&gt;" />
  <row Id="509" PostHistoryTypeId="2" PostId="222" RevisionGUID="bc3b2677-8409-4136-8d86-c113a7dd3e3e" CreationDate="2014-02-15T01:09:33.157" UserId="42" Text="**Optimisation**  &#xD;&#xA;Low-level programming for embedded systems is quite different from programming for general purpose devices, such as computers and cell phones. Efficiency (in terms of speed and space) is far more important because resources are at a premium. That means the very first thing to do if you run out of space is to look at what parts of your code you can optimise.&#xD;&#xA;&#xD;&#xA;In terms of reducing program space (Flash) usage, the code size can be quite difficult to optimise if you're inexperienced, or if you're more used to programming for desktop computers which don't tend to need that skill. Unfortunately, there's no 'magic bullet' approach which will work for all situations, although it helps if you consider seriously what your sketch really *needs* to have. If a feature isn't needed, take it out.&#xD;&#xA;&#xD;&#xA;Sometimes it's also helpful to identify where multiple parts of your code are the same (or very similar). You may be able to condense them into reusable functions which can be called from multiple places. However, be aware that sometimes trying to make code *too* reusable actually ends up making it more verbose. It's a tricky balance to strike that tends to come with practice. Spending some time looking at how code changes affect the compiler output can help.&#xD;&#xA;&#xD;&#xA;Runtime data (SRAM) optimisation tends to be a bit easier when you're used to it. A very common pitfall for beginner programmers is using too much global data. Anything declared at global scope will exist for the entire lifetime of the sketch, and that isn't always necessary. If a variable is only used inside one function, and it doesn't need to persist between calls, then make it a local variable. If a value needs to be shared between functions, consider if you can pass it as a parameter instead of making it global. That way you'll only use SRAM for those variables when you actually need it.&#xD;&#xA;&#xD;&#xA;Another killer for SRAM usage is text processing (e.g. using the `String` class). Generally speaking, you should avoid doing String operations if possible. They are massive memory hogs. For example, if you're outputting lots of text to serial, use multiple calls to `Serial.print()` instead of using string concatenation. Also try to reduce the number of string literals in your code if possible.&#xD;&#xA;&#xD;&#xA;Avoid recursion if possible as well. Each time a recursive call is made, it takes the stack a level deeper. Refactor your recursive functions to be iterative instead.&#xD;&#xA;&#xD;&#xA;**Use EEPROM**  &#xD;&#xA;EEPROM is used for long-term storage of things that only change occasionally. If you need to use large lists or look-up tables of fixed data, then consider storing it in EEPROM in advance, and only pulling out what you need when necessary.&#xD;&#xA;&#xD;&#xA;Obviously EEPROM is quite limited in size and speed though, and has a limited number of write cycles. It's not a great solution to data limitations, but it might be enough to ease the burden on Flash or SRAM. It's also quite possible to interface with similar external storage, such as an SD card.&#xD;&#xA;&#xD;&#xA;**Expansion**  &#xD;&#xA;If you've exhausted all other options, then expansion may be a possibility. Unfortunately, expanding Flash memory to increase program space isn't possible. However, it *is* possible to expand SRAM. This means you may be able to refactor your sketch to reduce code size at the expense of increasing data size.&#xD;&#xA;&#xD;&#xA;Getting more SRAM is actually fairly straightforward. One option is to use one or more [**23K256**][1] chips. They are accessed via SPI, and there is the [**SpiRAM library**][2] to help you use them. Just beware that they operate at 3.3V **not** 5V!&#xD;&#xA;&#xD;&#xA;If you're using the Mega, you could alternatively get SRAM expansion shields from [**Lagrangian Point**][3] or [**Rugged Circuits**][4].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://ww1.microchip.com/downloads/en/DeviceDoc/22100D.pdf&#xD;&#xA;  [2]: http://playground.arduino.cc/Main/SpiRAM&#xD;&#xA;  [3]: http://lagrangianpoint.net/store/arduino-mega-sram-expansion-shield-kit&#xD;&#xA;  [4]: http://www.ruggedcircuits.com/html/quadram.html" />
  <row Id="510" PostHistoryTypeId="5" PostId="215" RevisionGUID="55b94f7d-1502-414c-a7f9-9c5999d6e36d" CreationDate="2014-02-15T02:11:59.693" UserId="65" Comment="Typos; factual correction" Text="*First, a caveat. I'm a bit of a beginner in Arduino and AVR MCUs, so there is probably something inaccurate in what I'll say. If that's the case, feel free to just edit, criticize or downvote. In any case, I wanted to go into a little more detail than others have gone with their ansewers.*&#xD;&#xA;&#xD;&#xA;So, let's see a few examples of what can go wrong.&#xD;&#xA;&#xD;&#xA;# Uninitialized variables #&#xD;&#xA;&#xD;&#xA;    int status;&#xD;&#xA;    pinMode(13, OUTPUT);&#xD;&#xA;    digitalWrite(13, status);&#xD;&#xA;&#xD;&#xA;This problem is pretty harmless, but nobody knows whether the LED will light up or not. The value of variable `status` will be whatever happens to be the value that was written to that memory position in previous program runs. But it's not defined in your program.&#xD;&#xA;&#xD;&#xA;# Memory overflow #&#xD;&#xA;&#xD;&#xA;    int array[10];&#xD;&#xA;    int v = array[100];&#xD;&#xA;    array[-100] = 10;&#xD;&#xA;&#xD;&#xA;The first problem here is that you don't know what will be assigned to v, but worse is that you don't know what you messed up with the assignment to position -100 of `array`. The good news is that you only messed up with RAM and not with the EEPROM, thus your program is safe.&#xD;&#xA;&#xD;&#xA;# Jump to an illegal instruction #&#xD;&#xA;&#xD;&#xA;    void doSomething( void ) { &#xD;&#xA;        for (int i = 0; i &lt; 1000; i++); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void setup () &#xD;&#xA;    {&#xD;&#xA;        void (*funcPtr)( void );&#xD;&#xA;&#xD;&#xA;        funcPtr = &amp;doSomething;&#xD;&#xA;        funcPtr(); // calls doSomething();&#xD;&#xA;&#xD;&#xA;        funcPtr = NULL;&#xD;&#xA;        funcPtr(); // undefined behavior&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The first call to `funcPtr()` will actually be a call to `doSomething()`. The second one will lead to undefined behavior. It will probably continue execution from memory address 0. What's there? The bootloader begins there? I don't know, need to read the compiler fine print. But certainly it is not the intended behavior. &#xD;&#xA;&#xD;&#xA;# Other bad things that may happen #&#xD;&#xA;&#xD;&#xA;Well, you can run out of RAM, for example. What else. In any case, I think your program will keep running, probably not the way you intended it to.&#xD;&#xA;&#xD;&#xA;# Kinds of Protection #&#xD;&#xA;&#xD;&#xA;In computer systems, problems like these are usually dealt with at various levels:&#xD;&#xA;&#xD;&#xA;1. By the compiler&#xD;&#xA;1. By the programming language runtime (as in Java for example). &#xD;&#xA;1. By the operating system or the processor (if your memory access a position outside the boundaries of the address space reserved to your program, the OS or the processor may have safety mechanisms to prevent that)&#xD;&#xA;&#xD;&#xA;Arduinos only have only limited protection of the compiler, and probably nothing else. The good news is that they aren't multi-tasked, so the only program being affected is yours. In any case, any of those bugs will lead to erratic behavior.&#xD;&#xA;&#xD;&#xA;# The Answers #&#xD;&#xA;&#xD;&#xA;The assumptions are the all of the problems I stated above are runtime problems.&#xD;&#xA;&#xD;&#xA;&gt; What happens if there is a runtime error in a program? &#xD;&#xA;&#xD;&#xA;The program will continue and what happens will depend on the side-effects of the runtime error. A call to the null function pointer will probably (yes, I'm guessing) make the program jump to an unknown location. The assignment of an undetermined value to a variable will cause your program to use that value as a valid one, and gosh knows what it will do with that.&#xD;&#xA;&#xD;&#xA;&gt; Will execution of the program just stop?&#xD;&#xA;&#xD;&#xA;No, it will keep going as if nothing extraordinary happened, probably doing what you didn't intend it to do. It may reset or act erratically. It may turn some inputs into outputs and burn a sensor or two (*highly unlikely*).&#xD;&#xA;&#xD;&#xA;&gt; Is there some way I get the Arduino to tell me what the error is?&#xD;&#xA;&#xD;&#xA;I don't think so. As I said earlier, the protection mechanisms aren't there. There's no runtime support from the language, no OS, no hardware checks for out-of-bounds memory access (the bootloader doesn't count as either). You just have to be careful with your program and probably set your own safety nets. &#xD;&#xA;&#xD;&#xA;The reason for the lack of protection is probably because Arduino controllers are too cheap, have too little memory, and should not run anything too important (yes, there seems to be a disclaimer by AVR somewhere for you not to use the MCUs normally used by Arduino in life support systems)." />
  <row Id="511" PostHistoryTypeId="2" PostId="223" RevisionGUID="e6f781e1-eed8-4d59-a232-a3c42c6ed147" CreationDate="2014-02-15T03:24:15.173" UserId="11" Text="When you upload your code to your Arduino, say an Uno for example, it'll tell you how many bytes it uses up out of the 32K available. That's how much flash memory you have (think computer hard disk). While your program is running, it's using whats called SRAM, and there is much less of that available.&#xD;&#xA;&#xD;&#xA;Sometimes you'll notice your program behaving oddly at a point that you haven't even touched in a while. It could be that your most recent changes cause it to run out of memory (SRAM). Here are a few tips on how to free up some SRAM.&#xD;&#xA;&#xD;&#xA;## Storing strings in Flash instead of SRAM.&#xD;&#xA;&#xD;&#xA;One of the most common things I've seen is the chip running out of memory because there are too many long strings.&#xD;&#xA;&#xD;&#xA;Use the `F()` function when using strings so they are stored in Flash instead of SRAM, since you have much more of that available.&#xD;&#xA;&#xD;&#xA;    Serial.println(F(&quot;This string will be stored in flash memory&quot;));&#xD;&#xA;&#xD;&#xA;## Use the right data types&#xD;&#xA;&#xD;&#xA;You can save a byte by switching from an `int` (2 bytes) to a `byte` (1 byte). An unsigned byte will give you 0-255 so if you have numbers that don't go higher than 255, save a byte!&#xD;&#xA;&#xD;&#xA;## How do I know I'm running out of memory?&#xD;&#xA;&#xD;&#xA;Usually you'll observe your program behaving strangely and wonder what went wrong... You didn't change anything in the code near the point where it's messing up, so what gives? It's running out of memory.&#xD;&#xA;&#xD;&#xA;There are a couple of functions to tell you how much available memory you have.&#xD;&#xA;&#xD;&#xA;[Available Memory][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Code/AvailableMemory" />
  <row Id="512" PostHistoryTypeId="12" PostId="223" RevisionGUID="c8f2cb8f-3973-4532-9608-afd69de6a2b4" CreationDate="2014-02-15T03:24:43.380" UserId="11" Comment="via Vote" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="513" PostHistoryTypeId="13" PostId="223" RevisionGUID="5b74bfa8-6efe-4872-bd0f-b80396926d99" CreationDate="2014-02-15T03:25:06.383" UserId="11" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="514" PostHistoryTypeId="2" PostId="224" RevisionGUID="3999eb12-057b-4c7f-aa50-f91ef38df04e" CreationDate="2014-02-15T03:50:16.547" UserId="188" Text="I've recently received an Arduino Pro Mini as a gift, and I don't have an external USB programmer to program the Pro Mini. However, I do own an Arduino Uno R3, and I think it would be possible because they both have the same clock speed and micro-controller (16Mhz with an atmega328).&#xD;&#xA;&#xD;&#xA;Is it possible to program an Arduino Pro Mini using an Arduino Uno?&#xD;&#xA;If yes, how does one do so?&#xD;&#xA;" />
  <row Id="515" PostHistoryTypeId="1" PostId="224" RevisionGUID="3999eb12-057b-4c7f-aa50-f91ef38df04e" CreationDate="2014-02-15T03:50:16.547" UserId="188" Text="Is it possible to program an Arduino Pro Mini using an Arduino Uno R3?" />
  <row Id="516" PostHistoryTypeId="3" PostId="224" RevisionGUID="3999eb12-057b-4c7f-aa50-f91ef38df04e" CreationDate="2014-02-15T03:50:16.547" UserId="188" Text="&lt;uno&gt;&lt;uploading&gt;" />
  <row Id="517" PostHistoryTypeId="2" PostId="225" RevisionGUID="05cd9c67-b5f2-4986-b941-b9d2639543e5" CreationDate="2014-02-15T03:55:38.020" UserId="11" Text="Just hook up the pins (RX, TX, Power, and Ground) to the corresponding pins on your Uno.&#xD;&#xA;&#xD;&#xA;You may have to take the ATMega328 out of your Uno for this to work.&#xD;&#xA;&#xD;&#xA;Keep in mind that you need to hook it up to the correct power pin! If your pro mini is running at 3.3v then you must hook it up to the 3.3 pin on your Uno.&#xD;&#xA;&#xD;&#xA;Check out the [ArduinoToBreadboard][1] page for a bit more info. Scroll down to &quot;Uploading Using an Arduino Board&quot;. Although it shows you how to program an Arduino on a breadboard, the wiring is the same.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Tutorial/ArduinoToBreadboard" />
  <row Id="518" PostHistoryTypeId="5" PostId="225" RevisionGUID="1f96d747-4a4e-49a9-9614-ac29f2bf8bac" CreationDate="2014-02-15T04:03:42.247" UserId="11" Comment="added 7 characters in body" Text="Just hook up the pins (RX, TX, reset, Power, and Ground) to the corresponding pins on your Uno.&#xD;&#xA;&#xD;&#xA;You may have to take the ATMega328 out of your Uno for this to work.&#xD;&#xA;&#xD;&#xA;Keep in mind that you need to hook it up to the correct power pin! If your pro mini is running at 3.3v then you must hook it up to the 3.3 pin on your Uno.&#xD;&#xA;&#xD;&#xA;Check out the [ArduinoToBreadboard][1] page for a bit more info. Scroll down to &quot;Uploading Using an Arduino Board&quot;. Although it shows you how to program an Arduino on a breadboard, the wiring is the same.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Tutorial/ArduinoToBreadboard" />
  <row Id="519" PostHistoryTypeId="2" PostId="226" RevisionGUID="30021c61-539e-4c31-a327-2c8c51591d72" CreationDate="2014-02-15T04:09:14.367" UserId="190" Text="ATMEL says the cell lifetime of an EEprom cell is about 100 000 write cycle/ cell.&#xD;&#xA;If i do not change the value of a cell, does this stress the lifetime ?&#xD;&#xA;e.g. writing word with values between 0-255." />
  <row Id="520" PostHistoryTypeId="1" PostId="226" RevisionGUID="30021c61-539e-4c31-a327-2c8c51591d72" CreationDate="2014-02-15T04:09:14.367" UserId="190" Text="Lifetime of EEprom" />
  <row Id="521" PostHistoryTypeId="3" PostId="226" RevisionGUID="30021c61-539e-4c31-a327-2c8c51591d72" CreationDate="2014-02-15T04:09:14.367" UserId="190" Text="&lt;eeprom&gt;" />
  <row Id="522" PostHistoryTypeId="2" PostId="227" RevisionGUID="7e7ff66d-2eaf-4409-a1c5-4c4a75e8c0b6" CreationDate="2014-02-15T04:23:43.253" UserId="71" Text="I have no official credentials here, but in my experience things have gone pretty efficiently when I pick a certain character position(s) to contain the state of a variable, so that you might designate the first three characters as the temperature, and the next three as the angle of a servo, and so on. On the sending end I would save the variables individually and then combine them in a string to send serially. On the receiving end I would have the string picked apart, getting the first three characters and turning them into whatever variable type i need, then doing so again to get the next variable value.&#xD;&#xA;This system works best when you know for certain the amount of characters each variable will take up, and you always look for the same variables (which I hope is a given) each time the serial data loops through.&#xD;&#xA;&#xD;&#xA;You can pick one variable to put last of indeterminate length and then get that variable from it's first character to the end of the string. Granted, the serial data string could get really long depending on the variable types and the sheer amount of them, but this is the system I use and so far the only setback I've hit is the serial length, so that's the only disadvantage I know of." />
  <row Id="523" PostHistoryTypeId="2" PostId="228" RevisionGUID="f2730d8e-a624-4c58-8926-c176e24f363c" CreationDate="2014-02-15T04:47:54.653" UserId="8" Text="I once ran an experiment on an external EEPROM with 1 million max rated cycles. It took about 6 million cycles to become majorly corrupted, and before that it had progressed having sporadic amounts of corruption. &#xD;&#xA;&#xD;&#xA;When you say you do not change the value, i am assuming you are writing the same data to an address multiple times. This almost certainly would stress the life, although it would probably not stress the surrounding cells." />
  <row Id="524" PostHistoryTypeId="5" PostId="204" RevisionGUID="579d7206-ed01-4f1b-8778-f8677bc237c1" CreationDate="2014-02-15T04:50:45.477" UserId="62" Comment="Added comments to the code and more thoroughly explained things." Text="With my personal thoughts on Structs being the most efficient way to send many different variables I've constructed a library to help make it easier to send structs and variables over serial.  [Source Code][1]&#xD;&#xA;&#xD;&#xA;In this library it makes sending through serial easily. I've used with with hardware and software serial. Usually this is used in conjunct with xbee's so I can wirelessly send the data to and from the robot.&#xD;&#xA;&#xD;&#xA;When sending data it make it simple as it allows you to either send a variable or a struct (it doesn't care).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Here is an example of sending a simple char over the serial:**&#xD;&#xA;    &#xD;&#xA;    // Send the variable charVariable over the serial.&#xD;&#xA;    // To send the variable you need to pass an instance of the Serial to use,&#xD;&#xA;    // a reference to the variable to send, and the size of the variable being sent.&#xD;&#xA;    // If you would like you can specify 2 extra arguments at the end which change the&#xD;&#xA;    // default prefix and suffix character used when attempting to reconstruct the variable&#xD;&#xA;    // on the receiving end. If prefix and suffix character are specified they'll need to &#xD;&#xA;    // match on the receiving end otherwise data won't properly be sent across&#xD;&#xA;    &#xD;&#xA;    char charVariable = 'c'; // Define the variable to be sent over the serial&#xD;&#xA;    StreamSend::sendObject(Serial, &amp;charVariable, sizeof(charVariable));&#xD;&#xA;    &#xD;&#xA;    // Specify a prefix and suffix character&#xD;&#xA;    StreamSend::sendObject(Serial, &amp;charVariable, sizeof(charVariable), 'a', 'z');&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Example of sending a simple int over the serial:**&#xD;&#xA;    &#xD;&#xA;    int intVariable = 13496; // Define the int to be sent over the serial&#xD;&#xA;    StreamSend::sendObject(xbeeSerial, &amp;intVariable, sizeof(intVariable));&#xD;&#xA;    &#xD;&#xA;    // Specify a prefix and suffix character&#xD;&#xA;    StreamSend::sendObject(xbeeSerial, &amp;intVariable, sizeof(intVariable), 'j', 'p');&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Example of sending a struct over serial:**&#xD;&#xA;&#xD;&#xA;    // Define the struct to be sent over the serial&#xD;&#xA;    struct SIMPLE_STRUCT {&#xD;&#xA;      char charVariable;&#xD;&#xA;      int intVariable[7];&#xD;&#xA;      boolean boolVariable;&#xD;&#xA;    };&#xD;&#xA;    SIMPLE_STRUCT simpleStruct;&#xD;&#xA;    simpleStruct.charVariable = 'z'; // Set the charVariable in the struct to z&#xD;&#xA;    &#xD;&#xA;    // Fill the intVariable array in the struct with numbers 0 through 6&#xD;&#xA;    for(int i=0; i&lt;7; i++) {&#xD;&#xA;      simpleStruct.intVariable[i] = i;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // Send the struct to the object xbeeSerial which is a software serial that was&#xD;&#xA;    // defined. Instead of using xbeeSerial you can use Serial which will imply the&#xD;&#xA;    // hardware serial, and on a Mega you can specify Serial, Serial1, Serial2, Serial3.&#xD;&#xA;    StreamSend::sendObject(xbeeSerial, &amp;simpleStruct, sizeof(simpleStruct));&#xD;&#xA;    &#xD;&#xA;    // Send the same as above with a different prefix and suffix from the default values&#xD;&#xA;    // defined in StreamSend. When specifying when prefix and suffix character to send&#xD;&#xA;    // you need to make sure that on the receiving end they match otherwise the data&#xD;&#xA;    // won't be able to be read on the other end.&#xD;&#xA;    StreamSend::sendObject(xbeeSerial, &amp;simpleStruct, sizeof(simpleStruct), '3', 'u');&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Receiving Examples:**&#xD;&#xA;&#xD;&#xA;**Receiving a char that was send via Streamsend:**&#xD;&#xA;&#xD;&#xA;    char charVariable; // Define the variable on where the data will be put&#xD;&#xA;&#xD;&#xA;    // Read the data from the Serial object an save it into charVariable once&#xD;&#xA;    // the data has been received&#xD;&#xA;    byte packetResults = StreamSend::receiveObject(Serial, &amp;charVariable, sizeof(charVariable));&#xD;&#xA;    &#xD;&#xA;    // Reconstruct the char coming from the Serial into charVariable that has a custom&#xD;&#xA;    // suffix of a and a prefix of z&#xD;&#xA;    byte packetResults = StreamSend::receiveObject(Serial, &amp;charVariable, sizeof(charVariable), 'a', 'z');&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Receiving an int that was sent via StreamSend:**&#xD;&#xA;    &#xD;&#xA;    int intVariable; // Define the variable on where the data will be put&#xD;&#xA;&#xD;&#xA;    // Reconstruct the int from xbeeSerial into the variable intVariable&#xD;&#xA;    byte packetResults = StreamSend::receiveObject(xbeeSerial, &amp;intVariable, sizeof(intVariable));&#xD;&#xA;&#xD;&#xA;    // Reconstruct the data into intVariable that was send with a custom prefix&#xD;&#xA;    // of j and a suffix of p&#xD;&#xA;    byte packetResults = StreamSend::receiveObject(xbeeSerial, &amp;intVariable, sizeof(intVariable), 'j', 'p');&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Receiving a Struct that was sent via StreamSend:**&#xD;&#xA;&#xD;&#xA;    // Define the struct that the data will be put&#xD;&#xA;    struct SIMPLE_STRUCT {&#xD;&#xA;      char charVariable;&#xD;&#xA;      int intVariable[7];&#xD;&#xA;      boolean boolVariable;&#xD;&#xA;    };&#xD;&#xA;    SIMPLE_STRUCT simpleStruct; // Create a struct to store the data in&#xD;&#xA;&#xD;&#xA;    // Reconstruct the data from xbeeSerial into the object simpleStruct&#xD;&#xA;    byte packetResults = StreamSend::receiveObject(xbeeSerial, &amp;simpleStruct, sizeof(simpleStruct));&#xD;&#xA;    &#xD;&#xA;    // Reconstruct the data from xbeeSerial into the object simplestruct that has&#xD;&#xA;    // a prefix of 3 and a suffix of p&#xD;&#xA;    byte packetResults = StreamSend::receiveObject(xbeeSerial, &amp;simpleStruct, sizeof(simpleStruct), '3', 'p');&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Once you read the data using `StreamSend::receiveObject()` you need to know if the data was GOOD, Not Found, or BAD.&#xD;&#xA;&#xD;&#xA;**Good** = Successful&#xD;&#xA;&#xD;&#xA;**Not Found** = No prefix character was found in the specified ostream&#xD;&#xA;&#xD;&#xA;**Bad** = Somehow there was a prefix character found, but the data isn't intact. Usually it means there was no suffix character found or the data wasn't the correct size.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Testing Validity of Data:**&#xD;&#xA;    &#xD;&#xA;    // Once you call StreamSend::receiveObject() it returns a byte of the status of&#xD;&#xA;    // how things went. If you run that though some of the testing functions it'll&#xD;&#xA;    // let you know how the transaction went&#xD;&#xA;    if(StreamSend::isPacketGood(packetResults)) {&#xD;&#xA;      //The Packet was Good&#xD;&#xA;    } else {&#xD;&#xA;      //The Packet was Bad&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    if(StreamSend::isPacketCorrupt(packetResults)) {&#xD;&#xA;      //The Packet was Corrupt&#xD;&#xA;    } else {&#xD;&#xA;      //The Packet wasn't found or it was Good&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    if(StreamSend::isPacketNotFound(packetResults)) {&#xD;&#xA;      //The Packet was not found after Max # of Tries&#xD;&#xA;    } else {&#xD;&#xA;      //The Packet was Found, but can be corrupt&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**SteamSend Class:**&#xD;&#xA;&#xD;&#xA;    #include &quot;Arduino.h&quot;&#xD;&#xA;    &#xD;&#xA;    #ifndef STREAMSEND_H&#xD;&#xA;    #define STREAMSEND_H&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    #define PACKET_NOT_FOUND 0&#xD;&#xA;    #define BAD_PACKET 1&#xD;&#xA;    #define GOOD_PACKET 2&#xD;&#xA;    &#xD;&#xA;    // Set the Max size of the Serial Buffer or the amount of data you want to send+2&#xD;&#xA;    // You need to add 2 to allow the prefix and suffix character space to send.&#xD;&#xA;    #define MAX_SIZE 64&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    class StreamSend {&#xD;&#xA;      private:&#xD;&#xA;        static int getWrapperSize() { return sizeof(char)*2; }&#xD;&#xA;        static byte receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize, unsigned int loopSize);&#xD;&#xA;        static byte receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize, unsigned int loopSize, char prefixChar, char suffixChar);&#xD;&#xA;        static char _prefixChar; // Default value is s&#xD;&#xA;        static char _suffixChar; // Default value is e&#xD;&#xA;        static int _maxLoopsToWait;&#xD;&#xA;    &#xD;&#xA;      public:&#xD;&#xA;        static void sendObject(Stream &amp;ostream, void* ptr, unsigned int objSize);&#xD;&#xA;        static void sendObject(Stream &amp;ostream, void* ptr, unsigned int objSize, char prefixChar, char suffixChar);&#xD;&#xA;        static byte receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize);&#xD;&#xA;        static byte receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize, char prefixChar, char suffixChar);&#xD;&#xA;        static boolean isPacketNotFound(const byte packetStatus);&#xD;&#xA;        static boolean isPacketCorrupt(const byte packetStatus);&#xD;&#xA;        static boolean isPacketGood(const byte packetStatus);&#xD;&#xA;    &#xD;&#xA;        static void setPrefixChar(const char value) { _prefixChar = value; }&#xD;&#xA;        static void setSuffixChar(const char value) { _suffixChar = value; }&#xD;&#xA;        static void setMaxLoopsToWait(const int value) { _maxLoopsToWait = value; }&#xD;&#xA;        static const char getPrefixChar() { return _prefixChar; }&#xD;&#xA;        static const char getSuffixChar() { return _suffixChar; }&#xD;&#xA;        static const int getMaxLoopsToWait() { return _maxLoopsToWait; }&#xD;&#xA;    &#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    //Preset Some Default Variables&#xD;&#xA;    //Can be modified when seen fit&#xD;&#xA;    char StreamSend::_prefixChar = 's';   // Starting Character before sending any data across the Serial&#xD;&#xA;    char StreamSend::_suffixChar = 'e';   // Ending character after all the data is sent&#xD;&#xA;    int StreamSend::_maxLoopsToWait = -1; //Set to -1 for size of current Object and wrapper&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    /**&#xD;&#xA;      * sendObject&#xD;&#xA;      *&#xD;&#xA;      * Converts the Object to bytes and sends it to the stream&#xD;&#xA;      *&#xD;&#xA;      * @param Stream to send data to&#xD;&#xA;      * @param ptr to struct to fill&#xD;&#xA;      * @param size of struct&#xD;&#xA;      * @param character to send before the data stream (optional)&#xD;&#xA;      * @param character to send after the data stream (optional)&#xD;&#xA;      */&#xD;&#xA;    void StreamSend::sendObject(Stream &amp;ostream, void* ptr, unsigned int objSize) {&#xD;&#xA;      sendObject(ostream, ptr, objSize, _prefixChar, _suffixChar);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void StreamSend::sendObject(Stream &amp;ostream, void* ptr, unsigned int objSize, char prefixChar, char suffixChar) {&#xD;&#xA;      if(MAX_SIZE &gt;= objSize+getWrapperSize()) { //make sure the object isn't too large&#xD;&#xA;        byte * b = (byte *) ptr; // Create a ptr array of the bytes to send&#xD;&#xA;        ostream.write((byte)prefixChar); // Write the suffix character to signify the start of a stream&#xD;&#xA;    &#xD;&#xA;        // Loop through all the bytes being send and write them to the stream&#xD;&#xA;        for(unsigned int i = 0; i&lt;objSize; i++) {&#xD;&#xA;          ostream.write(b[i]); // Write each byte to the stream&#xD;&#xA;        }&#xD;&#xA;        ostream.write((byte)suffixChar); // Write the prefix character to signify the end of a stream&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /**&#xD;&#xA;      * receiveObject&#xD;&#xA;      *&#xD;&#xA;      * Gets the data from the stream and stores to supplied object&#xD;&#xA;      *&#xD;&#xA;      * @param Stream to read data from&#xD;&#xA;      * @param ptr to struct to fill&#xD;&#xA;      * @param size of struct&#xD;&#xA;      * @param character to send before the data stream (optional)&#xD;&#xA;      * @param character to send after the data stream (optional)&#xD;&#xA;      */&#xD;&#xA;    byte StreamSend::receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize) {&#xD;&#xA;        return receiveObject(ostream, ptr, objSize, _prefixChar, _suffixChar);&#xD;&#xA;    }&#xD;&#xA;    byte StreamSend::receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize, char prefixChar, char suffixChar) {&#xD;&#xA;      return receiveObject(ostream, ptr, objSize, 0, prefixChar, suffixChar);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    byte StreamSend::receiveObject(Stream &amp;ostream, void* ptr, unsigned int objSize, unsigned int loopSize, char prefixChar, char suffixChar) {&#xD;&#xA;      int maxLoops = (_maxLoopsToWait == -1) ? (objSize+getWrapperSize()) : _maxLoopsToWait;&#xD;&#xA;      if(loopSize &gt;= maxLoops) {&#xD;&#xA;    	  return PACKET_NOT_FOUND;&#xD;&#xA;      }&#xD;&#xA;      if(ostream.available() &gt;= (objSize+getWrapperSize())) { // Packet meets minimum size requirement&#xD;&#xA;      	if(ostream.read() != (byte)prefixChar) {&#xD;&#xA;      	  // Prefix character is not found&#xD;&#xA;      	  // Loop through the code again reading the next char&#xD;&#xA;      	  return receiveObject(ostream, ptr, objSize, loopSize+1, prefixChar, suffixChar);&#xD;&#xA;      	}&#xD;&#xA;    &#xD;&#xA;      	char data[objSize]; //Create a tmp char array of the data from Stream&#xD;&#xA;      	ostream.readBytes(data, objSize); //Read the # of bytes&#xD;&#xA;      	memcpy(ptr, data, objSize); //Copy the bytes into the struct&#xD;&#xA;    &#xD;&#xA;      	if(ostream.read() != (byte)suffixChar) {&#xD;&#xA;      	  //Suffix character is not found&#xD;&#xA;      	  return BAD_PACKET;&#xD;&#xA;      	}&#xD;&#xA;    	  return GOOD_PACKET;&#xD;&#xA;      }&#xD;&#xA;      return PACKET_NOT_FOUND; //Prefix character wasn't found so no packet detected&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    boolean StreamSend::isPacketNotFound(const byte packetStatus) {&#xD;&#xA;    	return (packetStatus == PACKET_NOT_FOUND);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    boolean StreamSend::isPacketCorrupt(const byte packetStatus) {&#xD;&#xA;    	return (packetStatus == BAD_PACKET);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    boolean StreamSend::isPacketGood(const byte packetStatus) {&#xD;&#xA;    	return (packetStatus == GOOD_PACKET);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;  [1]: http://paste.strictfp.com/39940" />
  <row Id="525" PostHistoryTypeId="5" PostId="220" RevisionGUID="d0cfcc8a-b91c-4693-bd61-c7d14bb56f0d" CreationDate="2014-02-15T04:52:08.083" UserId="8" Comment="explained articles" Text="While browsing sparkfun, i have found several news posts that show their struggle with mislabeled chips. Here are a few:&#xD;&#xA;&#xD;&#xA;* https://www.sparkfun.com/news/350&#xD;&#xA;* https://www.sparkfun.com/news/384&#xD;&#xA;* https://www.sparkfun.com/news/364&#xD;&#xA;&#xD;&#xA;Sparkfun had received a questionable shipment if ICs from a new seller in china. They decided to test them before sending them into production, and none of their test boards worked. Using nitric acid, they were able to remove the case of the ICs and fould a hunk of metal that looked like copper.&#xD;&#xA;&#xD;&#xA;In another article, they dissected some suspicious ICs from Atmel, and found an ON semiconductor silicon wafer inside. The chips were not functional ATmegas, but they did have silicon, unlike the other ones." />
  <row Id="526" PostHistoryTypeId="2" PostId="229" RevisionGUID="a520b94e-a28a-4a28-9099-7a0373c132e5" CreationDate="2014-02-15T05:09:45.997" UserId="160" Text="Sending a structure is fairly simple.   &#xD;&#xA;  &#xD;&#xA;You can declare the structure as you normally would, and then use memcpy(@myStruct,@myArray) to copy the data to a new location, and then use something similar to the below code to write the data as a datastream.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    unsigned char myArraySender[##];   //make ## large enough to fit struct&#xD;&#xA;    memcpy(&amp;myStruct,&amp;myArraySender);  //copy raw data from struct to the temp array&#xD;&#xA;    digitalWrite(frameStartPin,High);  //indicate to receiver that data is coming&#xD;&#xA;    serial.write(sizeof myStruct);     //tell receiver how many bytes to rx&#xD;&#xA;    Serial.write(&amp;myArraySender,sizeof myStruct);   //write bytes&#xD;&#xA;    digitalWrite)frameStartPin,Low);   //done indicating transmission &#xD;&#xA;    &#xD;&#xA;Then you can attach an interrupt routine to the pin on the other device that does the following:  &#xD;&#xA;  &#xD;&#xA;    volatile unsigned char len, tempBuff[##];   &#xD;&#xA;    //volatile because the interrupt will not happen at predictable intervals.&#xD;&#xA;    &#xD;&#xA;    attachInterrupt(0,readSerial,Rising);  &#xD;&#xA;//tell the mcu to call fxn when pinhigh. This will happen during virtually any moment. if that is not desired, remove the interrupt and simply watch for new characters in your main executive loop (aka, UART polling).&#xD;&#xA;        &#xD;&#xA;    void readSerial(unsigned char *myArrayReceiver){&#xD;&#xA;        unsigned char tempbuff[sizeof myArrayReceiver];&#xD;&#xA;        while (i&lt;(sizeof myArrayReceiver)) tempBuff[i]=Serial.read();&#xD;&#xA;        memcpy(&amp;tempbuff,&amp;myArrayReceiver);&#xD;&#xA;        Serial.flush();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Syntax and use of pointers will need some review. I pulled an all-nighter so I'm sure the above code won't even compile, but the idea is there. Fill your structure, copy it, use out-of-band signalling to avoid framing errors, write the data. On the other end, receive the data, copy it to a struct, and then the data becomes accessible via normal member access methods.  &#xD;&#xA;  &#xD;&#xA;The use of bitfields will also work, just be aware that the nibbles will appear to be backwards. For instance, attempting to write 0011 1101, may result in 1101 0011 appearing at the other end if the machines differ in byte order. &#xD;&#xA;&#xD;&#xA;If data integrity is important, you can also add a checksum to make sure you aren't copying misaligned garbage data. This is quick and effective check that I recommend. &#xD;&#xA;&#xD;&#xA;" />
  <row Id="527" PostHistoryTypeId="2" PostId="230" RevisionGUID="7a76dc9c-6935-478d-bb1a-eb0005920a0b" CreationDate="2014-02-15T07:33:52.483" UserId="136" Text="As you state, the internal EEPROM has a lifetime of 100,000 write cycles. This isn't a guess - a very significant proportion of ATmega328 will reach this number with no issues. I have test three processors before, and all reached 150,000 cycles with no issues.&#xD;&#xA;&#xD;&#xA;EEPROM is different to the RAM on an ATmega. Writing to it is not simple or quick, but it is wrapped up in a [friendly Arduino library][1], hiding this complexity from the user.&#xD;&#xA;&#xD;&#xA;The first level of indirection is the [EEPROM library][2], which is trivially simple], just calling two other functions for read and write. This calls eeprom_write_byte, found [here][3].&#xD;&#xA;&#xD;&#xA;This function uses inline assembly, so might not be easily understood. There is a comment that is easily understood though:&#xD;&#xA;&#xD;&#xA;&gt; Set programming mode: erase and write&#xD;&#xA;&#xD;&#xA;This hints to one of the complexities of dealing with EEPROM - to write to&#xD;&#xA;it, you first need to erase it. This means that if you call EEPROM.write(), it will perform a write cycle regardless of the value you are writing.&#xD;&#xA;&#xD;&#xA;This means that repeatedly writing 0xFF will likely have the same effect as writing 0xFF,0x00,0xFF,0x00 etc.&#xD;&#xA;&#xD;&#xA;There are ways to work around this - you can try calling EEPROM.read() before EEPROM.write() to see if the value is already the same, but this takes additional time. &#xD;&#xA;&#xD;&#xA;There are other techniques to avoid excessive EEPROM wear, but their use depends on your application.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/EEPROM#.Uv8RdHnG&#xD;&#xA;&#xD;&#xA;  [2]: https://github.com/arduino/Arduino/blob/598ab1d5c003e02b6bb193640fac8526ad8ab912/libraries/EEPROM/EEPROM.cpp&#xD;&#xA;  [3]: https://github.com/arduino/Arduino/blob/598ab1d5c003e02b6bb193640fac8526ad8ab912/build/windows/eeprom.h" />
  <row Id="528" PostHistoryTypeId="2" PostId="231" RevisionGUID="47718edd-6719-4d31-a7c4-064a93c8cab7" CreationDate="2014-02-15T07:35:23.420" UserId="83" Text="Not the preferred way to fix things and certainly not the first solution to consider, but you can consider programming the signature bytes. Before attempting this be absolutely sure you really want to do this and you have investigated what is involved to undo this. This may involve changing configuration files on your computer ...&#xD;&#xA;&#xD;&#xA;Anyways the way to set the controller's signature bytes is as follows (untested, I don't have a spare AVR lying around):&#xD;&#xA;&#xD;&#xA;    avrdude -p atmega328 -c arduino -P /dev/ttyUSB003 -b 19200 -v -U signature:w:0x1E,0x95,0x14:m" />
  <row Id="529" PostHistoryTypeId="5" PostId="230" RevisionGUID="8e54cbbb-a40b-4f3e-b9fa-76b28b64d1c9" CreationDate="2014-02-15T07:45:38.503" UserId="136" Comment="added 2 characters in body" Text="As you state, the internal EEPROM has a lifetime of 100,000 write cycles. This isn't a guess - a very significant proportion of ATmega328 will reach this number with no issues. I have tested three processors before, and all reached 150,000 cycles with no issues.&#xD;&#xA;&#xD;&#xA;EEPROM is different to the RAM on an ATmega. Writing to it is not simple or quick, but it is wrapped up in a [friendly Arduino library][1], hiding this complexity from the user.&#xD;&#xA;&#xD;&#xA;The first level of indirection is the [EEPROM library][2], which is trivially simple], just calling two other functions for read and write. This calls eeprom_write_byte, found [here][3].&#xD;&#xA;&#xD;&#xA;This function uses inline assembly, so might not be easily understood. There is a comment that is easily understood though:&#xD;&#xA;&#xD;&#xA;&gt; Set programming mode: erase and write&#xD;&#xA;&#xD;&#xA;This hints to one of the complexities of dealing with EEPROM - to write to&#xD;&#xA;it, you first need to erase it. This means that if you call EEPROM.write(), it will perform a write cycle regardless of the value you are writing.&#xD;&#xA;&#xD;&#xA;This means that repeatedly writing 0xFF will likely have the same effect as writing 0xFF,0x00,0xFF,0x00 etc.&#xD;&#xA;&#xD;&#xA;There are ways to work around this - you can try calling EEPROM.read() before EEPROM.write() to see if the value is already the same, but this takes additional time. &#xD;&#xA;&#xD;&#xA;There are other techniques to avoid excessive EEPROM wear, but their use depends on your application.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/EEPROM#.Uv8RdHnG&#xD;&#xA;&#xD;&#xA;  [2]: https://github.com/arduino/Arduino/blob/598ab1d5c003e02b6bb193640fac8526ad8ab912/libraries/EEPROM/EEPROM.cpp&#xD;&#xA;  [3]: https://github.com/arduino/Arduino/blob/598ab1d5c003e02b6bb193640fac8526ad8ab912/build/windows/eeprom.h" />
  <row Id="530" PostHistoryTypeId="5" PostId="226" RevisionGUID="64d0dc7b-7cc1-4e46-847f-fba4646dc399" CreationDate="2014-02-15T07:52:14.070" UserId="136" Comment="Clarified question." Text="ATMEL says the cell lifetime of an EEPROM cell is about 100,000 write cycle/ cell.&#xD;&#xA;If I do not change the value of a cell, does this stress the lifetime? For example, if I write the value 0xFF to the same cell again and again, is this any different to writing 0x00, 0xFF, 0x00 etc." />
  <row Id="531" PostHistoryTypeId="24" PostId="226" RevisionGUID="64d0dc7b-7cc1-4e46-847f-fba4646dc399" CreationDate="2014-02-15T07:52:14.070" Comment="Proposed by 136 approved by 65, 83 edit id of 43" />
  <row Id="532" PostHistoryTypeId="2" PostId="232" RevisionGUID="af59bb04-43a5-4898-8d3c-c7962b310ab9" CreationDate="2014-02-15T08:47:31.550" UserId="160" Text="http://hackaday.com/2011/05/16/destroying-an-arduinos-eeprom/&#xD;&#xA;&#xD;&#xA;&gt;The Arduino was plugged into a wall wart and sat, “behind a couch for a couple of months.” The EEPROM saw it’s first write error after 47 days and 1,230,163 cycles. This is an order of magnitude better than the spec on the atmel datasheet, but similar to the results of similar experiments." />
  <row Id="533" PostHistoryTypeId="5" PostId="230" RevisionGUID="81a7506a-28a0-4132-8c27-4aee023ed4e1" CreationDate="2014-02-15T10:32:02.853" UserId="136" Comment="Added detail about failure." Text="As you state, the internal EEPROM has a lifetime of 100,000 write cycles. This isn't a guess - a very significant proportion of ATmega328 will reach this number with no issues. I have tested three processors before, and all reached 150,000 cycles with no issues.&#xD;&#xA;&#xD;&#xA;It is important to note the failure mode of EEPROM. Most &quot;EEPROM destroyer&quot; projects repeatedly read/write until the data is not written at all. Before this point, the EEPROM will still be damaged. This would be manifested by data not being retained for a reasonable period. It is unwise to rely on anything more than 100,000 write cycles for this reason.&#xD;&#xA;&#xD;&#xA;EEPROM is different to the RAM on an ATmega. Writing to it is not simple or quick, but it is wrapped up in a [friendly Arduino library][1], hiding this complexity from the user.&#xD;&#xA;&#xD;&#xA;The first level of indirection is the [EEPROM library][2], which is trivially simple], just calling two other functions for read and write. This calls eeprom_write_byte, found [here][3].&#xD;&#xA;&#xD;&#xA;This function uses inline assembly, so might not be easily understood. There is a comment that is easily understood though:&#xD;&#xA;&#xD;&#xA;&gt; Set programming mode: erase and write&#xD;&#xA;&#xD;&#xA;This hints to one of the complexities of dealing with EEPROM - to write to&#xD;&#xA;it, you first need to erase it. This means that if you call EEPROM.write(), it will perform a write cycle regardless of the value you are writing.&#xD;&#xA;&#xD;&#xA;This means that repeatedly writing 0xFF will likely have the same effect as writing 0xFF,0x00,0xFF,0x00 etc.&#xD;&#xA;&#xD;&#xA;There are ways to work around this - you can try calling EEPROM.read() before EEPROM.write() to see if the value is already the same, but this takes additional time. &#xD;&#xA;&#xD;&#xA;There are other techniques to avoid excessive EEPROM wear, but their use depends on your application.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/EEPROM#.Uv8RdHnG&#xD;&#xA;&#xD;&#xA;  [2]: https://github.com/arduino/Arduino/blob/598ab1d5c003e02b6bb193640fac8526ad8ab912/libraries/EEPROM/EEPROM.cpp&#xD;&#xA;  [3]: https://github.com/arduino/Arduino/blob/598ab1d5c003e02b6bb193640fac8526ad8ab912/build/windows/eeprom.h" />
  <row Id="534" PostHistoryTypeId="2" PostId="233" RevisionGUID="c28d0696-9ec0-4c32-8c0b-a1715fd6f930" CreationDate="2014-02-15T10:49:28.927" UserId="136" Text="The [DS2482-100][1] and [DS2482-800][2] are I2C to 1-Wire bridges which are useful for driving complex 1-Wire networks.&#xD;&#xA;&#xD;&#xA;These are natively supported by a number of packages in Linux so you can interface easily with them on a Raspberry Pi.&#xD;&#xA;&#xD;&#xA;I was surprised to find there is not an obvious library for accessing them on an Arduino however.&#xD;&#xA;&#xD;&#xA;I have found the following:&#xD;&#xA;&#xD;&#xA; - An [Arduino library][3] - has some quirks and not-maintained.&#xD;&#xA; - [Part][4] of AVR-Liberty - less quirks, not sure if maintained, not &quot;Arduino&quot; as&#xD;&#xA;   such, more AVR.&#xD;&#xA;&#xD;&#xA;It is helpful to be able to rely on maintained libraries to deal with any changes to the Arduino environment. &#xD;&#xA;&#xD;&#xA;Arduino libraries are often easier to use than ones designed for AVR in general, which means more people are able to use the software.&#xD;&#xA;&#xD;&#xA;Is there a better library available?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.maximintegrated.com/datasheet/index.mvp/id/4382&#xD;&#xA;  [2]: http://www.maximintegrated.com/datasheet/index.mvp/id/4338&#xD;&#xA;  [3]: https://github.com/paeaetech/paeae&#xD;&#xA;  [4]: https://github.com/dreamiurg/avr-liberty/blob/e08e41d073be523a8a8e4202afb5b3c1e061d300/src/rsl/ds2482.c" />
  <row Id="535" PostHistoryTypeId="1" PostId="233" RevisionGUID="c28d0696-9ec0-4c32-8c0b-a1715fd6f930" CreationDate="2014-02-15T10:49:28.927" UserId="136" Text="Are there any good and maintained libraries for using DS2482 I2C to 1-Wire bridge?" />
  <row Id="536" PostHistoryTypeId="3" PostId="233" RevisionGUID="c28d0696-9ec0-4c32-8c0b-a1715fd6f930" CreationDate="2014-02-15T10:49:28.927" UserId="136" Text="&lt;library&gt;&lt;i2c&gt;&lt;1-wire&gt;" />
  <row Id="537" PostHistoryTypeId="5" PostId="218" RevisionGUID="daf79860-c60d-4b9d-ba74-c37939d51f9f" CreationDate="2014-02-15T11:08:24.083" UserId="46" Comment="added 291 characters in body; edited title" Text="Sometime in the past, I was burning bootloaders on a fresh batch of four **ATmega328-PU** using the Arduino IDE (notice there's no **P** after 328 - it's the slightly cheaper non-picopower version of the MCU, not to be confused with the **ATmega328P-PU** with a **P**), and was surprised with the following message from avrdude:&#xD;&#xA;&#xD;&#xA;    avrdude: Device signature = 0x1e950F &#xD;&#xA;    avrdude: Expected signature for ATMEGA328 is 1E 95 14 &#xD;&#xA;    Double check chip, or use -F to override this check. &#xD;&#xA;&#xD;&#xA;That means avrdude thought the chip was not what its label said.&#xD;&#xA;&#xD;&#xA;Then I changed the chip type on my Arduino IDE to **ATmega328P-PU** and avrdude burned the bootloader without complaints.&#xD;&#xA;&#xD;&#xA;What that means is that the chip was lebelled as one MCU and internally it responded as another, slightly different.&#xD;&#xA;&#xD;&#xA;**Edit:** In an effort to save the question, and also taking advantage that **I now KNOW that the chip signature CAN BE MODIFIED**, my question should have been: **How can I fix the signature so that avrdude recognize the chip correctly?**&#xD;&#xA;&#xD;&#xA;For historical reasons, I'll keep the original (lame) question, that was: how rare this event is? Has anyone had a similar experience? Please report it in your answer.&#xD;&#xA;&#xD;&#xA;This is a [cross-post from EE.SE][1]. I posted this question there but didn't attract much attention, so I wanted to see if anyone from our community had a similar experience.&#xD;&#xA;&#xD;&#xA;Some folks at EE.SE thought it could be a counterfeit, but I disagree, because I got a more expensive MCU for less money. How would that be lucrative?&#xD;&#xA;&#xD;&#xA;  [1]: http://electronics.stackexchange.com/questions/90692/mislabelled-atmega328-pu" />
  <row Id="538" PostHistoryTypeId="4" PostId="218" RevisionGUID="daf79860-c60d-4b9d-ba74-c37939d51f9f" CreationDate="2014-02-15T11:08:24.083" UserId="46" Comment="added 291 characters in body; edited title" Text="I got a missignatured ATmega328-PU. How can I fix that?" />
  <row Id="539" PostHistoryTypeId="2" PostId="234" RevisionGUID="35da0bcd-5666-4bae-adbd-1610d3cbcc91" CreationDate="2014-02-15T11:44:12.093" UserId="194" Text="There is one mechanism that can get MCU from erratic state and it's the **watchdog timer**. If you're implementing some code that will repeatedly run in a loop, that will not run anytime longer than some fixed time, you can set this time as watchdog period and enable the timer. &#xD;&#xA;&#xD;&#xA;Then, you have to repeatedly reset the timer in the loop. If your code freezes at some condition loop that will never end the watchdog will count to zero and eventually reset the MCU.&#xD;&#xA;&#xD;&#xA;This way you are losing data, but if you run the AVR WDT in interrupt mode, you can store some data before resetting the MCU.&#xD;&#xA;&#xD;&#xA;So the watchdog timer can guard your code from occasional unintended endles loops." />
  <row Id="540" PostHistoryTypeId="5" PostId="215" RevisionGUID="28ae283c-6ddc-4a96-af93-5c7dd38ab94b" CreationDate="2014-02-15T12:47:15.137" UserId="46" Comment="Tested what happens if you call a null function pointer and reported it here." Text="*First, a caveat. I'm a bit of a beginner in Arduino and AVR MCUs, so there is probably something inaccurate in what I'll say. If that's the case, feel free to just edit, criticize or downvote. In any case, I wanted to go into a little more detail than others have gone with their ansewers.*&#xD;&#xA;&#xD;&#xA;So, let's see a few examples of what can go wrong.&#xD;&#xA;&#xD;&#xA;# Uninitialized variables #&#xD;&#xA;&#xD;&#xA;    int status;&#xD;&#xA;    pinMode(13, OUTPUT);&#xD;&#xA;    digitalWrite(13, status);&#xD;&#xA;&#xD;&#xA;This problem is pretty harmless, but nobody knows whether the LED will light up or not. The value of variable `status` will be whatever happens to be the value that was written to that memory position in previous program runs. But it's not defined in your program.&#xD;&#xA;&#xD;&#xA;# Memory overflow #&#xD;&#xA;&#xD;&#xA;    int array[10];&#xD;&#xA;    int v = array[100];&#xD;&#xA;    array[-100] = 10;&#xD;&#xA;&#xD;&#xA;The first problem here is that you don't know what will be assigned to v, but worse is that you don't know what you messed up with the assignment to position -100 of `array`. The good news is that you only messed up with RAM and not with the EEPROM, thus your program is safe.&#xD;&#xA;&#xD;&#xA;# Jump to an illegal instruction #&#xD;&#xA;&#xD;&#xA;    void doSomething( void ) { &#xD;&#xA;        for (int i = 0; i &lt; 1000; i++); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void setup () &#xD;&#xA;    {&#xD;&#xA;        void (*funcPtr)( void );&#xD;&#xA;&#xD;&#xA;        funcPtr = &amp;doSomething;&#xD;&#xA;        funcPtr(); // calls doSomething();&#xD;&#xA;&#xD;&#xA;        funcPtr = NULL;&#xD;&#xA;        funcPtr(); // undefined behavior&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The first call to `funcPtr()` will actually be a call to `doSomething()`. Calls like the second one may lead to undefined behavior. In this case, it will continue execution from memory address 0, which seems to be the start of the sketch (I just tested and that's equivalent to a soft boot - it doesn't even go through the bootloader). But certainly it is not the intended behavior. &#xD;&#xA;&#xD;&#xA;# Other bad things that may happen #&#xD;&#xA;&#xD;&#xA;Well, you can run out of RAM, for example. What else. In any case, I think your program will keep running, probably not the way you intended it to.&#xD;&#xA;&#xD;&#xA;# Kinds of Protection #&#xD;&#xA;&#xD;&#xA;In computer systems, problems like these are usually dealt with at various levels:&#xD;&#xA;&#xD;&#xA;1. By the compiler&#xD;&#xA;1. By the programming language runtime (as in Java for example). &#xD;&#xA;1. By the operating system or the processor (if your memory access a position outside the boundaries of the address space reserved to your program, the OS or the processor may have safety mechanisms to prevent that)&#xD;&#xA;&#xD;&#xA;Arduinos only have only limited protection of the compiler, and probably nothing else. The good news is that they aren't multi-tasked, so the only program being affected is yours. In any case, any of those bugs will lead to erratic behavior.&#xD;&#xA;&#xD;&#xA;# The Answers #&#xD;&#xA;&#xD;&#xA;The assumptions are the all of the problems I stated above are runtime problems.&#xD;&#xA;&#xD;&#xA;&gt; What happens if there is a runtime error in a program? &#xD;&#xA;&#xD;&#xA;The program will continue and what happens will depend on the side-effects of the runtime error. A call to the null function pointer will probably (yes, I'm guessing) make the program jump to an unknown location. The assignment of an undetermined value to a variable will cause your program to use that value as a valid one, and gosh knows what it will do with that.&#xD;&#xA;&#xD;&#xA;&gt; Will execution of the program just stop?&#xD;&#xA;&#xD;&#xA;No, it will keep going as if nothing extraordinary happened, probably doing what you didn't intend it to do. It may reset or act erratically. It may turn some inputs into outputs and burn a sensor or two (*highly unlikely*).&#xD;&#xA;&#xD;&#xA;&gt; Is there some way I get the Arduino to tell me what the error is?&#xD;&#xA;&#xD;&#xA;I don't think so. As I said earlier, the protection mechanisms aren't there. There's no runtime support from the language, no OS, no hardware checks for out-of-bounds memory access (the bootloader doesn't count as either). You just have to be careful with your program and probably set your own safety nets. &#xD;&#xA;&#xD;&#xA;The reason for the lack of protection is probably because Arduino controllers are too cheap, have too little memory, and should not run anything too important (yes, there seems to be a disclaimer by AVR somewhere for you not to use the MCUs normally used by Arduino in life support systems)." />
  <row Id="541" PostHistoryTypeId="5" PostId="26" RevisionGUID="1b2a5af0-d1b0-47cd-acfd-f3fd8990269f" CreationDate="2014-02-15T12:52:43.017" UserId="46" Comment="added 792 characters in body" Text="The strangest thing is happening to a standalone Arduino board that I designed and built. The board (whose schematics are below) has the following features:&#xD;&#xA;&#xD;&#xA;1. It has a ATmega328P with a 5V voltage regulator and usual circuitry when set up as a standalone controller. &#xD;&#xA;1. It controls a scoreboard with several 7-display digits linked through the connectors on the right (JP1 through JP12). &#xD;&#xA;1. It has cursor buttons decoded using a voltage ladder through ANALOG_0 (A0).&#xD;&#xA;1. It has a Real Time Clock to keep time when it's turned off.&#xD;&#xA;1. It has an RF receiver module.&#xD;&#xA;1. It has a UART header (JP17) so I can program the board using a serial port.&#xD;&#xA;1. It has a speaker attached to digital pin 3 (D3). &#xD;&#xA;&#xD;&#xA;![Controller schematics][1]&#xD;&#xA;&#xD;&#xA;I upload sketches to it using a RS232-to-TTL adapter that I've also built (schematics also below) and a Serial-to-USB cable. When programming it, the board behaves much like a [Severino board](http://arduino.cc/en/Main/ArduinoBoardSerialSingleSided3).&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;What's strange is that, when I upload a sketch, the process is paused in the middle and then the speaker starts to beep continually. It pauses with the following avrdude messages:&#xD;&#xA;&#xD;&#xA;avrdude: Version 5.11, compiled on Sep  2 2011 at 19:38:36&#xD;&#xA;         Copyright (c) 2000-2005 Brian Dean, http://www.bdmicro.com/&#xD;&#xA;         Copyright (c) 2007-2009 Joerg Wunsch&#xD;&#xA;&#xD;&#xA;         System wide configuration file is &quot;C:\arduino-1.0.3\hardware/tools/avr/etc/avrdude.conf&quot;&#xD;&#xA;&#xD;&#xA;         Using Port                    : \\.\COM1&#xD;&#xA;         Using Programmer              : arduino&#xD;&#xA;         Overriding Baud Rate          : 115200&#xD;&#xA;&#xD;&#xA;When I press reset on the board, avrdude continues outputting its messages (such as below), the beep stops, the upload continues and the sketch is uploaded successfully to the board.&#xD;&#xA;&#xD;&#xA;    avrdude: Send: 0 [30]   [20] &#xD;&#xA;    avrdude: Send: 0 [30]   [20] &#xD;&#xA;    avrdude: Send: 0 [30]   [20] &#xD;&#xA;    ... messages and upload continue and completes successfully.&#xD;&#xA;&#xD;&#xA;I don't have the rest of the messages handy here, but I hope you get the idea.&#xD;&#xA;&#xD;&#xA;So, my questions are:&#xD;&#xA;&#xD;&#xA;1. **What is making the upload process pause?**&#xD;&#xA;2. **Why is the buzzer beeping when the process pauses?**&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/21kgT.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/h3HJq.png" />
  <row Id="542" PostHistoryTypeId="5" PostId="25" RevisionGUID="ee6f1915-f792-4fe1-a502-9dda614fda4d" CreationDate="2014-02-15T12:53:44.100" UserId="46" Comment="deleted 43 characters in body" Text="I have an original Arduino UNO R3 that I bought and an [Arduino Severino (S3V3)](http://arduino.cc/en/Main/ArduinoBoardSerialSingleSided3) that I've built.&#xD;&#xA;&#xD;&#xA;I have no problems uploading sketches to the UNO, but sometimes, when uploading to the Severino board, I have to hard reset it at a specific time during the upload process, when the IDE says something like this below:&#xD;&#xA;&#xD;&#xA;	avrdude: Version 5.11, compiled on Sep  2 2011 at 19:38:36&#xD;&#xA;			 Copyright (c) 2000-2005 Brian Dean, http://www.bdmicro.com/&#xD;&#xA;			 Copyright (c) 2007-2009 Joerg Wunsch&#xD;&#xA;&#xD;&#xA;			 System wide configuration file is &quot;C:\arduino-1.0.3\hardware/tools/avr/etc/avrdude.conf&quot;&#xD;&#xA;&#xD;&#xA;			 Using Port                    : \\.\COM1&#xD;&#xA;			 Using Programmer              : arduino&#xD;&#xA;			 Overriding Baud Rate          : 115200&#xD;&#xA;	avrdude: Send: 0 [30]   [20] &#xD;&#xA;	avrdude: Send: 0 [30]   [20] &#xD;&#xA;	avrdude: Send: 0 [30]   [20] &#xD;&#xA;&#xD;&#xA;If I don't reset it when one of the `Send` messages are being displayed, I get the `not in sync` message, as below:&#xD;&#xA;&#xD;&#xA;	avrdude: Recv: &#xD;&#xA;	avrdude: stk500_getsync(): not in sync: resp=0x00&#xD;&#xA;&#xD;&#xA;Other times, if I'm lucky, I can upload to the Severino board without having to reset it.&#xD;&#xA;&#xD;&#xA;So, my questions are:&#xD;&#xA;&#xD;&#xA;1. **Why does that happen? Why Severino needs a hard reset during upload?**&#xD;&#xA;&#xD;&#xA;1. **Why is the problem intermitent?** Why does it happen sometimes and others it doesn't?&#xD;&#xA;&#xD;&#xA;1. **How can I fix that problem?** Is there a simple change to the Severino design that would fix that?&#xD;&#xA;" />
  <row Id="543" PostHistoryTypeId="2" PostId="235" RevisionGUID="6a972642-41c3-43ad-89f9-895ab38f06a2" CreationDate="2014-02-15T13:51:05.673" UserId="123" Text=" I am looking for simple  low cost solution in which I would like control on/off of mains supply to certain equipment. The control will be done using one of the output pin of Arudino Uno.&#xD;&#xA;&#xD;&#xA; The input trigger and how control it is application dependent.  e. g. controlling an equipment or controlling supply to section of home but  in principle mains  control module implementation  remains same. So looking for solution which safe while doing connections as well while in use in  in-door conditions for years.&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="544" PostHistoryTypeId="1" PostId="235" RevisionGUID="6a972642-41c3-43ad-89f9-895ab38f06a2" CreationDate="2014-02-15T13:51:05.673" UserId="123" Text="Controlling mains (230V) supply upto 5/10 amps using Arudino" />
  <row Id="545" PostHistoryTypeId="3" PostId="235" RevisionGUID="6a972642-41c3-43ad-89f9-895ab38f06a2" CreationDate="2014-02-15T13:51:05.673" UserId="123" Text="&lt;power&gt;&lt;relay&gt;" />
  <row Id="546" PostHistoryTypeId="2" PostId="236" RevisionGUID="38dcc567-2f3a-4754-ac80-50b6a519ce99" CreationDate="2014-02-15T14:43:03.843" UserId="8" Text="The [PowerSwitch Tail 2](https://www.sparkfun.com/products/10747) is a great way for experimenters to control mains voltages. It is insulated and internally decoupled, do you only have to hook up 5v, gnd, and a signal line to control it.&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;image from sparkfun&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/kHPjV.png" />
  <row Id="547" PostHistoryTypeId="5" PostId="218" RevisionGUID="44a452b5-82dc-4d64-9e91-6b1c35c55d11" CreationDate="2014-02-15T14:56:23.443" UserId="65" Comment="Slight clean-up; Rephrased" Text="Sometime in the past, I was burning bootloaders on a fresh batch of four **ATmega328-PU** using the Arduino IDE (notice there's no **P** after 328 - it's the slightly cheaper non-picopower version of the MCU, not to be confused with the **ATmega328P-PU** with a **P**), and was surprised with the following message from avrdude:&#xD;&#xA;&#xD;&#xA;    avrdude: Device signature = 0x1e950F &#xD;&#xA;    avrdude: Expected signature for ATMEGA328 is 1E 95 14 &#xD;&#xA;    Double check chip, or use -F to override this check. &#xD;&#xA;&#xD;&#xA;That means avrdude thought the chip was not what its label said. Then I changed the chip type on my Arduino IDE to **ATmega328P-PU** and avrdude burned the bootloader without complaints. What that means is that the chip was labelled as one MCU and internally it responded as another, slightly different.&#xD;&#xA;&#xD;&#xA;What I would like to know is:&#xD;&#xA;&#xD;&#xA;- &lt;s&gt;How rare is this event? Has anyone had a similar experience?&lt;/s&gt; (*Original question, off-topic*)&#xD;&#xA;&#xD;&#xA;- Is it possible to fix this? How can I fix the signature so that avrdude recognize the chip correctly?&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;This is a [cross-post from EE.SE][1]. I posted this question there but didn't attract much attention, so I wanted to see if anyone from our community had a similar experience.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;  [1]: http://electronics.stackexchange.com/questions/90692/mislabelled-atmega328-pu" />
  <row Id="548" PostHistoryTypeId="5" PostId="236" RevisionGUID="2a8f5219-63a3-42fa-a04f-2f2c7b6b38c9" CreationDate="2014-02-15T15:07:03.587" UserId="8" Comment="edited body" Text="The [PowerSwitch Tail 2](https://www.sparkfun.com/products/10747) is a great way for experimenters to control mains voltages. It is insulated and internally decoupled, so you only have to hook up 5v, gnd, and a signal line to control it.&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;image from sparkfun&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/kHPjV.png" />
  <row Id="549" PostHistoryTypeId="5" PostId="31" RevisionGUID="35160b04-dc7a-4996-849c-a836598594db" CreationDate="2014-02-15T15:42:16.123" UserId="46" Comment="Added a note stating that Anindo's answer should be read before mine." Text="*Note: I wanted to point out that, even though my answer was accepted and currently has more upvotes, the reader (you) should really look into Anindo's answer first if you really want to save energy with any Arduino board. Once you address those items in your design, then you should read my answer and worry about how to set the MCU into low power mode.*&#xD;&#xA;&#xD;&#xA;Having said that, there are several techniques to make an Arduino save power. I'll list a few and then point you to a page that explains them all in more detail.&#xD;&#xA;&#xD;&#xA;1. While the controller isn't doing anything important (between one read of a sensor and the next, for example), you can put the controller into one of the sleep modes below, with the command `set_sleep_mode (SLEEP_MODE_PWR_DOWN)`. Next to each mode is the approximate power consumption of each mode. &#xD;&#xA;&#xD;&#xA;* SLEEP_MODE_IDLE: 15 mA&#xD;&#xA;* SLEEP_MODE_ADC: 6.5 mA&#xD;&#xA;* SLEEP_MODE_PWR_SAVE: 1.62 mA&#xD;&#xA;* SLEEP_MODE_EXT_STANDBY: 1.62 mA&#xD;&#xA;* SLEEP_MODE_STANDBY : 0.84 mA&#xD;&#xA;* SLEEP_MODE_PWR_DOWN : 0.36 mA&#xD;&#xA;&#xD;&#xA;1. Disable **brown-out detection** (the circuitry that turns off the controller when low voltage is detected).&#xD;&#xA;&#xD;&#xA;1. Turn off ADC (analog to digita conversion)&#xD;&#xA;&#xD;&#xA;1. Use the internal clock&#xD;&#xA;&#xD;&#xA;Then, when you put the controller to sleep, you need to use one or more mechanisms below to wake up the controller and do something with it:&#xD;&#xA;&#xD;&#xA;* Wake up with a signal&#xD;&#xA;&#xD;&#xA;* Wake up with a timer&#xD;&#xA;&#xD;&#xA;This is a summary I made from [this webpage](http://www.gammon.com.au/forum/?id=11497).&#xD;&#xA;&#xD;&#xA;That article applies mostly to ATmega328P, but the technique applies to other Arduino compatible controllers as well. As TheDoctor said well, you will need to check the datashet to make sure your controller suports any of those techniques and how to do it more precisely.&#xD;&#xA;" />
  <row Id="550" PostHistoryTypeId="2" PostId="237" RevisionGUID="b0f7c315-5dc1-410e-ba0a-e6580d8152f6" CreationDate="2014-02-15T16:15:17.440" UserId="197" Text="For a robotic project, I need to keep Arduino powered up for long time in an outdoor environment. What can I use to power the board?&#xD;&#xA;If battery is the only solution, can the device tell me remotely that batery is getting low?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="551" PostHistoryTypeId="1" PostId="237" RevisionGUID="b0f7c315-5dc1-410e-ba0a-e6580d8152f6" CreationDate="2014-02-15T16:15:17.440" UserId="197" Text="How to power Arduino externally for long term?" />
  <row Id="552" PostHistoryTypeId="3" PostId="237" RevisionGUID="b0f7c315-5dc1-410e-ba0a-e6580d8152f6" CreationDate="2014-02-15T16:15:17.440" UserId="197" Text="&lt;power&gt;" />
  <row Id="553" PostHistoryTypeId="2" PostId="238" RevisionGUID="c76e204f-dbbc-4ed4-a62d-a3c8fdf38588" CreationDate="2014-02-15T16:29:38.010" UserId="8" Text="There are several options for Arduino power in an external environment.&#xD;&#xA;&#xD;&#xA;* [Wall wart](https://www.sparkfun.com/products/298): Connects to a wall socket, provides a great long-term source of power&#xD;&#xA;* [Rechargeable battery](https://www.sparkfun.com/products/8483): Doesn't last long, but they can be recharged and monitored with a [low cost board](https://www.sparkfun.com/products/10217)&#xD;&#xA;* [Alkaline Battery](https://www.sparkfun.com/products/10218): Last longer, there are some monitoring systems available.&#xD;&#xA;* [Solar](https://www.sparkfun.com/products/7840): Only works when the sun is out, unless you combine it with a rechargable battery ([example](https://www.sparkfun.com/products/11496))&#xD;&#xA;* Nuclear power: NOT RECOMMENDED!!!" />
  <row Id="554" PostHistoryTypeId="5" PostId="200" RevisionGUID="e8ddd5c6-f835-4897-8775-1c4dc93c4e06" CreationDate="2014-02-15T17:21:21.880" UserId="60" Comment="clarity" Text="My initial guess is wrong. I would have thought it would simply return from loop and the core library would just call loop() again. However, I see the following code was created. Noticing that __stop_program is a hard loop...&#xD;&#xA;&#xD;&#xA;An extract of Blink.ino's listing, with exit(0) added:&#xD;&#xA;&#xD;&#xA;&lt;!-- language: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;    // the loop routine runs over and over again forever:&#xD;&#xA;    void loop() {&#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      exit(0);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The disassembly of the above:&#xD;&#xA;&#xD;&#xA;    00000100 &lt;loop&gt;:&#xD;&#xA;     100:	80 91 00 01 	lds	r24, 0x0100&#xD;&#xA;     104:	61 e0       	ldi	r22, 0x01	; 1&#xD;&#xA;     106:	0e 94 ca 01 	call	0x394	; 0x394 &lt;digitalWrite&gt;&#xD;&#xA;     10a:	68 ee       	ldi	r22, 0xE8	; 232&#xD;&#xA;     10c:	73 e0       	ldi	r23, 0x03	; 3&#xD;&#xA;     10e:	80 e0       	ldi	r24, 0x00	; 0&#xD;&#xA;     110:	90 e0       	ldi	r25, 0x00	; 0&#xD;&#xA;     112:	0e 94 23 01 	call	0x246	; 0x246 &lt;delay&gt;&#xD;&#xA;     116:	80 91 00 01 	lds	r24, 0x0100&#xD;&#xA;     11a:	60 e0       	ldi	r22, 0x00	; 0&#xD;&#xA;     11c:	0e 94 ca 01 	call	0x394	; 0x394 &lt;digitalWrite&gt;&#xD;&#xA;     120:	68 ee       	ldi	r22, 0xE8	; 232&#xD;&#xA;     122:	73 e0       	ldi	r23, 0x03	; 3&#xD;&#xA;     124:	80 e0       	ldi	r24, 0x00	; 0&#xD;&#xA;     126:	90 e0       	ldi	r25, 0x00	; 0&#xD;&#xA;     128:	0e 94 23 01 	call	0x246	; 0x246 &lt;delay&gt;&#xD;&#xA;     12c:	80 e0       	ldi	r24, 0x00	; 0&#xD;&#xA;     12e:	90 e0       	ldi	r25, 0x00	; 0&#xD;&#xA;     130:	0e 94 2e 02 	call	0x45c	; 0x45c &lt;_exit&gt;&#xD;&#xA;&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;    0000045c &lt;_exit&gt;:&#xD;&#xA;     45c:	f8 94       	cli&#xD;&#xA;&#xD;&#xA;    0000045e &lt;__stop_program&gt;:&#xD;&#xA;     45e:	ff cf       	rjmp	.-2      	; 0x45e &lt;__stop_program&gt;&#xD;&#xA;&#xD;&#xA;Note that if _exit had not called cli, interrupts would be able to do stuff. But that is not the case.&#xD;&#xA;" />
  <row Id="555" PostHistoryTypeId="2" PostId="239" RevisionGUID="cecafe59-f8b7-4fb6-8536-fae3cc210ce8" CreationDate="2014-02-15T17:28:24.073" UserId="84" Text="In addition to what others have said (on which I fully agree), I would advise to read [this adafruit article][1] about memory; it's well written, explains a lot of things about memory and provide hints on how to optimize it.&#xD;&#xA;&#xD;&#xA;At the end of the read, I think you would get a quite complete answer to your question.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://learn.adafruit.com/memories-of-an-arduino/you-know-you-have-a-memory-problem-when-dot-dot-dot" />
  <row Id="556" PostHistoryTypeId="6" PostId="193" RevisionGUID="44b3270b-ba9e-467e-ab4d-de556b7f28a5" CreationDate="2014-02-15T18:49:58.630" UserId="11" Comment="edited tags" Text="&lt;uno&gt;&lt;programming&gt;&lt;arduino-leonardo&gt;&lt;sketch&gt;" />
  <row Id="560" PostHistoryTypeId="10" PostId="38" RevisionGUID="f0b288f9-691a-405d-9c38-c2a288e4a109" CreationDate="2014-02-15T20:28:58.753" UserId="-1" Comment="102" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:13,&quot;DisplayName&quot;:&quot;Matthew G.&quot;},{&quot;Id&quot;:37,&quot;DisplayName&quot;:&quot;The Guy with The Hat&quot;},{&quot;Id&quot;:32,&quot;DisplayName&quot;:&quot;x4mer&quot;},{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;},{&quot;Id&quot;:52,&quot;DisplayName&quot;:&quot;anorton&quot;}]}" />
  <row Id="561" PostHistoryTypeId="5" PostId="216" RevisionGUID="3b55eb47-1345-4e51-bc1a-b345aca66540" CreationDate="2014-02-15T20:36:01.767" UserId="42" Comment="added 2161 characters in body" Text="A Pulse Width Modulation (PWM) signal is a series of digital pulses. Each pulse makes the signal go high (on) for a short period, and it then drops back to low (off) for a short period before the next pulse. The result can be referred to as a square or rectangular wave, because of its appearance if it is graphed as voltage over time.&#xD;&#xA;&#xD;&#xA;There are two important attributes which describe a PWM signal. Firstly, the frequency determines how often the pulses happen. Frequency is expressed in Hertz (Hz), which is the number of pulses per second. PWM signals generated by the Arduino usually have a frequency of 490 Hz (or 980 Hz in some cases).&#xD;&#xA;&#xD;&#xA;The second attribute of a PWM signal is the duty cycle. For human-readable purposes, it is often expressed as a percentage. This determines how long a pulse lasts compared to the space between pulses. For example, a pulse could last 5 milliseconds, and be followed by a 15 millisecond gap before the next pulse. This is a 25% duty cycle, because the pulse is high for a quarter of the total time. A 10ms pulse followed by a 10ms gap would be a 50% duty cycle, and so on.&#xD;&#xA;&#xD;&#xA;PWM is very useful for controlling the speed of a DC motor. Raising or lowing the duty cycle will cause the motor to speed up or slow down. A conventional analog approach to motor control would raise or lower the voltage instead, which can result in poorer performance.&#xD;&#xA;&#xD;&#xA;Similarly, a PWM signal can effectively control the brightness of an LED. Raising and lowering the duty cycle will increase and decrease the apparent brightness of the light.&#xD;&#xA;&#xD;&#xA;The most common way to produce a PWM signal on the Arduino is using the [`analogWrite()`][1] function. The frequency is fixed, but it allows specification of the duty cycle in the range 0 to 255 (where 255 represents 100%).&#xD;&#xA;&#xD;&#xA;The [`tone()`][2] function also allows a PWM output to be generated. It has a fixed 50% duty cycle, but allows specification of the frequency in Hz. It is primarily intended for generating simple sounds on a speaker, but could be used for other purposes as well.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/AnalogWrite&#xD;&#xA;  [2]: http://arduino.cc/en/Reference/Tone" />
  <row Id="562" PostHistoryTypeId="24" PostId="216" RevisionGUID="3b55eb47-1345-4e51-bc1a-b345aca66540" CreationDate="2014-02-15T20:36:01.767" Comment="Proposed by 42 approved by 8, 11 edit id of 41" />
  <row Id="563" PostHistoryTypeId="5" PostId="214" RevisionGUID="24a7ac12-9a84-41ee-b9d1-7bdac35f9722" CreationDate="2014-02-15T20:36:19.220" UserId="118" Comment="added 59 characters in body" Text="I&lt;sup&gt;2&lt;/sup&gt;C, I-squared-C, bus for low speed peripherals." />
  <row Id="564" PostHistoryTypeId="24" PostId="214" RevisionGUID="24a7ac12-9a84-41ee-b9d1-7bdac35f9722" CreationDate="2014-02-15T20:36:19.220" Comment="Proposed by 118 approved by 8, 11 edit id of 40" />
  <row Id="565" PostHistoryTypeId="5" PostId="217" RevisionGUID="c92e3742-1a71-4805-a89e-e56e0cd732a7" CreationDate="2014-02-15T20:36:33.470" UserId="42" Comment="added 148 characters in body" Text="Pulse Width Modulation is used to generate a digital signal which can (among other things) control the speed of a motor or the brightness of an LED." />
  <row Id="566" PostHistoryTypeId="24" PostId="217" RevisionGUID="c92e3742-1a71-4805-a89e-e56e0cd732a7" CreationDate="2014-02-15T20:36:33.470" Comment="Proposed by 42 approved by 8, 11 edit id of 42" />
  <row Id="567" PostHistoryTypeId="5" PostId="213" RevisionGUID="c5ec7ae6-0427-41e4-9b1f-e8db79dff4f0" CreationDate="2014-02-15T20:37:02.457" UserId="118" Comment="added 168 characters in body" Text="Inter-Integrated Circuit, I&lt;sup&gt;2&lt;/sup&gt;C, I-squared-C, bus for low speed peripherals.  See the [Wikipedia article for more info](http://en.wikipedia.org/wiki/I%C2%B2C)." />
  <row Id="568" PostHistoryTypeId="24" PostId="213" RevisionGUID="c5ec7ae6-0427-41e4-9b1f-e8db79dff4f0" CreationDate="2014-02-15T20:37:02.457" Comment="Proposed by 118 approved by 8, 11 edit id of 39" />
  <row Id="569" PostHistoryTypeId="2" PostId="241" RevisionGUID="c7e46d05-017f-4860-b7a6-83048c0d7563" CreationDate="2014-02-15T21:21:34.910" UserId="186" Text="There are two things to do if you run out of storage:&#xD;&#xA;&#xD;&#xA;* Somehow &quot;optimize&quot; your code so it needs less storage; or at least uses less of the particular kind of storage that you ran out of (and uses more of the kind of storage that you still have plenty of). Or,&#xD;&#xA;* Add more storage.&#xD;&#xA;&#xD;&#xA;There are lots of tips online on how to do the first (and for the vast majority of things people do with the Arduino, the build-in storage is more than enough after &quot;optimizing&quot;).&#xD;&#xA;So I'll focus on the second:&#xD;&#xA;&#xD;&#xA;There are 3 things that use up flash or SRAM; each one needs a slightly different approach to adding storage:&#xD;&#xA;&#xD;&#xA;* variable storage: it is possible to expand SRAM, as sachleen has already pointed out.&#xD;&#xA;**SRAM, FRAM, and NVSRAM** are all appropriate for rapidly-changing variables.&#xD;&#xA;(While in principle you could use flash to store variables, then you have to worry about flash wear-out).&#xD;&#xA;SPI (a serial protocol) is the easiest to connect to the Arduino.&#xD;&#xA;The [SpiRAM library][1] works with the Microchip [23K256][2] serial SRAM chip.&#xD;&#xA;The Ramtron [FM25W256 serial FRAM][3] chip (now owned by Cypress) also uses SPI.&#xD;&#xA;The Cypress [CY14B101 NVSRAM][4] also uses SPI.&#xD;&#xA;Etc.&#xD;&#xA;&#xD;&#xA;* constant data that needs to still be there the next time the power comes on: this is almost as simple as expanding SRAM. There are many external **EEPROM, FRAM, NVSRAM, and FLASH** storage devices available.&#xD;&#xA;Currently the lowest cost per MB are **SD flash cards** (which can accessed via SPI).&#xD;&#xA;The Ramtron FM25W256 (see above), the Cypress CY14B101 (see above), etc. can also store constant data.&#xD;&#xA;Many expansion shields include a SD card slot,&#xD;&#xA;and several [libraries][5] and [tutorials][6] support reading and writing to (flash) SD cards.&#xD;&#xA;(We can't use SRAM for this, because SRAM forgets everything when the power goes out).&#xD;&#xA;&#xD;&#xA;* executable code: Unfortunately, expanding an Arduino's Flash memory to increase program space isn't possible. However, a programmer can always refactor a sketch to reduce code size at the expense of increasing data size and making it run slightly slower. (In theory, you could go so far as translate your entire sketch into some interpreted language, store that version of your sketch on a SD card, and then write a interpreter for that language that runs on the Arduino to fetch and execute instructions from the SD card -- [Forth on Arduino][7], a BASIC interpreter, a Tom Napier Picaro interpreter, some application-specific language, etc.).&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Main/SpiRAM&#xD;&#xA;  [2]: http://ww1.microchip.com/downloads/en/DeviceDoc/22100D.pdf&#xD;&#xA;  [3]: http://www.cypress.com/?docID=44787&#xD;&#xA;  [4]: http://www.cypress.com/?rID=45568&#xD;&#xA;  [5]: http://arduino.cc/en/Reference/SDCardNotes&#xD;&#xA;  [6]: http://learn.adafruit.com/adafruit-micro-sd-breakout-board-card-tutorial/look-out&#xD;&#xA;  [7]: http://playground.arduino.cc//CommonTopics/ForthOnArduino" />
  <row Id="571" PostHistoryTypeId="2" PostId="242" RevisionGUID="1ea1541e-8b12-4538-b3c8-7e6cdc2c2185" CreationDate="2014-02-15T23:54:05.670" UserId="202" Text="I'm currently trying to create an Arduino time clock by using the PJRC Time library (http://www.pjrc.com/teensy/td_libs_Time.html). I know that since most of the Arduino boards are running with a 16MHz clock and a single resonator, the time can become &quot;out-of-sync&quot; after a certain period of time. &#xD;&#xA;&#xD;&#xA;However, I was wondering if anyone has an idea about the accuracy of the Time library when used on the Arduino DUE with a 84MHz clock. I've been testing it out and so far, the clock has been kept in sync for a few hours. Thanks!" />
  <row Id="572" PostHistoryTypeId="1" PostId="242" RevisionGUID="1ea1541e-8b12-4538-b3c8-7e6cdc2c2185" CreationDate="2014-02-15T23:54:05.670" UserId="202" Text="Arduino Time Clock Accuracy" />
  <row Id="573" PostHistoryTypeId="3" PostId="242" RevisionGUID="1ea1541e-8b12-4538-b3c8-7e6cdc2c2185" CreationDate="2014-02-15T23:54:05.670" UserId="202" Text="&lt;time&gt;&lt;arduino-due&gt;" />
  <row Id="574" PostHistoryTypeId="2" PostId="243" RevisionGUID="619389a9-2c5e-4d36-90d9-8bc1590490df" CreationDate="2014-02-16T00:30:46.663" UserId="10" Text="The limitations of accuracy of the library depend on accuracy of the crystal. When they make, or cook, the crystal they can only make it to a certain degree accurate, also the environment of the crystal (temperature, humidity, etc.) play a role in the accuracy of it. Let's say you have a crystal that is off by .5 second every hour, great for short term, but if you expand that over a year it is over 1 hour off by that time. If you want something to keep an accurate time over a long period I suggest a real time clock (they still have inaccuracies), a GPS module, or an internet connect to sync with.&#xD;&#xA;&#xD;&#xA;For further information look at the [wikipedia article on quartz crystals][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://en.wikipedia.org/wiki/Quartz_clock" />
  <row Id="575" PostHistoryTypeId="5" PostId="243" RevisionGUID="7eab1f13-5af5-4c27-b8a8-b393dbfb5eaf" CreationDate="2014-02-16T03:28:07.877" UserId="202" Comment="Added more info from comments above." Text="The limitations of accuracy of the library depend on accuracy of the crystal. When they make, or cook, the crystal they can only make it to a certain degree accurate, also the environment of the crystal (temperature, humidity, etc.) play a role in the accuracy of it. Let's say you have a crystal that is off by .5 second every hour, great for short term, but if you expand that over a year it is over 1 hour off by that time. If you want something to keep an accurate time over a long period I suggest a real time clock (they still have inaccuracies), a GPS module, or an internet connect to sync with.&#xD;&#xA;&#xD;&#xA;For further information look at the [wikipedia article on quartz crystals][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://en.wikipedia.org/wiki/Quartz_clock&#xD;&#xA;&#xD;&#xA;The use of a 84MHz crystal versus a 16MHz crystal will not necessarily improve the accuracy of the Arduino clock since the frequency of the crystal is more an indicator of processor speed than accuracy. The accuracy of the Arduino clock is primarily dependent on the accuracy of the crystal oscillator." />
  <row Id="576" PostHistoryTypeId="24" PostId="243" RevisionGUID="7eab1f13-5af5-4c27-b8a8-b393dbfb5eaf" CreationDate="2014-02-16T03:28:07.877" Comment="Proposed by 202 approved by 10, 65 edit id of 44" />
  <row Id="581" PostHistoryTypeId="2" PostId="244" RevisionGUID="17a622c8-66e0-4d87-b857-6e1cb5e47286" CreationDate="2014-02-16T07:50:26.030" UserId="83" Text="Your average system clock crystal will be off by several tens ppm (parts per million. They are great for stable and accurate timing of signals, but dramatic for keeping accurate time. Without special provisions the system crystal may be off by several seconds per day.&#xD;&#xA;&#xD;&#xA;The solution is to use a proper Real Time Clock, driven by what is commonly known as a 32768Hz watch crystal. These crystals are easily a factor 10 better in accuracy. You can either set up your own oscillator that interrupts the main processor and keep count in your Arduino sketch or you find a RTC breakout board.&#xD;&#xA;&#xD;&#xA;Two random examples that pop up in Google with search terms &quot;RTC breakout&quot;:&#xD;&#xA;&#xD;&#xA;- http://www.cutedigi.com/breakout-board/ds1302-rtc-breakout.html&#xD;&#xA;- https://www.sparkfun.com/products/10160&#xD;&#xA;&#xD;&#xA;" />
  <row Id="582" PostHistoryTypeId="2" PostId="245" RevisionGUID="07172b99-d528-4e61-ae43-12a4a134f25f" CreationDate="2014-02-16T08:20:35.773" UserId="84" Text="The best way to know the accuracy of the resonator of your board is to measure it yourself.&#xD;&#xA;&#xD;&#xA;To do so, you can use the Arduino `millis()` function of your board and write a small sketch that will:&#xD;&#xA;&#xD;&#xA;1. enable you to set the beginning time for measuring time drift (eg with a simple push button); you will trigger the button based on an **accurate** time base.&#xD;&#xA;2. then repeatedly call millis() until at least 120h (&quot;arduino hours&quot;, that would be around 5 days) have elapsed&#xD;&#xA;3. display a signal when those 120h have elapsed (your sketch should probably &quot;warn&quot; you before the exact time has been reached so you get ready for measure)&#xD;&#xA;4. when the 120h have elapsed, check your reference time based (used in step 1.) and check how much time have elapsed (should be 120h +/- epsilon)&#xD;&#xA;5. once you know the drift of your clock, and provided your board will run in the same environental conditions (temperature mainly) of your measure, you can use it in your sketches to adjust the `millis()` value every hour or so.&#xD;&#xA;&#xD;&#xA;Of course, this approach is **far from perfect** as it requires **human intervention** and thus will create additional time drifts during measurements, that's why you need to measure your clock time drifts over a long period.&#xD;&#xA;&#xD;&#xA;An improved approach would be to connect a high accuracy RTC clock (the accuracy must be chosen based on the accuracy you need for your application) to your board and adapt the sketch so that it automatically calculates the drift. Once you got the time drift you can do the same as step 5 above in your sketches, and disconnect the RTC clock from your board.&#xD;&#xA;&#xD;&#xA;**Important points**:&#xD;&#xA;&#xD;&#xA;- measure the time drift on the board that will need clock adjustment later on (if you have several boards, you must measure one drift per board)&#xD;&#xA;- ensure the stability of the environment in which your board will be used&#xD;&#xA;&#xD;&#xA;Finally, if you really need high accuracy, then definitely connect an external clock source (e.g. RTC clock, GPS, NTP) to your board and use it as a SyncProvider for the PJRC library.&#xD;&#xA;" />
  <row Id="584" PostHistoryTypeId="2" PostId="246" RevisionGUID="46bdc5b3-d2f6-49e9-afdf-efad71f3e90f" CreationDate="2014-02-16T13:57:37.557" UserId="65" Text="I am working on a mobile robot controlled via a wireless 2.4 GHz link.The receiver is connected to the Arduino Uno which serves onboard as the main controller. The most critical (and main) input channel coming from the receiver produces a very noisy signal, which leads to lots of minor changes in the output of the actuators, even though these are not needed.&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&gt; ^Plot of the input of the Arduino in a 30 second interval. &#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;&gt; ^Plot of the input signal and the desired signal &#xD;&#xA;&#xD;&#xA;I am looking for libraries that can perform efficient smoothing (as shown in second graph). Are there any signal smoothing libraries available for the Arduino (Uno)?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/Z1yB0.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/6tnNC.png" />
  <row Id="585" PostHistoryTypeId="1" PostId="246" RevisionGUID="46bdc5b3-d2f6-49e9-afdf-efad71f3e90f" CreationDate="2014-02-16T13:57:37.557" UserId="65" Text="Are there any signal smoothing libraries for Arduino?" />
  <row Id="586" PostHistoryTypeId="3" PostId="246" RevisionGUID="46bdc5b3-d2f6-49e9-afdf-efad71f3e90f" CreationDate="2014-02-16T13:57:37.557" UserId="65" Text="&lt;library&gt;&lt;signal-processing&gt;" />
  <row Id="587" PostHistoryTypeId="2" PostId="247" RevisionGUID="dba8950f-52e0-4b38-8cb1-749a474e57aa" CreationDate="2014-02-16T14:45:56.470" UserId="8" Text="Have you tried a low pass filter? I found an example [here](http://arduino.cc/en/Tutorial/Smoothing) an another one [here](http://playground.arduino.cc/main/smooth).&#xD;&#xA;&#xD;&#xA;Both of these libraries have a list of data being read from the analog sensor of your choice which is averaged. Every new sensor value is added to the list, and the last one is thrown out, like this:&#xD;&#xA;&#xD;&#xA;    List: 3 4 3 3 4 3 5 3 2 3 4 3 &#xD;&#xA;    new reading added. old one thrown out&#xD;&#xA;          /--                     /--&#xD;&#xA;    List: 5 3 4 3 3 4 3 5 3 2 3 4&#xD;&#xA;    list averaged&#xD;&#xA;" />
  <row Id="588" PostHistoryTypeId="5" PostId="236" RevisionGUID="38b7554c-16ae-4f37-a8c8-80189d2fd862" CreationDate="2014-02-16T14:51:00.807" UserId="84" Comment="Added ref to 230V kits." Text="The [PowerSwitch Tail 2](https://www.sparkfun.com/products/10747) is a great way for experimenters to control mains voltages. It is insulated and internally decoupled, so you only have to hook up 5v, gnd, and a signal line to control it. &#xD;&#xA;&#xD;&#xA;This model supports only 120V, but there are also [kits][1] for 230V.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;image from sparkfun&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.powerswitchtail.com/Pages/PSTKKit.aspx&#xD;&#xA;  [2]: http://i.stack.imgur.com/kHPjV.png" />
  <row Id="589" PostHistoryTypeId="24" PostId="236" RevisionGUID="38b7554c-16ae-4f37-a8c8-80189d2fd862" CreationDate="2014-02-16T14:51:00.807" Comment="Proposed by 84 approved by 8, 65 edit id of 46" />
  <row Id="591" PostHistoryTypeId="2" PostId="248" RevisionGUID="48bc0c3a-2956-496b-86f7-3416a587a669" CreationDate="2014-02-16T16:34:31.177" UserId="113" Text="You could filter this digitally using a low pass filter:&#xD;&#xA;&#xD;&#xA;    int valueFilt = (1-0.99)*value + 0.99*valueFilt;&#xD;&#xA;&#xD;&#xA;Change the 0.99 to change the cut off frequency (closer to 1.0 is lower frequency). The actual expression for that value is exp(-2*pi*f/fs) where f is the cutoff frequency you want and fs is the frequency the data is sampled at.&#xD;&#xA;&#xD;&#xA;Another type of &quot;digital filter&quot; is an event filter. It works well on data that has outliers; e.g. 9,9,8,10,9,25,9 . An event filter returns the most frequent value. Statistically this is the mode.&#xD;&#xA;&#xD;&#xA;Statistical averages such as Mean, Mode etc.. can be calculated using the [Arduino Average Library][1].&#xD;&#xA;&#xD;&#xA;An example taken from the Arduino Library page referred to :&#xD;&#xA;&#xD;&#xA;    #include &lt;Average.h&gt;&#xD;&#xA;    #define CNT 600&#xD;&#xA;    int d[CNT];&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      int i;&#xD;&#xA;    &#xD;&#xA;      for(i=0; i&lt;CNT; i++)&#xD;&#xA;      {&#xD;&#xA;        d[i] = random(500);&#xD;&#xA;      }  &#xD;&#xA;    &#xD;&#xA;      Serial.print(&quot;Mean: &quot;);&#xD;&#xA;      Serial.print(mean(d,CNT),DEC);&#xD;&#xA;      Serial.print(&quot; Mode: &quot;);&#xD;&#xA;      Serial.print(mode(d,CNT),DEC);&#xD;&#xA;      Serial.print(&quot; Max: &quot;);&#xD;&#xA;      Serial.print(maximum(d,CNT),DEC);&#xD;&#xA;      Serial.print(&quot; Min: &quot;);&#xD;&#xA;      Serial.print(minimum(d,CNT),DEC);&#xD;&#xA;      Serial.print(&quot; Standard deviation: &quot;);&#xD;&#xA;      Serial.print(stddev(d,CNT),4);&#xD;&#xA;      Serial.println(&quot;&quot;);&#xD;&#xA;      Serial.println(&quot;&quot;);&#xD;&#xA;    &#xD;&#xA;      delay(5000);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Main/Average" />
  <row Id="592" PostHistoryTypeId="5" PostId="243" RevisionGUID="2d5fe974-3188-4829-b99e-fe42f0e975b6" CreationDate="2014-02-16T16:41:13.303" UserId="10" Comment="added 100 characters in body" Text="The limitations of accuracy of the library depend on accuracy of the crystal. When they make, or cook, the crystal they can only make it to a certain degree accurate, also the environment of the crystal (temperature, humidity, etc.) play a role in the accuracy of it. Let's say you have a crystal that is off by .5 second every hour, great for short term, but if you expand that over a year it is over 1 hour off by that time. If you want something to keep an accurate time over a long period I suggest a real time clock (they still have inaccuracies), a GPS module, or an internet connect to sync with.&#xD;&#xA;&#xD;&#xA;For further information look at the [wikipedia article on quartz crystals][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://en.wikipedia.org/wiki/Quartz_clock&#xD;&#xA;&#xD;&#xA;The use of a 84MHz crystal versus a 16MHz crystal will not necessarily improve the accuracy of the Arduino clock since the frequency of the crystal is more an indicator of processor speed than accuracy. The accuracy of the Arduino clock is primarily dependent on the accuracy of the crystal oscillator.&#xD;&#xA;&#xD;&#xA;EDIT: I am no expert on crystal oscillators so if you see anything wrong here please let me know" />
  <row Id="593" PostHistoryTypeId="2" PostId="249" RevisionGUID="1efb1af7-7433-440d-b144-e2b11553fb34" CreationDate="2014-02-16T17:35:27.827" UserId="69" Text="On the hardware side of things, what is involved in making the Arduino receive signals from a TV Remote? What kind of infrared receiver is needed? Do TV remotes use some kind of channels, encoding, or encryption requiring special receivers or else additional programming work to decrypt the signals?" />
  <row Id="594" PostHistoryTypeId="1" PostId="249" RevisionGUID="1efb1af7-7433-440d-b144-e2b11553fb34" CreationDate="2014-02-16T17:35:27.827" UserId="69" Text="Infrared TV Remote to Arduino" />
  <row Id="595" PostHistoryTypeId="3" PostId="249" RevisionGUID="1efb1af7-7433-440d-b144-e2b11553fb34" CreationDate="2014-02-16T17:35:27.827" UserId="69" Text="&lt;wireless&gt;&lt;remote-control&gt;" />
  <row Id="596" PostHistoryTypeId="2" PostId="250" RevisionGUID="8bc659b8-0a08-444d-8748-1b0fe6fd00ac" CreationDate="2014-02-16T17:58:22.867" UserId="8" Text="A simple IR diode like [this](https://www.sparkfun.com/products/10266) can receive raw IR data. There are several chips which are designed to decode these signals, such as [this](https://www.sparkfun.com/products/8753) one.&#xD;&#xA;&#xD;&#xA;![Ir diode][1]  ----------------  ![Ir decoder chip][2]&#xD;&#xA;&#xD;&#xA;Ir Diode ------------------------------- Ir Decoder&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/yuUSq.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/Pj4C0.png" />
  <row Id="597" PostHistoryTypeId="2" PostId="251" RevisionGUID="81e2bfbd-f43a-4956-8a95-6de417b3cefe" CreationDate="2014-02-16T18:29:21.220" UserId="186" Text="&#xD;&#xA;&gt; How does one prepare clothing with embedded electronics for washing?&#xD;&#xA;&#xD;&#xA;* Remove the battery(ies) and other power supplies, and set them far away from the water. Buzzers and speakers also.&#xD;&#xA;* Gently wash clothing (including the Lilypad, LEDs, resistors, capacitors, integrated circuits, accelerometers, magnetometers, Bluetooth modules, GPS modules, etc.) by hand with a mild detergent.&#xD;&#xA;* Drip dry, or manually dry with a hair-dryer.&#xD;&#xA;&#xD;&#xA;See:&#xD;&#xA;&#xD;&#xA;* [&quot;LilyPad ... They're even washable!&quot;][2]&#xD;&#xA;* [&quot;accelerometer shirt ... is washable.&quot;][3]&#xD;&#xA;* [&quot;Are LEDs and Resistors Washable?&quot;][4] (Yes!)&#xD;&#xA;* [&quot;Remove After Washing&quot; on Piezo Buzzer][1]&#xD;&#xA;&#xD;&#xA;  [1]: http://electronics.stackexchange.com/questions/98556/remove-after-washing-on-piezo-buzzer&#xD;&#xA;  [2]: https://www.sparkfun.com/products/9266&#xD;&#xA;  [3]: http://web.media.mit.edu/~leah/LilyPad/build/accelero_shirt.html&#xD;&#xA;  [4]: http://forum.arduino.cc/index.php/topic,10382.0.html" />
  <row Id="598" PostHistoryTypeId="2" PostId="252" RevisionGUID="d1a73c15-5c01-4b29-b766-c9d45f167a36" CreationDate="2014-02-16T18:42:52.777" UserId="11" Text="The most common (not sure what others are used) carrier frequency is 38khz. You need an IR receiver tuned to that frequency to get the signal from the remove. See [this page][1] for way more information.&#xD;&#xA;&#xD;&#xA;There is no encryption or special receivers needed as long as the carrier frequencies match.&#xD;&#xA;&#xD;&#xA;That's really all the hardware you need. On the software side of things, you read this signal and decode it. There's a neat little library for doing exactly that. It's called [Arduino IRemote][2].&#xD;&#xA;&#xD;&#xA;It even has an example sketch which tells you just what the decoded value is of whatever button you pressed so you can use that in your other programs.&#xD;&#xA;&#xD;&#xA;  [1]: http://learn.adafruit.com/ir-sensor/ir-remote-signals&#xD;&#xA;  [2]: https://github.com/shirriff/Arduino-IRremote" />
  <row Id="599" PostHistoryTypeId="2" PostId="253" RevisionGUID="bbf5bd70-f48e-420e-8d71-d7b88bb99a6b" CreationDate="2014-02-16T18:48:57.677" UserId="186" Text="&#xD;&#xA;How do I write an Arduino sketch and an Android application to talk to each other over a standard USB cable?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="600" PostHistoryTypeId="1" PostId="253" RevisionGUID="bbf5bd70-f48e-420e-8d71-d7b88bb99a6b" CreationDate="2014-02-16T18:48:57.677" UserId="186" Text="How do I write an Arduino sketch and a Arduino application to talk to each other over a standard USB cable?" />
  <row Id="601" PostHistoryTypeId="3" PostId="253" RevisionGUID="bbf5bd70-f48e-420e-8d71-d7b88bb99a6b" CreationDate="2014-02-16T18:48:57.677" UserId="186" Text="&lt;android&gt;" />
  <row Id="602" PostHistoryTypeId="2" PostId="254" RevisionGUID="ccded112-2562-4fbb-b8b4-c6cbbdfc177f" CreationDate="2014-02-16T20:27:00.780" UserId="27" Text="Android devices usually don't have a USB host: they expect to be connected to some smarter device like your computer. Same goes with Arduino.&#xD;&#xA;For this reason Arduino made the [Mega ADK][1] (that means [Accessory Development Kit][2]).&#xD;&#xA;&#xD;&#xA;Mega ADK and Due act as USB hosts and can be connected directly to your Android phone. If you already have a board, another option is to get a USB host shield to add USB host capababilities.&#xD;&#xA;&#xD;&#xA;Your sketch will tell the phone what kind of accessory application it is and your phone will download the appropriate application from the store.&#xD;&#xA;&#xD;&#xA;There is a book about connecting [Arduino to Android][3].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardADK&#xD;&#xA;  [2]: https://developer.android.com/tools/adk/index.html&#xD;&#xA;  [3]: http://www.wrox.com/WileyCDA/WroxTitle/Professional-Android-Open-Accessory-Programming-with-Arduino.productCd-1118454766,descCd-DOWNLOAD.html" />
  <row Id="603" PostHistoryTypeId="5" PostId="253" RevisionGUID="859c2d47-9ec4-4b94-a732-f3646c084c99" CreationDate="2014-02-16T21:06:17.663" UserId="11" Comment="deleted 2 characters in body; edited title" Text="How do I write an Arduino sketch and an Android application to talk to each other over a standard USB cable?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="604" PostHistoryTypeId="4" PostId="253" RevisionGUID="859c2d47-9ec4-4b94-a732-f3646c084c99" CreationDate="2014-02-16T21:06:17.663" UserId="11" Comment="deleted 2 characters in body; edited title" Text="How do I write an Arduino sketch and an Android application to talk to each other over a standard USB cable?" />
  <row Id="605" PostHistoryTypeId="5" PostId="162" RevisionGUID="3da9018a-9102-40a0-8860-cba820a9d002" CreationDate="2014-02-16T21:48:06.310" UserId="44" Comment="fixed broken link" Text="If you want to know *exactly* how long something will take, there is only one solution: Look at the disassembly!&#xD;&#xA;&#xD;&#xA;Starting with the minimal code: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup(){};&#xD;&#xA;    &#xD;&#xA;    volatile uint16_t x;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      x = millis();&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;This code compiled and then fed into `avr-objdump -S` produces a documented disassembly. Here are the interesting excerpts:&#xD;&#xA;&#xD;&#xA;`void loop()` produces:  &#xD;&#xA;&#xD;&#xA;    000000a8 &lt;loop&gt;:&#xD;&#xA;      a8:	0e 94 a7 00 	call	0x14e	; 0x14e &lt;millis&gt;&#xD;&#xA;      ac:	60 93 00 01 	sts	0x0100, r22&#xD;&#xA;      b0:	70 93 01 01 	sts	0x0101, r23&#xD;&#xA;      b4:	80 93 02 01 	sts	0x0102, r24&#xD;&#xA;      b8:	90 93 03 01 	sts	0x0103, r25&#xD;&#xA;      bc:	08 95       	ret&#xD;&#xA;&#xD;&#xA;Which is a function call (`call`), four copies (which copy each of the bytes in the `uint32_t` return value of `millis()` (note that the arduino docs call this a `long`, but they are incorrect to not be explicitly specifying the variable sizes)), and finally the function return.&#xD;&#xA;&#xD;&#xA;`call` requires 4 clock cycles, and each `sts` requires 2 clock cycles, so we have a minimum of 12 clock cycles just for function call overhead.&#xD;&#xA;&#xD;&#xA;Now, lets look at the disassembly of the `&lt;millis&gt;` function, which is located at `0x14e`:  &#xD;&#xA;&#xD;&#xA;unsi&#xD;&#xA;&#xD;&#xA;    gned long millis()&#xD;&#xA;    {&#xD;&#xA;    	unsigned long m;&#xD;&#xA;    	uint8_t oldSREG = SREG;&#xD;&#xA;     14e:	8f b7       	in	r24, 0x3f	; 63&#xD;&#xA;    &#xD;&#xA;    	// disable interrupts while we read timer0_millis or we might get an&#xD;&#xA;    	// inconsistent value (e.g. in the middle of a write to timer0_millis)&#xD;&#xA;    	cli();&#xD;&#xA;     150:	f8 94       	cli&#xD;&#xA;    	m = timer0_millis;&#xD;&#xA;     152:	20 91 08 01 	lds	r18, 0x0108&#xD;&#xA;     156:	30 91 09 01 	lds	r19, 0x0109&#xD;&#xA;     15a:	40 91 0a 01 	lds	r20, 0x010A&#xD;&#xA;     15e:	50 91 0b 01 	lds	r21, 0x010B&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;     162:	8f bf       	out	0x3f, r24	; 63&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;     164:	b9 01       	movw	r22, r18&#xD;&#xA;     166:	ca 01       	movw	r24, r20&#xD;&#xA;     168:	08 95       	ret&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;As you can see, the `millis()` function is fairly simple:&#xD;&#xA;&#xD;&#xA;1. `in` saves the interrupt register settings (1 cycle)&#xD;&#xA;2. `cli` turns off the interrupts (1 cycle)&#xD;&#xA;3. `lds` copy one of the 4 bytes of the current value of the milli counter into a temporary register (2 clock cycles)&#xD;&#xA;4. `lds` Byte 2 (2 clock cycles)&#xD;&#xA;5. `lds` Byte 3 (2 clock cycles)&#xD;&#xA;6. `lds` Byte 4 (2 clock cycles)&#xD;&#xA;7. `out` restore interrupt settings (1 clock cycle)&#xD;&#xA;8. `movw` shuffle registers around (1 clock cycle)&#xD;&#xA;9. `movw` and again (1 clock cycle)&#xD;&#xA;10. `ret` return from subroutine  (4 cycles)&#xD;&#xA;&#xD;&#xA;So, if we add them all up, we have a total of 17 clock cycles in the `millis()` function itself, plus a call overhead of 12, for a total of 29 clock cycles.&#xD;&#xA;&#xD;&#xA;Assuming a 16 Mhz clock rate (most arduinos), each clock cycle is $1/16e6$ seconds, or 0.0000000625 seconds, which is 62.5 nanoseconds. 62.5 ns * 29 = 1.812 microseconds.&#xD;&#xA;&#xD;&#xA;Therefore, the total execution time for a single `millis()` call on *most* arduinos will be **1.812 microseconds**.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;[AVR Assembly reference][1]&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;As a side-note, there is space for optimization here! If you update the `unsigned long millis(){}` function definition to be `inline unsigned long millis(){}`, you would remove the call overhead (at the cost of *slightly* larger code size). Furthermore, it looks like the compiler is doing two unnecessary moves (the two `movw` calls, but I haven't looked at it that closely).&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Really, considering the function call overhead is 5 instructions, and the actual *contents* of the `millis()` function is only 6 instructions, I think the `millis()` function should really be `inline` by default, but the arduino codebase is rather poorly optimized.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Here is the full disassemby for anyone interested:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    sketch_feb13a.cpp.elf:     file format elf32-avr&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Disassembly of section .text:&#xD;&#xA;    &#xD;&#xA;    00000000 &lt;__vectors&gt;:&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    unsigned long micros() {&#xD;&#xA;       0:	0c 94 34 00 	jmp	0x68	; 0x68 &lt;__ctors_end&gt;&#xD;&#xA;       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      40:	0c 94 5f 00 	jmp	0xbe	; 0xbe &lt;__vector_16&gt;&#xD;&#xA;      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;    &#xD;&#xA;    00000068 &lt;__ctors_end&gt;:&#xD;&#xA;      68:	11 24       	eor	r1, r1&#xD;&#xA;      6a:	1f be       	out	0x3f, r1	; 63&#xD;&#xA;      6c:	cf ef       	ldi	r28, 0xFF	; 255&#xD;&#xA;      6e:	d8 e0       	ldi	r29, 0x08	; 8&#xD;&#xA;      70:	de bf       	out	0x3e, r29	; 62&#xD;&#xA;      72:	cd bf       	out	0x3d, r28	; 61&#xD;&#xA;    &#xD;&#xA;    00000074 &lt;__do_copy_data&gt;:&#xD;&#xA;      74:	11 e0       	ldi	r17, 0x01	; 1&#xD;&#xA;      76:	a0 e0       	ldi	r26, 0x00	; 0&#xD;&#xA;      78:	b1 e0       	ldi	r27, 0x01	; 1&#xD;&#xA;      7a:	e2 e0       	ldi	r30, 0x02	; 2&#xD;&#xA;      7c:	f2 e0       	ldi	r31, 0x02	; 2&#xD;&#xA;      7e:	02 c0       	rjmp	.+4      	; 0x84 &lt;.do_copy_data_start&gt;&#xD;&#xA;    &#xD;&#xA;    00000080 &lt;.do_copy_data_loop&gt;:&#xD;&#xA;      80:	05 90       	lpm	r0, Z+&#xD;&#xA;      82:	0d 92       	st	X+, r0&#xD;&#xA;    &#xD;&#xA;    00000084 &lt;.do_copy_data_start&gt;:&#xD;&#xA;      84:	a0 30       	cpi	r26, 0x00	; 0&#xD;&#xA;      86:	b1 07       	cpc	r27, r17&#xD;&#xA;      88:	d9 f7       	brne	.-10     	; 0x80 &lt;.do_copy_data_loop&gt;&#xD;&#xA;    &#xD;&#xA;    0000008a &lt;__do_clear_bss&gt;:&#xD;&#xA;      8a:	11 e0       	ldi	r17, 0x01	; 1&#xD;&#xA;      8c:	a0 e0       	ldi	r26, 0x00	; 0&#xD;&#xA;      8e:	b1 e0       	ldi	r27, 0x01	; 1&#xD;&#xA;      90:	01 c0       	rjmp	.+2      	; 0x94 &lt;.do_clear_bss_start&gt;&#xD;&#xA;    &#xD;&#xA;    00000092 &lt;.do_clear_bss_loop&gt;:&#xD;&#xA;      92:	1d 92       	st	X+, r1&#xD;&#xA;    &#xD;&#xA;    00000094 &lt;.do_clear_bss_start&gt;:&#xD;&#xA;      94:	ad 30       	cpi	r26, 0x0D	; 13&#xD;&#xA;      96:	b1 07       	cpc	r27, r17&#xD;&#xA;      98:	e1 f7       	brne	.-8      	; 0x92 &lt;.do_clear_bss_loop&gt;&#xD;&#xA;      9a:	0e 94 f0 00 	call	0x1e0	; 0x1e0 &lt;main&gt;&#xD;&#xA;      9e:	0c 94 ff 00 	jmp	0x1fe	; 0x1fe &lt;_exit&gt;&#xD;&#xA;    &#xD;&#xA;    000000a2 &lt;__bad_interrupt&gt;:&#xD;&#xA;      a2:	0c 94 00 00 	jmp	0	; 0x0 &lt;__vectors&gt;&#xD;&#xA;    &#xD;&#xA;    000000a6 &lt;setup&gt;:&#xD;&#xA;      a6:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    000000a8 &lt;loop&gt;:&#xD;&#xA;      a8:	0e 94 a7 00 	call	0x14e	; 0x14e &lt;millis&gt;&#xD;&#xA;      ac:	60 93 00 01 	sts	0x0100, r22&#xD;&#xA;      b0:	70 93 01 01 	sts	0x0101, r23&#xD;&#xA;      b4:	80 93 02 01 	sts	0x0102, r24&#xD;&#xA;      b8:	90 93 03 01 	sts	0x0103, r25&#xD;&#xA;      bc:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    000000be &lt;__vector_16&gt;:&#xD;&#xA;    #if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)&#xD;&#xA;    ISR(TIM0_OVF_vect)&#xD;&#xA;    #else&#xD;&#xA;    ISR(TIMER0_OVF_vect)&#xD;&#xA;    #endif&#xD;&#xA;    {&#xD;&#xA;      be:	1f 92       	push	r1&#xD;&#xA;      c0:	0f 92       	push	r0&#xD;&#xA;      c2:	0f b6       	in	r0, 0x3f	; 63&#xD;&#xA;      c4:	0f 92       	push	r0&#xD;&#xA;      c6:	11 24       	eor	r1, r1&#xD;&#xA;      c8:	2f 93       	push	r18&#xD;&#xA;      ca:	3f 93       	push	r19&#xD;&#xA;      cc:	8f 93       	push	r24&#xD;&#xA;      ce:	9f 93       	push	r25&#xD;&#xA;      d0:	af 93       	push	r26&#xD;&#xA;      d2:	bf 93       	push	r27&#xD;&#xA;    	// copy these to local variables so they can be stored in registers&#xD;&#xA;    	// (volatile variables must be read from memory on every access)&#xD;&#xA;    	unsigned long m = timer0_millis;&#xD;&#xA;      d4:	80 91 08 01 	lds	r24, 0x0108&#xD;&#xA;      d8:	90 91 09 01 	lds	r25, 0x0109&#xD;&#xA;      dc:	a0 91 0a 01 	lds	r26, 0x010A&#xD;&#xA;      e0:	b0 91 0b 01 	lds	r27, 0x010B&#xD;&#xA;    	unsigned char f = timer0_fract;&#xD;&#xA;      e4:	30 91 0c 01 	lds	r19, 0x010C&#xD;&#xA;    &#xD;&#xA;    	m += MILLIS_INC;&#xD;&#xA;      e8:	01 96       	adiw	r24, 0x01	; 1&#xD;&#xA;      ea:	a1 1d       	adc	r26, r1&#xD;&#xA;      ec:	b1 1d       	adc	r27, r1&#xD;&#xA;    	f += FRACT_INC;&#xD;&#xA;      ee:	23 2f       	mov	r18, r19&#xD;&#xA;      f0:	2d 5f       	subi	r18, 0xFD	; 253&#xD;&#xA;    	if (f &gt;= FRACT_MAX) {&#xD;&#xA;      f2:	2d 37       	cpi	r18, 0x7D	; 125&#xD;&#xA;      f4:	20 f0       	brcs	.+8      	; 0xfe &lt;__vector_16+0x40&gt;&#xD;&#xA;    		f -= FRACT_MAX;&#xD;&#xA;      f6:	2d 57       	subi	r18, 0x7D	; 125&#xD;&#xA;    		m += 1;&#xD;&#xA;      f8:	01 96       	adiw	r24, 0x01	; 1&#xD;&#xA;      fa:	a1 1d       	adc	r26, r1&#xD;&#xA;      fc:	b1 1d       	adc	r27, r1&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	timer0_fract = f;&#xD;&#xA;      fe:	20 93 0c 01 	sts	0x010C, r18&#xD;&#xA;    	timer0_millis = m;&#xD;&#xA;     102:	80 93 08 01 	sts	0x0108, r24&#xD;&#xA;     106:	90 93 09 01 	sts	0x0109, r25&#xD;&#xA;     10a:	a0 93 0a 01 	sts	0x010A, r26&#xD;&#xA;     10e:	b0 93 0b 01 	sts	0x010B, r27&#xD;&#xA;    	timer0_overflow_count++;&#xD;&#xA;     112:	80 91 04 01 	lds	r24, 0x0104&#xD;&#xA;     116:	90 91 05 01 	lds	r25, 0x0105&#xD;&#xA;     11a:	a0 91 06 01 	lds	r26, 0x0106&#xD;&#xA;     11e:	b0 91 07 01 	lds	r27, 0x0107&#xD;&#xA;     122:	01 96       	adiw	r24, 0x01	; 1&#xD;&#xA;     124:	a1 1d       	adc	r26, r1&#xD;&#xA;     126:	b1 1d       	adc	r27, r1&#xD;&#xA;     128:	80 93 04 01 	sts	0x0104, r24&#xD;&#xA;     12c:	90 93 05 01 	sts	0x0105, r25&#xD;&#xA;     130:	a0 93 06 01 	sts	0x0106, r26&#xD;&#xA;     134:	b0 93 07 01 	sts	0x0107, r27&#xD;&#xA;    }&#xD;&#xA;     138:	bf 91       	pop	r27&#xD;&#xA;     13a:	af 91       	pop	r26&#xD;&#xA;     13c:	9f 91       	pop	r25&#xD;&#xA;     13e:	8f 91       	pop	r24&#xD;&#xA;     140:	3f 91       	pop	r19&#xD;&#xA;     142:	2f 91       	pop	r18&#xD;&#xA;     144:	0f 90       	pop	r0&#xD;&#xA;     146:	0f be       	out	0x3f, r0	; 63&#xD;&#xA;     148:	0f 90       	pop	r0&#xD;&#xA;     14a:	1f 90       	pop	r1&#xD;&#xA;     14c:	18 95       	reti&#xD;&#xA;    &#xD;&#xA;    0000014e &lt;millis&gt;:&#xD;&#xA;    &#xD;&#xA;    unsigned long millis()&#xD;&#xA;    {&#xD;&#xA;    	unsigned long m;&#xD;&#xA;    	uint8_t oldSREG = SREG;&#xD;&#xA;     14e:	8f b7       	in	r24, 0x3f	; 63&#xD;&#xA;    &#xD;&#xA;    	// disable interrupts while we read timer0_millis or we might get an&#xD;&#xA;    	// inconsistent value (e.g. in the middle of a write to timer0_millis)&#xD;&#xA;    	cli();&#xD;&#xA;     150:	f8 94       	cli&#xD;&#xA;    	m = timer0_millis;&#xD;&#xA;     152:	20 91 08 01 	lds	r18, 0x0108&#xD;&#xA;     156:	30 91 09 01 	lds	r19, 0x0109&#xD;&#xA;     15a:	40 91 0a 01 	lds	r20, 0x010A&#xD;&#xA;     15e:	50 91 0b 01 	lds	r21, 0x010B&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;     162:	8f bf       	out	0x3f, r24	; 63&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;     164:	b9 01       	movw	r22, r18&#xD;&#xA;     166:	ca 01       	movw	r24, r20&#xD;&#xA;     168:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    0000016a &lt;init&gt;:&#xD;&#xA;    &#xD;&#xA;    void init()&#xD;&#xA;    {&#xD;&#xA;    	// this needs to be called before setup() or some functions won't&#xD;&#xA;    	// work there&#xD;&#xA;    	sei();&#xD;&#xA;     16a:	78 94       	sei&#xD;&#xA;    	&#xD;&#xA;    	// on the ATmega168, timer 0 is also used for fast hardware pwm&#xD;&#xA;    	// (using phase-correct PWM would mean that timer 0 overflowed half as often&#xD;&#xA;    	// resulting in different millis() behavior on the ATmega8 and ATmega168)&#xD;&#xA;    #if defined(TCCR0A) &amp;&amp; defined(WGM01)&#xD;&#xA;    	sbi(TCCR0A, WGM01);&#xD;&#xA;     16c:	84 b5       	in	r24, 0x24	; 36&#xD;&#xA;     16e:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     170:	84 bd       	out	0x24, r24	; 36&#xD;&#xA;    	sbi(TCCR0A, WGM00);&#xD;&#xA;     172:	84 b5       	in	r24, 0x24	; 36&#xD;&#xA;     174:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     176:	84 bd       	out	0x24, r24	; 36&#xD;&#xA;    	// this combination is for the standard atmega8&#xD;&#xA;    	sbi(TCCR0, CS01);&#xD;&#xA;    	sbi(TCCR0, CS00);&#xD;&#xA;    #elif defined(TCCR0B) &amp;&amp; defined(CS01) &amp;&amp; defined(CS00)&#xD;&#xA;    	// this combination is for the standard 168/328/1280/2560&#xD;&#xA;    	sbi(TCCR0B, CS01);&#xD;&#xA;     178:	85 b5       	in	r24, 0x25	; 37&#xD;&#xA;     17a:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     17c:	85 bd       	out	0x25, r24	; 37&#xD;&#xA;    	sbi(TCCR0B, CS00);&#xD;&#xA;     17e:	85 b5       	in	r24, 0x25	; 37&#xD;&#xA;     180:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     182:	85 bd       	out	0x25, r24	; 37&#xD;&#xA;    &#xD;&#xA;    	// enable timer 0 overflow interrupt&#xD;&#xA;    #if defined(TIMSK) &amp;&amp; defined(TOIE0)&#xD;&#xA;    	sbi(TIMSK, TOIE0);&#xD;&#xA;    #elif defined(TIMSK0) &amp;&amp; defined(TOIE0)&#xD;&#xA;    	sbi(TIMSK0, TOIE0);&#xD;&#xA;     184:	ee e6       	ldi	r30, 0x6E	; 110&#xD;&#xA;     186:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     188:	80 81       	ld	r24, Z&#xD;&#xA;     18a:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     18c:	80 83       	st	Z, r24&#xD;&#xA;    	// this is better for motors as it ensures an even waveform&#xD;&#xA;    	// note, however, that fast pwm mode can achieve a frequency of up&#xD;&#xA;    	// 8 MHz (with a 16 MHz clock) at 50% duty cycle&#xD;&#xA;    &#xD;&#xA;    #if defined(TCCR1B) &amp;&amp; defined(CS11) &amp;&amp; defined(CS10)&#xD;&#xA;    	TCCR1B = 0;&#xD;&#xA;     18e:	e1 e8       	ldi	r30, 0x81	; 129&#xD;&#xA;     190:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     192:	10 82       	st	Z, r1&#xD;&#xA;    &#xD;&#xA;    	// set timer 1 prescale factor to 64&#xD;&#xA;    	sbi(TCCR1B, CS11);&#xD;&#xA;     194:	80 81       	ld	r24, Z&#xD;&#xA;     196:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     198:	80 83       	st	Z, r24&#xD;&#xA;    #if F_CPU &gt;= 8000000L&#xD;&#xA;    	sbi(TCCR1B, CS10);&#xD;&#xA;     19a:	80 81       	ld	r24, Z&#xD;&#xA;     19c:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     19e:	80 83       	st	Z, r24&#xD;&#xA;    	sbi(TCCR1, CS10);&#xD;&#xA;    #endif&#xD;&#xA;    #endif&#xD;&#xA;    	// put timer 1 in 8-bit phase correct pwm mode&#xD;&#xA;    #if defined(TCCR1A) &amp;&amp; defined(WGM10)&#xD;&#xA;    	sbi(TCCR1A, WGM10);&#xD;&#xA;     1a0:	e0 e8       	ldi	r30, 0x80	; 128&#xD;&#xA;     1a2:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1a4:	80 81       	ld	r24, Z&#xD;&#xA;     1a6:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     1a8:	80 83       	st	Z, r24&#xD;&#xA;    &#xD;&#xA;    	// set timer 2 prescale factor to 64&#xD;&#xA;    #if defined(TCCR2) &amp;&amp; defined(CS22)&#xD;&#xA;    	sbi(TCCR2, CS22);&#xD;&#xA;    #elif defined(TCCR2B) &amp;&amp; defined(CS22)&#xD;&#xA;    	sbi(TCCR2B, CS22);&#xD;&#xA;     1aa:	e1 eb       	ldi	r30, 0xB1	; 177&#xD;&#xA;     1ac:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1ae:	80 81       	ld	r24, Z&#xD;&#xA;     1b0:	84 60       	ori	r24, 0x04	; 4&#xD;&#xA;     1b2:	80 83       	st	Z, r24&#xD;&#xA;    &#xD;&#xA;    	// configure timer 2 for phase correct pwm (8-bit)&#xD;&#xA;    #if defined(TCCR2) &amp;&amp; defined(WGM20)&#xD;&#xA;    	sbi(TCCR2, WGM20);&#xD;&#xA;    #elif defined(TCCR2A) &amp;&amp; defined(WGM20)&#xD;&#xA;    	sbi(TCCR2A, WGM20);&#xD;&#xA;     1b4:	e0 eb       	ldi	r30, 0xB0	; 176&#xD;&#xA;     1b6:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1b8:	80 81       	ld	r24, Z&#xD;&#xA;     1ba:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     1bc:	80 83       	st	Z, r24&#xD;&#xA;    #if defined(ADCSRA)&#xD;&#xA;    	// set a2d prescale factor to 128&#xD;&#xA;    	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.&#xD;&#xA;    	// XXX: this will not work properly for other clock speeds, and&#xD;&#xA;    	// this code should use F_CPU to determine the prescale factor.&#xD;&#xA;    	sbi(ADCSRA, ADPS2);&#xD;&#xA;     1be:	ea e7       	ldi	r30, 0x7A	; 122&#xD;&#xA;     1c0:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1c2:	80 81       	ld	r24, Z&#xD;&#xA;     1c4:	84 60       	ori	r24, 0x04	; 4&#xD;&#xA;     1c6:	80 83       	st	Z, r24&#xD;&#xA;    	sbi(ADCSRA, ADPS1);&#xD;&#xA;     1c8:	80 81       	ld	r24, Z&#xD;&#xA;     1ca:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     1cc:	80 83       	st	Z, r24&#xD;&#xA;    	sbi(ADCSRA, ADPS0);&#xD;&#xA;     1ce:	80 81       	ld	r24, Z&#xD;&#xA;     1d0:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     1d2:	80 83       	st	Z, r24&#xD;&#xA;    &#xD;&#xA;    	// enable a2d conversions&#xD;&#xA;    	sbi(ADCSRA, ADEN);&#xD;&#xA;     1d4:	80 81       	ld	r24, Z&#xD;&#xA;     1d6:	80 68       	ori	r24, 0x80	; 128&#xD;&#xA;     1d8:	80 83       	st	Z, r24&#xD;&#xA;    	// here so they can be used as normal digital i/o; they will be&#xD;&#xA;    	// reconnected in Serial.begin()&#xD;&#xA;    #if defined(UCSRB)&#xD;&#xA;    	UCSRB = 0;&#xD;&#xA;    #elif defined(UCSR0B)&#xD;&#xA;    	UCSR0B = 0;&#xD;&#xA;     1da:	10 92 c1 00 	sts	0x00C1, r1&#xD;&#xA;    #endif&#xD;&#xA;    }&#xD;&#xA;     1de:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    000001e0 &lt;main&gt;:&#xD;&#xA;    #include &lt;Arduino.h&gt;&#xD;&#xA;    &#xD;&#xA;    int main(void)&#xD;&#xA;     1e0:	cf 93       	push	r28&#xD;&#xA;     1e2:	df 93       	push	r29&#xD;&#xA;    {&#xD;&#xA;    	init();&#xD;&#xA;     1e4:	0e 94 b5 00 	call	0x16a	; 0x16a &lt;init&gt;&#xD;&#xA;    &#xD;&#xA;    #if defined(USBCON)&#xD;&#xA;    	USBDevice.attach();&#xD;&#xA;    #endif&#xD;&#xA;    	&#xD;&#xA;    	setup();&#xD;&#xA;     1e8:	0e 94 53 00 	call	0xa6	; 0xa6 &lt;setup&gt;&#xD;&#xA;        &#xD;&#xA;    	for (;;) {&#xD;&#xA;    		loop();&#xD;&#xA;    		if (serialEventRun) serialEventRun();&#xD;&#xA;     1ec:	c0 e0       	ldi	r28, 0x00	; 0&#xD;&#xA;     1ee:	d0 e0       	ldi	r29, 0x00	; 0&#xD;&#xA;    #endif&#xD;&#xA;    	&#xD;&#xA;    	setup();&#xD;&#xA;        &#xD;&#xA;    	for (;;) {&#xD;&#xA;    		loop();&#xD;&#xA;     1f0:	0e 94 54 00 	call	0xa8	; 0xa8 &lt;loop&gt;&#xD;&#xA;    		if (serialEventRun) serialEventRun();&#xD;&#xA;     1f4:	20 97       	sbiw	r28, 0x00	; 0&#xD;&#xA;     1f6:	e1 f3       	breq	.-8      	; 0x1f0 &lt;main+0x10&gt;&#xD;&#xA;     1f8:	0e 94 00 00 	call	0	; 0x0 &lt;__vectors&gt;&#xD;&#xA;     1fc:	f9 cf       	rjmp	.-14     	; 0x1f0 &lt;main+0x10&gt;&#xD;&#xA;    &#xD;&#xA;    000001fe &lt;_exit&gt;:&#xD;&#xA;     1fe:	f8 94       	cli&#xD;&#xA;    &#xD;&#xA;    00000200 &lt;__stop_program&gt;:&#xD;&#xA;     200:	ff cf       	rjmp	.-2      	; 0x200 &lt;__stop_program&gt;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/images/doc0856.pdf&#xD;&#xA;" />
  <row Id="606" PostHistoryTypeId="24" PostId="162" RevisionGUID="3da9018a-9102-40a0-8860-cba820a9d002" CreationDate="2014-02-16T21:48:06.310" Comment="Proposed by 44 approved by 8, 11 edit id of 47" />
  <row Id="607" PostHistoryTypeId="2" PostId="255" RevisionGUID="7741e18e-cdbb-4008-825e-bee1d3f4430e" CreationDate="2014-02-16T22:58:05.850" UserId="201" Text="In addition to the mentioned IDEs you can use Xcode with [embedXcode](http://embedxcode.weebly.com/) if you use a mac. The IDE has a great file structure and support for a lot of boards. For big and complex projects it is really good. I like to use vim or the arduino IDE for simpler and less complex sketches/projects. " />
  <row Id="608" PostHistoryTypeId="2" PostId="256" RevisionGUID="c8b81c14-1549-433c-a2cb-49cadb60ca05" CreationDate="2014-02-16T23:04:50.190" UserId="201" Text="Because avr-g++ should support all standard C / C++ constructs it is possible to code inline assembly. More info on [this](http://forum.arduino.cc/index.php/topic,40916.0.html) arduino.cc forum thread" />
  <row Id="609" PostHistoryTypeId="5" PostId="162" RevisionGUID="05871366-62a6-49ef-999f-11c791614efb" CreationDate="2014-02-16T23:05:10.977" UserId="11" Comment="deleted 2 characters in body" Text="If you want to know *exactly* how long something will take, there is only one solution: Look at the disassembly!&#xD;&#xA;&#xD;&#xA;Starting with the minimal code: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup(){};&#xD;&#xA;    &#xD;&#xA;    volatile uint16_t x;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      x = millis();&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;This code compiled and then fed into `avr-objdump -S` produces a documented disassembly. Here are the interesting excerpts:&#xD;&#xA;&#xD;&#xA;`void loop()` produces:  &#xD;&#xA;&#xD;&#xA;    000000a8 &lt;loop&gt;:&#xD;&#xA;      a8:	0e 94 a7 00 	call	0x14e	; 0x14e &lt;millis&gt;&#xD;&#xA;      ac:	60 93 00 01 	sts	0x0100, r22&#xD;&#xA;      b0:	70 93 01 01 	sts	0x0101, r23&#xD;&#xA;      b4:	80 93 02 01 	sts	0x0102, r24&#xD;&#xA;      b8:	90 93 03 01 	sts	0x0103, r25&#xD;&#xA;      bc:	08 95       	ret&#xD;&#xA;&#xD;&#xA;Which is a function call (`call`), four copies (which copy each of the bytes in the `uint32_t` return value of `millis()` (note that the arduino docs call this a `long`, but they are incorrect to not be explicitly specifying the variable sizes)), and finally the function return.&#xD;&#xA;&#xD;&#xA;`call` requires 4 clock cycles, and each `sts` requires 2 clock cycles, so we have a minimum of 12 clock cycles just for function call overhead.&#xD;&#xA;&#xD;&#xA;Now, lets look at the disassembly of the `&lt;millis&gt;` function, which is located at `0x14e`:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    unsigned long millis()&#xD;&#xA;    {&#xD;&#xA;    	unsigned long m;&#xD;&#xA;    	uint8_t oldSREG = SREG;&#xD;&#xA;     14e:	8f b7       	in	r24, 0x3f	; 63&#xD;&#xA;    &#xD;&#xA;    	// disable interrupts while we read timer0_millis or we might get an&#xD;&#xA;    	// inconsistent value (e.g. in the middle of a write to timer0_millis)&#xD;&#xA;    	cli();&#xD;&#xA;     150:	f8 94       	cli&#xD;&#xA;    	m = timer0_millis;&#xD;&#xA;     152:	20 91 08 01 	lds	r18, 0x0108&#xD;&#xA;     156:	30 91 09 01 	lds	r19, 0x0109&#xD;&#xA;     15a:	40 91 0a 01 	lds	r20, 0x010A&#xD;&#xA;     15e:	50 91 0b 01 	lds	r21, 0x010B&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;     162:	8f bf       	out	0x3f, r24	; 63&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;     164:	b9 01       	movw	r22, r18&#xD;&#xA;     166:	ca 01       	movw	r24, r20&#xD;&#xA;     168:	08 95       	ret&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;As you can see, the `millis()` function is fairly simple:&#xD;&#xA;&#xD;&#xA;1. `in` saves the interrupt register settings (1 cycle)&#xD;&#xA;2. `cli` turns off the interrupts (1 cycle)&#xD;&#xA;3. `lds` copy one of the 4 bytes of the current value of the milli counter into a temporary register (2 clock cycles)&#xD;&#xA;4. `lds` Byte 2 (2 clock cycles)&#xD;&#xA;5. `lds` Byte 3 (2 clock cycles)&#xD;&#xA;6. `lds` Byte 4 (2 clock cycles)&#xD;&#xA;7. `out` restore interrupt settings (1 clock cycle)&#xD;&#xA;8. `movw` shuffle registers around (1 clock cycle)&#xD;&#xA;9. `movw` and again (1 clock cycle)&#xD;&#xA;10. `ret` return from subroutine  (4 cycles)&#xD;&#xA;&#xD;&#xA;So, if we add them all up, we have a total of 17 clock cycles in the `millis()` function itself, plus a call overhead of 12, for a total of 29 clock cycles.&#xD;&#xA;&#xD;&#xA;Assuming a 16 Mhz clock rate (most arduinos), each clock cycle is $1/16e6$ seconds, or 0.0000000625 seconds, which is 62.5 nanoseconds. 62.5 ns * 29 = 1.812 microseconds.&#xD;&#xA;&#xD;&#xA;Therefore, the total execution time for a single `millis()` call on *most* arduinos will be **1.812 microseconds**.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;[AVR Assembly reference][1]&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;As a side-note, there is space for optimization here! If you update the `unsigned long millis(){}` function definition to be `inline unsigned long millis(){}`, you would remove the call overhead (at the cost of *slightly* larger code size). Furthermore, it looks like the compiler is doing two unnecessary moves (the two `movw` calls, but I haven't looked at it that closely).&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Really, considering the function call overhead is 5 instructions, and the actual *contents* of the `millis()` function is only 6 instructions, I think the `millis()` function should really be `inline` by default, but the arduino codebase is rather poorly optimized.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Here is the full disassemby for anyone interested:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    sketch_feb13a.cpp.elf:     file format elf32-avr&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Disassembly of section .text:&#xD;&#xA;    &#xD;&#xA;    00000000 &lt;__vectors&gt;:&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    unsigned long micros() {&#xD;&#xA;       0:	0c 94 34 00 	jmp	0x68	; 0x68 &lt;__ctors_end&gt;&#xD;&#xA;       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      40:	0c 94 5f 00 	jmp	0xbe	; 0xbe &lt;__vector_16&gt;&#xD;&#xA;      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;    &#xD;&#xA;    00000068 &lt;__ctors_end&gt;:&#xD;&#xA;      68:	11 24       	eor	r1, r1&#xD;&#xA;      6a:	1f be       	out	0x3f, r1	; 63&#xD;&#xA;      6c:	cf ef       	ldi	r28, 0xFF	; 255&#xD;&#xA;      6e:	d8 e0       	ldi	r29, 0x08	; 8&#xD;&#xA;      70:	de bf       	out	0x3e, r29	; 62&#xD;&#xA;      72:	cd bf       	out	0x3d, r28	; 61&#xD;&#xA;    &#xD;&#xA;    00000074 &lt;__do_copy_data&gt;:&#xD;&#xA;      74:	11 e0       	ldi	r17, 0x01	; 1&#xD;&#xA;      76:	a0 e0       	ldi	r26, 0x00	; 0&#xD;&#xA;      78:	b1 e0       	ldi	r27, 0x01	; 1&#xD;&#xA;      7a:	e2 e0       	ldi	r30, 0x02	; 2&#xD;&#xA;      7c:	f2 e0       	ldi	r31, 0x02	; 2&#xD;&#xA;      7e:	02 c0       	rjmp	.+4      	; 0x84 &lt;.do_copy_data_start&gt;&#xD;&#xA;    &#xD;&#xA;    00000080 &lt;.do_copy_data_loop&gt;:&#xD;&#xA;      80:	05 90       	lpm	r0, Z+&#xD;&#xA;      82:	0d 92       	st	X+, r0&#xD;&#xA;    &#xD;&#xA;    00000084 &lt;.do_copy_data_start&gt;:&#xD;&#xA;      84:	a0 30       	cpi	r26, 0x00	; 0&#xD;&#xA;      86:	b1 07       	cpc	r27, r17&#xD;&#xA;      88:	d9 f7       	brne	.-10     	; 0x80 &lt;.do_copy_data_loop&gt;&#xD;&#xA;    &#xD;&#xA;    0000008a &lt;__do_clear_bss&gt;:&#xD;&#xA;      8a:	11 e0       	ldi	r17, 0x01	; 1&#xD;&#xA;      8c:	a0 e0       	ldi	r26, 0x00	; 0&#xD;&#xA;      8e:	b1 e0       	ldi	r27, 0x01	; 1&#xD;&#xA;      90:	01 c0       	rjmp	.+2      	; 0x94 &lt;.do_clear_bss_start&gt;&#xD;&#xA;    &#xD;&#xA;    00000092 &lt;.do_clear_bss_loop&gt;:&#xD;&#xA;      92:	1d 92       	st	X+, r1&#xD;&#xA;    &#xD;&#xA;    00000094 &lt;.do_clear_bss_start&gt;:&#xD;&#xA;      94:	ad 30       	cpi	r26, 0x0D	; 13&#xD;&#xA;      96:	b1 07       	cpc	r27, r17&#xD;&#xA;      98:	e1 f7       	brne	.-8      	; 0x92 &lt;.do_clear_bss_loop&gt;&#xD;&#xA;      9a:	0e 94 f0 00 	call	0x1e0	; 0x1e0 &lt;main&gt;&#xD;&#xA;      9e:	0c 94 ff 00 	jmp	0x1fe	; 0x1fe &lt;_exit&gt;&#xD;&#xA;    &#xD;&#xA;    000000a2 &lt;__bad_interrupt&gt;:&#xD;&#xA;      a2:	0c 94 00 00 	jmp	0	; 0x0 &lt;__vectors&gt;&#xD;&#xA;    &#xD;&#xA;    000000a6 &lt;setup&gt;:&#xD;&#xA;      a6:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    000000a8 &lt;loop&gt;:&#xD;&#xA;      a8:	0e 94 a7 00 	call	0x14e	; 0x14e &lt;millis&gt;&#xD;&#xA;      ac:	60 93 00 01 	sts	0x0100, r22&#xD;&#xA;      b0:	70 93 01 01 	sts	0x0101, r23&#xD;&#xA;      b4:	80 93 02 01 	sts	0x0102, r24&#xD;&#xA;      b8:	90 93 03 01 	sts	0x0103, r25&#xD;&#xA;      bc:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    000000be &lt;__vector_16&gt;:&#xD;&#xA;    #if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)&#xD;&#xA;    ISR(TIM0_OVF_vect)&#xD;&#xA;    #else&#xD;&#xA;    ISR(TIMER0_OVF_vect)&#xD;&#xA;    #endif&#xD;&#xA;    {&#xD;&#xA;      be:	1f 92       	push	r1&#xD;&#xA;      c0:	0f 92       	push	r0&#xD;&#xA;      c2:	0f b6       	in	r0, 0x3f	; 63&#xD;&#xA;      c4:	0f 92       	push	r0&#xD;&#xA;      c6:	11 24       	eor	r1, r1&#xD;&#xA;      c8:	2f 93       	push	r18&#xD;&#xA;      ca:	3f 93       	push	r19&#xD;&#xA;      cc:	8f 93       	push	r24&#xD;&#xA;      ce:	9f 93       	push	r25&#xD;&#xA;      d0:	af 93       	push	r26&#xD;&#xA;      d2:	bf 93       	push	r27&#xD;&#xA;    	// copy these to local variables so they can be stored in registers&#xD;&#xA;    	// (volatile variables must be read from memory on every access)&#xD;&#xA;    	unsigned long m = timer0_millis;&#xD;&#xA;      d4:	80 91 08 01 	lds	r24, 0x0108&#xD;&#xA;      d8:	90 91 09 01 	lds	r25, 0x0109&#xD;&#xA;      dc:	a0 91 0a 01 	lds	r26, 0x010A&#xD;&#xA;      e0:	b0 91 0b 01 	lds	r27, 0x010B&#xD;&#xA;    	unsigned char f = timer0_fract;&#xD;&#xA;      e4:	30 91 0c 01 	lds	r19, 0x010C&#xD;&#xA;    &#xD;&#xA;    	m += MILLIS_INC;&#xD;&#xA;      e8:	01 96       	adiw	r24, 0x01	; 1&#xD;&#xA;      ea:	a1 1d       	adc	r26, r1&#xD;&#xA;      ec:	b1 1d       	adc	r27, r1&#xD;&#xA;    	f += FRACT_INC;&#xD;&#xA;      ee:	23 2f       	mov	r18, r19&#xD;&#xA;      f0:	2d 5f       	subi	r18, 0xFD	; 253&#xD;&#xA;    	if (f &gt;= FRACT_MAX) {&#xD;&#xA;      f2:	2d 37       	cpi	r18, 0x7D	; 125&#xD;&#xA;      f4:	20 f0       	brcs	.+8      	; 0xfe &lt;__vector_16+0x40&gt;&#xD;&#xA;    		f -= FRACT_MAX;&#xD;&#xA;      f6:	2d 57       	subi	r18, 0x7D	; 125&#xD;&#xA;    		m += 1;&#xD;&#xA;      f8:	01 96       	adiw	r24, 0x01	; 1&#xD;&#xA;      fa:	a1 1d       	adc	r26, r1&#xD;&#xA;      fc:	b1 1d       	adc	r27, r1&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	timer0_fract = f;&#xD;&#xA;      fe:	20 93 0c 01 	sts	0x010C, r18&#xD;&#xA;    	timer0_millis = m;&#xD;&#xA;     102:	80 93 08 01 	sts	0x0108, r24&#xD;&#xA;     106:	90 93 09 01 	sts	0x0109, r25&#xD;&#xA;     10a:	a0 93 0a 01 	sts	0x010A, r26&#xD;&#xA;     10e:	b0 93 0b 01 	sts	0x010B, r27&#xD;&#xA;    	timer0_overflow_count++;&#xD;&#xA;     112:	80 91 04 01 	lds	r24, 0x0104&#xD;&#xA;     116:	90 91 05 01 	lds	r25, 0x0105&#xD;&#xA;     11a:	a0 91 06 01 	lds	r26, 0x0106&#xD;&#xA;     11e:	b0 91 07 01 	lds	r27, 0x0107&#xD;&#xA;     122:	01 96       	adiw	r24, 0x01	; 1&#xD;&#xA;     124:	a1 1d       	adc	r26, r1&#xD;&#xA;     126:	b1 1d       	adc	r27, r1&#xD;&#xA;     128:	80 93 04 01 	sts	0x0104, r24&#xD;&#xA;     12c:	90 93 05 01 	sts	0x0105, r25&#xD;&#xA;     130:	a0 93 06 01 	sts	0x0106, r26&#xD;&#xA;     134:	b0 93 07 01 	sts	0x0107, r27&#xD;&#xA;    }&#xD;&#xA;     138:	bf 91       	pop	r27&#xD;&#xA;     13a:	af 91       	pop	r26&#xD;&#xA;     13c:	9f 91       	pop	r25&#xD;&#xA;     13e:	8f 91       	pop	r24&#xD;&#xA;     140:	3f 91       	pop	r19&#xD;&#xA;     142:	2f 91       	pop	r18&#xD;&#xA;     144:	0f 90       	pop	r0&#xD;&#xA;     146:	0f be       	out	0x3f, r0	; 63&#xD;&#xA;     148:	0f 90       	pop	r0&#xD;&#xA;     14a:	1f 90       	pop	r1&#xD;&#xA;     14c:	18 95       	reti&#xD;&#xA;    &#xD;&#xA;    0000014e &lt;millis&gt;:&#xD;&#xA;    &#xD;&#xA;    unsigned long millis()&#xD;&#xA;    {&#xD;&#xA;    	unsigned long m;&#xD;&#xA;    	uint8_t oldSREG = SREG;&#xD;&#xA;     14e:	8f b7       	in	r24, 0x3f	; 63&#xD;&#xA;    &#xD;&#xA;    	// disable interrupts while we read timer0_millis or we might get an&#xD;&#xA;    	// inconsistent value (e.g. in the middle of a write to timer0_millis)&#xD;&#xA;    	cli();&#xD;&#xA;     150:	f8 94       	cli&#xD;&#xA;    	m = timer0_millis;&#xD;&#xA;     152:	20 91 08 01 	lds	r18, 0x0108&#xD;&#xA;     156:	30 91 09 01 	lds	r19, 0x0109&#xD;&#xA;     15a:	40 91 0a 01 	lds	r20, 0x010A&#xD;&#xA;     15e:	50 91 0b 01 	lds	r21, 0x010B&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;     162:	8f bf       	out	0x3f, r24	; 63&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;     164:	b9 01       	movw	r22, r18&#xD;&#xA;     166:	ca 01       	movw	r24, r20&#xD;&#xA;     168:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    0000016a &lt;init&gt;:&#xD;&#xA;    &#xD;&#xA;    void init()&#xD;&#xA;    {&#xD;&#xA;    	// this needs to be called before setup() or some functions won't&#xD;&#xA;    	// work there&#xD;&#xA;    	sei();&#xD;&#xA;     16a:	78 94       	sei&#xD;&#xA;    	&#xD;&#xA;    	// on the ATmega168, timer 0 is also used for fast hardware pwm&#xD;&#xA;    	// (using phase-correct PWM would mean that timer 0 overflowed half as often&#xD;&#xA;    	// resulting in different millis() behavior on the ATmega8 and ATmega168)&#xD;&#xA;    #if defined(TCCR0A) &amp;&amp; defined(WGM01)&#xD;&#xA;    	sbi(TCCR0A, WGM01);&#xD;&#xA;     16c:	84 b5       	in	r24, 0x24	; 36&#xD;&#xA;     16e:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     170:	84 bd       	out	0x24, r24	; 36&#xD;&#xA;    	sbi(TCCR0A, WGM00);&#xD;&#xA;     172:	84 b5       	in	r24, 0x24	; 36&#xD;&#xA;     174:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     176:	84 bd       	out	0x24, r24	; 36&#xD;&#xA;    	// this combination is for the standard atmega8&#xD;&#xA;    	sbi(TCCR0, CS01);&#xD;&#xA;    	sbi(TCCR0, CS00);&#xD;&#xA;    #elif defined(TCCR0B) &amp;&amp; defined(CS01) &amp;&amp; defined(CS00)&#xD;&#xA;    	// this combination is for the standard 168/328/1280/2560&#xD;&#xA;    	sbi(TCCR0B, CS01);&#xD;&#xA;     178:	85 b5       	in	r24, 0x25	; 37&#xD;&#xA;     17a:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     17c:	85 bd       	out	0x25, r24	; 37&#xD;&#xA;    	sbi(TCCR0B, CS00);&#xD;&#xA;     17e:	85 b5       	in	r24, 0x25	; 37&#xD;&#xA;     180:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     182:	85 bd       	out	0x25, r24	; 37&#xD;&#xA;    &#xD;&#xA;    	// enable timer 0 overflow interrupt&#xD;&#xA;    #if defined(TIMSK) &amp;&amp; defined(TOIE0)&#xD;&#xA;    	sbi(TIMSK, TOIE0);&#xD;&#xA;    #elif defined(TIMSK0) &amp;&amp; defined(TOIE0)&#xD;&#xA;    	sbi(TIMSK0, TOIE0);&#xD;&#xA;     184:	ee e6       	ldi	r30, 0x6E	; 110&#xD;&#xA;     186:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     188:	80 81       	ld	r24, Z&#xD;&#xA;     18a:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     18c:	80 83       	st	Z, r24&#xD;&#xA;    	// this is better for motors as it ensures an even waveform&#xD;&#xA;    	// note, however, that fast pwm mode can achieve a frequency of up&#xD;&#xA;    	// 8 MHz (with a 16 MHz clock) at 50% duty cycle&#xD;&#xA;    &#xD;&#xA;    #if defined(TCCR1B) &amp;&amp; defined(CS11) &amp;&amp; defined(CS10)&#xD;&#xA;    	TCCR1B = 0;&#xD;&#xA;     18e:	e1 e8       	ldi	r30, 0x81	; 129&#xD;&#xA;     190:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     192:	10 82       	st	Z, r1&#xD;&#xA;    &#xD;&#xA;    	// set timer 1 prescale factor to 64&#xD;&#xA;    	sbi(TCCR1B, CS11);&#xD;&#xA;     194:	80 81       	ld	r24, Z&#xD;&#xA;     196:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     198:	80 83       	st	Z, r24&#xD;&#xA;    #if F_CPU &gt;= 8000000L&#xD;&#xA;    	sbi(TCCR1B, CS10);&#xD;&#xA;     19a:	80 81       	ld	r24, Z&#xD;&#xA;     19c:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     19e:	80 83       	st	Z, r24&#xD;&#xA;    	sbi(TCCR1, CS10);&#xD;&#xA;    #endif&#xD;&#xA;    #endif&#xD;&#xA;    	// put timer 1 in 8-bit phase correct pwm mode&#xD;&#xA;    #if defined(TCCR1A) &amp;&amp; defined(WGM10)&#xD;&#xA;    	sbi(TCCR1A, WGM10);&#xD;&#xA;     1a0:	e0 e8       	ldi	r30, 0x80	; 128&#xD;&#xA;     1a2:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1a4:	80 81       	ld	r24, Z&#xD;&#xA;     1a6:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     1a8:	80 83       	st	Z, r24&#xD;&#xA;    &#xD;&#xA;    	// set timer 2 prescale factor to 64&#xD;&#xA;    #if defined(TCCR2) &amp;&amp; defined(CS22)&#xD;&#xA;    	sbi(TCCR2, CS22);&#xD;&#xA;    #elif defined(TCCR2B) &amp;&amp; defined(CS22)&#xD;&#xA;    	sbi(TCCR2B, CS22);&#xD;&#xA;     1aa:	e1 eb       	ldi	r30, 0xB1	; 177&#xD;&#xA;     1ac:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1ae:	80 81       	ld	r24, Z&#xD;&#xA;     1b0:	84 60       	ori	r24, 0x04	; 4&#xD;&#xA;     1b2:	80 83       	st	Z, r24&#xD;&#xA;    &#xD;&#xA;    	// configure timer 2 for phase correct pwm (8-bit)&#xD;&#xA;    #if defined(TCCR2) &amp;&amp; defined(WGM20)&#xD;&#xA;    	sbi(TCCR2, WGM20);&#xD;&#xA;    #elif defined(TCCR2A) &amp;&amp; defined(WGM20)&#xD;&#xA;    	sbi(TCCR2A, WGM20);&#xD;&#xA;     1b4:	e0 eb       	ldi	r30, 0xB0	; 176&#xD;&#xA;     1b6:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1b8:	80 81       	ld	r24, Z&#xD;&#xA;     1ba:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     1bc:	80 83       	st	Z, r24&#xD;&#xA;    #if defined(ADCSRA)&#xD;&#xA;    	// set a2d prescale factor to 128&#xD;&#xA;    	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.&#xD;&#xA;    	// XXX: this will not work properly for other clock speeds, and&#xD;&#xA;    	// this code should use F_CPU to determine the prescale factor.&#xD;&#xA;    	sbi(ADCSRA, ADPS2);&#xD;&#xA;     1be:	ea e7       	ldi	r30, 0x7A	; 122&#xD;&#xA;     1c0:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1c2:	80 81       	ld	r24, Z&#xD;&#xA;     1c4:	84 60       	ori	r24, 0x04	; 4&#xD;&#xA;     1c6:	80 83       	st	Z, r24&#xD;&#xA;    	sbi(ADCSRA, ADPS1);&#xD;&#xA;     1c8:	80 81       	ld	r24, Z&#xD;&#xA;     1ca:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     1cc:	80 83       	st	Z, r24&#xD;&#xA;    	sbi(ADCSRA, ADPS0);&#xD;&#xA;     1ce:	80 81       	ld	r24, Z&#xD;&#xA;     1d0:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     1d2:	80 83       	st	Z, r24&#xD;&#xA;    &#xD;&#xA;    	// enable a2d conversions&#xD;&#xA;    	sbi(ADCSRA, ADEN);&#xD;&#xA;     1d4:	80 81       	ld	r24, Z&#xD;&#xA;     1d6:	80 68       	ori	r24, 0x80	; 128&#xD;&#xA;     1d8:	80 83       	st	Z, r24&#xD;&#xA;    	// here so they can be used as normal digital i/o; they will be&#xD;&#xA;    	// reconnected in Serial.begin()&#xD;&#xA;    #if defined(UCSRB)&#xD;&#xA;    	UCSRB = 0;&#xD;&#xA;    #elif defined(UCSR0B)&#xD;&#xA;    	UCSR0B = 0;&#xD;&#xA;     1da:	10 92 c1 00 	sts	0x00C1, r1&#xD;&#xA;    #endif&#xD;&#xA;    }&#xD;&#xA;     1de:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    000001e0 &lt;main&gt;:&#xD;&#xA;    #include &lt;Arduino.h&gt;&#xD;&#xA;    &#xD;&#xA;    int main(void)&#xD;&#xA;     1e0:	cf 93       	push	r28&#xD;&#xA;     1e2:	df 93       	push	r29&#xD;&#xA;    {&#xD;&#xA;    	init();&#xD;&#xA;     1e4:	0e 94 b5 00 	call	0x16a	; 0x16a &lt;init&gt;&#xD;&#xA;    &#xD;&#xA;    #if defined(USBCON)&#xD;&#xA;    	USBDevice.attach();&#xD;&#xA;    #endif&#xD;&#xA;    	&#xD;&#xA;    	setup();&#xD;&#xA;     1e8:	0e 94 53 00 	call	0xa6	; 0xa6 &lt;setup&gt;&#xD;&#xA;        &#xD;&#xA;    	for (;;) {&#xD;&#xA;    		loop();&#xD;&#xA;    		if (serialEventRun) serialEventRun();&#xD;&#xA;     1ec:	c0 e0       	ldi	r28, 0x00	; 0&#xD;&#xA;     1ee:	d0 e0       	ldi	r29, 0x00	; 0&#xD;&#xA;    #endif&#xD;&#xA;    	&#xD;&#xA;    	setup();&#xD;&#xA;        &#xD;&#xA;    	for (;;) {&#xD;&#xA;    		loop();&#xD;&#xA;     1f0:	0e 94 54 00 	call	0xa8	; 0xa8 &lt;loop&gt;&#xD;&#xA;    		if (serialEventRun) serialEventRun();&#xD;&#xA;     1f4:	20 97       	sbiw	r28, 0x00	; 0&#xD;&#xA;     1f6:	e1 f3       	breq	.-8      	; 0x1f0 &lt;main+0x10&gt;&#xD;&#xA;     1f8:	0e 94 00 00 	call	0	; 0x0 &lt;__vectors&gt;&#xD;&#xA;     1fc:	f9 cf       	rjmp	.-14     	; 0x1f0 &lt;main+0x10&gt;&#xD;&#xA;    &#xD;&#xA;    000001fe &lt;_exit&gt;:&#xD;&#xA;     1fe:	f8 94       	cli&#xD;&#xA;    &#xD;&#xA;    00000200 &lt;__stop_program&gt;:&#xD;&#xA;     200:	ff cf       	rjmp	.-2      	; 0x200 &lt;__stop_program&gt;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/images/doc0856.pdf&#xD;&#xA;" />
  <row Id="610" PostHistoryTypeId="2" PostId="257" RevisionGUID="46c174ed-4f0b-4231-b5a1-bf9dd4261565" CreationDate="2014-02-16T23:28:38.343" UserId="-1" Text="" />
  <row Id="611" PostHistoryTypeId="2" PostId="258" RevisionGUID="c32eb7f2-fb97-46a5-80b1-8fd0cc1ee759" CreationDate="2014-02-16T23:28:38.343" UserId="-1" Text="" />
  <row Id="612" PostHistoryTypeId="5" PostId="257" RevisionGUID="6fe86c2d-6222-4c4d-8046-7de33f6c40a7" CreationDate="2014-02-16T23:53:40.327" UserId="201" Comment="added 185 characters in body" Text="The arduino DUE is different than most arduino cards on the marked since it runs at 3.3V. &#xD;&#xA;&#xD;&#xA;[Spesifications and information](http://arduino.cc/en/Main/arduinoBoardDue#.UwFH6vbzT1o)&#xD;&#xA; " />
  <row Id="613" PostHistoryTypeId="24" PostId="257" RevisionGUID="6fe86c2d-6222-4c4d-8046-7de33f6c40a7" CreationDate="2014-02-16T23:53:40.327" Comment="Proposed by 201 approved by 8, 11 edit id of 48" />
  <row Id="614" PostHistoryTypeId="5" PostId="258" RevisionGUID="b87ae9a3-ebef-4953-b544-c037e05b8318" CreationDate="2014-02-16T23:53:44.720" UserId="201" Comment="added 114 characters in body" Text="Arduino DUE is an microcontroller card based on the Atmel SAM3X8E ARM Cortex-M3 CPU. This is a 32bit ARM core MCU." />
  <row Id="615" PostHistoryTypeId="24" PostId="258" RevisionGUID="b87ae9a3-ebef-4953-b544-c037e05b8318" CreationDate="2014-02-16T23:53:44.720" Comment="Proposed by 201 approved by 8, 11 edit id of 49" />
  <row Id="616" PostHistoryTypeId="2" PostId="259" RevisionGUID="cf0b98d6-b851-4b9f-8d33-284d2200a752" CreationDate="2014-02-16T23:58:24.540" UserId="-1" Text="" />
  <row Id="617" PostHistoryTypeId="2" PostId="260" RevisionGUID="d2d49760-2f03-4769-8c27-98eb79347942" CreationDate="2014-02-16T23:58:24.540" UserId="-1" Text="" />
  <row Id="618" PostHistoryTypeId="2" PostId="261" RevisionGUID="d516a7a9-f5b1-463b-9047-58f033ad0f1e" CreationDate="2014-02-17T02:24:00.157" UserId="11" Text="I have a simple sketch that prints out Hello World to the serial but I'm getting a bunch of gibberish instead.&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        Serial.println(&quot;Hello World&quot;);&#xD;&#xA;        delay(1000);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Why isn't it printing &quot;Hello World&quot; like the code says?" />
  <row Id="619" PostHistoryTypeId="1" PostId="261" RevisionGUID="d516a7a9-f5b1-463b-9047-58f033ad0f1e" CreationDate="2014-02-17T02:24:00.157" UserId="11" Text="Serial data showing up weird" />
  <row Id="620" PostHistoryTypeId="3" PostId="261" RevisionGUID="d516a7a9-f5b1-463b-9047-58f033ad0f1e" CreationDate="2014-02-17T02:24:00.157" UserId="11" Text="&lt;serial&gt;" />
  <row Id="621" PostHistoryTypeId="2" PostId="262" RevisionGUID="f679e980-0df3-4ee1-bf84-080eceaad7a2" CreationDate="2014-02-17T02:24:00.157" UserId="11" Text="The board and terminal are probably not using the same baud rate. Check the bottom right corner of the Arduino Serial Terminal and make sure it is set to 9600.&#xD;&#xA;&#xD;&#xA;# Serial Data&#xD;&#xA;&#xD;&#xA;Serial communication works by sending the entire data stream one bit at a time. This is in contrast to the standard parallel port which sends one byte at a time. Both devices need to know at what speed the data is being sent. Furthermore, both devices need to be operating at the same speed. This is called the baud rate.&#xD;&#xA;&#xD;&#xA;# Baud Rate&#xD;&#xA;&#xD;&#xA;Baud really just means pulses per second. In the context of serial communication, it means how many bits are transmitted per second. One of the most common values is 9600, but there are other common ones which are factors or multiples of 9600. It doesn't really matter, though, as long as both devices operate at the same speed.&#xD;&#xA;&#xD;&#xA;If I'm sending you messages faster than you are getting them, you lose data. If I am sending you messages slower than you are receiving them, you get nonsense mixed in with what I sent you.&#xD;&#xA;&#xD;&#xA;# Data, Parity, Stop bits&#xD;&#xA;&#xD;&#xA;If you look at the documentation for [`begin()`][1], you'll see it can take two parameters:&#xD;&#xA;&#xD;&#xA;    Serial.begin(speed)&#xD;&#xA;    Serial.begin(speed, config)&#xD;&#xA;&#xD;&#xA;Hopefully you understand speed now, it is the bits per second at which the Arduino will communicate.&#xD;&#xA;&#xD;&#xA;The second parameter, `config`, lets you configure some other things about the serial data transmission. These are the Data, [Parity][2], and Stop bits. You'll see on the page it has values like `5N1`, `6N1` and `SERIAL_8N1 (the default)`&#xD;&#xA;&#xD;&#xA;The first number represents how many data bits. The second character tells you what kind of parity bit there is. `E` for even parity, `O` for odd parity, or `N` for no parity. The third number tells you how many stop bits.&#xD;&#xA;&#xD;&#xA;So really, with 8N1, we have 10 bits being sent for each 8 bits of &quot;your&quot; data. 1 start bit, 8 data bits, and 1 stop bit.&#xD;&#xA;&#xD;&#xA;Anyway, both sides need to agree on this information as well as the speed. The Arduino Serial Terminal doesn't give you the option of changing these settings, but others do, so you'll need to be sure all of these configuration settings are the same.&#xD;&#xA;&#xD;&#xA;More info on wiki: [Asynchronous serial communication][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Serial/begin&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Parity_bit&#xD;&#xA;  [3]: http://en.wikipedia.org/wiki/Asynchronous_serial_communication" />
  <row Id="624" PostHistoryTypeId="2" PostId="264" RevisionGUID="3da4e298-1c72-40da-9053-59481443a8e1" CreationDate="2014-02-17T03:36:28.923" UserId="186" Text="The USB protocol requires one end to be a &quot;host&quot; and the other end to be a &quot;peripheral&quot;, and it doesn't work if the devices at both ends of the cable are &quot;peripherals&quot;.&#xD;&#xA;Alas, most Arduinos and many early Android devices are &quot;peripherals&quot;, so connecting such devices with a standard USB cable doesn't work.&#xD;&#xA;&#xD;&#xA;Some modern Android devices support &quot;OTG&quot;, so in theory one could make the Android end of the cable the &quot;host&quot;. Has anyone gotten this to work?&#xD;&#xA;&#xD;&#xA;Another approach is to somehow make the Arduino end of the cable the &quot;host&quot;, and the Android end of the cable the &quot;peripheral&quot;.&#xD;&#xA;That's the approach taken by&#xD;&#xA;&#xD;&#xA;* Microbridge [(a)][5] [(b)][6]&#xD;&#xA;* The IOIO board [(a)][1] [(b)][2]&#xD;&#xA;* The Android Accessory Development Kit (ADK) [(a)][3] [(b)][4] (c)&#xD;&#xA;&#xD;&#xA;(The Amarino [(a)][9] and Cellbots [(a)][7] [(b)][8] take yet another completely different approach).&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sparkfun.com/tutorials/280&#xD;&#xA;  [2]: https://github.com/ytai/ioio/wiki&#xD;&#xA;  [3]: http://makezine.com/2011/05/12/why-google-choosing-arduino-matters-and-the-end-of-made-for-ipod-tm/&#xD;&#xA;  [4]: http://developer.android.com/tools/adk/&#xD;&#xA;  [5]: https://en.wikipedia.org/wiki/Microbridge&#xD;&#xA;  [6]: https://code.google.com/p/microbridge/&#xD;&#xA;  [7]: http://www.cellbots.com/&#xD;&#xA;  [8]: https://code.google.com/p/cellbots/&#xD;&#xA;  [9]: http://www.amarino-toolkit.net/" />
  <row Id="628" PostHistoryTypeId="5" PostId="162" RevisionGUID="02645a77-06e4-4532-b17c-8a06666afb85" CreationDate="2014-02-17T03:43:46.333" UserId="86" Comment="added 52 characters in body" Text="If you want to know *exactly* how long something will take, there is only one solution: Look at the disassembly!&#xD;&#xA;&#xD;&#xA;Starting with the minimal code: &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup(){};&#xD;&#xA;    &#xD;&#xA;    volatile uint16_t x;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      x = millis();&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;This code compiled and then fed into `avr-objdump -S` produces a documented disassembly. Here are the interesting excerpts:&#xD;&#xA;&#xD;&#xA;`void loop()` produces:  &#xD;&#xA;&#xD;&#xA;    000000a8 &lt;loop&gt;:&#xD;&#xA;      a8:	0e 94 a7 00 	call	0x14e	; 0x14e &lt;millis&gt;&#xD;&#xA;      ac:	60 93 00 01 	sts	0x0100, r22&#xD;&#xA;      b0:	70 93 01 01 	sts	0x0101, r23&#xD;&#xA;      b4:	80 93 02 01 	sts	0x0102, r24&#xD;&#xA;      b8:	90 93 03 01 	sts	0x0103, r25&#xD;&#xA;      bc:	08 95       	ret&#xD;&#xA;&#xD;&#xA;Which is a function call (`call`), four copies (which copy each of the bytes in the `uint32_t` return value of `millis()` (note that the arduino docs call this a `long`, but they are incorrect to not be explicitly specifying the variable sizes)), and finally the function return.&#xD;&#xA;&#xD;&#xA;`call` requires 4 clock cycles, and each `sts` requires 2 clock cycles, so we have a minimum of 12 clock cycles just for function call overhead.&#xD;&#xA;&#xD;&#xA;Now, lets look at the disassembly of the `&lt;millis&gt;` function, which is located at `0x14e`:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    unsigned long millis()&#xD;&#xA;    {&#xD;&#xA;    	unsigned long m;&#xD;&#xA;    	uint8_t oldSREG = SREG;&#xD;&#xA;     14e:	8f b7       	in	r24, 0x3f	; 63&#xD;&#xA;    &#xD;&#xA;    	// disable interrupts while we read timer0_millis or we might get an&#xD;&#xA;    	// inconsistent value (e.g. in the middle of a write to timer0_millis)&#xD;&#xA;    	cli();&#xD;&#xA;     150:	f8 94       	cli&#xD;&#xA;    	m = timer0_millis;&#xD;&#xA;     152:	20 91 08 01 	lds	r18, 0x0108&#xD;&#xA;     156:	30 91 09 01 	lds	r19, 0x0109&#xD;&#xA;     15a:	40 91 0a 01 	lds	r20, 0x010A&#xD;&#xA;     15e:	50 91 0b 01 	lds	r21, 0x010B&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;     162:	8f bf       	out	0x3f, r24	; 63&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;     164:	b9 01       	movw	r22, r18&#xD;&#xA;     166:	ca 01       	movw	r24, r20&#xD;&#xA;     168:	08 95       	ret&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;As you can see, the `millis()` function is fairly simple:&#xD;&#xA;&#xD;&#xA;1. `in` saves the interrupt register settings (1 cycle)&#xD;&#xA;2. `cli` turns off the interrupts (1 cycle)&#xD;&#xA;3. `lds` copy one of the 4 bytes of the current value of the milli counter into a temporary register (2 clock cycles)&#xD;&#xA;4. `lds` Byte 2 (2 clock cycles)&#xD;&#xA;5. `lds` Byte 3 (2 clock cycles)&#xD;&#xA;6. `lds` Byte 4 (2 clock cycles)&#xD;&#xA;7. `out` restore interrupt settings (1 clock cycle)&#xD;&#xA;8. `movw` shuffle registers around (1 clock cycle)&#xD;&#xA;9. `movw` and again (1 clock cycle)&#xD;&#xA;10. `ret` return from subroutine  (4 cycles)&#xD;&#xA;&#xD;&#xA;So, if we add them all up, we have a total of 17 clock cycles in the `millis()` function itself, plus a call overhead of 12, for a total of 29 clock cycles.&#xD;&#xA;&#xD;&#xA;Assuming a 16 Mhz clock rate (most arduinos), each clock cycle is $1/16e6$ (Arrrgh, what are the TeX/mathJaX delimiters here?) seconds, or 0.0000000625 seconds, which is 62.5 nanoseconds. 62.5 ns * 29 = 1.812 microseconds.&#xD;&#xA;&#xD;&#xA;Therefore, the total execution time for a single `millis()` call on *most* arduinos will be **1.812 microseconds**.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;[AVR Assembly reference][1]&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;As a side-note, there is space for optimization here! If you update the `unsigned long millis(){}` function definition to be `inline unsigned long millis(){}`, you would remove the call overhead (at the cost of *slightly* larger code size). Furthermore, it looks like the compiler is doing two unnecessary moves (the two `movw` calls, but I haven't looked at it that closely).&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Really, considering the function call overhead is 5 instructions, and the actual *contents* of the `millis()` function is only 6 instructions, I think the `millis()` function should really be `inline` by default, but the arduino codebase is rather poorly optimized.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Here is the full disassemby for anyone interested:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    sketch_feb13a.cpp.elf:     file format elf32-avr&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Disassembly of section .text:&#xD;&#xA;    &#xD;&#xA;    00000000 &lt;__vectors&gt;:&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    unsigned long micros() {&#xD;&#xA;       0:	0c 94 34 00 	jmp	0x68	; 0x68 &lt;__ctors_end&gt;&#xD;&#xA;       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      40:	0c 94 5f 00 	jmp	0xbe	; 0xbe &lt;__vector_16&gt;&#xD;&#xA;      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 &lt;__bad_interrupt&gt;&#xD;&#xA;    &#xD;&#xA;    00000068 &lt;__ctors_end&gt;:&#xD;&#xA;      68:	11 24       	eor	r1, r1&#xD;&#xA;      6a:	1f be       	out	0x3f, r1	; 63&#xD;&#xA;      6c:	cf ef       	ldi	r28, 0xFF	; 255&#xD;&#xA;      6e:	d8 e0       	ldi	r29, 0x08	; 8&#xD;&#xA;      70:	de bf       	out	0x3e, r29	; 62&#xD;&#xA;      72:	cd bf       	out	0x3d, r28	; 61&#xD;&#xA;    &#xD;&#xA;    00000074 &lt;__do_copy_data&gt;:&#xD;&#xA;      74:	11 e0       	ldi	r17, 0x01	; 1&#xD;&#xA;      76:	a0 e0       	ldi	r26, 0x00	; 0&#xD;&#xA;      78:	b1 e0       	ldi	r27, 0x01	; 1&#xD;&#xA;      7a:	e2 e0       	ldi	r30, 0x02	; 2&#xD;&#xA;      7c:	f2 e0       	ldi	r31, 0x02	; 2&#xD;&#xA;      7e:	02 c0       	rjmp	.+4      	; 0x84 &lt;.do_copy_data_start&gt;&#xD;&#xA;    &#xD;&#xA;    00000080 &lt;.do_copy_data_loop&gt;:&#xD;&#xA;      80:	05 90       	lpm	r0, Z+&#xD;&#xA;      82:	0d 92       	st	X+, r0&#xD;&#xA;    &#xD;&#xA;    00000084 &lt;.do_copy_data_start&gt;:&#xD;&#xA;      84:	a0 30       	cpi	r26, 0x00	; 0&#xD;&#xA;      86:	b1 07       	cpc	r27, r17&#xD;&#xA;      88:	d9 f7       	brne	.-10     	; 0x80 &lt;.do_copy_data_loop&gt;&#xD;&#xA;    &#xD;&#xA;    0000008a &lt;__do_clear_bss&gt;:&#xD;&#xA;      8a:	11 e0       	ldi	r17, 0x01	; 1&#xD;&#xA;      8c:	a0 e0       	ldi	r26, 0x00	; 0&#xD;&#xA;      8e:	b1 e0       	ldi	r27, 0x01	; 1&#xD;&#xA;      90:	01 c0       	rjmp	.+2      	; 0x94 &lt;.do_clear_bss_start&gt;&#xD;&#xA;    &#xD;&#xA;    00000092 &lt;.do_clear_bss_loop&gt;:&#xD;&#xA;      92:	1d 92       	st	X+, r1&#xD;&#xA;    &#xD;&#xA;    00000094 &lt;.do_clear_bss_start&gt;:&#xD;&#xA;      94:	ad 30       	cpi	r26, 0x0D	; 13&#xD;&#xA;      96:	b1 07       	cpc	r27, r17&#xD;&#xA;      98:	e1 f7       	brne	.-8      	; 0x92 &lt;.do_clear_bss_loop&gt;&#xD;&#xA;      9a:	0e 94 f0 00 	call	0x1e0	; 0x1e0 &lt;main&gt;&#xD;&#xA;      9e:	0c 94 ff 00 	jmp	0x1fe	; 0x1fe &lt;_exit&gt;&#xD;&#xA;    &#xD;&#xA;    000000a2 &lt;__bad_interrupt&gt;:&#xD;&#xA;      a2:	0c 94 00 00 	jmp	0	; 0x0 &lt;__vectors&gt;&#xD;&#xA;    &#xD;&#xA;    000000a6 &lt;setup&gt;:&#xD;&#xA;      a6:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    000000a8 &lt;loop&gt;:&#xD;&#xA;      a8:	0e 94 a7 00 	call	0x14e	; 0x14e &lt;millis&gt;&#xD;&#xA;      ac:	60 93 00 01 	sts	0x0100, r22&#xD;&#xA;      b0:	70 93 01 01 	sts	0x0101, r23&#xD;&#xA;      b4:	80 93 02 01 	sts	0x0102, r24&#xD;&#xA;      b8:	90 93 03 01 	sts	0x0103, r25&#xD;&#xA;      bc:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    000000be &lt;__vector_16&gt;:&#xD;&#xA;    #if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)&#xD;&#xA;    ISR(TIM0_OVF_vect)&#xD;&#xA;    #else&#xD;&#xA;    ISR(TIMER0_OVF_vect)&#xD;&#xA;    #endif&#xD;&#xA;    {&#xD;&#xA;      be:	1f 92       	push	r1&#xD;&#xA;      c0:	0f 92       	push	r0&#xD;&#xA;      c2:	0f b6       	in	r0, 0x3f	; 63&#xD;&#xA;      c4:	0f 92       	push	r0&#xD;&#xA;      c6:	11 24       	eor	r1, r1&#xD;&#xA;      c8:	2f 93       	push	r18&#xD;&#xA;      ca:	3f 93       	push	r19&#xD;&#xA;      cc:	8f 93       	push	r24&#xD;&#xA;      ce:	9f 93       	push	r25&#xD;&#xA;      d0:	af 93       	push	r26&#xD;&#xA;      d2:	bf 93       	push	r27&#xD;&#xA;    	// copy these to local variables so they can be stored in registers&#xD;&#xA;    	// (volatile variables must be read from memory on every access)&#xD;&#xA;    	unsigned long m = timer0_millis;&#xD;&#xA;      d4:	80 91 08 01 	lds	r24, 0x0108&#xD;&#xA;      d8:	90 91 09 01 	lds	r25, 0x0109&#xD;&#xA;      dc:	a0 91 0a 01 	lds	r26, 0x010A&#xD;&#xA;      e0:	b0 91 0b 01 	lds	r27, 0x010B&#xD;&#xA;    	unsigned char f = timer0_fract;&#xD;&#xA;      e4:	30 91 0c 01 	lds	r19, 0x010C&#xD;&#xA;    &#xD;&#xA;    	m += MILLIS_INC;&#xD;&#xA;      e8:	01 96       	adiw	r24, 0x01	; 1&#xD;&#xA;      ea:	a1 1d       	adc	r26, r1&#xD;&#xA;      ec:	b1 1d       	adc	r27, r1&#xD;&#xA;    	f += FRACT_INC;&#xD;&#xA;      ee:	23 2f       	mov	r18, r19&#xD;&#xA;      f0:	2d 5f       	subi	r18, 0xFD	; 253&#xD;&#xA;    	if (f &gt;= FRACT_MAX) {&#xD;&#xA;      f2:	2d 37       	cpi	r18, 0x7D	; 125&#xD;&#xA;      f4:	20 f0       	brcs	.+8      	; 0xfe &lt;__vector_16+0x40&gt;&#xD;&#xA;    		f -= FRACT_MAX;&#xD;&#xA;      f6:	2d 57       	subi	r18, 0x7D	; 125&#xD;&#xA;    		m += 1;&#xD;&#xA;      f8:	01 96       	adiw	r24, 0x01	; 1&#xD;&#xA;      fa:	a1 1d       	adc	r26, r1&#xD;&#xA;      fc:	b1 1d       	adc	r27, r1&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	timer0_fract = f;&#xD;&#xA;      fe:	20 93 0c 01 	sts	0x010C, r18&#xD;&#xA;    	timer0_millis = m;&#xD;&#xA;     102:	80 93 08 01 	sts	0x0108, r24&#xD;&#xA;     106:	90 93 09 01 	sts	0x0109, r25&#xD;&#xA;     10a:	a0 93 0a 01 	sts	0x010A, r26&#xD;&#xA;     10e:	b0 93 0b 01 	sts	0x010B, r27&#xD;&#xA;    	timer0_overflow_count++;&#xD;&#xA;     112:	80 91 04 01 	lds	r24, 0x0104&#xD;&#xA;     116:	90 91 05 01 	lds	r25, 0x0105&#xD;&#xA;     11a:	a0 91 06 01 	lds	r26, 0x0106&#xD;&#xA;     11e:	b0 91 07 01 	lds	r27, 0x0107&#xD;&#xA;     122:	01 96       	adiw	r24, 0x01	; 1&#xD;&#xA;     124:	a1 1d       	adc	r26, r1&#xD;&#xA;     126:	b1 1d       	adc	r27, r1&#xD;&#xA;     128:	80 93 04 01 	sts	0x0104, r24&#xD;&#xA;     12c:	90 93 05 01 	sts	0x0105, r25&#xD;&#xA;     130:	a0 93 06 01 	sts	0x0106, r26&#xD;&#xA;     134:	b0 93 07 01 	sts	0x0107, r27&#xD;&#xA;    }&#xD;&#xA;     138:	bf 91       	pop	r27&#xD;&#xA;     13a:	af 91       	pop	r26&#xD;&#xA;     13c:	9f 91       	pop	r25&#xD;&#xA;     13e:	8f 91       	pop	r24&#xD;&#xA;     140:	3f 91       	pop	r19&#xD;&#xA;     142:	2f 91       	pop	r18&#xD;&#xA;     144:	0f 90       	pop	r0&#xD;&#xA;     146:	0f be       	out	0x3f, r0	; 63&#xD;&#xA;     148:	0f 90       	pop	r0&#xD;&#xA;     14a:	1f 90       	pop	r1&#xD;&#xA;     14c:	18 95       	reti&#xD;&#xA;    &#xD;&#xA;    0000014e &lt;millis&gt;:&#xD;&#xA;    &#xD;&#xA;    unsigned long millis()&#xD;&#xA;    {&#xD;&#xA;    	unsigned long m;&#xD;&#xA;    	uint8_t oldSREG = SREG;&#xD;&#xA;     14e:	8f b7       	in	r24, 0x3f	; 63&#xD;&#xA;    &#xD;&#xA;    	// disable interrupts while we read timer0_millis or we might get an&#xD;&#xA;    	// inconsistent value (e.g. in the middle of a write to timer0_millis)&#xD;&#xA;    	cli();&#xD;&#xA;     150:	f8 94       	cli&#xD;&#xA;    	m = timer0_millis;&#xD;&#xA;     152:	20 91 08 01 	lds	r18, 0x0108&#xD;&#xA;     156:	30 91 09 01 	lds	r19, 0x0109&#xD;&#xA;     15a:	40 91 0a 01 	lds	r20, 0x010A&#xD;&#xA;     15e:	50 91 0b 01 	lds	r21, 0x010B&#xD;&#xA;    	SREG = oldSREG;&#xD;&#xA;     162:	8f bf       	out	0x3f, r24	; 63&#xD;&#xA;    &#xD;&#xA;    	return m;&#xD;&#xA;    }&#xD;&#xA;     164:	b9 01       	movw	r22, r18&#xD;&#xA;     166:	ca 01       	movw	r24, r20&#xD;&#xA;     168:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    0000016a &lt;init&gt;:&#xD;&#xA;    &#xD;&#xA;    void init()&#xD;&#xA;    {&#xD;&#xA;    	// this needs to be called before setup() or some functions won't&#xD;&#xA;    	// work there&#xD;&#xA;    	sei();&#xD;&#xA;     16a:	78 94       	sei&#xD;&#xA;    	&#xD;&#xA;    	// on the ATmega168, timer 0 is also used for fast hardware pwm&#xD;&#xA;    	// (using phase-correct PWM would mean that timer 0 overflowed half as often&#xD;&#xA;    	// resulting in different millis() behavior on the ATmega8 and ATmega168)&#xD;&#xA;    #if defined(TCCR0A) &amp;&amp; defined(WGM01)&#xD;&#xA;    	sbi(TCCR0A, WGM01);&#xD;&#xA;     16c:	84 b5       	in	r24, 0x24	; 36&#xD;&#xA;     16e:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     170:	84 bd       	out	0x24, r24	; 36&#xD;&#xA;    	sbi(TCCR0A, WGM00);&#xD;&#xA;     172:	84 b5       	in	r24, 0x24	; 36&#xD;&#xA;     174:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     176:	84 bd       	out	0x24, r24	; 36&#xD;&#xA;    	// this combination is for the standard atmega8&#xD;&#xA;    	sbi(TCCR0, CS01);&#xD;&#xA;    	sbi(TCCR0, CS00);&#xD;&#xA;    #elif defined(TCCR0B) &amp;&amp; defined(CS01) &amp;&amp; defined(CS00)&#xD;&#xA;    	// this combination is for the standard 168/328/1280/2560&#xD;&#xA;    	sbi(TCCR0B, CS01);&#xD;&#xA;     178:	85 b5       	in	r24, 0x25	; 37&#xD;&#xA;     17a:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     17c:	85 bd       	out	0x25, r24	; 37&#xD;&#xA;    	sbi(TCCR0B, CS00);&#xD;&#xA;     17e:	85 b5       	in	r24, 0x25	; 37&#xD;&#xA;     180:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     182:	85 bd       	out	0x25, r24	; 37&#xD;&#xA;    &#xD;&#xA;    	// enable timer 0 overflow interrupt&#xD;&#xA;    #if defined(TIMSK) &amp;&amp; defined(TOIE0)&#xD;&#xA;    	sbi(TIMSK, TOIE0);&#xD;&#xA;    #elif defined(TIMSK0) &amp;&amp; defined(TOIE0)&#xD;&#xA;    	sbi(TIMSK0, TOIE0);&#xD;&#xA;     184:	ee e6       	ldi	r30, 0x6E	; 110&#xD;&#xA;     186:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     188:	80 81       	ld	r24, Z&#xD;&#xA;     18a:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     18c:	80 83       	st	Z, r24&#xD;&#xA;    	// this is better for motors as it ensures an even waveform&#xD;&#xA;    	// note, however, that fast pwm mode can achieve a frequency of up&#xD;&#xA;    	// 8 MHz (with a 16 MHz clock) at 50% duty cycle&#xD;&#xA;    &#xD;&#xA;    #if defined(TCCR1B) &amp;&amp; defined(CS11) &amp;&amp; defined(CS10)&#xD;&#xA;    	TCCR1B = 0;&#xD;&#xA;     18e:	e1 e8       	ldi	r30, 0x81	; 129&#xD;&#xA;     190:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     192:	10 82       	st	Z, r1&#xD;&#xA;    &#xD;&#xA;    	// set timer 1 prescale factor to 64&#xD;&#xA;    	sbi(TCCR1B, CS11);&#xD;&#xA;     194:	80 81       	ld	r24, Z&#xD;&#xA;     196:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     198:	80 83       	st	Z, r24&#xD;&#xA;    #if F_CPU &gt;= 8000000L&#xD;&#xA;    	sbi(TCCR1B, CS10);&#xD;&#xA;     19a:	80 81       	ld	r24, Z&#xD;&#xA;     19c:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     19e:	80 83       	st	Z, r24&#xD;&#xA;    	sbi(TCCR1, CS10);&#xD;&#xA;    #endif&#xD;&#xA;    #endif&#xD;&#xA;    	// put timer 1 in 8-bit phase correct pwm mode&#xD;&#xA;    #if defined(TCCR1A) &amp;&amp; defined(WGM10)&#xD;&#xA;    	sbi(TCCR1A, WGM10);&#xD;&#xA;     1a0:	e0 e8       	ldi	r30, 0x80	; 128&#xD;&#xA;     1a2:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1a4:	80 81       	ld	r24, Z&#xD;&#xA;     1a6:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     1a8:	80 83       	st	Z, r24&#xD;&#xA;    &#xD;&#xA;    	// set timer 2 prescale factor to 64&#xD;&#xA;    #if defined(TCCR2) &amp;&amp; defined(CS22)&#xD;&#xA;    	sbi(TCCR2, CS22);&#xD;&#xA;    #elif defined(TCCR2B) &amp;&amp; defined(CS22)&#xD;&#xA;    	sbi(TCCR2B, CS22);&#xD;&#xA;     1aa:	e1 eb       	ldi	r30, 0xB1	; 177&#xD;&#xA;     1ac:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1ae:	80 81       	ld	r24, Z&#xD;&#xA;     1b0:	84 60       	ori	r24, 0x04	; 4&#xD;&#xA;     1b2:	80 83       	st	Z, r24&#xD;&#xA;    &#xD;&#xA;    	// configure timer 2 for phase correct pwm (8-bit)&#xD;&#xA;    #if defined(TCCR2) &amp;&amp; defined(WGM20)&#xD;&#xA;    	sbi(TCCR2, WGM20);&#xD;&#xA;    #elif defined(TCCR2A) &amp;&amp; defined(WGM20)&#xD;&#xA;    	sbi(TCCR2A, WGM20);&#xD;&#xA;     1b4:	e0 eb       	ldi	r30, 0xB0	; 176&#xD;&#xA;     1b6:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1b8:	80 81       	ld	r24, Z&#xD;&#xA;     1ba:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     1bc:	80 83       	st	Z, r24&#xD;&#xA;    #if defined(ADCSRA)&#xD;&#xA;    	// set a2d prescale factor to 128&#xD;&#xA;    	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.&#xD;&#xA;    	// XXX: this will not work properly for other clock speeds, and&#xD;&#xA;    	// this code should use F_CPU to determine the prescale factor.&#xD;&#xA;    	sbi(ADCSRA, ADPS2);&#xD;&#xA;     1be:	ea e7       	ldi	r30, 0x7A	; 122&#xD;&#xA;     1c0:	f0 e0       	ldi	r31, 0x00	; 0&#xD;&#xA;     1c2:	80 81       	ld	r24, Z&#xD;&#xA;     1c4:	84 60       	ori	r24, 0x04	; 4&#xD;&#xA;     1c6:	80 83       	st	Z, r24&#xD;&#xA;    	sbi(ADCSRA, ADPS1);&#xD;&#xA;     1c8:	80 81       	ld	r24, Z&#xD;&#xA;     1ca:	82 60       	ori	r24, 0x02	; 2&#xD;&#xA;     1cc:	80 83       	st	Z, r24&#xD;&#xA;    	sbi(ADCSRA, ADPS0);&#xD;&#xA;     1ce:	80 81       	ld	r24, Z&#xD;&#xA;     1d0:	81 60       	ori	r24, 0x01	; 1&#xD;&#xA;     1d2:	80 83       	st	Z, r24&#xD;&#xA;    &#xD;&#xA;    	// enable a2d conversions&#xD;&#xA;    	sbi(ADCSRA, ADEN);&#xD;&#xA;     1d4:	80 81       	ld	r24, Z&#xD;&#xA;     1d6:	80 68       	ori	r24, 0x80	; 128&#xD;&#xA;     1d8:	80 83       	st	Z, r24&#xD;&#xA;    	// here so they can be used as normal digital i/o; they will be&#xD;&#xA;    	// reconnected in Serial.begin()&#xD;&#xA;    #if defined(UCSRB)&#xD;&#xA;    	UCSRB = 0;&#xD;&#xA;    #elif defined(UCSR0B)&#xD;&#xA;    	UCSR0B = 0;&#xD;&#xA;     1da:	10 92 c1 00 	sts	0x00C1, r1&#xD;&#xA;    #endif&#xD;&#xA;    }&#xD;&#xA;     1de:	08 95       	ret&#xD;&#xA;    &#xD;&#xA;    000001e0 &lt;main&gt;:&#xD;&#xA;    #include &lt;Arduino.h&gt;&#xD;&#xA;    &#xD;&#xA;    int main(void)&#xD;&#xA;     1e0:	cf 93       	push	r28&#xD;&#xA;     1e2:	df 93       	push	r29&#xD;&#xA;    {&#xD;&#xA;    	init();&#xD;&#xA;     1e4:	0e 94 b5 00 	call	0x16a	; 0x16a &lt;init&gt;&#xD;&#xA;    &#xD;&#xA;    #if defined(USBCON)&#xD;&#xA;    	USBDevice.attach();&#xD;&#xA;    #endif&#xD;&#xA;    	&#xD;&#xA;    	setup();&#xD;&#xA;     1e8:	0e 94 53 00 	call	0xa6	; 0xa6 &lt;setup&gt;&#xD;&#xA;        &#xD;&#xA;    	for (;;) {&#xD;&#xA;    		loop();&#xD;&#xA;    		if (serialEventRun) serialEventRun();&#xD;&#xA;     1ec:	c0 e0       	ldi	r28, 0x00	; 0&#xD;&#xA;     1ee:	d0 e0       	ldi	r29, 0x00	; 0&#xD;&#xA;    #endif&#xD;&#xA;    	&#xD;&#xA;    	setup();&#xD;&#xA;        &#xD;&#xA;    	for (;;) {&#xD;&#xA;    		loop();&#xD;&#xA;     1f0:	0e 94 54 00 	call	0xa8	; 0xa8 &lt;loop&gt;&#xD;&#xA;    		if (serialEventRun) serialEventRun();&#xD;&#xA;     1f4:	20 97       	sbiw	r28, 0x00	; 0&#xD;&#xA;     1f6:	e1 f3       	breq	.-8      	; 0x1f0 &lt;main+0x10&gt;&#xD;&#xA;     1f8:	0e 94 00 00 	call	0	; 0x0 &lt;__vectors&gt;&#xD;&#xA;     1fc:	f9 cf       	rjmp	.-14     	; 0x1f0 &lt;main+0x10&gt;&#xD;&#xA;    &#xD;&#xA;    000001fe &lt;_exit&gt;:&#xD;&#xA;     1fe:	f8 94       	cli&#xD;&#xA;    &#xD;&#xA;    00000200 &lt;__stop_program&gt;:&#xD;&#xA;     200:	ff cf       	rjmp	.-2      	; 0x200 &lt;__stop_program&gt;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/images/doc0856.pdf&#xD;&#xA;" />
  <row Id="629" PostHistoryTypeId="2" PostId="266" RevisionGUID="039c201c-d43a-4b5f-b14a-d7ad17e921c0" CreationDate="2014-02-17T03:48:20.310" UserId="186" Text="&#xD;&#xA;&gt; Is there any easy way to upload a program/sketch from an iPad or&#xD;&#xA;&gt; Android tablet without a shield (Bluetooth or Wi-Fi)?&#xD;&#xA;&#xD;&#xA;If you don't mind re-writing your program in an interpreted language,&#xD;&#xA;one option is:&#xD;&#xA;&#xD;&#xA;* Install an [interpreter on the Arduino][1], perhaps using the standard Arduino IDE running on a standard desktop PC -- like the bootloader, this only needs to be done once.&#xD;&#xA;&#xD;&#xA;Then:&#xD;&#xA;&#xD;&#xA;* Use your favorite terminal emulator on the tablet&#xD;&#xA;* Somehow link the Arduino and the Android together, and tell the terminal emulator to talk over that link.(*)&#xD;&#xA;* Tell the terminal emulator to send the (more-or-less human-readable plain text) program to the interpreter over the link. (No compiler necessary on the tablet).&#xD;&#xA;&#xD;&#xA;(*) There are several different ways to make this link; some of them are mentioned at http://arduino.stackexchange.com/questions/253/how-do-i-write-an-arduino-sketch-and-an-android-application-to-talk-to-each-othe .&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/CommonTopics/InterpretedLanguages" />
  <row Id="632" PostHistoryTypeId="5" PostId="200" RevisionGUID="a2e0060d-ed3c-4c20-a6cb-f829a729f2c8" CreationDate="2014-02-17T04:26:53.973" UserId="86" Comment="Better disassembly (includes inline corresponding C++ source)" Text="My initial guess is wrong. I would have thought it would simply return from loop and the core library would just call loop() again. However, I see the following code was created. Noticing that __stop_program is a hard loop...&#xD;&#xA;&#xD;&#xA;An extract of Blink.ino's listing, with exit(0) added:&#xD;&#xA;&#xD;&#xA;&lt;!-- language: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;    // the loop routine runs over and over again forever:&#xD;&#xA;    void loop() {&#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      exit(0);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The disassembly of the above:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // the loop routine runs over and over again forever:&#xD;&#xA;    void loop() {&#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;     100:	80 91 00 01 	lds	r24, 0x0100&#xD;&#xA;     104:	61 e0       	ldi	r22, 0x01	; 1&#xD;&#xA;     106:	0e 94 ca 01 	call	0x394	; 0x394 &lt;digitalWrite&gt;&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;     10a:	68 ee       	ldi	r22, 0xE8	; 232&#xD;&#xA;     10c:	73 e0       	ldi	r23, 0x03	; 3&#xD;&#xA;     10e:	80 e0       	ldi	r24, 0x00	; 0&#xD;&#xA;     110:	90 e0       	ldi	r25, 0x00	; 0&#xD;&#xA;     112:	0e 94 f7 00 	call	0x1ee	; 0x1ee &lt;delay&gt;&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;     116:	80 91 00 01 	lds	r24, 0x0100&#xD;&#xA;     11a:	60 e0       	ldi	r22, 0x00	; 0&#xD;&#xA;     11c:	0e 94 ca 01 	call	0x394	; 0x394 &lt;digitalWrite&gt;&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;     120:	68 ee       	ldi	r22, 0xE8	; 232&#xD;&#xA;     122:	73 e0       	ldi	r23, 0x03	; 3&#xD;&#xA;     124:	80 e0       	ldi	r24, 0x00	; 0&#xD;&#xA;     126:	90 e0       	ldi	r25, 0x00	; 0&#xD;&#xA;     128:	0e 94 f7 00 	call	0x1ee	; 0x1ee &lt;delay&gt;&#xD;&#xA;      exit(0);&#xD;&#xA;     12c:	80 e0       	ldi	r24, 0x00	; 0&#xD;&#xA;     12e:	90 e0       	ldi	r25, 0x00	; 0&#xD;&#xA;     130:	0e 94 1e 02 	call	0x43c	; 0x43c &lt;_exit&gt;&#xD;&#xA;&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;    0000043c &lt;_exit&gt;:&#xD;&#xA;     43c:	f8 94       	cli&#xD;&#xA;    &#xD;&#xA;    0000043e &lt;__stop_program&gt;:&#xD;&#xA;     43e:	ff cf       	rjmp	.-2      	; 0x43e &lt;__stop_program&gt;&#xD;&#xA;&#xD;&#xA;Note that if _exit had not called cli, interrupts would be able to do stuff. But that is not the case.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="633" PostHistoryTypeId="24" PostId="200" RevisionGUID="a2e0060d-ed3c-4c20-a6cb-f829a729f2c8" CreationDate="2014-02-17T04:26:53.973" Comment="Proposed by 86 approved by 8, 11 edit id of 56" />
  <row Id="634" PostHistoryTypeId="2" PostId="269" RevisionGUID="83c76d7a-4ca2-443d-93e1-f928d52ad17f" CreationDate="2014-02-17T04:28:35.933" UserId="213" Text="Spanish company Libelium makes this pretty impressive sensor board:&#xD;&#xA;&#xD;&#xA;http://www.libelium.com/products/waspmote/sensors/&#xD;&#xA;&#xD;&#xA;for their Waspmote series of boards.  These are not meant for Arduino compatibility, but they are not only interesting for combining so many sensors, the availability of calibrated sensor sets makes it even more unique.&#xD;&#xA;&#xD;&#xA;So here is the challenge: can we reasonably leverage these from an Uno or a Mega? &#xD;&#xA;&#xD;&#xA;" />
  <row Id="635" PostHistoryTypeId="1" PostId="269" RevisionGUID="83c76d7a-4ca2-443d-93e1-f928d52ad17f" CreationDate="2014-02-17T04:28:35.933" UserId="213" Text="Waspmote senosrs board" />
  <row Id="636" PostHistoryTypeId="3" PostId="269" RevisionGUID="83c76d7a-4ca2-443d-93e1-f928d52ad17f" CreationDate="2014-02-17T04:28:35.933" UserId="213" Text="&lt;sensors&gt;&lt;waspmote&gt;&lt;libelium&gt;" />
  <row Id="637" PostHistoryTypeId="2" PostId="270" RevisionGUID="30ecb259-c7ff-4515-a6ad-4bca5cb0ec14" CreationDate="2014-02-17T04:48:01.030" UserId="11" Text="Too long for a comment...&#xD;&#xA;&#xD;&#xA;Look at some of their docs for [examples][1]. seems like they have a very similar platform to Arduino.&#xD;&#xA;&#xD;&#xA;&gt; Their forums suggest making the connection is not trivial, but may be&#xD;&#xA;&gt; possible: http://www.libelium.com/forum/viewtopic.php?f=15&amp;t=8811&#xD;&#xA;&#xD;&#xA;All that's saying is you can't simply plug in a sensor into your Arduino like a shield, because it's not a shield. You'd have to hook up the connections to the right pins and then use their libraries and code to communicate with it.&#xD;&#xA;&#xD;&#xA;That involves reading their documentation and code to figure out what pins it uses to communicate with what. You may have to modify the code slightly to work with Arduino (mainly changing pin numbers).&#xD;&#xA;&#xD;&#xA;All in all, I wouldn't invest my time or effort into it. Don't lock yourself into a product that isn't intended to be used the way you're using it. You'll get no support from the company and there's no guarantee future versions of their product will work. Or things like this (from the [forum link][2]):&#xD;&#xA;&#xD;&#xA;&gt; Anyway, I'm afraid the Libelium's sales policy implies a minimum first&#xD;&#xA;&gt; order including five Waspmotes, five batteries and one Gateway.&#xD;&#xA;&#xD;&#xA;Simply not worth the effort. You'd be much better off making your own sensor board to fit your requirements.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.libelium.com/development/waspmote/examples/ga-11-co-sensor-on-socket4-reading/&#xD;&#xA;  [2]: http://www.libelium.com/forum/viewtopic.php?f=15&amp;t=8811" />
  <row Id="638" PostHistoryTypeId="5" PostId="237" RevisionGUID="195b845d-bc06-45ec-a789-fcc6fc584b1c" CreationDate="2014-02-17T05:51:30.510" UserId="213" Comment="typo corrected." Text="For a robotic project, I need to keep an Arduino powered up for a long time in an outdoor environment. What can I use to power the board?&#xD;&#xA;If battery is the only solution, can the device tell me remotely that battery is getting low?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="639" PostHistoryTypeId="24" PostId="237" RevisionGUID="195b845d-bc06-45ec-a789-fcc6fc584b1c" CreationDate="2014-02-17T05:51:30.510" Comment="Proposed by 213 approved by 11, 83 edit id of 57" />
  <row Id="640" PostHistoryTypeId="5" PostId="79" RevisionGUID="2311c69b-1efe-4c99-9814-436770950e18" CreationDate="2014-02-17T08:00:10.263" UserId="70" Comment="edited body" Text="Realistically, the biggest power waster on an Arduino board is the linear voltage regulator on it. &#xD;&#xA;&#xD;&#xA; 1. As long as the microcontroller on the board, the LEDs, or any other peripherals, draw current, the linear regulator wastes power equal to `difference between supply and board voltage` x `current drawn`.&#xD;&#xA;&#xD;&#xA;    So, a first fix would be to disconnect the power indicator LED on the board, and not use any of the other LEDs as far as possible.&#xD;&#xA;    Second, supply the board with as low a voltage as possible that is just sufficient to power the on-board regulator.&#xD;&#xA;&#xD;&#xA; 2. On the original designs, the voltage regulators used do not boast low quiescent current. This means even with nothing drawing power within the board, the regulator itself wastes a fair bit of power all the time it is on. &#xD;&#xA;&#xD;&#xA;    An easy fix is to replace the on-board regulator with an LDO (low drop-out linear regulator) rated for extremely low quiescent current. Parametric searches on various vendor sites will yield likely substitutes.&#xD;&#xA;&#xD;&#xA; 3. Even with the above steps, the Arduino board does not provide a mechanism to set the LDO into low-power mode, if the LDO chosen supports this. Power efficient designs typically use a &quot;sleep mode&quot; pin on voltage regulators to save a fair bit of energy - not an option here.&#xD;&#xA;&#xD;&#xA;Even with all possible power saving modes and tricks applied at the microcontroller level, the Arduino simply is not designed to be an ultra-low-power device out of the box. Having experimented with several non-trivial applications, I have found that the best that is realistically achievable is some 10% to 30% power saving depending on application, since the voltage regulator and the LEDs are going to consume the rest anyway.&#xD;&#xA;" />
  <row Id="641" PostHistoryTypeId="5" PostId="237" RevisionGUID="7fae3fca-23e9-4ffc-8a6d-d3216752661c" CreationDate="2014-02-17T08:59:44.660" UserId="197" Comment="added 181 characters in body" Text="For a robotic project, I need to keep an Arduino powered up for a long time in an outdoor environment. What can I use to power the board?&#xD;&#xA;If battery is the only solution, can the device tell me remotely that battery is getting low?&#xD;&#xA;&#xD;&#xA;It needs to be powered for at least few days ( at least). The unit monitors an outdoor sensor that is shaded from sun but still exposed to wind and moisture. The unit does not move." />
  <row Id="642" PostHistoryTypeId="2" PostId="271" RevisionGUID="e9571f42-5c47-4457-a587-39f0c1709004" CreationDate="2014-02-17T09:54:06.537" UserId="160" Text="Processing is a great place to get started with device to device communication.   &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The interface and language are very similar to Arduino and there are many examples to get you started. &#xD;&#xA;&#xD;&#xA;http://playground.arduino.cc/Interfacing/Processing   &#xD;&#xA;   &#xD;&#xA;" />
  <row Id="643" PostHistoryTypeId="5" PostId="269" RevisionGUID="ea7e8f21-bf04-4f05-9edc-f98f33999dee" CreationDate="2014-02-17T11:51:51.500" UserId="65" Comment="deleted 5 characters in body; edited tags; edited title" Text="Spanish company Libelium makes this pretty impressive sensor board:&#xD;&#xA;&#xD;&#xA;http://www.libelium.com/products/waspmote/sensors/&#xD;&#xA;&#xD;&#xA;for their Waspmote series of boards.  These are not meant for Arduino compatibility, but they are not only interesting for combining so many sensors, the availability of calibrated sensor sets makes it even more unique.&#xD;&#xA;&#xD;&#xA;So here is the challenge: can we reasonably leverage these from an Uno or a Mega?" />
  <row Id="644" PostHistoryTypeId="4" PostId="269" RevisionGUID="ea7e8f21-bf04-4f05-9edc-f98f33999dee" CreationDate="2014-02-17T11:51:51.500" UserId="65" Comment="deleted 5 characters in body; edited tags; edited title" Text="Using the Waspmote Sensor Board" />
  <row Id="645" PostHistoryTypeId="6" PostId="269" RevisionGUID="ea7e8f21-bf04-4f05-9edc-f98f33999dee" CreationDate="2014-02-17T11:51:51.500" UserId="65" Comment="deleted 5 characters in body; edited tags; edited title" Text="&lt;uno&gt;&lt;sensors&gt;&lt;libelium&gt;&lt;waspmote&gt;&lt;arduino-mega&gt;" />
  <row Id="646" PostHistoryTypeId="2" PostId="272" RevisionGUID="d1dd64da-eedf-4cb6-b6d8-be566553010b" CreationDate="2014-02-17T14:00:41.933" UserId="220" Text="## You never mentioned your tablet model... or Arduino model ##&#xD;&#xA;&#xD;&#xA;There are some tablets designed to work with USB flash drives and printers. This is called OTG (on the go.&#xD;&#xA;&#xD;&#xA;**You need:**&#xD;&#xA;&#xD;&#xA; - A tablet supporting OTG&#xD;&#xA; - An OTG adapter that fits into your tablets USB slot and is compatible&#xD;&#xA; - [The Arduino Uno Communicator App](https://play.google.com/store/apps/details?id=com.primavera.arduino.listener)&#xD;&#xA; - Arduino Uno (or clone) [Note: It says that it works with Atmega16U2 or Atmega8U2 programmed as a USB-to-serial converter so I would assume that that would cover a few boards more than the Uno.)&#xD;&#xA;&#xD;&#xA;Another alternitive is to look into [Bluetooth](https://www.google.com/search?q=arduino+bluetooth&amp;qscrl=1&amp;tbm=isch&amp;imgil=WyPC4O05Xn4rhM%253A%253Bhttps%253A%252F%252Fencrypted-tbn2.gstatic.com%252Fimages%253Fq%253Dtbn%253AANd9GcSfTtWqIuN9YYdd90OO_tlxsvLUYhV_pl7NfaMhHDzSRq9N6W9rNA%253B1200%253B1200%253B1soQc4CzMzh0MM%253Bhttp%25253A%25252F%25252Fm.dhgate.com%25252Fproduct%25252Fjy-mcu-arduino-bluetooth-wireless-serial%25252F151048482.html&amp;source=iu&amp;usg=__KyMLS4aeubxJnDaMvprgRgADxAs%3D&amp;sa=X&amp;ei=1BUCU635IYmEygGO1oHwCQ&amp;ved=0CGkQ9QEwBg&amp;biw=1280&amp;bih=899) (Note: I just picked a random link but there are hundreds of similar BT adapters)" />
  <row Id="647" PostHistoryTypeId="2" PostId="273" RevisionGUID="9da94b5d-9895-40a8-9f46-a60eded891f7" CreationDate="2014-02-17T15:18:42.393" UserId="220" Text="I am used to relays some, and they are useful, especially for large loads like a incandescent light bulb or other 120V AC device. However, it seems like overkill to use a relay for a bunch of LEDs linked together (parallel) that use 60 mA (too much for the Arduino). Also, it wouldn't work if you wanted to turn it on/off frequently or do PWM. **I've heard some about transistors and MOSFETS and know a little about them. When should I use each one and how do I know what type to get?** Also, it seems like relays can be more expensive than transistors/MOSFETS." />
  <row Id="648" PostHistoryTypeId="1" PostId="273" RevisionGUID="9da94b5d-9895-40a8-9f46-a60eded891f7" CreationDate="2014-02-17T15:18:42.393" UserId="220" Text="When should I use a transistor, mosfet, and when should I use a relay?" />
  <row Id="649" PostHistoryTypeId="3" PostId="273" RevisionGUID="9da94b5d-9895-40a8-9f46-a60eded891f7" CreationDate="2014-02-17T15:18:42.393" UserId="220" Text="&lt;relay&gt;&lt;mosfet&gt;&lt;transistor&gt;" />
  <row Id="650" PostHistoryTypeId="2" PostId="274" RevisionGUID="9ee2d190-6b8d-4016-805d-24f0d84b11cd" CreationDate="2014-02-17T15:26:30.470" UserId="220" Text="&gt; Related to:&#xD;&#xA;&gt; http://arduino.stackexchange.com/questions/189/what-happens-if-there-is-a-runtime-error&#xD;&#xA;&#xD;&#xA;This question is similar to the one above, however this is an alternate situation:&#xD;&#xA;&#xD;&#xA;    int pin = 999;&#xD;&#xA;    pinMode(pin, OUTPUT);&#xD;&#xA;    digitalWrite(pin, HIGH);&#xD;&#xA;What would happen? The compiler might catch it but if you used a random nubmer I don't know if the IDE would catch it." />
  <row Id="651" PostHistoryTypeId="1" PostId="274" RevisionGUID="9ee2d190-6b8d-4016-805d-24f0d84b11cd" CreationDate="2014-02-17T15:26:30.470" UserId="220" Text="What happens when I call an invaled PIN number on m" />
  <row Id="652" PostHistoryTypeId="3" PostId="274" RevisionGUID="9ee2d190-6b8d-4016-805d-24f0d84b11cd" CreationDate="2014-02-17T15:26:30.470" UserId="220" Text="&lt;program&gt;" />
  <row Id="653" PostHistoryTypeId="2" PostId="275" RevisionGUID="c9b884da-b76c-44db-ae22-d0dfebf61d41" CreationDate="2014-02-17T15:32:47.543" UserId="8" Text="Transistors are solid state switchers, that is, they don't have any moving parts. MOSFETS are like transistors, but are rated for higher voltages. Relays are more expensive, but they have moving parts.&#xD;&#xA;&#xD;&#xA;Transistors and MOSFETS produce a lot of heat. They have 3 pins (usually) called the base, emitter, and collector. [More info here](http://www.technologystudent.com/elec1/transis1.htm)&#xD;&#xA;&#xD;&#xA;Relays use a magnet to control the position of a metal switch. They generally take more power than an Arduino pin can deliver, and therefore they are often controlled by a transistor. Relays can usually switch more current than either a transistor or a MOSFET.&#xD;&#xA;&#xD;&#xA;There are also solid state relays, which have a TRIAC (like a transistor) in them. These can't switch as much as a normal relay, but they generally have better ratings than MOSFETS and transistors. [example](https://www.sparkfun.com/products/10636)&#xD;&#xA;&#xD;&#xA;![from Sparkfun][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/71AlP.png" />
  <row Id="654" PostHistoryTypeId="5" PostId="107" RevisionGUID="17d68eb3-b7ec-4a8d-83af-22fee39ffe43" CreationDate="2014-02-17T15:46:05.490" UserId="11" Comment="deleted 15 characters in body" Text="The Arduino Uno is the most common and one of the newest Arduino boards. It has 14 digital I/O pins and 6 Analog input pins. There are three different versions of the Uno: R1, R2, and R3.&#xD;&#xA;&#xD;&#xA; - Microcontroller: ATmega328&#xD;&#xA; - Operating Voltage: 5V&#xD;&#xA; - Input Voltage (recommended): 7-12V&#xD;&#xA; - Input Voltage (limits): 6-20V&#xD;&#xA; - Digital I/O Pins: 14 (of which 6 provide PWM output)&#xD;&#xA; - Analog Input Pins: 6&#xD;&#xA; - DC Current per I/O Pin: 40 mA&#xD;&#xA; - DC Current for 3.3V Pin: 50 mA&#xD;&#xA; - Flash Memory: 32 KB (ATmega328) of which 0.5 KB used by bootloader&#xD;&#xA; - SRAM: 2 KB (ATmega328)&#xD;&#xA; - EEPROM: 1 KB (ATmega328)&#xD;&#xA; - Clock Speed: 16 MHz&#xD;&#xA;&#xD;&#xA;[Official Arduino Uno][1] page.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardUno" />
  <row Id="655" PostHistoryTypeId="24" PostId="107" RevisionGUID="17d68eb3-b7ec-4a8d-83af-22fee39ffe43" CreationDate="2014-02-17T15:46:05.490" Comment="Proposed by 11 approved by 8, 48 edit id of 55" />
  <row Id="656" PostHistoryTypeId="5" PostId="273" RevisionGUID="7011e948-4da6-4e5b-b7a9-994271dbe3da" CreationDate="2014-02-17T15:47:18.013" UserId="220" Comment="added 50 characters in body" Text="I am used to relays some, and they are useful, especially for large loads like a incandescent light bulb or other 120V AC device. However, it seems like overkill to use a relay for a bunch of LEDs linked together (parallel) that use 60 mA (too much for the Arduino). Also, it wouldn't work if you wanted to turn it on/off frequently or do PWM. **I've heard some about transistors and MOSFETS and know a little about them. When should I use each one and how do I know what type to get?** Also, it seems like relays can be more expensive than transistors/MOSFETS.&#xD;&#xA;&#xD;&#xA;**Edit:** How can I use these with my Arduino?" />
  <row Id="657" PostHistoryTypeId="2" PostId="276" RevisionGUID="f2507217-caa8-4407-95f6-94b0db677c61" CreationDate="2014-02-17T15:50:12.013" UserId="8" Text="In the standard libraries, there are macros designed for converting pins to ports, which are used in assembly. Here they are for the Uno from Arduino 1.0.5:&#xD;&#xA;&#xD;&#xA;    #define digitalPinToPCICR(p)    (((p) &gt;= 0 &amp;&amp; (p) &lt;= 21) ? (&amp;PCICR) : ((uint8_t *)0))&#xD;&#xA;    #define digitalPinToPCICRbit(p) (((p) &lt;= 7) ? 2 : (((p) &lt;= 13) ? 0 : 1))&#xD;&#xA;    #define digitalPinToPCMSK(p)    (((p) &lt;= 7) ? (&amp;PCMSK2) : (((p) &lt;= 13) ? (&amp;PCMSK0) : (((p) &lt;= 21) ? (&amp;PCMSK1) : ((uint8_t *)0))))&#xD;&#xA;    #define digitalPinToPCMSKbit(p) (((p) &lt;= 7) ? (p) : (((p) &lt;= 13) ? ((p) - 8) : ((p) - 14)))&#xD;&#xA;&#xD;&#xA;There are more, but I won't show them here.&#xD;&#xA;&#xD;&#xA;I believe your program would subtract 14 from 999, which would still be too big for the brogram. It would then try to point to the 985th element of the `digital_pn_to_bit_mask_PGM` array, which only contains 20 elements. This would most likely end up screwing the Arduino by pointing to a random spot in progmem." />
  <row Id="658" PostHistoryTypeId="2" PostId="277" RevisionGUID="3b2a26c4-0bbe-4a43-a13c-4f3b339b1f55" CreationDate="2014-02-17T16:48:05.083" UserId="65" Text="The second line in your code is where the magic will happen and thats where we need to focus. &#xD;&#xA;&#xD;&#xA;    pinMode(pin, OUTPUT);&#xD;&#xA;&#xD;&#xA;The portion of `pinMode` relevant to this discussion is:&#xD;&#xA;&#xD;&#xA;    void pinMode(uint8_t pin, uint8_t mode) &#xD;&#xA;    {&#xD;&#xA;&#xD;&#xA;    	uint8_t bit = digitalPinToBitMask(pin); //The first instance where pin is used&#xD;&#xA;    	uint8_t port = digitalPinToPort(pin);&#xD;&#xA;&#xD;&#xA;        if (port == NOT_A_PIN) return;&#xD;&#xA;&#xD;&#xA;    //Do something&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;(The complete implementation can be found in [wiring_digital.c][1])&#xD;&#xA;&#xD;&#xA;So, here, `digitalPinToBitMask` seems to be using `pin` to compute an intermediate bit. Exploring further, `digitalPinToBitMask` is a macro defined in [`Arduino.h`][2] whose definition is this one-liner:&#xD;&#xA;&#xD;&#xA;    #define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )&#xD;&#xA;&#xD;&#xA;This weird looking one liner does a very simple task. It indexes the P&lt;sup&gt;th&lt;/sup&gt; element in the array `digital_pin_to_bit_mask_PGM` and returns it. This array `digital_pin_to_bit_mask_PGM` is defined in [`pins_arduino.h`][3] or the pin map for the specific board being used.&#xD;&#xA;&#xD;&#xA;    const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] = {&#xD;&#xA;    	_BV(0), /* 0, port D */&#xD;&#xA;    	_BV(1),&#xD;&#xA;    	_BV(2),&#xD;&#xA;    	_BV(3),&#xD;&#xA;    	_BV(4),&#xD;&#xA;    	_BV(5),&#xD;&#xA;    	_BV(6),&#xD;&#xA;    	_BV(7),&#xD;&#xA;    ...&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;This array has 20 elements in total, so we are out of luck. 999 will index a memory location in the flash memory outside of this array, thereby leading to unpredictable behavior. *Or will it?*&#xD;&#xA;&#xD;&#xA;We still have another line of defense against runtime anarchy. Its the next line of the function `pinMode`:&#xD;&#xA;&#xD;&#xA;    uint8_t port = digitalPinToPort(pin);&#xD;&#xA;&#xD;&#xA;`digitalPinToPort` takes us along a similar path. It is defined as a macro along with `digitalPinToBitMask`. Its definition is:&#xD;&#xA;&#xD;&#xA;    #define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )&#xD;&#xA;&#xD;&#xA;Now, we index the P&lt;sup&gt;th&lt;/sup&gt; element of `digital_pin_to_port_PGM` which is an array defined in the pin map:&#xD;&#xA;&#xD;&#xA;    const uint8_t PROGMEM digital_pin_to_port_PGM[] = {&#xD;&#xA;    	PD, /* 0 */&#xD;&#xA;    	PD,&#xD;&#xA;        ....&#xD;&#xA;    	PC,&#xD;&#xA;    	PC,&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;This array contains 20 elements, so 999 is again out of range. Again, this command reads and returns a value from flash memory of whose value we cannot be certain. This will again lead to unpredictable behavior from here on.&#xD;&#xA;&#xD;&#xA;There is still one last line of defense. That is the `if` check in `pinMode` on the return value of `digitalPinToPort`:&#xD;&#xA;&#xD;&#xA;    if (port == NOT_A_PIN) return;&#xD;&#xA;&#xD;&#xA;`NOT_A_PIN` is defined as 0 in `Arduino.h`. So, if the returned byte from `digitalPinToPort` happens to be zero, then `pinMode` will silently fail and return. &#xD;&#xA;&#xD;&#xA;In any case, `pinMode` cannot save us from anarchy. 999 is destined to result in doom.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;**In summary, the result of this will be unpredictable.** Most likely, no pin will be set to `OUTPUT`, and `digitalWrite` will fail. If you happen to have exceptionally bad luck, then a random pin may get set to `OUTPUT`, and `digitalWrite` may set it to `HIGH`.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/arduino/Arduino/blob/master/hardware/arduino/cores/arduino/wiring_digital.c&#xD;&#xA;  [2]: https://github.com/arduino/Arduino/blob/cc6d7cdbd1f97aa90ffcb759b5fc4c5ba553304e/hardware/arduino/cores/arduino/Arduino.h&#xD;&#xA;  [3]: https://github.com/arduino/Arduino/blob/2a8c06381fbc6fdb7e6363d0cb5d1c16019ccab0/hardware/arduino/variants/standard/pins_arduino.h" />
  <row Id="659" PostHistoryTypeId="5" PostId="277" RevisionGUID="55e1be4f-507e-44f2-94ae-ac0fe88782ce" CreationDate="2014-02-17T16:54:20.897" UserId="65" Comment="added 182 characters in body" Text="The compiler will not detect any error and the code will compile and execute. Hence, to see what happens we need to explore the behind-the-scenes magic. *For a summary, skip to end.*&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;The second line in your code is where the magic will happen and thats where we need to focus. &#xD;&#xA;&#xD;&#xA;    pinMode(pin, OUTPUT);&#xD;&#xA;&#xD;&#xA;The portion of `pinMode` relevant to this discussion is:&#xD;&#xA;&#xD;&#xA;    void pinMode(uint8_t pin, uint8_t mode) &#xD;&#xA;    {&#xD;&#xA;&#xD;&#xA;    	uint8_t bit = digitalPinToBitMask(pin); //The first instance where pin is used&#xD;&#xA;    	uint8_t port = digitalPinToPort(pin);&#xD;&#xA;&#xD;&#xA;        if (port == NOT_A_PIN) return;&#xD;&#xA;&#xD;&#xA;    //Do something&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;(The complete implementation can be found in [wiring_digital.c][1])&#xD;&#xA;&#xD;&#xA;So, here, `digitalPinToBitMask` seems to be using `pin` to compute an intermediate bit. Exploring further, `digitalPinToBitMask` is a macro defined in [`Arduino.h`][2] whose definition is this one-liner:&#xD;&#xA;&#xD;&#xA;    #define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )&#xD;&#xA;&#xD;&#xA;This weird looking one liner does a very simple task. It indexes the P&lt;sup&gt;th&lt;/sup&gt; element in the array `digital_pin_to_bit_mask_PGM` and returns it. This array `digital_pin_to_bit_mask_PGM` is defined in [`pins_arduino.h`][3] or the pin map for the specific board being used.&#xD;&#xA;&#xD;&#xA;    const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[] = {&#xD;&#xA;    	_BV(0), /* 0, port D */&#xD;&#xA;    	_BV(1),&#xD;&#xA;    	_BV(2),&#xD;&#xA;    	_BV(3),&#xD;&#xA;    	_BV(4),&#xD;&#xA;    	_BV(5),&#xD;&#xA;    	_BV(6),&#xD;&#xA;    	_BV(7),&#xD;&#xA;    ...&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;This array has 20 elements in total, so we are out of luck. 999 will index a memory location in the flash memory outside of this array, thereby leading to unpredictable behavior. *Or will it?*&#xD;&#xA;&#xD;&#xA;We still have another line of defense against runtime anarchy. Its the next line of the function `pinMode`:&#xD;&#xA;&#xD;&#xA;    uint8_t port = digitalPinToPort(pin);&#xD;&#xA;&#xD;&#xA;`digitalPinToPort` takes us along a similar path. It is defined as a macro along with `digitalPinToBitMask`. Its definition is:&#xD;&#xA;&#xD;&#xA;    #define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )&#xD;&#xA;&#xD;&#xA;Now, we index the P&lt;sup&gt;th&lt;/sup&gt; element of `digital_pin_to_port_PGM` which is an array defined in the pin map:&#xD;&#xA;&#xD;&#xA;    const uint8_t PROGMEM digital_pin_to_port_PGM[] = {&#xD;&#xA;    	PD, /* 0 */&#xD;&#xA;    	PD,&#xD;&#xA;        ....&#xD;&#xA;    	PC,&#xD;&#xA;    	PC,&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;This array contains 20 elements, so 999 is again out of range. Again, this command reads and returns a value from flash memory of whose value we cannot be certain. This will again lead to unpredictable behavior from here on.&#xD;&#xA;&#xD;&#xA;There is still one last line of defense. That is the `if` check in `pinMode` on the return value of `digitalPinToPort`:&#xD;&#xA;&#xD;&#xA;    if (port == NOT_A_PIN) return;&#xD;&#xA;&#xD;&#xA;`NOT_A_PIN` is defined as 0 in `Arduino.h`. So, if the returned byte from `digitalPinToPort` happens to be zero, then `pinMode` will silently fail and return. &#xD;&#xA;&#xD;&#xA;In any case, `pinMode` cannot save us from anarchy. 999 is destined to result in doom.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;**TL;DR, the code will execute and the result of this will be unpredictable.** Most likely, no pin will be set to `OUTPUT`, and `digitalWrite` will fail. If you happen to have exceptionally bad luck, then a random pin may get set to `OUTPUT`, and `digitalWrite` may set it to `HIGH`.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/arduino/Arduino/blob/master/hardware/arduino/cores/arduino/wiring_digital.c&#xD;&#xA;  [2]: https://github.com/arduino/Arduino/blob/cc6d7cdbd1f97aa90ffcb759b5fc4c5ba553304e/hardware/arduino/cores/arduino/Arduino.h&#xD;&#xA;  [3]: https://github.com/arduino/Arduino/blob/2a8c06381fbc6fdb7e6363d0cb5d1c16019ccab0/hardware/arduino/variants/standard/pins_arduino.h" />
  <row Id="660" PostHistoryTypeId="4" PostId="274" RevisionGUID="74921f90-e38f-4c8a-bd85-9791ed02a67b" CreationDate="2014-02-17T16:56:35.470" UserId="65" Comment="edited tags; edited title" Text="What will happen when I use an invalid pin number?" />
  <row Id="661" PostHistoryTypeId="6" PostId="274" RevisionGUID="74921f90-e38f-4c8a-bd85-9791ed02a67b" CreationDate="2014-02-17T16:56:35.470" UserId="65" Comment="edited tags; edited title" Text="&lt;programming&gt;" />
  <row Id="662" PostHistoryTypeId="2" PostId="278" RevisionGUID="f75739c1-4d37-4daf-9da6-8fc49f122c39" CreationDate="2014-02-17T18:10:17.507" UserId="84" Text="Big differences between relays and transistors are:&#xD;&#xA;&#xD;&#xA;- relays are all-or-nothing (like switches) whereas transistors can transmit more or less current through the **collector** based on the current present on their **base**.&#xD;&#xA;- relays provide isolation between the command circuit (the one with the electromagnet) and the controlled circuit (the one on the switch side of the relay)&#xD;&#xA;&#xD;&#xA;If you want to play with arduino, you definitely need to know about transistors; using relays is more akin to special applications." />
  <row Id="663" PostHistoryTypeId="5" PostId="274" RevisionGUID="67abf550-b7cd-4be7-9a10-76eff62fff94" CreationDate="2014-02-17T18:11:35.250" UserId="225" Comment="corrected spelling, reworded as question" Text="&gt; Related to:&#xD;&#xA;&gt; http://arduino.stackexchange.com/questions/189/what-happens-if-there-is-a-runtime-error&#xD;&#xA;&#xD;&#xA;This question is similar to the one above, however this is an alternate situation:&#xD;&#xA;&#xD;&#xA;    int pin = 999;&#xD;&#xA;    pinMode(pin, OUTPUT);&#xD;&#xA;    digitalWrite(pin, HIGH);&#xD;&#xA;What would happen in this instance? The compiler might catch it but if you used a random number would the IDE catch it?" />
  <row Id="664" PostHistoryTypeId="24" PostId="274" RevisionGUID="67abf550-b7cd-4be7-9a10-76eff62fff94" CreationDate="2014-02-17T18:11:35.250" Comment="Proposed by 225 approved by 8, 11 edit id of 58" />
  <row Id="666" PostHistoryTypeId="10" PostId="273" RevisionGUID="4cc9bb26-f1b5-43fe-874f-01186e4bbaeb" CreationDate="2014-02-17T18:55:44.213" UserId="-1" Comment="102" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:10,&quot;DisplayName&quot;:&quot;jamolnng&quot;},{&quot;Id&quot;:3,&quot;DisplayName&quot;:&quot;Butzke&quot;},{&quot;Id&quot;:52,&quot;DisplayName&quot;:&quot;anorton&quot;},{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;},{&quot;Id&quot;:220,&quot;DisplayName&quot;:&quot;Annonomus Person&quot;}]}" />
  <row Id="667" PostHistoryTypeId="10" PostId="237" RevisionGUID="6ce1b577-9717-4a2b-99f0-bfdd46bffab2" CreationDate="2014-02-17T19:11:56.487" UserId="-1" Comment="104" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;},{&quot;Id&quot;:52,&quot;DisplayName&quot;:&quot;anorton&quot;},{&quot;Id&quot;:65,&quot;DisplayName&quot;:&quot;AsheeshR&quot;},{&quot;Id&quot;:3,&quot;DisplayName&quot;:&quot;Butzke&quot;},{&quot;Id&quot;:220,&quot;DisplayName&quot;:&quot;Annonomus Person&quot;}]}" />
  <row Id="668" PostHistoryTypeId="5" PostId="117" RevisionGUID="74574bb1-287b-4495-b39b-cfeb1c53bcb6" CreationDate="2014-02-17T20:25:47.243" UserId="220" Comment="Don't forget about pin 0!" Text="Is it possible to have more than 14 output pins on the Arduino, I am working on a project in which I need to light up several LEDs individually. I only have an Arduino Uno, and I don't want to get a Mega. " />
  <row Id="669" PostHistoryTypeId="4" PostId="117" RevisionGUID="74574bb1-287b-4495-b39b-cfeb1c53bcb6" CreationDate="2014-02-17T20:25:47.243" UserId="220" Comment="Don't forget about pin 0!" Text="Is there a way to have more than 14 Output pins on arduino?" />
  <row Id="670" PostHistoryTypeId="6" PostId="117" RevisionGUID="74574bb1-287b-4495-b39b-cfeb1c53bcb6" CreationDate="2014-02-17T20:25:47.243" UserId="220" Comment="Don't forget about pin 0!" Text="&lt;uno&gt;&lt;pins&gt;" />
  <row Id="671" PostHistoryTypeId="24" PostId="117" RevisionGUID="74574bb1-287b-4495-b39b-cfeb1c53bcb6" CreationDate="2014-02-17T20:25:47.243" Comment="Proposed by 220 approved by 8, 11 edit id of 59" />
  <row Id="672" PostHistoryTypeId="2" PostId="279" RevisionGUID="98323603-4b89-4b6b-a4de-100adab54fa5" CreationDate="2014-02-17T22:27:42.840" UserId="84" Text="Once you have uploaded a sketch to one of your Arduino boards, it is hard to know exactly what source code led to that sketch.&#xD;&#xA;&#xD;&#xA;Indeed, you may change the source code of your sketch on your PC without updating it (in binary format) to your board.&#xD;&#xA;&#xD;&#xA;I had the idea of setting up a kind of &quot;*sketch repository*&quot; that would be populated as soon as I upload a sketch to one of my boards. Then I could retrieve, later on, the source code for a sketch running on any of my boards.&#xD;&#xA;&#xD;&#xA;For such a repository, I would first need to have an &quot;*index*&quot; that would enable me to know **which board** the sketch source code is linked to.&#xD;&#xA;&#xD;&#xA;Typically, such an index should be unique for every single arduino board.&#xD;&#xA;&#xD;&#xA;Hence my question: how can I get a unique ID for an Arduino board?" />
  <row Id="673" PostHistoryTypeId="1" PostId="279" RevisionGUID="98323603-4b89-4b6b-a4de-100adab54fa5" CreationDate="2014-02-17T22:27:42.840" UserId="84" Text="How can I get a unique ID for all my Arduino board?" />
  <row Id="674" PostHistoryTypeId="3" PostId="279" RevisionGUID="98323603-4b89-4b6b-a4de-100adab54fa5" CreationDate="2014-02-17T22:27:42.840" UserId="84" Text="&lt;unique&gt;&lt;identifier&gt;" />
  <row Id="675" PostHistoryTypeId="2" PostId="280" RevisionGUID="a9ea1f17-2871-4fc9-ac75-2756fb76d994" CreationDate="2014-02-17T23:37:06.103" UserId="11" Text="The chip doesn't have any sort of unique ID as far as I know.... but you could program one into the EEPROM of your boards.&#xD;&#xA;&#xD;&#xA;[EEPROM documetnation][1]&#xD;&#xA;&#xD;&#xA;You would write to a specific address and then future sketches can read the ID and do whatever with it.&#xD;&#xA;&#xD;&#xA;Alternatively, just use a label maker and put a label on each board.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/EEPROM" />
  <row Id="676" PostHistoryTypeId="5" PostId="280" RevisionGUID="f7ab69b1-a6d1-4230-96bc-609c82952c9b" CreationDate="2014-02-17T23:42:41.960" UserId="11" Comment="added 270 characters in body" Text="The chip doesn't have any sort of unique ID as far as I know.... but you could program one into the EEPROM of your boards.&#xD;&#xA;&#xD;&#xA;[EEPROM documetnation][1]&#xD;&#xA;&#xD;&#xA;You would write to a specific address and then future sketches can read the ID and do whatever with it.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;You may also be able to see a unqiue ID or address on the host side. I don't know enough about USB devices to tell you more, but the chip handling USB communication might have a unique ID you could use. Your Arduino code would not be able to use this, though.&#xD;&#xA;&#xD;&#xA;Alternatively, just use a label maker and put a label on each board.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/EEPROM" />
  <row Id="677" PostHistoryTypeId="2" PostId="281" RevisionGUID="34b6e8b0-64bf-4cb0-a27e-ced005f09737" CreationDate="2014-02-17T23:45:14.113" UserId="27" Text="Some boards, when connected to a computer, publish their serial number. My Arduino Uno R3 says&#xD;&#xA;&#xD;&#xA;    [16818.451423] usb 3-2: SerialNumber: 85235353137351E02242&#xD;&#xA;&#xD;&#xA;Though I'm not sure how unique it is." />
  <row Id="679" PostHistoryTypeId="4" PostId="279" RevisionGUID="8993e1c5-15af-44e4-9b29-bbd77c6ea757" CreationDate="2014-02-18T04:16:22.600" UserId="84" Comment="fixed typo" Text="How can I get a unique ID for all my Arduino boards?" />
  <row Id="680" PostHistoryTypeId="2" PostId="282" RevisionGUID="a6665ed5-083c-4544-af10-d17cb0ce4488" CreationDate="2014-02-18T05:19:19.273" UserId="83" Text="To the best of my knowledge the USB chips all come with a unique serial number, at least for the FTDI chips. On Linux you can easily assign unique device names from that, check [my website](http://wirespeed.xs4all.nl/mediawiki/index.php/Udev_rules_file_for_Arduino_boards).&#xD;&#xA;&#xD;&#xA;Other than that, what you are describing is pretty much a simple form of [version control](https://en.wikipedia.org/wiki/Revision_control). Make sure your source files have version numbers. To identify your Arduino, you can make it `Serial.Print();` print out name and version of the code during `setup();`." />
  <row Id="681" PostHistoryTypeId="5" PostId="282" RevisionGUID="1145d815-3e24-4993-b33b-a274fa8cac9a" CreationDate="2014-02-18T05:36:36.733" UserId="83" Comment="deleted 10 characters in body" Text="To the best of my knowledge the USB chips all come with a unique serial number, at least for the FTDI chips. On Linux you can easily assign unique device names from that, check [my website](http://wirespeed.xs4all.nl/mediawiki/index.php/Udev_rules_file_for_Arduino_boards).&#xD;&#xA;&#xD;&#xA;Other than that, what you are describing is pretty much a simple form of [version control](https://en.wikipedia.org/wiki/Revision_control). Make sure your source files have version numbers. To identify your Arduino, you can make it `Serial.Print();` name and version of the code during `setup();`." />
  <row Id="682" PostHistoryTypeId="2" PostId="283" RevisionGUID="694766c8-72c3-436f-9f51-1679126627ba" CreationDate="2014-02-18T08:27:19.557" UserId="136" Text="There are a number of techniques you could use here to get a unique ID.&#xD;&#xA;&#xD;&#xA; 1. FTDI chips have a unique serial number programmed onto them. This can only be accessed from the PC side of the connection as far as I am aware.&#xD;&#xA; 2. Some of the chips with built in USB (e.g. ATmega8U2/16U2/32U2) have a unique ID in the signature data, normally used for USB. Can easily be accessed from both sides of the connection. This includes the ATmega16U2 that is used as the USB-&gt;Serial bridge Arduino Uno R3.&#xD;&#xA; 3. Some of the chips with built in USB but no unique ID in the signature will still have a unique ID programmed into the USB stack (e.g. LUFA) used for the bootloader or DFU (Device Firmware Upgrade).&#xD;&#xA; 4. There are many chips with globally unique serial IDs in them e.g. the Microchip [11AA02E48][1], all of the Dallas 1-Wire sensors (including the common DS18B20 temperature sensor), and other serial EEPROMS. I've used these in production hardware that must have a unique MAC address.&#xD;&#xA; 5. You could modify the standard Optiboot bootloader (or whichever boat loader you use) so that it can hold and respond with a unique ID. &#xD;&#xA;&#xD;&#xA;The problem with these is that there is no option except 5 that will work across all boards.&#xD;&#xA;&#xD;&#xA;If your solution is going to be a generic one, I would suggest that using a USB ID is not the way forwards. I have ~30 Arduino-based boards, and only 5 of them have built in USB hardware. All the rest of them need an external FTDI cable to be programmed. This means they would all have the same ID. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en538621" />
  <row Id="683" PostHistoryTypeId="2" PostId="284" RevisionGUID="2a236f37-93f7-4760-92ab-7aca71cfb5ed" CreationDate="2014-02-18T12:10:10.547" UserId="-1" Text="" />
  <row Id="684" PostHistoryTypeId="2" PostId="285" RevisionGUID="9f661f38-7b44-4286-9b9a-a819b3588e74" CreationDate="2014-02-18T12:10:10.547" UserId="-1" Text="" />
  <row Id="685" PostHistoryTypeId="2" PostId="286" RevisionGUID="411045a4-cf15-4eb2-9c93-c5422dd0586c" CreationDate="2014-02-18T15:11:41.877" UserId="193" Text="Is there a way I can have multiple parts of the program running together without doing multiple things in the same code block?&#xD;&#xA;&#xD;&#xA;One thread waiting for an external device while also blinking a LED in another thread.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="686" PostHistoryTypeId="1" PostId="286" RevisionGUID="411045a4-cf15-4eb2-9c93-c5422dd0586c" CreationDate="2014-02-18T15:11:41.877" UserId="193" Text="How can I create multiple running threads?" />
  <row Id="687" PostHistoryTypeId="3" PostId="286" RevisionGUID="411045a4-cf15-4eb2-9c93-c5422dd0586c" CreationDate="2014-02-18T15:11:41.877" UserId="193" Text="&lt;uno&gt;&lt;threads&gt;" />
  <row Id="688" PostHistoryTypeId="2" PostId="287" RevisionGUID="c95cadb0-0863-42a3-bf5c-498e1343f13d" CreationDate="2014-02-18T15:36:32.877" UserId="65" Text="It is possible to do software side multi-threading on the Uno. Hardware level threading is not supported.&#xD;&#xA;&#xD;&#xA;To achieve multithreading, it will require the implementation of a basic scheduler and maintaining a process or task list to track the different tasks that need to be run. &#xD;&#xA;&#xD;&#xA;The structure of a very simple non-preemptive scheduler would be like:&#xD;&#xA;&#xD;&#xA;    //Pseudocode&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;    for(i=o; i&lt;n; i++) &#xD;&#xA;    run(tasklist[i] for timelimit):&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here, `tasklist` can be an array of function pointers.&#xD;&#xA;&#xD;&#xA;    tasklist [] = {function1, function2, function3, ...}&#xD;&#xA;&#xD;&#xA;With each function of the form:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    int function1(long time_available)&#xD;&#xA;    {&#xD;&#xA;       top:&#xD;&#xA;       //Do short task&#xD;&#xA;       if (run_time&lt;time_available)&#xD;&#xA;       goto top;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Each function can be doing a separate task such as `function1` performing LED manipulations, while `function2` doing a float calculation. It will be the responsibility of each task(function) to adhere to the time allocated to it.&#xD;&#xA;&#xD;&#xA;Hopefully, this should be enough to get you started. " />
  <row Id="689" PostHistoryTypeId="5" PostId="287" RevisionGUID="105a8eda-e9a7-4126-97b7-c0dd131fe004" CreationDate="2014-02-18T15:46:38.783" UserId="65" Comment="deleted 4 characters in body" Text="It is possible to do software side multi-threading on the Uno. Hardware level threading is not supported.&#xD;&#xA;&#xD;&#xA;To achieve multithreading, it will require the implementation of a basic scheduler and maintaining a process or task list to track the different tasks that need to be run. &#xD;&#xA;&#xD;&#xA;The structure of a very simple non-preemptive scheduler would be like:&#xD;&#xA;&#xD;&#xA;    //Pseudocode&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;    for(i=o; i&lt;n; i++) &#xD;&#xA;    run(tasklist[i] for timelimit):&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here, `tasklist` can be an array of function pointers.&#xD;&#xA;&#xD;&#xA;    tasklist [] = {function1, function2, function3, ...}&#xD;&#xA;&#xD;&#xA;With each function of the form:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    int function1(long time_available)&#xD;&#xA;    {&#xD;&#xA;       top:&#xD;&#xA;       //Do short task&#xD;&#xA;       if (run_time&lt;time_available)&#xD;&#xA;       goto top;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Each function can perform a separate task such as `function1` performing LED manipulations, and `function2` doing float calculations. It will be the responsibility of each task(function) to adhere to the time allocated to it.&#xD;&#xA;&#xD;&#xA;Hopefully, this should be enough to get you started. " />
  <row Id="690" PostHistoryTypeId="5" PostId="285" RevisionGUID="9428ea4a-85ad-4d98-9d33-f66c6e9f9d0b" CreationDate="2014-02-18T16:34:04.380" UserId="201" Comment="added 91 characters in body" Text="This tag is for questions regarding powering and/or power consumption of arduino systems.  " />
  <row Id="691" PostHistoryTypeId="24" PostId="285" RevisionGUID="9428ea4a-85ad-4d98-9d33-f66c6e9f9d0b" CreationDate="2014-02-18T16:34:04.380" Comment="Proposed by 201 approved by 8, 48 edit id of 61" />
  <row Id="692" PostHistoryTypeId="5" PostId="226" RevisionGUID="ef6b2265-8196-44f8-bf40-96ca50cd431b" CreationDate="2014-02-18T16:42:02.160" UserId="65" Comment="added 65 characters in body; edited title" Text="ATMEL says the cell lifetime of an EEPROM cell is about 100,000 write cycle/ cell.&#xD;&#xA;Is this actually how the EEPROM performs in the wild?&#xD;&#xA;&#xD;&#xA;If I do not change the value of a cell, does this stress the lifetime? For example, if I write the value `0xFF` to the same cell again and again, is this any different to writing `0x00`, `0xFF`, `0x00` etc." />
  <row Id="693" PostHistoryTypeId="4" PostId="226" RevisionGUID="ef6b2265-8196-44f8-bf40-96ca50cd431b" CreationDate="2014-02-18T16:42:02.160" UserId="65" Comment="added 65 characters in body; edited title" Text="What is the real lifetime of EEPROM?" />
  <row Id="694" PostHistoryTypeId="2" PostId="288" RevisionGUID="1af54d9a-0271-4a5c-8c0a-51f160d945f7" CreationDate="2014-02-18T17:23:17.690" UserId="11" Text="There is no multi-process or multi-threadding support on the Arduino. You can do something  close to multiple threads with some software though.&#xD;&#xA;&#xD;&#xA;You want to look at [Protothreads][1]:&#xD;&#xA;&#xD;&#xA;&gt; Protothreads are extremely lightweight stackless threads designed for&#xD;&#xA;&gt; severely memory constrained systems, such as small embedded systems or&#xD;&#xA;&gt; wireless sensor network nodes. Protothreads provide linear code&#xD;&#xA;&gt; execution for event-driven systems implemented in C. Protothreads can&#xD;&#xA;&gt; be used with or without an underlying operating system to provide&#xD;&#xA;&gt; blocking event-handlers. Protothreads provide sequential flow of&#xD;&#xA;&gt; control without complex state machines or full multi-threading.&#xD;&#xA;&#xD;&#xA;Of course, there's an Arduino example [here][2] with [example code][3]. This [SO question][4] might be useful, too.&#xD;&#xA;&#xD;&#xA;[ArduinoThread][5] is a good one too.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://dunkels.com/adam/pt/&#xD;&#xA;  [2]: http://harteware.blogspot.com/2010/11/protothread-powerfull-library.html&#xD;&#xA;  [3]: http://harteware.blogspot.com/2010/11/protothread-and-arduino-first-easy.html&#xD;&#xA;  [4]: http://stackoverflow.com/questions/6230878/some-problems-with-arduino-protothreads&#xD;&#xA;  [5]: https://github.com/ivanseidel/ArduinoThread" />
  <row Id="695" PostHistoryTypeId="2" PostId="289" RevisionGUID="d597d49a-f14d-4d78-96a4-18699ef54832" CreationDate="2014-02-18T18:14:37.177" UserId="83" Text="AVR based Arduino's do not support (hardware) threading, I am unfamiliar with the ARM based Arduino's. One way around this limitation is the use of interrupts, especially timed interrupts. You can program a timer to interrupt the main routine every so many microseconds, to run a specific other routine.&#xD;&#xA;&#xD;&#xA;http://arduino.cc/en/Reference/Interrupts" />
  <row Id="696" PostHistoryTypeId="5" PostId="279" RevisionGUID="efd89263-1795-4ceb-bc18-1c933c6dd426" CreationDate="2014-02-18T20:26:24.343" UserId="84" Comment="Added the list of boards to be supported." Text="Once you have uploaded a sketch to one of your Arduino boards, it is hard to know exactly what source code led to that sketch.&#xD;&#xA;&#xD;&#xA;Indeed, you may change the source code of your sketch on your PC without updating it (in binary format) to your board.&#xD;&#xA;&#xD;&#xA;I had the idea of setting up a kind of &quot;*sketch repository*&quot; that would be populated as soon as I upload a sketch to one of my boards. Then I could retrieve, later on, the source code for a sketch running on any of my boards.&#xD;&#xA;&#xD;&#xA;For such a repository, I would first need to have an &quot;*index*&quot; that would enable me to know **which board** the sketch source code is linked to.&#xD;&#xA;&#xD;&#xA;Typically, such an index should be unique for every single arduino board.&#xD;&#xA;&#xD;&#xA;Hence my question: how can I get a unique ID for an Arduino board?&#xD;&#xA;&#xD;&#xA;**Edit:**&#xD;&#xA;&#xD;&#xA;This is my current list of boards (the miniumum list to be supported by a single unique ID approach):&#xD;&#xA;&#xD;&#xA;- UNO R3&#xD;&#xA;- Mega 2560&#xD;&#xA;- Yun&#xD;&#xA;- Arduino Robot (that must be 2 Leonardo equivalent boards)&#xD;&#xA;&#xD;&#xA;In the future, I may also build my own boards (Uno equivalent but barebones, without FTDI), hence if an approach also supports these that would be better." />
  <row Id="697" PostHistoryTypeId="2" PostId="290" RevisionGUID="9bf39190-173d-4ada-8054-a1072167d511" CreationDate="2014-02-18T20:58:55.920" UserId="84" Text="As per the description of your requirements:&#xD;&#xA;&#xD;&#xA;- one thread waiting for an external device&#xD;&#xA;- one thread blinking a LED&#xD;&#xA;&#xD;&#xA;It seems you could use one Arduino timer for the first &quot;thread&quot; (we should rather call it &quot;task&quot; in fact).&#xD;&#xA;&#xD;&#xA;Arduino timers can call one function (your code) based on an external event (voltage level or level change on a digital input pin), that will trigger your function immediately.&#xD;&#xA;&#xD;&#xA;However, one important point to keep in mind with timers is that the called function should be as fast as possible (typically, there should be no `delay()` call or any other API that would depend on `delay()`).&#xD;&#xA;&#xD;&#xA;If you have a long task to activate upon external event trigger, then you could potentially use a cooperative scheduler and add a new task to it from your timer function.&#xD;&#xA;" />
  <row Id="698" PostHistoryTypeId="5" PostId="290" RevisionGUID="469f437a-01fc-4087-8d03-b896065e1145" CreationDate="2014-02-18T21:07:29.017" UserId="84" Comment="Fixed misnamed &quot;timer&quot; to &quot;interrupt&quot; and added some further info." Text="As per the description of your requirements:&#xD;&#xA;&#xD;&#xA;- one thread waiting for an external device&#xD;&#xA;- one thread blinking a LED&#xD;&#xA;&#xD;&#xA;It seems you could use one Arduino interrupt for the first &quot;thread&quot; (I would rather call it &quot;task&quot; in fact).&#xD;&#xA;&#xD;&#xA;Arduino interrupts can call one function (your code) based on an external event (voltage level or level change on a digital input pin), that will trigger your function immediately.&#xD;&#xA;&#xD;&#xA;However, one important point to keep in mind with interrupts is that the called function should be as fast as possible (typically, there should be no `delay()` call or any other API that would depend on `delay()`).&#xD;&#xA;&#xD;&#xA;If you have a long task to activate upon external event trigger, then you could potentially use a cooperative scheduler and add a new task to it from your interrupt function.&#xD;&#xA;&#xD;&#xA;A second important point about interrupts is that their number is limited (e.g. only 2 on UNO). So if you start tohave more external events, you would need to implement some kind of multiplexing all inputs into one, and have your interrupt function determine what multiplexed inut was the actual trigger." />
  <row Id="699" PostHistoryTypeId="2" PostId="291" RevisionGUID="0b096001-5281-407b-9950-b4e805a87b19" CreationDate="2014-02-18T22:21:17.023" UserId="236" Text="There are also some people working on **Javascript** node.js based systems. One that is already publicly available is [Espruino][1] and another is [Tessel][2] which launches in spring 2014.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/espruino/Espruino&#xD;&#xA;  [2]: https://github.com/technicalmachine" />
  <row Id="700" PostHistoryTypeId="2" PostId="292" RevisionGUID="64715124-68a0-42de-8e8b-b0cda3dcb310" CreationDate="2014-02-18T22:56:12.727" UserId="201" Text="I am involved in a project that is going to take measure ph and chlorine in a swimming pool.  The plan is to use a Arduino Yun. The sensors we are going to use are connected serial.  Since we may be using multiple sensors is my question: is there any difference in reliability, latency, known issues (bugs) of using software serial contra pin0 and pin1? and is there any way to avoid software serial pitfalls (if there are any)?" />
  <row Id="701" PostHistoryTypeId="1" PostId="292" RevisionGUID="64715124-68a0-42de-8e8b-b0cda3dcb310" CreationDate="2014-02-18T22:56:12.727" UserId="201" Text="Serial sensors and the Yun" />
  <row Id="702" PostHistoryTypeId="3" PostId="292" RevisionGUID="64715124-68a0-42de-8e8b-b0cda3dcb310" CreationDate="2014-02-18T22:56:12.727" UserId="201" Text="&lt;serial&gt;&lt;arduino-yun&gt;&lt;sensors&gt;" />
  <row Id="703" PostHistoryTypeId="5" PostId="292" RevisionGUID="5fd5bfe2-36e4-4c6f-928e-e10e9cfbaa2c" CreationDate="2014-02-18T23:00:00.060" UserId="8" Comment="spelling, grammar" Text="I am involved in a project that is going to take measure PH and chlorine in a swimming pool.  The plan is to use a Arduino Yun. The sensors we are going to use are connected using serial.  Since we may be using multiple sensors, is there any difference in reliability, latency, known issues (bugs) of using software serial versus pin0 and pin1? Is there any way to avoid software serial pitfalls (if there are any)?" />
  <row Id="704" PostHistoryTypeId="2" PostId="293" RevisionGUID="fd8e0456-d701-4cf9-9394-3efd4185bb2f" CreationDate="2014-02-19T00:40:29.107" UserId="11" Text="I don't have any experience with the Yun so I can't comment on that specifically, but the only problem you'll encounter with using [SoftwareSerial][1] is that you can only communicate with one device at a time.&#xD;&#xA;&#xD;&#xA;This means you'll have to make a call to [`listen()`][2]&#xD;&#xA;&#xD;&#xA;    sensor1.listen()&#xD;&#xA;&#xD;&#xA;before communicating with `sensor1`. Then when you want to communicate with another sensor, you have to do the same.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/SoftwareSerial&#xD;&#xA;  [2]: http://arduino.cc/en/Reference/SoftwareSerialListen" />
  <row Id="705" PostHistoryTypeId="2" PostId="294" RevisionGUID="af47dac7-b570-44cc-aa7a-14047d580d01" CreationDate="2014-02-19T00:48:23.407" UserId="220" Text="I've been hearing a lot about clones and counterfeits. **What are the differences between the two?**" />
  <row Id="706" PostHistoryTypeId="1" PostId="294" RevisionGUID="af47dac7-b570-44cc-aa7a-14047d580d01" CreationDate="2014-02-19T00:48:23.407" UserId="220" Text="What's the difference between a clone and a counterfeit Arduino?" />
  <row Id="707" PostHistoryTypeId="3" PostId="294" RevisionGUID="af47dac7-b570-44cc-aa7a-14047d580d01" CreationDate="2014-02-19T00:48:23.407" UserId="220" Text="&lt;clones&gt;&lt;counterfiet&gt;" />
  <row Id="708" PostHistoryTypeId="2" PostId="295" RevisionGUID="8d8e1bb3-4105-4810-ba8a-e39555eb1661" CreationDate="2014-02-19T00:48:23.407" UserId="220" Text="The difference is simple: &#xD;&#xA;&#xD;&#xA;## Clones don't say &quot;Arduino,&quot; where counterfeits do ##&#xD;&#xA;&#xD;&#xA;If I were to create 200 boards all labeled &quot;Arduino UNO R3,&quot; it would be a counterfeit. If I were to call them &quot;Happyduino,&quot; it would be a *clone*. &#xD;&#xA;****&#xD;&#xA;**Note:** You can still write *Happyduino (Arduino Compatible)* on your product. Here's a quote from the [Arduino FAQ section](http://arduino.cc/en/Main/FAQ)&#xD;&#xA;&#xD;&#xA;&gt; Not okay:&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Arduino Xxxxxx&#xD;&#xA;&gt;  - Xxxxxx Arduino&#xD;&#xA;&gt;  - Arduino Compatible Xxxxxx - use &quot;Xxxxxx (Arduino-Compatible)&quot; instead&#xD;&#xA;&gt; &#xD;&#xA;&gt; Okay:&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Xxxxxx for Arduino - products that work with official Arduino boards    (e.g. shields or kits)&#xD;&#xA;&gt;  - Xxxxxx (Arduino-Compatible) - variations and clones which are    software and hardware compatible&#xD;&#xA;&gt; &#xD;&#xA;&gt; Note that while we don't attempt to restrict uses of the &quot;duino&quot;&#xD;&#xA;&gt; suffix, its use causes the Italians on the team to cringe (apparently&#xD;&#xA;&gt; it sounds terrible); you might want to avoid it. (It's also&#xD;&#xA;&gt; trademarked by a Hungarian company.)" />
  <row Id="709" PostHistoryTypeId="2" PostId="296" RevisionGUID="53d67714-cc0f-4e10-8181-ba10a0de723f" CreationDate="2014-02-19T03:16:57.470" UserId="220" Text="The standard is 9600 baud. That's just the *standard*. **Using a Arduino Uno SMD R2, what is the highest practical baud rate I can achieve?**&#xD;&#xA;&#xD;&#xA;Bonus points for the audacious: **How would you go about creating an error checking mechanism and then increasing the baud rate ridiculous high to get high transfer rates?**" />
  <row Id="710" PostHistoryTypeId="1" PostId="296" RevisionGUID="53d67714-cc0f-4e10-8181-ba10a0de723f" CreationDate="2014-02-19T03:16:57.470" UserId="220" Text="How high of a baud rate can I go (without errors)?" />
  <row Id="711" PostHistoryTypeId="3" PostId="296" RevisionGUID="53d67714-cc0f-4e10-8181-ba10a0de723f" CreationDate="2014-02-19T03:16:57.470" UserId="220" Text="&lt;arduino-uno-smd&gt;" />
  <row Id="713" PostHistoryTypeId="2" PostId="298" RevisionGUID="6dacb128-a74d-4622-8019-a9ed6cc7b06a" CreationDate="2014-02-19T05:27:35.870" UserId="11" Text="The Arduino Serial Monitor window limits you to 115200, but that's not the highest baud rate capable. You can read the Atmel and the FT232 (or whatever you're using) datasheets to find out the maximum but I am able to successfully use 230400 (twice as fast as the largest the Arduino Serial Monitor supports) with no issues.&#xD;&#xA;&#xD;&#xA;If you want to see the results in your computer, you will need another serial monitor that supports other baud rate options. I like [CoolTerm][1] and [Termite][2].&#xD;&#xA;&#xD;&#xA;Do note that this heavily depends on your clock speed as well.&#xD;&#xA;&#xD;&#xA;Here's a [calculator][3] to help you with calculating what's possible.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://freeware.the-meiers.org/&#xD;&#xA;  [2]: http://www.compuphase.com/software_termite.htm&#xD;&#xA;  [3]: http://www.wormfood.net/avrbaudcalc.php" />
  <row Id="714" PostHistoryTypeId="2" PostId="299" RevisionGUID="6ba81f6f-4b4b-4d37-b63a-5a5ade0da437" CreationDate="2014-02-19T06:24:54.967" UserId="86" Text="There are several factors here:&#xD;&#xA;&#xD;&#xA; - How high of a baud-rate can the ATmega328P MCU achieve?&#xD;&#xA; - How high of a baud-rate can the USB-Serial interface achieve?&#xD;&#xA; - What is the oscillator frequency on the ATmega328P?&#xD;&#xA; - What is the oscillator frequency on the USB-serial interface (if it has one)?&#xD;&#xA; - How tolerant is the USB-serial interface of baud-rate mismatch?&#xD;&#xA;&#xD;&#xA;All of these factors are relevant to determining the maximum achieveable baud rate. The ATmega328P uses a hardware divisor from it's clock-rate to generate the base-clock for the serial interface. If there is no integer ratio from the main clock to the bit-time of the desired baud rate, the MCU will not be able to *exactly* produce the desired rate. This can lead to potential issues, as some devices are much more sensitive to baud-rate mismatch then others.&#xD;&#xA;&#xD;&#xA;FTDI-based interfaces are quite tolerant of baud-rate mismatch, up to several percent error. However, I have worked with specialized embedded GPS modules that were unable to handle even a 0.5% baud rate error.&#xD;&#xA;&#xD;&#xA;General serial interfaces are tolerant of ~5% baud-rate error. However, since each end can be off, a more common spec is +-2.5%. This way, if one end is 2.5% fast, and the other is 2.5% slow, your *overall* error is still only 5%.&#xD;&#xA;&#xD;&#xA;--- &#xD;&#xA;&#xD;&#xA;Anyways. The Uno uses a ATmega328P as the primary MCU, and a ATmega16U2 as the USB-serial interface. We're also fortunate here in that both these MCUs use similar harware USARTs, as well as 16 Mhz clocks. &#xD;&#xA;&#xD;&#xA;Since both MCUs have the same harware and clock-rate, they'll both have the same baud-rate error in the same direction, so we can functionally ignore the baud error issue.&#xD;&#xA;&#xD;&#xA;Anyways, the &quot;proper&quot; answer to this question would involve digging up the source for the ATmega16U2, and working out the possible baud-rates from there, but since I'm lazy, I figure simple, empirical testing will work.&#xD;&#xA;&#xD;&#xA;A quick glance at the ATmega328P datasheet produces the following table:  &#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;So given the max stated baud-rate of 2 Mbps, I wrote a quick test program:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup(){};&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(57600);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 57600&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(76800);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 76800&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(115200);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 115200&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(230400);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 230400&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(250000);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 250000&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(500000);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 500000&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(1000000);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 1000000&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(2000000);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 2000000&quot;);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;And then looking at the relevant serial port with a serial terminal:  &#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;So it appears the hardware can run at 2,000,000 baud without problems.&#xD;&#xA;&#xD;&#xA;Note that this baud rate only gives the MCU 64 clock-cycles per byte, so it would be very challenging to keep the serial interface busy. While the individual bytes may be transferred very rapidly, there is likely to be lots of time when the interface is simply idle.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/P8kN2.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/US17S.png" />
  <row Id="715" PostHistoryTypeId="2" PostId="300" RevisionGUID="eeeb85a6-b08c-4f6b-b0cc-ad346cf3ef7e" CreationDate="2014-02-19T06:39:32.413" UserId="83" Text="This is probably one of the few aspects where el-Cheapo boards differ from original boards. The maximum serial transfer rate is pretty much only limited by the quality of the board and its layout. Once the serial data enters either AVR or USB interface chip, the data will be processed differently from the serial UART protocol. &#xD;&#xA;&#xD;&#xA;Keep in mind though that the microcontroller has some basic hardware to shift in/out serial data to/from the IO pins, but the absolute maximum rate is limited to the 16MHz clock (for AVRs). Once a byte is moved to the serial buffer, the UART hardware will take over and push out / pull in the bits on its own. An AVR at best reaches 16M instructions per second and the interrupts used to fill the serial buffer have some overhead (at least 8 clock ticks for the interrupt handling + instructions to save current state + several instructions for actually filling the buffer). At a given bitrate, the protocol will run at a whopping n bits per second, but your controller needs more time to fill the serial buffer than it needs to actually output the data, resulting in a lower average throughput than you expect and the UART idling for a relatively long time. Disadvantage is the increased probability for bit errors.&#xD;&#xA;&#xD;&#xA;Another effect to remember is that all the overhead required to push data out onto UART (or pull it in) cannot be spent in your actual program, again affecting the average practical throughput. You can only use every instruction cycle once, either for filling the buffer or for computing the main loop.&#xD;&#xA;&#xD;&#xA;The maximum throughput is therefore dependent on the application you use (how fast is data generated/computed/ready to move to/from the serial buffer) and the actual 'physical' bitrate is only a small part of the design decision." />
  <row Id="716" PostHistoryTypeId="5" PostId="299" RevisionGUID="c985d640-6028-45d3-b82e-69b5b569818b" CreationDate="2014-02-19T06:46:48.357" UserId="86" Comment="added 1015 characters in body" Text="There are several factors here:&#xD;&#xA;&#xD;&#xA; - How high of a baud-rate can the ATmega328P MCU achieve?&#xD;&#xA; - How high of a baud-rate can the USB-Serial interface achieve?&#xD;&#xA; - What is the oscillator frequency on the ATmega328P?&#xD;&#xA; - What is the oscillator frequency on the USB-serial interface (if it has one)?&#xD;&#xA; - How tolerant is the USB-serial interface of baud-rate mismatch?&#xD;&#xA;&#xD;&#xA;All of these factors are relevant to determining the maximum achieveable baud rate. The ATmega328P uses a hardware divisor from it's clock-rate to generate the base-clock for the serial interface. If there is no integer ratio from the main clock to the bit-time of the desired baud rate, the MCU will not be able to *exactly* produce the desired rate. This can lead to potential issues, as some devices are much more sensitive to baud-rate mismatch then others.&#xD;&#xA;&#xD;&#xA;FTDI-based interfaces are quite tolerant of baud-rate mismatch, up to several percent error. However, I have worked with specialized embedded GPS modules that were unable to handle even a 0.5% baud rate error.&#xD;&#xA;&#xD;&#xA;General serial interfaces are tolerant of ~5% baud-rate error. However, since each end can be off, a more common spec is +-2.5%. This way, if one end is 2.5% fast, and the other is 2.5% slow, your *overall* error is still only 5%.&#xD;&#xA;&#xD;&#xA;--- &#xD;&#xA;&#xD;&#xA;Anyways. The Uno uses a ATmega328P as the primary MCU, and a ATmega16U2 as the USB-serial interface. We're also fortunate here in that both these MCUs use similar harware USARTs, as well as 16 Mhz clocks. &#xD;&#xA;&#xD;&#xA;Since both MCUs have the same harware and clock-rate, they'll both have the same baud-rate error in the same direction, so we can functionally ignore the baud error issue.&#xD;&#xA;&#xD;&#xA;Anyways, the &quot;proper&quot; answer to this question would involve digging up the source for the ATmega16U2, and working out the possible baud-rates from there, but since I'm lazy, I figure simple, empirical testing will work.&#xD;&#xA;&#xD;&#xA;A quick glance at the ATmega328P datasheet produces the following table:  &#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;So given the max stated baud-rate of 2 Mbps, I wrote a quick test program:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup(){};&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(57600);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 57600&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(76800);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 76800&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(115200);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 115200&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(230400);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 230400&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(250000);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 250000&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(500000);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 500000&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(1000000);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 1000000&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(2000000);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 2000000&quot;);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;And then looking at the relevant serial port with a serial terminal:  &#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;So it appears the hardware can run at 2,000,000 baud without problems.&#xD;&#xA;&#xD;&#xA;Note that this baud rate only gives the MCU 64 clock-cycles per byte, so it would be very challenging to keep the serial interface busy. While the individual bytes may be transferred very rapidly, there is likely to be lots of time when the interface is simply idle.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Edit: Actual Testing!&#xD;&#xA;&#xD;&#xA;The 2 Mbps is real:  &#xD;&#xA;![enter image description here][3]  &#xD;&#xA;each bit-time is 500 ns, which matches exactly with what is expected.&#xD;&#xA;&#xD;&#xA;Performance issues! Overall packet length:    &#xD;&#xA;500 Kbaud:&#xD;&#xA;![enter image description here][4]&#xD;&#xA;&#xD;&#xA;1 Mbaud:&#xD;&#xA;![enter image description here][5]&#xD;&#xA;&#xD;&#xA;2 Mbaud:&#xD;&#xA;![enter image description here][6]&#xD;&#xA;&#xD;&#xA;As you can see, the overall transmission length is the same for 0.5, 1 and 2 Mbaud. This is because the code that is placing the bytes in the serial buffer is poorly optimized. As such, you will never achieve anything better then an *effective* 500 Kbaud, unless you write your own serial libraries. The Arduino libraries are very poorly optimized, so it probably wouldn't be *too* hard to get a proper 2 Mbaud, at least for burst transmissions, if you spent a bit of time on it.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/P8kN2.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/US17S.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/APzfe.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/rlBti.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/9ACpH.jpg&#xD;&#xA;  [6]: http://i.stack.imgur.com/vUDoN.jpg" />
  <row Id="717" PostHistoryTypeId="2" PostId="301" RevisionGUID="775beb79-2477-4ae8-85c9-3f5457463f5b" CreationDate="2014-02-19T06:57:15.270" UserId="83" Text="I didn't check the circuit diagrams, but on most AVR based Arduino's pins 0 and 1 are used to program the device. By reusing the pins, you may run into problems when trying to program the Arduino from IDE. It is easily solved by detaching the hardware from those pins, but you have to reattach them to test the sketch. I personally try to avoid using those to pins, just for ease of development." />
  <row Id="718" PostHistoryTypeId="2" PostId="302" RevisionGUID="2fe45235-0805-4558-bd17-c22dbe8efe24" CreationDate="2014-02-19T08:00:46.920" UserId="136" Text="The Yun is a bit different to other Arduinos. The main microcontroller is a ATmega32U4 with a build in USB interface. This is used for the connection to the PC so the single USART is not used for this purpose.&#xD;&#xA;&#xD;&#xA;However, the single USART is used for connecting to the built in wireless processor. This means that you can't use the wireless and hardware serial at the same time. I presume you are using the Yun for wireless, so disabling this is not desirable.&#xD;&#xA;&#xD;&#xA;SoftwareSerial is relatively good, but does consume a lot of cycles. You can only listen on a single port at a time. It is possible to use pin change interrupts to listen for activity on multiple ports and switch to the one required, but this requires that the other end can wait for a response.&#xD;&#xA;&#xD;&#xA;[SoftwareSerial][1] will tie up the microcontroller whilst sending, which can lead to problems when supporting *low* baud rates. Conversely, because it is CPU heavy, it can also have problems with *high* baud rates. There is a window, between 9600 and 38400 baud, where it seems to work best.&#xD;&#xA;&#xD;&#xA;There is another software serial version called [AltSoftSerial][2]. This works faster than SoftwareSerial and can transmit and receive at the same time.&#xD;&#xA;&#xD;&#xA;You can use the USART, SoftwareSerial and AltSoftSerial all at the same time. Be warned that because all three of these use interrupts and some use timers, you are highly likely to end up with complex, hard to debug interactions.&#xD;&#xA;&#xD;&#xA;Note than in older versions of Arduino (pre v1), SoftwareSerial was very, very poor. It was replaced entirely with &quot;NewSoftSerial&quot;. &#xD;&#xA;&#xD;&#xA;I am not a massive fan of the Yun. It isn't popular, the wireless is still relatively hard to use (compared to the TI CC3000), and the wireless interface uses valuable pins. Personally, if I was to work on a project that required multiple serial interfaces, I would either&#xD;&#xA;&#xD;&#xA; 1. Use a board with multiple USART, such as a ATmega1280 (2 USARTs) or ATmega2560 (4 USARTs) and a CC3000 (SPI connected) wireless board.&#xD;&#xA; 2. Use SPI/I2C-&gt;USART bridges. This allows a single SPI/I2C port to control multiple USARTs. Sparkfun [sell one][3], there are many others available.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.pjrc.com/teensy/td_libs_NewSoftSerial.html#cpu&#xD;&#xA;  [2]: https://www.pjrc.com/teensy/td_libs_AltSoftSerial.html&#xD;&#xA;  [3]: https://www.sparkfun.com/products/9981" />
  <row Id="719" PostHistoryTypeId="5" PostId="302" RevisionGUID="1fa70704-9299-45a2-9909-fbbe43096179" CreationDate="2014-02-19T08:10:49.197" UserId="136" Comment="added 237 characters in body" Text="The Yun is a bit different to other Arduinos. The main microcontroller is a ATmega32U4 with a build in USB interface. This is used for the connection to the PC so the single USART is not used for this purpose.&#xD;&#xA;&#xD;&#xA;However, the single USART is used for connecting to the built in wireless processor. This means that you can't use the wireless and hardware serial at the same time. I presume you are using the Yun for wireless, so disabling this is not desirable.&#xD;&#xA;&#xD;&#xA;SoftwareSerial is relatively good, but does consume a lot of cycles. You can only listen on a single port at a time. It is possible to use pin change interrupts to listen for activity on multiple ports and switch to the one required, but this requires that the other end can wait for a response.&#xD;&#xA;&#xD;&#xA;[SoftwareSerial][1] will tie up the microcontroller whilst sending, which can lead to problems when supporting *low* baud rates. Conversely, because it is CPU heavy, it can also have problems with *high* baud rates. There is a window, between 9600 and 38400 baud, where it seems to work best.&#xD;&#xA;&#xD;&#xA;There is another software serial version called [AltSoftSerial][2]. This works faster than SoftwareSerial and can transmit and receive at the same time.&#xD;&#xA;&#xD;&#xA;You can use the USART, SoftwareSerial and AltSoftSerial all at the same time. Be warned that because all three of these use interrupts and some use timers, you are highly likely to end up with complex, hard to debug interactions.&#xD;&#xA;&#xD;&#xA;Note than in older versions of Arduino (pre v1), SoftwareSerial was very, very poor. It was replaced entirely with &quot;NewSoftSerial&quot;. &#xD;&#xA;&#xD;&#xA;Sensors are often have very basic USART hardware with limited buffer sizes, and drop data when they aren't serviced in a timely manner.&#xD;&#xA;&#xD;&#xA;I am not a massive fan of the Yun. It isn't popular, the wireless is still relatively hard to use (compared to the TI CC3000), and the wireless interface uses valuable pins. Personally, if I was to work on a project that required multiple serial interfaces, I would either&#xD;&#xA;&#xD;&#xA; 1. Use a board with multiple USART, such as a ATmega1280 (2 USARTs) or ATmega2560 (4 USARTs) and a CC3000 (SPI connected) wireless board.&#xD;&#xA; 2. Use SPI/I2C-&gt;USART bridges. This allows a single SPI/I2C port to control multiple USARTs. Sparkfun [sell one][3], there are many others available.&#xD;&#xA;&#xD;&#xA;Be cautious of falling into the trap of using hardware because it is what you have available. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.pjrc.com/teensy/td_libs_NewSoftSerial.html#cpu&#xD;&#xA;  [2]: https://www.pjrc.com/teensy/td_libs_AltSoftSerial.html&#xD;&#xA;  [3]: https://www.sparkfun.com/products/9981" />
  <row Id="720" PostHistoryTypeId="5" PostId="292" RevisionGUID="d7a92b41-68c0-4f4c-b0fb-176d59453601" CreationDate="2014-02-19T08:15:29.850" UserId="201" Comment="Grammar" Text="I am involved in a project that is going to measure PH and chlorine in a swimming pool.  The plan is to use a Arduino Yun. The sensors we are going to use are connected using serial.  Since we may be using multiple sensors, is there any difference in reliability, latency, known issues (bugs) of using software serial versus pin0 and pin1? Is it any way to avoid software serial pitfalls (if there are any)?" />
  <row Id="721" PostHistoryTypeId="2" PostId="303" RevisionGUID="0b5989f5-2c59-40b5-a532-a5f4151d201d" CreationDate="2014-02-19T10:48:33.700" UserId="27" Text="On the Arduino blog, an [article][1] explains the differences between official, clones, derivatives, compatibles and counterfeits.&#xD;&#xA;&#xD;&#xA;  [1]: http://blog.arduino.cc/2013/07/10/send-in-the-clones" />
  <row Id="722" PostHistoryTypeId="2" PostId="304" RevisionGUID="5dc08621-bef2-4a1d-a1b5-889568b1cf89" CreationDate="2014-02-19T14:30:38.310" UserId="42" Text="I bought a SainSmart clone board which is compatible with the Arduino Uno R3. Alongside each of the standard IO pins, there is a row of 3 additional pins (male). They are arranged in columns, marked S, V, and G.&#xD;&#xA;&#xD;&#xA;They can be seen on this image:&#xD;&#xA;&#xD;&#xA;![Photo of SainSmart Uno R3 clone board][1]&#xD;&#xA;&#xD;&#xA;Most of them are immediately above the SainSmart and UNO logos. The SVG pins corresponding to the analog pins can be seen immediately below the microprocessor.&#xD;&#xA;&#xD;&#xA;What are these pins for? Is this a standard format for some applications, or is it something unique to the SainSmart?&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/rwQpm.jpg&#xD;&#xA;" />
  <row Id="723" PostHistoryTypeId="1" PostId="304" RevisionGUID="5dc08621-bef2-4a1d-a1b5-889568b1cf89" CreationDate="2014-02-19T14:30:38.310" UserId="42" Text="What are the SVG pins for on the SainSmart Uno clone?" />
  <row Id="724" PostHistoryTypeId="3" PostId="304" RevisionGUID="5dc08621-bef2-4a1d-a1b5-889568b1cf89" CreationDate="2014-02-19T14:30:38.310" UserId="42" Text="&lt;uno&gt;&lt;gpio&gt;&lt;clones&gt;" />
  <row Id="725" PostHistoryTypeId="2" PostId="305" RevisionGUID="35b6e0d7-611e-46c5-a2c9-5fc2767d52d9" CreationDate="2014-02-19T14:30:38.310" UserId="42" Text="SVG = Signal, Voltage, Ground.&#xD;&#xA;&#xD;&#xA;The Signal pin will carry the actual output, which may be high or low at any given time. It's basically just a male version of the corresponding standard GPIO pin. The Voltage pin will always be high (which can be 5v or 3.3v on this board, depending on the output level switch). The Ground pin is exactly what the name suggests -- it's connected to the board's ground.&#xD;&#xA;&#xD;&#xA;This obviously means there is a lot of duplication. Why have two signal pins? And why bother having so many Voltage and Ground pins if they're all the same anyway?&#xD;&#xA;&#xD;&#xA;The reason is simply convenience.&#xD;&#xA;&#xD;&#xA;If you have a standalone external component (such as a motor), you would normally have to run 3 separate wires to it. With the regularly-spaced SVG pins on the board, you can instead use a 3-way cable with a suitable female header block. You can run that to an equivalent set of 3 pins on the external component. That means you are able to attach/detach the component by plugging/unplugging (effectively) a single cable.&#xD;&#xA;&#xD;&#xA;I don't think the SVG idea is a 'standard' as such, largely because (in this form) it's only really of benefit to people who are experimenting or prototyping (as opposed to designing a more permanent system). It seems to be fairly popular among hobbyists and enthusiasts though. You just need to watch out for components which may put their equivalent SVG pins in a different order." />
  <row Id="727" PostHistoryTypeId="2" PostId="306" RevisionGUID="f7524b7e-a2eb-4375-b2c9-0ba1f06a33b5" CreationDate="2014-02-19T15:31:57.060" UserId="160" Text="Error checking is actually very easy and there is an AVR lib that does this in a one liner.     &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Read up on  'util/crc16.h' and you should be good to go in no time with the included examples.&#xD;&#xA;    &#xD;&#xA;CRC is quite robust and fast for simple applications." />
  <row Id="728" PostHistoryTypeId="5" PostId="303" RevisionGUID="67b345ef-ba51-45ae-bc0e-a3d571016d2f" CreationDate="2014-02-19T20:20:14.867" UserId="27" Comment="edited after Peter's comment" Text="A **clone** is an exact or almost exact replica of an original Arduino board, with a different branding.&#xD;&#xA;&#xD;&#xA;A **derivative** is a board based or inspired by Arduino boards, with some specific addition or modification (different layouts, built-in sensors...)&#xD;&#xA;&#xD;&#xA;A **counterfeit** is a clone of an Arduino board, with the same branding of an Arduino board.&#xD;&#xA;&#xD;&#xA;More info on an [article][1] on the Arduino blog.&#xD;&#xA;&#xD;&#xA;  [1]: http://blog.arduino.cc/2013/07/10/send-in-the-clones" />
  <row Id="729" PostHistoryTypeId="2" PostId="307" RevisionGUID="c456bb1a-8817-4124-8863-fd1cd151477d" CreationDate="2014-02-19T22:11:19.283" UserId="220" Text="I know there are different revisions of the Arduino Uno itself, but are there any revisions of the SMD? If they are is SMD R2 identical to through-hole R2? I have a board marked R2 SMD and I am wondering if that is the only version that they produced in SMD format and just are signifying that it is compatible with the standard R2." />
  <row Id="730" PostHistoryTypeId="1" PostId="307" RevisionGUID="c456bb1a-8817-4124-8863-fd1cd151477d" CreationDate="2014-02-19T22:11:19.283" UserId="220" Text="Are there different revisions of Arduino Uno SMD?" />
  <row Id="731" PostHistoryTypeId="3" PostId="307" RevisionGUID="c456bb1a-8817-4124-8863-fd1cd151477d" CreationDate="2014-02-19T22:11:19.283" UserId="220" Text="&lt;arduino-uno-smd&gt;&lt;revisions&gt;" />
  <row Id="732" PostHistoryTypeId="2" PostId="308" RevisionGUID="d62f3ded-6a31-4a4d-a1b7-ad035839451b" CreationDate="2014-02-19T22:15:45.733" UserId="42" Text="Responding to TV remotes is surprisingly simple, because they typically all work on exactly the same principle, with no concept of channels or encryption.&#xD;&#xA;&#xD;&#xA;What you need is an IR receiver module, which you can buy fairly cheaply from many electronics suppliers. Anything intended to work with remote controls should be suitable. The important part is that it will work with ~38 kHz signals.&#xD;&#xA;&#xD;&#xA;It will typically be a 3 pin component. Many are able to operate at 5 volts, which means you can usually connect the IR module's voltage and ground pins directly to the Arduino's power supply. The data (or signal) pin can typically be connected straight to any GPIO pin. Always check the component's data sheet though. It will often recommend using some additional components (e.g. resistor and capacitor) to smooth out power fluctuations. That shouldn't be necessary for a small project though.&#xD;&#xA;&#xD;&#xA;When an IR signal is detected, the module will usually output a series of pulses on the data pin. These will be digital pulses, so there's no need to use an analog-to-digital converter. What matters is typically either the length of each pulse (Pulse Width Modulation), or the length of the gap between consecutive pulses (Pulse Distance Modulation).&#xD;&#xA;&#xD;&#xA;The timings of the pulses/gaps will be very fast; usually in the region of 400 to 2000 microseconds. That means it's probably too fast to try to detect them using repeated calls to `digitalRead()`. Instead, there is a core Arduino function called [`pulseIn()`][1]. When it's called, it will wait for a pulse to arrive on the specified GPIO pin. It will then return the approximate length of the pulse. You can detect high pulses for PWM, or low pulses for PDM.&#xD;&#xA;&#xD;&#xA;Precise timing values will vary considerably, so you can ignore small variations. The key is to categorise each pulse as short or long, corresponding to a binary 0 or 1. A good starting point is to consider anything below 1000 usec as short, and everything else as long. Check what timings you actually receive though, and adjust that value accordingly.&#xD;&#xA;&#xD;&#xA;Call `pulseIn()` repeatedly, storing each result. Keep going until no more pulses arrive (you will need to give it a timeout after which it gives up waiting, e.g. 10,000 usec or more).&#xD;&#xA;&#xD;&#xA;Your TV remote will output a unique sequence of short/long pulses for each button, typically 32 bits or less (possibly with extra pulses at the beginning/end). All you need to do is figure out which sequence corresponds to each button. You could store that information in a lookup table, and respond accordingly when a sequence is recognised.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/PulseIn" />
  <row Id="733" PostHistoryTypeId="6" PostId="294" RevisionGUID="31c53522-b06b-4fb0-8cf0-1d75375e2a58" CreationDate="2014-02-19T22:18:21.060" UserId="42" Comment="Corrected spelling of tag" Text="&lt;clones&gt;&lt;counterfeit&gt;" />
  <row Id="734" PostHistoryTypeId="2" PostId="309" RevisionGUID="7c7680e7-a481-44a6-9615-42e43100c8bf" CreationDate="2014-02-19T22:32:09.893" UserId="8" Text="The only difference with the SMD Uno is the fact you can't remove the chip. There are also 2 extra analog comparators not connected to anything.&#xD;&#xA;&#xD;&#xA;The SMD boards are compatible with the thru-hole boards, but they have SMD components, which apparently make them easier to make and cheaper. As I said before, the two extra analog inputs (A7 and A6) are left unconnected on the official boards." />
  <row Id="738" PostHistoryTypeId="5" PostId="309" RevisionGUID="1c14c015-9771-4993-95c0-0187275d98e0" CreationDate="2014-02-19T23:18:46.483" UserId="8" Comment="for sachleen's amusement" Text="The only difference with the SMD Uno is the fact you can't remove the chip. There are also 2 extra analog comparators not connected to anything.&#xD;&#xA;&#xD;&#xA;The SMD boards are compatible with the thru-hole boards, but they have SMD components, which apparently make them easier to make and cheaper. As I said before, the two extra analog inputs (A7 and A6) are left unconnected on the official boards.&#xD;&#xA;&#xD;&#xA;Here is my Uno R3:&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/5miJQ.jpg" />
  <row Id="739" PostHistoryTypeId="2" PostId="311" RevisionGUID="d2f4d46b-70db-4736-aba9-a1013e6589be" CreationDate="2014-02-19T23:25:15.357" UserId="-1" Text="" />
  <row Id="740" PostHistoryTypeId="2" PostId="312" RevisionGUID="605a0829-ac6a-492f-bae5-12d42edd9c94" CreationDate="2014-02-19T23:25:15.357" UserId="-1" Text="" />
  <row Id="742" PostHistoryTypeId="2" PostId="314" RevisionGUID="b09af16e-6d47-480c-a008-a95c7a20908c" CreationDate="2014-02-19T23:38:22.120" UserId="-1" Text="" />
  <row Id="743" PostHistoryTypeId="2" PostId="315" RevisionGUID="dac7e33f-1253-4cff-b465-3d3bfa48872b" CreationDate="2014-02-19T23:38:22.120" UserId="-1" Text="" />
  <row Id="746" PostHistoryTypeId="2" PostId="316" RevisionGUID="be7ed267-11aa-4036-8ce9-9bf1282b405c" CreationDate="2014-02-20T00:42:53.183" UserId="42" Text="Currently, my sketch is checking an input pin every time round the main loop. If it detects a change, it calls a custom function to respond to it. Here's the code (trimmed down to the essentials):&#xD;&#xA;&#xD;&#xA;    int pinValue = LOW;&#xD;&#xA;    &#xD;&#xA;    void pinChanged()&#xD;&#xA;    {&#xD;&#xA;        //...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        pinMode(2, INPUT);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        // Read current input&#xD;&#xA;        int newValue = digitalRead(2);&#xD;&#xA;&#xD;&#xA;        // Has the input changed?&#xD;&#xA;        if (newValue != pinValue) {&#xD;&#xA;            pinValue = newValue;&#xD;&#xA;            pinChanged();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Unfortunately, this doesn't always work properly for very short changes on the input (e.g. brief pulses), especially if `loop()` is running a bit slowly.&#xD;&#xA;&#xD;&#xA;Is there a way to make the Arduino detect the input change and call my function automatically?" />
  <row Id="747" PostHistoryTypeId="1" PostId="316" RevisionGUID="be7ed267-11aa-4036-8ce9-9bf1282b405c" CreationDate="2014-02-20T00:42:53.183" UserId="42" Text="Can a function be called automatically when an input changes?" />
  <row Id="748" PostHistoryTypeId="3" PostId="316" RevisionGUID="be7ed267-11aa-4036-8ce9-9bf1282b405c" CreationDate="2014-02-20T00:42:53.183" UserId="42" Text="&lt;gpio&gt;&lt;interrupt&gt;&lt;input&gt;&lt;isr&gt;" />
  <row Id="749" PostHistoryTypeId="2" PostId="317" RevisionGUID="0f37d92f-e60d-4ed9-ac98-0c87e380308e" CreationDate="2014-02-20T00:42:53.183" UserId="42" Text="You can do this using external interrupts. Most Arduinos only support this on a limited number of pins though. For full details, see the documentation on [`attachInterrupt()`][1].&#xD;&#xA;&#xD;&#xA;Assuming you're using an Uno, you could do it like this:&#xD;&#xA;&#xD;&#xA;    void pinChanged()&#xD;&#xA;    {&#xD;&#xA;        //...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        pinMode(2, INPUT);&#xD;&#xA;        attachInterrupt(0, pinChanged, CHANGE);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This will call `pinChanged()` whenever a change is detected on external interrupt 0. On the Uno, that corresponds to GPIO pin 2. The external interrupt numbering is different on other boards, so it's important to check the relevant documentation.&#xD;&#xA;&#xD;&#xA;There are limitations to this approach though. The custom `pinChanged()` function is being used as an Interrupt Service Routine (ISR). That means the rest of the code (everything in `loop()`) is temporarily stopped while the call is executing. In order to prevent disrupting any important timing, you should aim to make ISRs as fast as possible.&#xD;&#xA;&#xD;&#xA;It's also important to note that no other interrupts will run during your ISR. That means anything relying on interrupts (such as the core `delay()` and `millis()` functions) may not work properly inside it.&#xD;&#xA;&#xD;&#xA;Lastly, if your ISR needs to change any global variables in the sketch, they should usually be declared as `volatile`, e.g.:&#xD;&#xA;&#xD;&#xA;    volatile int someNumber;&#xD;&#xA;&#xD;&#xA;That's important because it tells the compiler that the value could change unexpectedly, so it should be careful not to use any out-of-date copies/caches of it.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/AttachInterrupt" />
  <row Id="750" PostHistoryTypeId="5" PostId="314" RevisionGUID="ce168f14-31a9-43e9-8cb4-41ad6fb0e1c5" CreationDate="2014-02-20T00:49:29.687" UserId="35" Comment="added 407 characters in body" Text="Programming is creating programs written with a programming language.&#xD;&#xA;&#xD;&#xA;Use this tag for questions regarding problems with your code specific to Arduino, or for questions about programming with Arduino. For general programming questions, please post them on [Stack Overflow](http://www.stackoverflow.com).&#xD;&#xA;&#xD;&#xA;Also consider using tags such as [tag:library] and [tag:matlab] to specifically tag your problem." />
  <row Id="751" PostHistoryTypeId="24" PostId="314" RevisionGUID="ce168f14-31a9-43e9-8cb4-41ad6fb0e1c5" CreationDate="2014-02-20T00:49:29.687" Comment="Proposed by 35 approved by 8, 11 edit id of 64" />
  <row Id="752" PostHistoryTypeId="5" PostId="311" RevisionGUID="2da502ed-f9e2-468e-8889-ebe4a7ef4111" CreationDate="2014-02-20T00:49:39.970" UserId="35" Comment="added 357 characters in body" Text="MATLAB is a programming language used primarily for numerical computations. It can also be used to connect to other programming languages, plot data, or implement algorithms.&#xD;&#xA;&#xD;&#xA;Use this tag for questions regarding communicating or using MATLAB with Arduino. &#xD;&#xA;&#xD;&#xA;Also consider using other programming related tags such as [tag:programming] or [tag:library]." />
  <row Id="753" PostHistoryTypeId="24" PostId="311" RevisionGUID="2da502ed-f9e2-468e-8889-ebe4a7ef4111" CreationDate="2014-02-20T00:49:39.970" Comment="Proposed by 35 approved by 8, 11 edit id of 62" />
  <row Id="754" PostHistoryTypeId="5" PostId="315" RevisionGUID="37e49eed-7e49-4cc6-9418-4bcb3a38ca74" CreationDate="2014-02-20T00:49:46.940" UserId="35" Comment="added 212 characters in body" Text="Use this tag for questions regarding problems with your code specific to Arduino, or for questions about programming with Arduino. Also consider using tags such as [library] and [matlab] specific to your problem." />
  <row Id="755" PostHistoryTypeId="24" PostId="315" RevisionGUID="37e49eed-7e49-4cc6-9418-4bcb3a38ca74" CreationDate="2014-02-20T00:49:46.940" Comment="Proposed by 35 approved by 8, 11 edit id of 65" />
  <row Id="756" PostHistoryTypeId="5" PostId="312" RevisionGUID="7fa73045-187f-44d0-b16a-4e927e0637eb" CreationDate="2014-02-20T00:49:57.393" UserId="35" Comment="added 210 characters in body" Text="MATLAB is a programming language used primarily for numerical computations. Use this tag for questions regarding communicating or using MATLAB with Arduino. Also consider using other tags such as [programming]." />
  <row Id="757" PostHistoryTypeId="24" PostId="312" RevisionGUID="7fa73045-187f-44d0-b16a-4e927e0637eb" CreationDate="2014-02-20T00:49:57.393" Comment="Proposed by 35 approved by 8, 11 edit id of 63" />
  <row Id="758" PostHistoryTypeId="5" PostId="299" RevisionGUID="4780ca36-a2cf-4310-868c-1921ba4a4224" CreationDate="2014-02-20T01:05:31.720" UserId="86" Comment="added 261 characters in body" Text="There are several factors here:&#xD;&#xA;&#xD;&#xA; - How high of a baud-rate can the ATmega328P MCU achieve?&#xD;&#xA; - How high of a baud-rate can the USB-Serial interface achieve?&#xD;&#xA; - What is the oscillator frequency on the ATmega328P?&#xD;&#xA; - What is the oscillator frequency on the USB-serial interface (if it has one)?&#xD;&#xA; - How tolerant is the USB-serial interface of baud-rate mismatch?&#xD;&#xA;&#xD;&#xA;All of these factors are relevant to determining the maximum achieveable baud rate. The ATmega328P uses a hardware divisor from it's clock-rate to generate the base-clock for the serial interface. If there is no integer ratio from the main clock to the bit-time of the desired baud rate, the MCU will not be able to *exactly* produce the desired rate. This can lead to potential issues, as some devices are much more sensitive to baud-rate mismatch then others.&#xD;&#xA;&#xD;&#xA;FTDI-based interfaces are quite tolerant of baud-rate mismatch, up to several percent error. However, I have worked with specialized embedded GPS modules that were unable to handle even a 0.5% baud rate error.&#xD;&#xA;&#xD;&#xA;General serial interfaces are tolerant of ~5% baud-rate error. However, since each end can be off, a more common spec is +-2.5%. This way, if one end is 2.5% fast, and the other is 2.5% slow, your *overall* error is still only 5%.&#xD;&#xA;&#xD;&#xA;--- &#xD;&#xA;&#xD;&#xA;Anyways. The Uno uses a ATmega328P as the primary MCU, and a ATmega16U2 as the USB-serial interface. We're also fortunate here in that both these MCUs use similar harware USARTs, as well as 16 Mhz clocks. &#xD;&#xA;&#xD;&#xA;Since both MCUs have the same harware and clock-rate, they'll both have the same baud-rate error in the same direction, so we can functionally ignore the baud error issue.&#xD;&#xA;&#xD;&#xA;Anyways, the &quot;proper&quot; answer to this question would involve digging up the source for the ATmega16U2, and working out the possible baud-rates from there, but since I'm lazy, I figure simple, empirical testing will work.&#xD;&#xA;&#xD;&#xA;A quick glance at the ATmega328P datasheet produces the following table:  &#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;So given the max stated baud-rate of 2 Mbps, I wrote a quick test program:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup(){};&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(57600);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 57600&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(76800);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 76800&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(115200);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 115200&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(230400);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 230400&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(250000);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 250000&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(500000);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 500000&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(1000000);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 1000000&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.begin(2000000);&#xD;&#xA;      Serial.println(&quot;\r\rBaud-rate = 2000000&quot;);&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;And then looking at the relevant serial port with a serial terminal:  &#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;So it appears the hardware can run at 2,000,000 baud without problems.&#xD;&#xA;&#xD;&#xA;Note that this baud rate only gives the MCU 64 clock-cycles per byte, so it would be very challenging to keep the serial interface busy. While the individual bytes may be transferred very rapidly, there is likely to be lots of time when the interface is simply idle.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Edit: Actual Testing!&#xD;&#xA;&#xD;&#xA;The 2 Mbps is real:  &#xD;&#xA;![enter image description here][3]  &#xD;&#xA;each bit-time is 500 ns, which matches exactly with what is expected.&#xD;&#xA;&#xD;&#xA;Performance issues! Overall packet length:    &#xD;&#xA;500 Kbaud:&#xD;&#xA;![enter image description here][4]&#xD;&#xA;&#xD;&#xA;1 Mbaud:&#xD;&#xA;![enter image description here][5]&#xD;&#xA;&#xD;&#xA;2 Mbaud:&#xD;&#xA;![enter image description here][6]  &#xD;&#xA;&lt;sub&gt;Note: The noticeable overshoot is due to poor scope probe grounding practices, and is *probably* not real. I'm using the ground-clip-lead that's part of my scope probe, and the lead-inductance is likely the cause of the majority of the overshoot.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;As you can see, the overall transmission length is the same for 0.5, 1 and 2 Mbaud. This is because the code that is placing the bytes in the serial buffer is poorly optimized. As such, you will never achieve anything better then an *effective* 500 Kbaud, unless you write your own serial libraries. The Arduino libraries are very poorly optimized, so it probably wouldn't be *too* hard to get a proper 2 Mbaud, at least for burst transmissions, if you spent a bit of time on it.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/P8kN2.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/US17S.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/APzfe.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/rlBti.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/9ACpH.jpg&#xD;&#xA;  [6]: http://i.stack.imgur.com/vUDoN.jpg" />
  <row Id="760" PostHistoryTypeId="2" PostId="318" RevisionGUID="e4f03894-3bba-4b5c-a21e-0e3df61b1aff" CreationDate="2014-02-20T11:03:18.267" UserId="42" Text="I've been using the `pulseIn()` function for processing PWM-based binary data encoding. It works well for distinguishing pulses which are significantly different lengths, e.g. 500us vs. 1500us. That makes it more than sufficient for handling typical IR remotes.&#xD;&#xA;&#xD;&#xA;However, I want to make my own IR system which can use more than 2 pulse lengths, so that data transfer can occur faster. Ideally, I'd like to use 8 different pulse lengths for octal encoding (e.g. 200us, 400us, 600us, etc.).&#xD;&#xA;&#xD;&#xA;I've noticed quite significant variations in the values returned by `pulseIn()` though (+/- 10%). I expect at least some of it is introduced by the IR transmitter and receiver modules, but I don't have good enough equipment to verify that.&#xD;&#xA;&#xD;&#xA;Assuming I can mitigate that external error, is `pulseIn()` likely to be precise enough to distinguish such similar pulses?" />
  <row Id="761" PostHistoryTypeId="1" PostId="318" RevisionGUID="e4f03894-3bba-4b5c-a21e-0e3df61b1aff" CreationDate="2014-02-20T11:03:18.267" UserId="42" Text="How precise is the timing of pulseIn()?" />
  <row Id="762" PostHistoryTypeId="3" PostId="318" RevisionGUID="e4f03894-3bba-4b5c-a21e-0e3df61b1aff" CreationDate="2014-02-20T11:03:18.267" UserId="42" Text="&lt;pwm&gt;&lt;pulsein&gt;&lt;timing&gt;" />
  <row Id="763" PostHistoryTypeId="2" PostId="319" RevisionGUID="24f405ca-3cf2-40b6-b235-7d0716b851cd" CreationDate="2014-02-20T11:37:03.207" UserId="42" Text="When using C/C++ on other platforms, the `int` type is typically 4 bytes (or potentially more). However, on Arduino, it's only 2 bytes.&#xD;&#xA;&#xD;&#xA;Why is it different? Does it affect performance if I always use the 4 byte `long` instead?" />
  <row Id="764" PostHistoryTypeId="1" PostId="319" RevisionGUID="24f405ca-3cf2-40b6-b235-7d0716b851cd" CreationDate="2014-02-20T11:37:03.207" UserId="42" Text="Why is int only 2 bytes?" />
  <row Id="765" PostHistoryTypeId="3" PostId="319" RevisionGUID="24f405ca-3cf2-40b6-b235-7d0716b851cd" CreationDate="2014-02-20T11:37:03.207" UserId="42" Text="&lt;programming&gt;&lt;c++&gt;&lt;data-type&gt;&lt;performance&gt;" />
  <row Id="768" PostHistoryTypeId="2" PostId="321" RevisionGUID="db1e8f2a-3ece-4fc2-9b7d-cdcf077e55ec" CreationDate="2014-02-20T13:55:44.603" UserId="136" Text="The ATmega328 used in a lot of Arduinos is a 8-bit microcontroller. This means that registers are 8-bits, the data bus is 8-bits, the ports are 8-bits. There are some minimal 16-bit aspects to the system (e.g. one of the timers), but nearly everything is 8-bits.&#xD;&#xA;&#xD;&#xA;Therefore, most operations handle 8-bits at a time. Working on anything except 8-bits (i.e. 16-bit or 32-bit integers and floating point numbers) requires what could essentially be described as software emulation, where the compiler uses multiple instructions to work on these larger variables.&#xD;&#xA;&#xD;&#xA;8-bits is obviously adequate to address a 8-bit port. It's also enough to deal with many loop counters, return values, and ASCII characters. It isn't really enough though when dealing with numbers. A signed 8-bit int (int8_t) can only represent -128 -&gt; +127. Unsigned (uint8_t) can only represent 0 -&gt; 255.&#xD;&#xA;&#xD;&#xA;This is quite limiting, and I suspect that the Arduino team decided to map int to int16_t which gives a range of -32,678 -&gt; +32,767, as this is far more versatile and less likely to cause problems with overflow. This is especially important when beginners are learning.&#xD;&#xA;&#xD;&#xA;There is a performance impact of doing this however, because most 16-bit operations take at least twice as long as an 8-bit operation, and use twice as many registers. This may or may not make a difference to you.&#xD;&#xA;&#xD;&#xA;Many of us switch to the native types such as int8_t and uint8_t as it gives you far more control.&#xD;&#xA;" />
  <row Id="769" PostHistoryTypeId="2" PostId="322" RevisionGUID="1370e744-21a5-4e4e-b301-e7e0db0f9986" CreationDate="2014-02-20T14:06:18.787" UserId="136" Text="I have a simple library which uses another library. &#xD;&#xA;&#xD;&#xA;Here is the header:&#xD;&#xA;&#xD;&#xA;    #ifndef __DERIVEDCLASS_H__&#xD;&#xA;    #define __DERIVEDCLASS_H__&#xD;&#xA;    &#xD;&#xA;    #include &lt;HardwareSerial.h&gt;&#xD;&#xA;    &#xD;&#xA;    class DerivedClass&#xD;&#xA;    {&#xD;&#xA;    private:&#xD;&#xA;    	HardwareSerial* serial;&#xD;&#xA;    &#xD;&#xA;    public:&#xD;&#xA;    	DerivedClass();&#xD;&#xA;    };&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;And the CPP:&#xD;&#xA;&#xD;&#xA;    #include &quot;DerivedClass.h&quot;&#xD;&#xA;    &#xD;&#xA;    DerivedClass::DerivedClass()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;And the sketch:&#xD;&#xA;&#xD;&#xA;    #include &lt;DerivedClass.h&gt;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This works fine.&#xD;&#xA;&#xD;&#xA;However, if I change the library header to this:&#xD;&#xA;&#xD;&#xA;    #ifndef __DERIVEDCLASS_H__&#xD;&#xA;    #define __DERIVEDCLASS_H__&#xD;&#xA;    &#xD;&#xA;    #include &lt;SoftwareSerial.h&gt;&#xD;&#xA;    &#xD;&#xA;    class DerivedClass&#xD;&#xA;    {&#xD;&#xA;    private:&#xD;&#xA;    	SoftwareSerial* serial;&#xD;&#xA;    &#xD;&#xA;    public:&#xD;&#xA;    	DerivedClass();&#xD;&#xA;    };&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;The sketch fails to compile:&#xD;&#xA;&#xD;&#xA;&gt; /Users/andrew/Documents/Arduino/libraries/DerivedClass/DerivedClass.h:9:&#xD;&#xA;&gt; error: ISO C++ forbids declaration of 'SoftwareSerial' with no type&#xD;&#xA;&gt; /Users/andrew/Documents/Arduino/libraries/DerivedClass/DerivedClass.h:9:&#xD;&#xA;&gt; error: expected ';' before '*' token&#xD;&#xA;&#xD;&#xA;Why is this? HardwareSerial is a built-in part of the Arduino, located in *hardware/arduino/cores/arduino* and SoftwareSerial is in *libraries*, but why would the build process differentiate between the two.&#xD;&#xA;" />
  <row Id="770" PostHistoryTypeId="1" PostId="322" RevisionGUID="1370e744-21a5-4e4e-b301-e7e0db0f9986" CreationDate="2014-02-20T14:06:18.787" UserId="136" Text="Why do I need to include libraries used in other libraries?" />
  <row Id="771" PostHistoryTypeId="3" PostId="322" RevisionGUID="1370e744-21a5-4e4e-b301-e7e0db0f9986" CreationDate="2014-02-20T14:06:18.787" UserId="136" Text="&lt;library&gt;&lt;c++&gt;&lt;build&gt;" />
  <row Id="772" PostHistoryTypeId="2" PostId="323" RevisionGUID="061e7fe3-fa5e-416e-aaa3-a062b470a263" CreationDate="2014-02-20T14:15:29.497" UserId="136" Text="A commonly used library is the [DallasTemperature][1] library, used to access DS18B20 sensors on a 1-Wire bus. When creating a DallasTemperature object you pass a reference to a [OneWire][2] object. OneWire can create a 1-Wire bus on pretty much any port of an Arduino.&#xD;&#xA;&#xD;&#xA;An example of this is like so:&#xD;&#xA;&#xD;&#xA;    // Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)&#xD;&#xA;    OneWire oneWire(ONE_WIRE_BUS);&#xD;&#xA;    &#xD;&#xA;    // Pass our oneWire reference to Dallas Temperature.&#xD;&#xA;    DallasTemperature sensors(&amp;oneWire);&#xD;&#xA;&#xD;&#xA;However, there are some issues with using OneWire like this, mainly around driving longer bus lengths, dealing with shorts, and other errors. &#xD;&#xA;&#xD;&#xA;There is a commonly available chip called the DS2482-100 that can drive longer busses (hundreds of feet), deals with shorts and other errors. It is also less CPU heavy and it deals with a number of the slower aspects of 1-Wire.&#xD;&#xA;&#xD;&#xA;For this reason, I would like to be able to pass a reference to a library that I have created instead. Currently, I am doing this by:&#xD;&#xA;&#xD;&#xA; - Calling the library OneWire&#xD;&#xA; - Replicating all the methods called by the DallasTemperature library&#xD;&#xA; - Swapping out the OneWire library for mine&#xD;&#xA;&#xD;&#xA;This is relatively messy. I would ideally like to be able to pass either a reference to my library or a 1-Wire library, so that people can chose which interface to use.&#xD;&#xA;&#xD;&#xA;How would I go about doing this?&#xD;&#xA;&#xD;&#xA;  [1]: http://milesburton.com/Dallas_Temperature_Control_Library&#xD;&#xA;  [2]: http://www.pjrc.com/teensy/td_libs_OneWire.html" />
  <row Id="773" PostHistoryTypeId="1" PostId="323" RevisionGUID="061e7fe3-fa5e-416e-aaa3-a062b470a263" CreationDate="2014-02-20T14:15:29.497" UserId="136" Text="How can I adapt the DallasTemperature library to accept another 1-Wire class?" />
  <row Id="774" PostHistoryTypeId="3" PostId="323" RevisionGUID="061e7fe3-fa5e-416e-aaa3-a062b470a263" CreationDate="2014-02-20T14:15:29.497" UserId="136" Text="&lt;library&gt;&lt;build&gt;" />
  <row Id="775" PostHistoryTypeId="2" PostId="324" RevisionGUID="81671373-3bfd-4a0e-b9b0-e2133cc2fa5d" CreationDate="2014-02-20T14:22:35.903" UserId="8" Text="Here is some test data of a `pulseIn` test. One Arduino sent what were supposed to be 14us pulses, and the other spat out this data:&#xD;&#xA;&#xD;&#xA;&gt; 18,18,18,12,18,18,18,18,18,18,18,18,18,18,18,18,18,24,19,18,18,18,18,18,24,18,18,18,19,18,18,12,18,18,19,18,18,18,18,18,18,18,18,18,18,18,19,18,19,24,18,18,18,18,18,18,18,24,18,18,18,18,18,18,18,18,18,18,18,18,18,19,18,18,18,18,18,18,18,18,18,18,19,18,18,18,11,18&#xD;&#xA;&#xD;&#xA;As you can see, the pulses are by no means accurate. The time would be more accurate if the sending and recieving ends were written in assembly, or even offloaded to their own processors." />
  <row Id="777" PostHistoryTypeId="2" PostId="326" RevisionGUID="f36d22a8-fc48-4983-bbe7-9bb69daf10c7" CreationDate="2014-02-20T14:30:16.777" UserId="136" Text="I have been using the [Jeelib Sleepy][1] functionality for several years now to achieve low power states on the Arduino ATmega328/1280/2560 boards, specifically the LoseSomeTime functionality.&#xD;&#xA;&#xD;&#xA;I want to get my Teensy 2 to go into a similar low power state, so I tried a very simple sketch that simply put the device to sleep, flashed an LED, and posted some Serial messages. I did need to comment out a few lines in Jeelib:&#xD;&#xA;&#xD;&#xA;    // adjust the milli ticks, since we will have missed several&#xD;&#xA;    #if defined(__AVR_ATtiny84__) || defined(__AVR_ATtiny85__) || defined (__AVR_ATtiny44__) || defined (__AVR_ATtiny45__)&#xD;&#xA;        extern volatile unsigned long millis_timer_millis;&#xD;&#xA;        millis_timer_millis += msecs - msleft;&#xD;&#xA;    #else&#xD;&#xA;        extern volatile unsigned long timer0_millis;&#xD;&#xA;        timer0_millis += msecs - msleft;&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;This had to be done as the delay() and millis() functions on the Teensy use different variable names for the adjustment, and it was the quickest way of solving the problem. LoseSomeTime works on the ATmega328 hardware with this change.&#xD;&#xA;&#xD;&#xA;I found that although the LoseSomeTime function did sleep for a period, the Serial functionality stopped working entirely - no messages were being printed at all. I have encountered this before on ATmega328 hardware because the microcontroller has gone to sleep before the serial buffer was flushed. I added a number of delay()s after the Serial.writes and also tried using Serial.flush() to make sure the buffer was empty.&#xD;&#xA;&#xD;&#xA;LoseSomeTime requires setting an interrupt on the watchdog timer, but I can't see how this would impact Serial operation.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://jeelabs.net/pub/docs/jeelib/classSleepy.html" />
  <row Id="778" PostHistoryTypeId="1" PostId="326" RevisionGUID="f36d22a8-fc48-4983-bbe7-9bb69daf10c7" CreationDate="2014-02-20T14:30:16.777" UserId="136" Text="Why can't I use Jeelib Sleepy on the Teensy 2 along with Serial" />
  <row Id="779" PostHistoryTypeId="3" PostId="326" RevisionGUID="f36d22a8-fc48-4983-bbe7-9bb69daf10c7" CreationDate="2014-02-20T14:30:16.777" UserId="136" Text="&lt;serial&gt;&lt;library&gt;&lt;power&gt;" />
  <row Id="780" PostHistoryTypeId="5" PostId="322" RevisionGUID="aef29911-77b2-4339-aed9-baf6493ea13d" CreationDate="2014-02-20T14:33:24.790" UserId="136" Comment="added 352 characters in body" Text="I have a simple library which uses another library. &#xD;&#xA;&#xD;&#xA;Here is the header:&#xD;&#xA;&#xD;&#xA;    #ifndef __DERIVEDCLASS_H__&#xD;&#xA;    #define __DERIVEDCLASS_H__&#xD;&#xA;    &#xD;&#xA;    #include &lt;HardwareSerial.h&gt;&#xD;&#xA;    &#xD;&#xA;    class DerivedClass&#xD;&#xA;    {&#xD;&#xA;    private:&#xD;&#xA;    	HardwareSerial* serial;&#xD;&#xA;    &#xD;&#xA;    public:&#xD;&#xA;    	DerivedClass();&#xD;&#xA;    };&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;And the CPP:&#xD;&#xA;&#xD;&#xA;    #include &quot;DerivedClass.h&quot;&#xD;&#xA;    &#xD;&#xA;    DerivedClass::DerivedClass()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;And the sketch:&#xD;&#xA;&#xD;&#xA;    #include &lt;DerivedClass.h&gt;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This works fine.&#xD;&#xA;&#xD;&#xA;However, if I change the library header to this:&#xD;&#xA;&#xD;&#xA;    #ifndef __DERIVEDCLASS_H__&#xD;&#xA;    #define __DERIVEDCLASS_H__&#xD;&#xA;    &#xD;&#xA;    #include &lt;SoftwareSerial.h&gt;&#xD;&#xA;    &#xD;&#xA;    class DerivedClass&#xD;&#xA;    {&#xD;&#xA;    private:&#xD;&#xA;    	SoftwareSerial* serial;&#xD;&#xA;    &#xD;&#xA;    public:&#xD;&#xA;    	DerivedClass();&#xD;&#xA;    };&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;The sketch fails to compile:&#xD;&#xA;&#xD;&#xA;&gt; /Users/andrew/Documents/Arduino/libraries/DerivedClass/DerivedClass.h:9:&#xD;&#xA;&gt; error: ISO C++ forbids declaration of 'SoftwareSerial' with no type&#xD;&#xA;&gt; /Users/andrew/Documents/Arduino/libraries/DerivedClass/DerivedClass.h:9:&#xD;&#xA;&gt; error: expected ';' before '*' token&#xD;&#xA;&#xD;&#xA;If I change the sketch to:&#xD;&#xA;&#xD;&#xA;    #include &lt;DerivedClass.h&gt;&#xD;&#xA;    #include &lt;SoftwareSerial.h&gt;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;i.e. including the SoftwareSerial library in the top level sketch, it compiles fine.&#xD;&#xA;&#xD;&#xA;If I expand the library out so it actually performs actions, then if it compiles, it works.&#xD;&#xA;&#xD;&#xA;Why is this? HardwareSerial is a built-in part of the Arduino, located in *hardware/arduino/cores/arduino* and SoftwareSerial is in *libraries*, but why would the build process differentiate between the two." />
  <row Id="782" PostHistoryTypeId="5" PostId="321" RevisionGUID="fb0d5e00-6068-45a7-ac48-ae99b2c47027" CreationDate="2014-02-20T15:34:20.750" UserId="136" Comment="Change answer in response to comment." Text="The ATmega328 used in a lot of Arduinos is a 8-bit microcontroller. This means that registers are 8-bits, the data bus is 8-bits, the ports are 8-bits. There are some minimal 16-bit aspects to the system (e.g. one of the timers), but nearly everything is 8-bits.&#xD;&#xA;&#xD;&#xA;Therefore, most operations handle 8-bits at a time. Working on anything except 8-bits (i.e. 16-bit or 32-bit integers and floating point numbers) requires what could essentially be described as software emulation, where the compiler uses multiple instructions to work on these larger variables.&#xD;&#xA;&#xD;&#xA;8-bits is obviously adequate to address a 8-bit port. It's also enough to deal with many loop counters, return values, and ASCII characters. It isn't really enough though when dealing with numbers. A signed 8-bit int (int8_t) can only represent -128 -&gt; +127. Unsigned (uint8_t) can only represent 0 -&gt; 255.&#xD;&#xA;&#xD;&#xA;8-bit integers are quite limiting. C/C++ int must represent at least -32,678 -&gt; +32,767 so maps to int16_t - the smallest size that will do so. This gives a good balance of range and efficiency. This is especially important when beginners are learning - overflow is not really something that non-programmers understand.&#xD;&#xA;&#xD;&#xA;There is a performance impact of doing this however, because most 16-bit operations take at least twice as long as an 8-bit operation, and use twice as many registers. This may or may not make a difference to you.&#xD;&#xA;&#xD;&#xA;Many of us switch to the native types such as int8_t and uint8_t as it gives you far more control." />
  <row Id="783" PostHistoryTypeId="2" PostId="327" RevisionGUID="b6891177-1ec5-472a-9939-de9f2265b22f" CreationDate="2014-02-20T18:36:59.780" UserId="84" Text="One important fact about C and C++ languages is that their respective standards do not define the size (in bytes) of integral and floating point number types.&#xD;&#xA;&#xD;&#xA;They just define minimal ranges and relation between these ranges, e.g.&#xD;&#xA;&#xD;&#xA;range(short) c range(int) c range(long)&#xD;&#xA;&#xD;&#xA;NB: I have used **c** above as the mathematical operator &quot;*is a subset of*&quot;.&#xD;&#xA;&#xD;&#xA;So the size of e.g. an `int` will typically depend on:&#xD;&#xA;&#xD;&#xA;- the target platform (processor)&#xD;&#xA;- the compiler itself&#xD;&#xA;" />
  <row Id="784" PostHistoryTypeId="2" PostId="328" RevisionGUID="f4e034e5-6e26-469e-af48-cb11dcba2017" CreationDate="2014-02-20T18:41:12.700" UserId="84" Text="If I remember correctly this is in fact a limitation of the **Arduino IDE**.&#xD;&#xA;&#xD;&#xA;If you use a better IDE (personally I use Eclipse with the Arduino plugin) it works as it should, i.e. if you include a library A that includes another library B, then in the end you won't get compile-time errors and both B and A will be included in the final binary." />
  <row Id="785" PostHistoryTypeId="5" PostId="323" RevisionGUID="1b4870fc-58c6-4a26-8fcc-145bdcb29dd9" CreationDate="2014-02-20T19:18:39.017" UserId="136" Comment="added 12 characters in body" Text="A commonly used library is the [DallasTemperature][1] library, used to access DS18B20 sensors on a 1-Wire bus. When creating a DallasTemperature object you pass a reference to a [OneWire][2] object. OneWire can create a 1-Wire bus on pretty much any port of an Arduino.&#xD;&#xA;&#xD;&#xA;An example of this is like so:&#xD;&#xA;&#xD;&#xA;    // Setup a oneWire instance to communicate with any OneWire devices (not just Maxim/Dallas temperature ICs)&#xD;&#xA;    OneWire oneWire(ONE_WIRE_BUS);&#xD;&#xA;    &#xD;&#xA;    // Pass our oneWire reference to Dallas Temperature.&#xD;&#xA;    DallasTemperature sensors(&amp;oneWire);&#xD;&#xA;&#xD;&#xA;However, there are some issues with using OneWire to drive a 1-Wire bus, mainly around driving longer bus lengths, dealing with shorts, and other errors. &#xD;&#xA;&#xD;&#xA;There is a commonly available chip called the DS2482-100 that can drive longer busses (hundreds of feet), deals with shorts and other errors. It is also less CPU heavy and it deals with a number of the slower aspects of 1-Wire.&#xD;&#xA;&#xD;&#xA;For this reason, I would like to be able to pass a reference to a library that I have created instead. Currently, I am doing this by:&#xD;&#xA;&#xD;&#xA; - Calling the library OneWire&#xD;&#xA; - Replicating all the methods called by the DallasTemperature library&#xD;&#xA; - Swapping out the OneWire library for mine&#xD;&#xA;&#xD;&#xA;This is relatively messy. I would ideally like to be able to pass either a reference to my library or a 1-Wire library, so that people can chose which interface to use.&#xD;&#xA;&#xD;&#xA;How would I go about doing this?&#xD;&#xA;&#xD;&#xA;  [1]: http://milesburton.com/Dallas_Temperature_Control_Library&#xD;&#xA;  [2]: http://www.pjrc.com/teensy/td_libs_OneWire.html" />
  <row Id="786" PostHistoryTypeId="2" PostId="329" RevisionGUID="58b8e905-3a3b-42ec-a550-c6080fed6b49" CreationDate="2014-02-20T20:51:31.323" UserId="84" Text="The typical way to achieve what you want would normally be to create your own **subclass** of `OneWire` class and **override** the methods you need to change, then pass a pointer to an instance of your class to the `DallasTemperature` constructor.&#xD;&#xA;&#xD;&#xA;However, for this to work, the `OneWire` class must have been developed with extensibility (subclassing) in mind, i.e. use **virtual** methods that you can override.&#xD;&#xA;&#xD;&#xA;Unfortunately, a quick look at `OneWire.h` shows that no method is virtual in there.&#xD;&#xA;&#xD;&#xA;So that means in the end you will have to perform some hacks, just as you do now.&#xD;&#xA;&#xD;&#xA;What you could potentially do (that's still a hack, but maybe a bit less dirty) is:&#xD;&#xA;&#xD;&#xA;- replace `OneWire.h` to make all methods virtual (at least those you need to override)&#xD;&#xA;- keep the original `OneWire.cpp` that should still compile with the newly adapted header file&#xD;&#xA;- create a new `MyOneWire.h` / `MyOneWire.cpp` to define your own `OneWire` subclass that overrides all necessary methods as you want&#xD;&#xA;&#xD;&#xA;Then you can pass either a `OneWire` or a `MyOneWire` instance to `DallasTemperature` constructor.&#xD;&#xA;&#xD;&#xA;NB: when I see my answer, this makes me think your question is more a general C++ question than an Arduino-related one." />
  <row Id="789" PostHistoryTypeId="2" PostId="330" RevisionGUID="563ca751-c711-4c4a-8526-328634c815cc" CreationDate="2014-02-21T03:38:54.990" UserId="60" Text="The pulsein() function is very lossy, in that it is a hard loop and returns a number * the assumed clock cycles it takes for per loop&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    ...&#xD;&#xA;    // wait for the pulse to stop&#xD;&#xA;    while ((*portInputRegister(port) &amp; bit) == stateMask) {&#xD;&#xA;      if (numloops++ == maxloops)&#xD;&#xA;        return 0;&#xD;&#xA;      width++;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // convert the reading to microseconds. The loop has been determined&#xD;&#xA;    // to be 20 clock cycles long and have about 16 clocks between the edge&#xD;&#xA;    // and the start of the loop. There will be some error introduced by&#xD;&#xA;    // the interrupt handlers.&#xD;&#xA;    return clockCyclesToMicroseconds(width * 21 + 16); &#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;The most accurate method for capturing the timing of a PIN is use the INPUT CAPTURE FEATURE. Look at the [this example ](https://gist.github.com/mpflaga/4404996). It enables the input capture at 1x of CPU for max resolution and each edge of the input pin captures the timer's clock value for reading from the generated Interrupt service. It also enables the timer overflow interrupt to as to maintain large absolute time, to be capture. Since the 1x will roll rather quickly. The captures store the time into an array for reading by the main loop.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Where for signals over IR the typical library to use is [shirriff/Arduino-IRremote](https://github.com/shirriff/Arduino-IRremote) library. Where it has several demo's that will read and send the IR from a demodulated signal. To allow one to build a sketch of their own design. This code originally creates a timer interrupt that polls the input pin at a rate determine by &#xD;&#xA;&#xD;&#xA;    #define USECPERTICK 50  // microseconds per clock interrupt tick&#xD;&#xA;&#xD;&#xA;in the IRremote.h file. For my purposes I have change it to 25 us. Where I find this still can be intermittently missing pulse streams. &#xD;&#xA;&#xD;&#xA;Note the demodulation is best accomplished within the IR receiver, which in turn outputs this signal of interest. Where to add some background. Using the typical 38KHz modulation, equates to a minimum resolution of 26.3uS per pulse's cycle. sherriff's library shows typically most bauds or bits are in the order of 10+ pulses. Which appear to meet your desired timings.&#xD;&#xA;&#xD;&#xA;[microtherion/Arduino-IRremote](https://github.com/microtherion/Arduino-IRremote) fork of shirriff's work improves the reception by replacing the timer interrupt polling of the pin with the use of PinChangeInterrupts. Which I have merged into my own [mpflaga/Arduino-IRremote](https://github.com/mpflaga/Arduino-IRremote) fork, that adds several other features.&#xD;&#xA;&#xD;&#xA;So you could use any of the above libraries. Or create your own app that uses either of the below to capture edges.&#xD;&#xA;&#xD;&#xA; 1. polls on a Timer event (e.g. 50uS)&#xD;&#xA; 2. captures the micros() on a PinChangeInterrupt&#xD;&#xA; 3. uses Input Capture Interrupts to grab the exact time " />
  <row Id="791" PostHistoryTypeId="2" PostId="331" RevisionGUID="7555f60e-fec5-4681-900e-fc46a72b00ab" CreationDate="2014-02-21T10:14:47.667" UserId="42" Text="I'm trying to use an unusual 16x2 LCD display with my Uno. As far as I know, it's an EA-X16027AR. It doesn't seem to be compatible with the HD44780 driver, which is typically used for Arduino LCD's.&#xD;&#xA;&#xD;&#xA;According to the datasheet, the display's ENB (Enable) pin requires a clock input, described as follows:&#xD;&#xA;&#xD;&#xA;&gt; Basical Clock to perform Instructions in Controller LSI. The Clock at the same timing as MPU are usually input.&#xD;&#xA;&#xD;&#xA;The timing graphs elsewhere in the datasheet show it wants a speed of around 2 MHz.&#xD;&#xA;&#xD;&#xA;Is it possible to get the internal clock signal from the Uno, scale it down to 2 MHz, and output it to a GPIO pin or similar? Alternatively, is it possible to emulate a clock signal at that speed on-board, without adding additional timing components?" />
  <row Id="792" PostHistoryTypeId="1" PostId="331" RevisionGUID="7555f60e-fec5-4681-900e-fc46a72b00ab" CreationDate="2014-02-21T10:14:47.667" UserId="42" Text="Can I link another device to the Uno's clock?" />
  <row Id="793" PostHistoryTypeId="3" PostId="331" RevisionGUID="7555f60e-fec5-4681-900e-fc46a72b00ab" CreationDate="2014-02-21T10:14:47.667" UserId="42" Text="&lt;uno&gt;&lt;lcd&gt;&lt;clock&gt;" />
  <row Id="794" PostHistoryTypeId="2" PostId="332" RevisionGUID="57f7d24d-883e-4dc7-8b3e-96a8614acfa5" CreationDate="2014-02-21T12:21:09.433" UserId="42" Text="I'm planning to build a simple XY plotter, and have been looking at the possibility of using a pair of small 5V 4-phase steppers to provide the movement. In my research, I've often seen stepper driver boards advertised, ranging from very big and expensive, through to quite small and cheap. Some of them actually look like little more than a darlington array on a PCB.&#xD;&#xA;&#xD;&#xA;Do I really need one of those external driver boards, or can I control the steppers directly from my Arduino?" />
  <row Id="795" PostHistoryTypeId="1" PostId="332" RevisionGUID="57f7d24d-883e-4dc7-8b3e-96a8614acfa5" CreationDate="2014-02-21T12:21:09.433" UserId="42" Text="Can a stepper motor be controlled directly from an Arduino?" />
  <row Id="796" PostHistoryTypeId="3" PostId="332" RevisionGUID="57f7d24d-883e-4dc7-8b3e-96a8614acfa5" CreationDate="2014-02-21T12:21:09.433" UserId="42" Text="&lt;stepper&gt;&lt;motor&gt;&lt;driver&gt;" />
  <row Id="797" PostHistoryTypeId="2" PostId="333" RevisionGUID="e31eaa42-f80f-4de5-ae7d-c0d39ec1263e" CreationDate="2014-02-21T12:31:40.307" UserId="261" Text="I have following setup:&#xD;&#xA;&#xD;&#xA;- Arduino Duemilanove&#xD;&#xA;- Small water heater connected with optical relay (PWM is ok)&#xD;&#xA;- Waterproof DS18B20 temperature sensor&#xD;&#xA;- Unknown amount of water (but temperature sensor and heater are always underwater).&#xD;&#xA;&#xD;&#xA;How can I accurately control water temperature, based on temperature sensor readings? By accurately, I mean up to accuracy of temperature sensor (in this case, ±0.5°C). Everything should run on Arduino, so no additional data storage or processing power is available. For debugging, I can obviously use computer.&#xD;&#xA;&#xD;&#xA;I have tried running PID, but it seems really hard to &#xD;&#xA;&#xD;&#xA;1. Avoid overshooting - going over target temperature either initially, or when (cold) water is added&#xD;&#xA;2. Stabilize properly after adding cold water." />
  <row Id="798" PostHistoryTypeId="1" PostId="333" RevisionGUID="e31eaa42-f80f-4de5-ae7d-c0d39ec1263e" CreationDate="2014-02-21T12:31:40.307" UserId="261" Text="Controlling water temperature accurately" />
  <row Id="799" PostHistoryTypeId="3" PostId="333" RevisionGUID="e31eaa42-f80f-4de5-ae7d-c0d39ec1263e" CreationDate="2014-02-21T12:31:40.307" UserId="261" Text="&lt;pwm&gt;" />
  <row Id="800" PostHistoryTypeId="2" PostId="334" RevisionGUID="965b65e2-f7df-4947-bb99-9ffeca1d94b0" CreationDate="2014-02-21T13:48:27.017" UserId="8" Text="Generally, stepper motors cannot be controlled by an Arduino pin. They have a voltage draw of over the 20mA any single pin can supply.&#xD;&#xA;&#xD;&#xA;Kickback is also a problem. Because the motors have moving magnetic parts inside, they will continue to generate electricity after power has been cut. this will almost certainly cause enough negative voltage that is enough to fry your Arduino.&#xD;&#xA;&#xD;&#xA;A solution is to use a motor driver chip or shield. [This one](https://www.sparkfun.com/products/9815) is a good example. These have transistor based chips that can drive enough current to power a motor, and diodes to mitigate the kickback from the motors." />
  <row Id="804" PostHistoryTypeId="5" PostId="334" RevisionGUID="aee67f61-f1e5-4aa6-a8ac-5dc2a184e6fa" CreationDate="2014-02-21T15:22:08.023" UserId="42" Comment="edited body" Text="Generally, stepper motors cannot be controlled by an Arduino pin. They have a current draw of over the 20mA any single pin can supply.&#xD;&#xA;&#xD;&#xA;Kickback is also a problem. Because the motors have moving magnetic parts inside, they will continue to generate electricity after power has been cut. this will almost certainly cause enough negative voltage that is enough to fry your Arduino.&#xD;&#xA;&#xD;&#xA;A solution is to use a motor driver chip or shield. [This one](https://www.sparkfun.com/products/9815) is a good example. These have transistor based chips that can drive enough current to power a motor, and diodes to mitigate the kickback from the motors." />
  <row Id="805" PostHistoryTypeId="2" PostId="337" RevisionGUID="6e6cfd2d-0950-4468-9c6a-df0fa537c1f1" CreationDate="2014-02-21T15:36:19.237" UserId="42" Text="When you're writing a typical sketch, you usually rely on `loop()` being called repeatedly for as long as the Arduino is running. Moving in and out of the `loop()` function must introduce a small overhead though.&#xD;&#xA;&#xD;&#xA;To avoid that, you could presumably create your own infinite loop, like this:&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        while (true)&#xD;&#xA;        {&#xD;&#xA;            // do stuff...&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Is that a viable way to improve performance? Will it cause other problems if `loop()` never returns?" />
  <row Id="806" PostHistoryTypeId="1" PostId="337" RevisionGUID="6e6cfd2d-0950-4468-9c6a-df0fa537c1f1" CreationDate="2014-02-21T15:36:19.237" UserId="42" Text="Would an infinite loop inside loop() perform faster?" />
  <row Id="807" PostHistoryTypeId="3" PostId="337" RevisionGUID="6e6cfd2d-0950-4468-9c6a-df0fa537c1f1" CreationDate="2014-02-21T15:36:19.237" UserId="42" Text="&lt;programming&gt;&lt;sketch&gt;&lt;performance&gt;" />
  <row Id="809" PostHistoryTypeId="2" PostId="339" RevisionGUID="af2689ca-8ac0-4993-9952-5b0e4dd0c7a3" CreationDate="2014-02-21T16:43:46.067" UserId="136" Text="while(true) isn't going to incur overhead - it's likely to just be a call with no condition. " />
  <row Id="810" PostHistoryTypeId="12" PostId="339" RevisionGUID="7ff330f9-66de-4eca-94bf-96531d7342ef" CreationDate="2014-02-21T16:43:51.803" UserId="136" Comment="via Vote" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:136,&quot;DisplayName&quot;:&quot;Cybergibbons&quot;}]}" />
  <row Id="811" PostHistoryTypeId="5" PostId="339" RevisionGUID="0e760f6c-e8c4-4675-8d21-7e5a454e42e8" CreationDate="2014-02-21T17:12:53.173" UserId="136" Comment="added 1160 characters in body" Text="The part of the code on an ATmega core that does setup() and loop() is at follows:&#xD;&#xA;&#xD;&#xA;    #include &lt;Arduino.h&gt;&#xD;&#xA;    &#xD;&#xA;    int main(void)&#xD;&#xA;    {&#xD;&#xA;            init();&#xD;&#xA;    &#xD;&#xA;    #if defined(USBCON)&#xD;&#xA;            USBDevice.attach();&#xD;&#xA;    #endif&#xD;&#xA;            &#xD;&#xA;            setup();&#xD;&#xA;        &#xD;&#xA;            for (;;) {&#xD;&#xA;                    loop();&#xD;&#xA;                    if (serialEventRun) serialEventRun();&#xD;&#xA;            }&#xD;&#xA;            &#xD;&#xA;            return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Pretty simple, but there is the overhead of the serialEventRun(); in there.&#xD;&#xA;&#xD;&#xA;Let's compare two simple sketches:&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    	&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    volatile uint8_t x;&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    	&#xD;&#xA;        x = 1;&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;and&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    	&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    volatile uint8_t x;&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    	while(true)&#xD;&#xA;    	{&#xD;&#xA;    		x = 1;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The x and volatile is just to ensure it isn't optimised out.&#xD;&#xA;&#xD;&#xA;In the ASM produced, you get different results:&#xD;&#xA;![Comparison of two][1]&#xD;&#xA;&#xD;&#xA;You can see the while(true) just performs a rjmp (relative jump) back a few instructions, whereas loop() performs a subtraction, comparison and call. This is 4 instructions vs 1 instruction.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/CkIST.png" />
  <row Id="812" PostHistoryTypeId="13" PostId="339" RevisionGUID="4f12fada-82a4-4faf-8f37-10f94a084130" CreationDate="2014-02-21T17:12:58.550" UserId="136" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:136,&quot;DisplayName&quot;:&quot;Cybergibbons&quot;}]}" />
  <row Id="813" PostHistoryTypeId="2" PostId="340" RevisionGUID="9801fa19-57d2-40c7-b01d-b882b48dc2d4" CreationDate="2014-02-21T17:48:05.103" UserId="262" Text="I've managed to adapt some code from the arduino forums to display timecode on an lcd display.&#xD;&#xA;&#xD;&#xA;What I would like some extra help with is firstly is there a way of defining the one_time_max etc differently depending on the high low state of a pin. This way i could use a switch to change the times so it could switch between NTSC and PAL.&#xD;&#xA;&#xD;&#xA;Secondly would anyone be kind enough to explain what is happening in the middle part of this code. I've made some notes but any help would be really appreciated.&#xD;&#xA;&#xD;&#xA;Here is a picture of how it's going so far. I'll keep you guys up to date as the project continues :)&#xD;&#xA;&#xD;&#xA;http://i.imgur.com/kuGBfsZ.jpg&#xD;&#xA;&#xD;&#xA;&lt;script src=&quot;http://pastebin.com/embed_js.php?i=nkB08zX8&quot;&gt;&lt;/script&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;pre&gt;&#xD;&#xA;// Code from forum post Dec 12, 2007&#xD;&#xA;//&#xD;&#xA;//&#xD;&#xA;&#xD;&#xA;// include the library code:&#xD;&#xA;#include &lt;LiquidCrystal.h&gt;&#xD;&#xA;&#xD;&#xA;// initialize the library with the numbers of the interface pins&#xD;&#xA;LiquidCrystal lcd(12, 11, 5, 4, 3, 2);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#define one_time_max          600 // these values are setup for PA video&#xD;&#xA;#define one_time_min          400 // It's the durstion of a one and zero with a little bit of room for error. &#xD;&#xA;#define zero_time_max          1050 // &#xD;&#xA;#define zero_time_min          950 // &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#define icpPin 8	  // ICP input pin on arduino&#xD;&#xA;//#define one_time_max	    475 // these values are setup for NTSC video&#xD;&#xA;//#define one_time_min	    300 // PAL would be around 1000 for 0 and 500 for 1&#xD;&#xA;//#define zero_time_max	   875 // 80bits times 29.97 frames per sec&#xD;&#xA;//#define zero_time_min	   700 // equals 833 (divide by 8 clock pulses)&#xD;&#xA;&#xD;&#xA;#define end_data_position	63&#xD;&#xA;#define end_sync_position	77&#xD;&#xA;#define end_smpte_position     80&#xD;&#xA;&#xD;&#xA;volatile unsigned int pin = 13;&#xD;&#xA;volatile unsigned int bit_time;   // volatile instructs the variable to be stored in RAM&#xD;&#xA;volatile boolean valid_tc_word;   // booleon can be either of two values true or false but default to false&#xD;&#xA;volatile boolean ones_bit_count;  // booleon can be either of two values true or false but default to false&#xD;&#xA;volatile boolean tc_sync;         // booleon can be either of two values true or false but default to false&#xD;&#xA;volatile boolean write_tc_out;    // booleon can be either of two values true or false but default to false&#xD;&#xA;volatile boolean drop_frame_flag; // booleon can be either of two values true or false but default to false&#xD;&#xA;&#xD;&#xA;volatile byte total_bits;   //this stores a an 8-bit unsigned number&#xD;&#xA;volatile byte current_bit;  //this stores a an 8-bit unsigned number&#xD;&#xA;volatile byte sync_count;   //this stores a an 8-bit unsigned number&#xD;&#xA;&#xD;&#xA;volatile byte tc[8];         //this stores a an 8-bit unsigned number&#xD;&#xA;volatile char timeCode[11];  //this stores a an 8-bit unsigned number&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;/* ICR interrupt vector */&#xD;&#xA;ISR(TIMER1_CAPT_vect)   //ISR=Interrupt Service Routine, and timer1 capture event&#xD;&#xA;{&#xD;&#xA;  //toggleCaptureEdge&#xD;&#xA;  TCCR1B ^= _BV(ICES1); //toggles the edge that triggers the handler so that the duration of both high and low pulses is measured.&#xD;&#xA;&#xD;&#xA;  bit_time = ICR1; //this is the value the timer generates &#xD;&#xA;&#xD;&#xA;  //resetTimer1&#xD;&#xA;  TCNT1 = 0;&#xD;&#xA;// Ignore phase changes &lt; time for 1 bit or &gt; time for zero bit (zero bit phase change time is double that of 1 bit)&#xD;&#xA;if ((bit_time &lt; one_time_min) || (bit_time &gt; zero_time_max)) // this gets rid of anything that's not what we're looking for&#xD;&#xA;{&#xD;&#xA;  total_bits = 0;&#xD;&#xA;}&#xD;&#xA;else&#xD;&#xA;{&#xD;&#xA;  // If the bit we are reading is a 1 then ignore the first phase change&#xD;&#xA;  if (ones_bit_count == true) // only count the second ones pulse&#xD;&#xA;	ones_bit_count = false;&#xD;&#xA;  else&#xD;&#xA;  { // We have already checked the outer times for 1 and zero bits so no see if the inner time is &gt; zero min&#xD;&#xA;    if (bit_time &gt; zero_time_min)&#xD;&#xA;    { // We have a zero bit&#xD;&#xA;      current_bit = 0;  &#xD;&#xA;      sync_count = 0;   // Not a 1 bit so cannot be part of the 12 bit sync&#xD;&#xA;    }&#xD;&#xA;    else // It must be a 1 bit then&#xD;&#xA;    {&#xD;&#xA;      ones_bit_count = true;  // Flag so we don't read the next edge of a 1 bit&#xD;&#xA;      current_bit = 1;&#xD;&#xA;      sync_count++;     // Increment sync bit count&#xD;&#xA;      if (sync_count == 12) // part of the last two bytes of a timecode word&#xD;&#xA;      { // We have 12 1's in a row that can only be part of the sync&#xD;&#xA;        sync_count = 0;&#xD;&#xA;        tc_sync = true;&#xD;&#xA;        total_bits = end_sync_position;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    if (total_bits &lt;= end_data_position) // timecode runs least to most so we need&#xD;&#xA;    {						// to shift things around&#xD;&#xA;      tc[0] = tc[0] &gt;&gt; 1;&#xD;&#xA;      &#xD;&#xA;      for(int n=1;n&lt;8;n++) //creates tc[1-8]&#xD;&#xA;      {&#xD;&#xA;        if(tc[n] &amp; 1)&#xD;&#xA;        tc[n-1] |= 0x80;&#xD;&#xA;        &#xD;&#xA;        tc[n] = tc[n] &gt;&gt; 1;&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      if(current_bit == 1)&#xD;&#xA;	    tc[7] |= 0x80;&#xD;&#xA;    }&#xD;&#xA;    total_bits++;&#xD;&#xA;  }&#xD;&#xA;  &#xD;&#xA;  if (total_bits == end_smpte_position) // we have the 80th bit&#xD;&#xA;  {&#xD;&#xA;    total_bits = 0;&#xD;&#xA;    if (tc_sync)&#xD;&#xA;    {&#xD;&#xA;      tc_sync = false;&#xD;&#xA;      valid_tc_word = true;&#xD;&#xA;    }&#xD;&#xA;  } &#xD;&#xA;	if (total_bits &lt;= end_data_position) // timecode runs least to most so we need&#xD;&#xA;	{						// to shift things around&#xD;&#xA;	  tc[0] = tc[0] &gt;&gt; 1;&#xD;&#xA;&#xD;&#xA;	  for(int n=1;n&lt;8;n++) //creates tc[1-8]&#xD;&#xA;	  {&#xD;&#xA;	    if(tc[n] &amp; 1)&#xD;&#xA;		tc[n-1] |= 0x80;&#xD;&#xA;&#xD;&#xA;	    tc[n] = tc[n] &gt;&gt; 1;&#xD;&#xA;	  }&#xD;&#xA;&#xD;&#xA;	  if(current_bit == 1)&#xD;&#xA;	    tc[7] |= 0x80;&#xD;&#xA;	}&#xD;&#xA;	total_bits++;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    if (total_bits == end_smpte_position) // we have the 80th bit&#xD;&#xA;    {&#xD;&#xA;	total_bits = 0;&#xD;&#xA;	if (tc_sync)&#xD;&#xA;	{&#xD;&#xA;	  tc_sync = false;&#xD;&#xA;	  valid_tc_word = true;&#xD;&#xA;	}&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    if (valid_tc_word)&#xD;&#xA;    {&#xD;&#xA;	valid_tc_word = false;&#xD;&#xA;&#xD;&#xA;	timeCode[10] = (tc[0]&amp;0x0F)+0x30;	// frames  this converst from binary to decimal giving us the last digit&#xD;&#xA;	timeCode[9] = (tc[1]&amp;0x03)+0x30;	// 10's of frames this converst from binary to decimal giving us the first digit&#xD;&#xA;	timeCode[8] =  ':';&#xD;&#xA;	timeCode[7] = (tc[2]&amp;0x0F)+0x30;	// seconds&#xD;&#xA;	timeCode[6] = (tc[3]&amp;0x07)+0x30;	// 10's of seconds&#xD;&#xA;	timeCode[5] =  ':';&#xD;&#xA;	timeCode[4] = (tc[4]&amp;0x0F)+0x30;	// minutes&#xD;&#xA;	timeCode[3] = (tc[5]&amp;0x07)+0x30;	// 10's of minutes&#xD;&#xA;	timeCode[2] = ':';&#xD;&#xA;	timeCode[1] = (tc[6]&amp;0x0F)+0x30;	// hours&#xD;&#xA;	timeCode[0] = (tc[7]&amp;0x03)+0x30;	// 10's of hours&#xD;&#xA;&#xD;&#xA;	drop_frame_flag = bit_is_set(tc[1], 2); //detects whether theree is the drop frame bit.&#xD;&#xA;&#xD;&#xA;	write_tc_out = true;&#xD;&#xA;    }&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;void setup()&#xD;&#xA;{&#xD;&#xA;  lcd.begin (16, 2);&#xD;&#xA;  pinMode(icpPin, INPUT);			// ICP pin (digital pin 8 on arduino) as input&#xD;&#xA;&#xD;&#xA;  bit_time = 0;&#xD;&#xA;  valid_tc_word = false;&#xD;&#xA;  ones_bit_count = false;&#xD;&#xA;  tc_sync = false;&#xD;&#xA;  write_tc_out = false;&#xD;&#xA;  drop_frame_flag = false;&#xD;&#xA;  total_bits =  0;&#xD;&#xA;  current_bit =  0;&#xD;&#xA;  sync_count =  0;&#xD;&#xA;&#xD;&#xA;lcd.print(&quot;FINISHED SETUP&quot;);&#xD;&#xA;delay (1000);&#xD;&#xA;&#xD;&#xA;  TCCR1A = B00000000; // clear all&#xD;&#xA;  TCCR1B = B11000010; // ICNC1 noise reduction + ICES1 start on rising edge + CS11 divide by 8&#xD;&#xA;  TCCR1C = B00000000; // clear all&#xD;&#xA;  TIMSK1 = B00100000; // ICIE1 enable the icp&#xD;&#xA;&#xD;&#xA;  TCNT1 = 0; // clear timer1&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void loop()&#xD;&#xA;{&#xD;&#xA;    if (write_tc_out)&#xD;&#xA;    {&#xD;&#xA;	write_tc_out = false;&#xD;&#xA;	if (drop_frame_flag)&#xD;&#xA;	  lcd.print(&quot;TC-[df] &quot;);&#xD;&#xA;	else&#xD;&#xA;	  lcd.print(&quot;TC-NO DROP FRAME&quot;);&#xD;&#xA;lcd.setCursor(0, 1);&#xD;&#xA;	lcd.print((char*)timeCode);&#xD;&#xA;	lcd.print(&quot;\r&quot;);&#xD;&#xA;lcd.setCursor(11, 1);&#xD;&#xA;lcd.print(&quot;......&quot;);&#xD;&#xA;delay (30);&#xD;&#xA;lcd.clear();&#xD;&#xA;    }&#xD;&#xA;}&#xD;&#xA;&lt;code&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="814" PostHistoryTypeId="1" PostId="340" RevisionGUID="9801fa19-57d2-40c7-b01d-b882b48dc2d4" CreationDate="2014-02-21T17:48:05.103" UserId="262" Text="SMPTE Timecode Readr with LCD display coding question" />
  <row Id="815" PostHistoryTypeId="3" PostId="340" RevisionGUID="9801fa19-57d2-40c7-b01d-b882b48dc2d4" CreationDate="2014-02-21T17:48:05.103" UserId="262" Text="&lt;arduino-uno&gt;" />
  <row Id="816" PostHistoryTypeId="5" PostId="340" RevisionGUID="abca63ef-43b2-4b67-b38b-4b3436640b24" CreationDate="2014-02-21T18:03:21.013" UserId="136" Comment="Get code from pastebin as embed doesn't work." Text="I've managed to adapt some code from the arduino forums to display timecode on an lcd display.&#xD;&#xA;&#xD;&#xA;What I would like some extra help with is firstly is there a way of defining the one_time_max etc differently depending on the high low state of a pin. This way i could use a switch to change the times so it could switch between NTSC and PAL.&#xD;&#xA;&#xD;&#xA;Secondly would anyone be kind enough to explain what is happening in the middle part of this code. I've made some notes but any help would be really appreciated.&#xD;&#xA;&#xD;&#xA;Here is a picture of how it's going so far. I'll keep you guys up to date as the project continues :)&#xD;&#xA;&#xD;&#xA;http://i.imgur.com/kuGBfsZ.jpg&#xD;&#xA;&#xD;&#xA;    // Code from forum post Dec 12, 2007&#xD;&#xA;    //&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    // include the library code:&#xD;&#xA;    #include &lt;LiquidCrystal.h&gt;&#xD;&#xA;    &#xD;&#xA;    // initialize the library with the numbers of the interface pins&#xD;&#xA;    LiquidCrystal lcd(12, 11, 5, 4, 3, 2);&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    #define one_time_max          600 // these values are setup for PA video&#xD;&#xA;    #define one_time_min          400 // It's the durstion of a one and zero with a little bit of room for error. &#xD;&#xA;    #define zero_time_max          1050 // &#xD;&#xA;    #define zero_time_min          950 // &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    #define icpPin 8	  // ICP input pin on arduino&#xD;&#xA;    //#define one_time_max	    475 // these values are setup for NTSC video&#xD;&#xA;    //#define one_time_min	    300 // PAL would be around 1000 for 0 and 500 for 1&#xD;&#xA;    //#define zero_time_max	   875 // 80bits times 29.97 frames per sec&#xD;&#xA;    //#define zero_time_min	   700 // equals 833 (divide by 8 clock pulses)&#xD;&#xA;    &#xD;&#xA;    #define end_data_position	63&#xD;&#xA;    #define end_sync_position	77&#xD;&#xA;    #define end_smpte_position     80&#xD;&#xA;    &#xD;&#xA;    volatile unsigned int pin = 13;&#xD;&#xA;    volatile unsigned int bit_time;   // volatile instructs the variable to be stored in RAM&#xD;&#xA;    volatile boolean valid_tc_word;   // booleon can be either of two values true or false but default to false&#xD;&#xA;    volatile boolean ones_bit_count;  // booleon can be either of two values true or false but default to false&#xD;&#xA;    volatile boolean tc_sync;         // booleon can be either of two values true or false but default to false&#xD;&#xA;    volatile boolean write_tc_out;    // booleon can be either of two values true or false but default to false&#xD;&#xA;    volatile boolean drop_frame_flag; // booleon can be either of two values true or false but default to false&#xD;&#xA;    &#xD;&#xA;    volatile byte total_bits;   //this stores a an 8-bit unsigned number&#xD;&#xA;    volatile byte current_bit;  //this stores a an 8-bit unsigned number&#xD;&#xA;    volatile byte sync_count;   //this stores a an 8-bit unsigned number&#xD;&#xA;    &#xD;&#xA;    volatile byte tc[8];         //this stores a an 8-bit unsigned number&#xD;&#xA;    volatile char timeCode[11];  //this stores a an 8-bit unsigned number&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    /* ICR interrupt vector */&#xD;&#xA;    ISR(TIMER1_CAPT_vect)   //ISR=Interrupt Service Routine, and timer1 capture event&#xD;&#xA;    {&#xD;&#xA;      //toggleCaptureEdge&#xD;&#xA;      TCCR1B ^= _BV(ICES1); //toggles the edge that triggers the handler so that the duration of both high and low pulses is measured.&#xD;&#xA;    &#xD;&#xA;      bit_time = ICR1; //this is the value the timer generates &#xD;&#xA;    &#xD;&#xA;      //resetTimer1&#xD;&#xA;      TCNT1 = 0;&#xD;&#xA;    // Ignore phase changes &lt; time for 1 bit or &gt; time for zero bit (zero bit phase change time is double that of 1 bit)&#xD;&#xA;    if ((bit_time &lt; one_time_min) || (bit_time &gt; zero_time_max)) // this gets rid of anything that's not what we're looking for&#xD;&#xA;    {&#xD;&#xA;      total_bits = 0;&#xD;&#xA;    }&#xD;&#xA;    else&#xD;&#xA;    {&#xD;&#xA;      // If the bit we are reading is a 1 then ignore the first phase change&#xD;&#xA;      if (ones_bit_count == true) // only count the second ones pulse&#xD;&#xA;    	ones_bit_count = false;&#xD;&#xA;      else&#xD;&#xA;      { // We have already checked the outer times for 1 and zero bits so no see if the inner time is &gt; zero min&#xD;&#xA;        if (bit_time &gt; zero_time_min)&#xD;&#xA;        { // We have a zero bit&#xD;&#xA;          current_bit = 0;  &#xD;&#xA;          sync_count = 0;   // Not a 1 bit so cannot be part of the 12 bit sync&#xD;&#xA;        }&#xD;&#xA;        else // It must be a 1 bit then&#xD;&#xA;        {&#xD;&#xA;          ones_bit_count = true;  // Flag so we don't read the next edge of a 1 bit&#xD;&#xA;          current_bit = 1;&#xD;&#xA;          sync_count++;     // Increment sync bit count&#xD;&#xA;          if (sync_count == 12) // part of the last two bytes of a timecode word&#xD;&#xA;          { // We have 12 1's in a row that can only be part of the sync&#xD;&#xA;            sync_count = 0;&#xD;&#xA;            tc_sync = true;&#xD;&#xA;            total_bits = end_sync_position;&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        if (total_bits &lt;= end_data_position) // timecode runs least to most so we need&#xD;&#xA;        {						// to shift things around&#xD;&#xA;          tc[0] = tc[0] &gt;&gt; 1;&#xD;&#xA;          &#xD;&#xA;          for(int n=1;n&lt;8;n++) //creates tc[1-8]&#xD;&#xA;          {&#xD;&#xA;            if(tc[n] &amp; 1)&#xD;&#xA;            tc[n-1] |= 0x80;&#xD;&#xA;            &#xD;&#xA;            tc[n] = tc[n] &gt;&gt; 1;&#xD;&#xA;          }&#xD;&#xA;          &#xD;&#xA;          if(current_bit == 1)&#xD;&#xA;    	    tc[7] |= 0x80;&#xD;&#xA;        }&#xD;&#xA;        total_bits++;&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      if (total_bits == end_smpte_position) // we have the 80th bit&#xD;&#xA;      {&#xD;&#xA;        total_bits = 0;&#xD;&#xA;        if (tc_sync)&#xD;&#xA;        {&#xD;&#xA;          tc_sync = false;&#xD;&#xA;          valid_tc_word = true;&#xD;&#xA;        }&#xD;&#xA;      } &#xD;&#xA;    	if (total_bits &lt;= end_data_position) // timecode runs least to most so we need&#xD;&#xA;    	{						// to shift things around&#xD;&#xA;    	  tc[0] = tc[0] &gt;&gt; 1;&#xD;&#xA;    &#xD;&#xA;    	  for(int n=1;n&lt;8;n++) //creates tc[1-8]&#xD;&#xA;    	  {&#xD;&#xA;    	    if(tc[n] &amp; 1)&#xD;&#xA;    		tc[n-1] |= 0x80;&#xD;&#xA;    &#xD;&#xA;    	    tc[n] = tc[n] &gt;&gt; 1;&#xD;&#xA;    	  }&#xD;&#xA;    &#xD;&#xA;    	  if(current_bit == 1)&#xD;&#xA;    	    tc[7] |= 0x80;&#xD;&#xA;    	}&#xD;&#xA;    	total_bits++;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        if (total_bits == end_smpte_position) // we have the 80th bit&#xD;&#xA;        {&#xD;&#xA;    	total_bits = 0;&#xD;&#xA;    	if (tc_sync)&#xD;&#xA;    	{&#xD;&#xA;    	  tc_sync = false;&#xD;&#xA;    	  valid_tc_word = true;&#xD;&#xA;    	}&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        if (valid_tc_word)&#xD;&#xA;        {&#xD;&#xA;    	valid_tc_word = false;&#xD;&#xA;    &#xD;&#xA;    	timeCode[10] = (tc[0]&amp;0x0F)+0x30;	// frames  this converst from binary to decimal giving us the last digit&#xD;&#xA;    	timeCode[9] = (tc[1]&amp;0x03)+0x30;	// 10's of frames this converst from binary to decimal giving us the first digit&#xD;&#xA;    	timeCode[8] =  ':';&#xD;&#xA;    	timeCode[7] = (tc[2]&amp;0x0F)+0x30;	// seconds&#xD;&#xA;    	timeCode[6] = (tc[3]&amp;0x07)+0x30;	// 10's of seconds&#xD;&#xA;    	timeCode[5] =  ':';&#xD;&#xA;    	timeCode[4] = (tc[4]&amp;0x0F)+0x30;	// minutes&#xD;&#xA;    	timeCode[3] = (tc[5]&amp;0x07)+0x30;	// 10's of minutes&#xD;&#xA;    	timeCode[2] = ':';&#xD;&#xA;    	timeCode[1] = (tc[6]&amp;0x0F)+0x30;	// hours&#xD;&#xA;    	timeCode[0] = (tc[7]&amp;0x03)+0x30;	// 10's of hours&#xD;&#xA;    &#xD;&#xA;    	drop_frame_flag = bit_is_set(tc[1], 2); //detects whether theree is the drop frame bit.&#xD;&#xA;    &#xD;&#xA;    	write_tc_out = true;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      lcd.begin (16, 2);&#xD;&#xA;      pinMode(icpPin, INPUT);			// ICP pin (digital pin 8 on arduino) as input&#xD;&#xA;    &#xD;&#xA;      bit_time = 0;&#xD;&#xA;      valid_tc_word = false;&#xD;&#xA;      ones_bit_count = false;&#xD;&#xA;      tc_sync = false;&#xD;&#xA;      write_tc_out = false;&#xD;&#xA;      drop_frame_flag = false;&#xD;&#xA;      total_bits =  0;&#xD;&#xA;      current_bit =  0;&#xD;&#xA;      sync_count =  0;&#xD;&#xA;    &#xD;&#xA;    lcd.print(&quot;FINISHED SETUP&quot;);&#xD;&#xA;    delay (1000);&#xD;&#xA;    &#xD;&#xA;      TCCR1A = B00000000; // clear all&#xD;&#xA;      TCCR1B = B11000010; // ICNC1 noise reduction + ICES1 start on rising edge + CS11 divide by 8&#xD;&#xA;      TCCR1C = B00000000; // clear all&#xD;&#xA;      TIMSK1 = B00100000; // ICIE1 enable the icp&#xD;&#xA;    &#xD;&#xA;      TCNT1 = 0; // clear timer1&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        if (write_tc_out)&#xD;&#xA;        {&#xD;&#xA;    	write_tc_out = false;&#xD;&#xA;    	if (drop_frame_flag)&#xD;&#xA;    	  lcd.print(&quot;TC-[df] &quot;);&#xD;&#xA;    	else&#xD;&#xA;    	  lcd.print(&quot;TC-NO DROP FRAME&quot;);&#xD;&#xA;    lcd.setCursor(0, 1);&#xD;&#xA;    	lcd.print((char*)timeCode);&#xD;&#xA;    	lcd.print(&quot;\r&quot;);&#xD;&#xA;    lcd.setCursor(11, 1);&#xD;&#xA;    lcd.print(&quot;......&quot;);&#xD;&#xA;    delay (30);&#xD;&#xA;    lcd.clear();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="817" PostHistoryTypeId="2" PostId="341" RevisionGUID="90160f84-684e-426e-b514-754fbb29e3d2" CreationDate="2014-02-21T18:10:45.933" UserId="136" Text="The *one_time_max*, *one_time_min*, *zero_time_max* and *zero_time_min* are all defines at the top of the file. This will insert them as constant values at compile time. This makes changing the code to deal with them slightly awkward, but not impossible.&#xD;&#xA;&#xD;&#xA;Oddly, the *one_time_max* value isn't used, but the others are. To allow you to switch between PAL and *NTSC*, I would do the following (this is marginally lazy, but quick):&#xD;&#xA;&#xD;&#xA; - change one_time_max to ONE_TIME_MAX_NTSC and ONE_TIME_MAX_PAL so that you have two defined constants for each part. Caps is convention for defines.&#xD;&#xA; - create a new global variable, a boolean, that is a flag to decide if PAL or NTSC is to be decoded.&#xD;&#xA; - every time that one of the constant is used, use a conditional statement based on the global variable to decided which constants are used.&#xD;&#xA; - use the input from a button to decided the value of the global variable." />
  <row Id="818" PostHistoryTypeId="5" PostId="341" RevisionGUID="5a357567-3961-4099-87df-6ac51511fcce" CreationDate="2014-02-21T18:23:59.083" UserId="136" Comment="Italics don't work around _" Text="The one_time_max, one_time_min, zero_time_max and zero_time_min are all defines at the top of the file. This will insert them as constant values at compile time. This makes changing the code to deal with them slightly awkward, but not impossible.&#xD;&#xA;&#xD;&#xA;Oddly, the one_time_max value isn't used, but the others are. To allow you to switch between PAL and NTSC, I would do the following (this is marginally lazy, but quick):&#xD;&#xA;&#xD;&#xA; - change one_time_max to ONE_TIME_MAX_NTSC and ONE_TIME_MAX_PAL so that you have two defined constants for each part. Caps is convention for defines.&#xD;&#xA; - create a new global variable, a boolean, that is a flag to decide if PAL or NTSC is to be decoded.&#xD;&#xA; - every time that one of the constant is used, use a conditional statement based on the global variable to decided which constants are used.&#xD;&#xA; - use the input from a button to decided the value of the global variable." />
  <row Id="819" PostHistoryTypeId="2" PostId="342" RevisionGUID="60e55f00-47a6-420a-82f7-6dc170613658" CreationDate="2014-02-21T19:30:53.623" UserId="261" Text="I have Arduino Uno with SD card shield. I'm planning to log a huge amount of data from various sensors - including accelerometers and 3D compass - to the SD card. &#xD;&#xA;&#xD;&#xA;However, I have understood that Arduino, 64GB SD, FAT and large amount of data are not working too well.&#xD;&#xA;&#xD;&#xA;Does Arduino work well with this amount of data on FAT? There's no need to read any data from SD on Arduino. If not, is there a better approach? Writing directly to SD without FAT? &#xD;&#xA;&#xD;&#xA;This data logger will be on the environment where no computer or network connection is available. Performance is not an issue - around 8kB/s (over three months) is already enough." />
  <row Id="820" PostHistoryTypeId="1" PostId="342" RevisionGUID="60e55f00-47a6-420a-82f7-6dc170613658" CreationDate="2014-02-21T19:30:53.623" UserId="261" Text="Logging multiple gigabytes of data with Arduino" />
  <row Id="821" PostHistoryTypeId="3" PostId="342" RevisionGUID="60e55f00-47a6-420a-82f7-6dc170613658" CreationDate="2014-02-21T19:30:53.623" UserId="261" Text="&lt;secure-digital&gt;&lt;fat&gt;" />
  <row Id="822" PostHistoryTypeId="5" PostId="339" RevisionGUID="1a57e33d-aa10-4cf0-a2e3-dc74372bfa81" CreationDate="2014-02-21T21:20:58.340" UserId="136" Comment="added 657 characters in body" Text="The part of the code on an ATmega core that does setup() and loop() is at follows:&#xD;&#xA;&#xD;&#xA;    #include &lt;Arduino.h&gt;&#xD;&#xA;    &#xD;&#xA;    int main(void)&#xD;&#xA;    {&#xD;&#xA;            init();&#xD;&#xA;    &#xD;&#xA;    #if defined(USBCON)&#xD;&#xA;            USBDevice.attach();&#xD;&#xA;    #endif&#xD;&#xA;            &#xD;&#xA;            setup();&#xD;&#xA;        &#xD;&#xA;            for (;;) {&#xD;&#xA;                    loop();&#xD;&#xA;                    if (serialEventRun) serialEventRun();&#xD;&#xA;            }&#xD;&#xA;            &#xD;&#xA;            return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Pretty simple, but there is the overhead of the serialEventRun(); in there.&#xD;&#xA;&#xD;&#xA;Let's compare two simple sketches:&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    	&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    volatile uint8_t x;&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    	&#xD;&#xA;        x = 1;&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;and&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    	&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    volatile uint8_t x;&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    	while(true)&#xD;&#xA;    	{&#xD;&#xA;    		x = 1;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The x and volatile is just to ensure it isn't optimised out.&#xD;&#xA;&#xD;&#xA;In the ASM produced, you get different results:&#xD;&#xA;![Comparison of two][1]&#xD;&#xA;&#xD;&#xA;You can see the while(true) just performs a rjmp (relative jump) back a few instructions, whereas loop() performs a subtraction, comparison and call. This is 4 instructions vs 1 instruction.&#xD;&#xA;&#xD;&#xA;To generate ASM as above, you need to use a tool called avr-objdump. This is included with avr-gcc. Location varies depending on OS so it is easiest to search for it by name.&#xD;&#xA;&#xD;&#xA;avr-objdump can operate on .hex files, but these are missing the original source and comments. If you have just built code, you will have a .elf file that does contain this data. Again, the location of these files varies by OS - the easiest way to locate them is to turn on verbose compilation in preferences and see where the output files are being stored.&#xD;&#xA;&#xD;&#xA;Run the command as follows:&#xD;&#xA;&#xD;&#xA;&gt; avr-objdump -S output.elf &gt; asm.txt&#xD;&#xA;&#xD;&#xA;And examine the output in a text editor.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/CkIST.png" />
  <row Id="823" PostHistoryTypeId="2" PostId="343" RevisionGUID="bc3d9411-3d43-4d4d-be93-63db09f545ad" CreationDate="2014-02-21T21:29:25.117" UserId="35" Text="When I compile this sketch for the Yún:&#xD;&#xA;&#xD;&#xA;    int led = 7;&#xD;&#xA;    &#xD;&#xA;    void setup() {                &#xD;&#xA;      pinMode(led, OUTPUT);     &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      digitalWrite(led, HIGH);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I get:&#xD;&#xA;&#xD;&#xA;&gt; Sketch uses 5,098 bytes (17%) of program storage space. &#xD;&#xA;&gt;&#xD;&#xA;&gt;Maximum is&#xD;&#xA;&gt; 28,672 bytes. Global variables use 153 bytes (5%) of dynamic memory,&#xD;&#xA;&gt; leaving 2,407 bytes for local variables. Maximum is 2,560 bytes.&#xD;&#xA;&#xD;&#xA;Even when I compile the BareMinimum sketch, I get:&#xD;&#xA;&#xD;&#xA;&gt; Sketch uses 4,548 bytes (15%) of program storage space.&#xD;&#xA;&gt;&#xD;&#xA;&gt; Maximum is&#xD;&#xA;&gt; 28,672 bytes. Global variables use 151 bytes (5%) of dynamic memory,&#xD;&#xA;&gt; leaving 2,409 bytes for local variables. Maximum is 2,560 bytes.&#xD;&#xA;&#xD;&#xA;Why does a bare minimum sketch take up 15% of the program storage space allocated? And why does a very simple sketch take up 17% of the program storage space? According to [the Arduino website][1]:&#xD;&#xA;&#xD;&#xA;&gt; It's easy to use it all up by having lots of strings in your program.&#xD;&#xA;&gt; For example, a declaration like: `char message[] = &quot;I support the Cape&#xD;&#xA;&gt; Wind project.&quot;;` puts 33 bytes into SRAM (each character takes a byte,&#xD;&#xA;&gt; plus the '\0' terminator).&#xD;&#xA;&#xD;&#xA;However, there aren't any strings declared in either of these sketches.&#xD;&#xA;&#xD;&#xA;It seems as if they might import or use other libraries/classes that I don't specify. Maybe it imports a system default library? Or is it something else?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Tutorial/Memory#.UwfEavkiEw8" />
  <row Id="824" PostHistoryTypeId="1" PostId="343" RevisionGUID="bc3d9411-3d43-4d4d-be93-63db09f545ad" CreationDate="2014-02-21T21:29:25.117" UserId="35" Text="Why do sketches take up so much space and memory?" />
  <row Id="825" PostHistoryTypeId="3" PostId="343" RevisionGUID="bc3d9411-3d43-4d4d-be93-63db09f545ad" CreationDate="2014-02-21T21:29:25.117" UserId="35" Text="&lt;programming&gt;&lt;compile&gt;" />
  <row Id="826" PostHistoryTypeId="2" PostId="344" RevisionGUID="e29794ed-cf7a-4e9b-8b6b-f448bfce4d9a" CreationDate="2014-02-21T21:33:58.613" UserId="136" Text="I'm not sure where you have the impression it won't work. I haven't used 64GB cards, but have used 32GB cards and they work fine in terms of FAT32 and writing files.&#xD;&#xA;&#xD;&#xA;As you have already worked out, reading or searching the file system can get very slow as size increases.&#xD;&#xA;&#xD;&#xA;That said, I have found that larger capacity cards are more likely to have problems with the SPI interface being poor quality. Consumer devices do not use the SPI interface, and it seems that some manufacturers are willing to skimp on this side of it. The SPI interface can be buggy or unstable as a result. Genuine name-brand cards should work fine though." />
  <row Id="827" PostHistoryTypeId="2" PostId="345" RevisionGUID="2f16216a-82a7-4e0f-8ab5-567df7d3cff9" CreationDate="2014-02-21T21:36:27.060" UserId="83" Text="Arduino compiles in a lot of standard libraries, interrupts, ... etc. For example the pinMode and digitalWrite functions use a lookup table to figure out at run time which GPIO registers to write data to. Another example is that Arduino keeps track of time, it defines some interrupts by default and all this functionality requires some space. You'll notice that if you extend the program, the foot print will only change slightly.&#xD;&#xA;&#xD;&#xA;I personally like to program controllers with bare minimum, without &quot;bloat&quot;, but you'll enter the world of EE.SE because several easy to use functions will no longer work out of the box. There are some alternative libraries for pinMode and digitalWrite that compile into a smaller footprint, but come with other disadvantages like for example static compiled pins (where `led` cannot be a variable, but is a constant).&#xD;&#xA;&#xD;&#xA;" />
  <row Id="828" PostHistoryTypeId="5" PostId="343" RevisionGUID="8ae0c0e4-9849-4d88-bfd0-54d24d4564a5" CreationDate="2014-02-21T21:38:07.423" UserId="35" Comment="added 117 characters in body" Text="When I compile this sketch for the Yún:&#xD;&#xA;&#xD;&#xA;    int led = 7;&#xD;&#xA;    &#xD;&#xA;    void setup() {                &#xD;&#xA;      pinMode(led, OUTPUT);     &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      digitalWrite(led, HIGH);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I get:&#xD;&#xA;&#xD;&#xA;&gt; Sketch uses 5,098 bytes (17%) of program storage space. &#xD;&#xA;&gt;&#xD;&#xA;&gt;Maximum is&#xD;&#xA;&gt; 28,672 bytes. Global variables use 153 bytes (5%) of dynamic memory,&#xD;&#xA;&gt; leaving 2,407 bytes for local variables. Maximum is 2,560 bytes.&#xD;&#xA;&#xD;&#xA;Even when I compile the BareMinimum sketch:&#xD;&#xA;    &#xD;&#xA;    void setup() {                &#xD;&#xA;      // setup    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      // loop&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I get:&#xD;&#xA;&gt; Sketch uses 4,548 bytes (15%) of program storage space.&#xD;&#xA;&gt;&#xD;&#xA;&gt; Maximum is&#xD;&#xA;&gt; 28,672 bytes. Global variables use 151 bytes (5%) of dynamic memory,&#xD;&#xA;&gt; leaving 2,409 bytes for local variables. Maximum is 2,560 bytes.&#xD;&#xA;&#xD;&#xA;Why does a bare minimum sketch take up 15% of the program storage space allocated? And why does a very simple sketch take up 17% of the program storage space? According to [the Arduino website][1]:&#xD;&#xA;&#xD;&#xA;&gt; It's easy to use it all up by having lots of strings in your program.&#xD;&#xA;&gt; For example, a declaration like: `char message[] = &quot;I support the Cape&#xD;&#xA;&gt; Wind project.&quot;;` puts 33 bytes into SRAM (each character takes a byte,&#xD;&#xA;&gt; plus the '\0' terminator).&#xD;&#xA;&#xD;&#xA;However, there aren't any strings declared in either of these sketches.&#xD;&#xA;&#xD;&#xA;It seems as if they might import or use other libraries/classes that I don't specify. Maybe it imports a system default library? Or is it something else?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Tutorial/Memory#.UwfEavkiEw8" />
  <row Id="829" PostHistoryTypeId="5" PostId="345" RevisionGUID="3293dc8d-c2fe-4717-b938-e6c3d4faf9c6" CreationDate="2014-02-21T21:43:59.177" UserId="83" Comment="added 15 characters in body" Text="Arduino compiles in a lot of standard libraries, interrupts, ... etc. For example the pinMode and digitalWrite functions use a lookup table to figure out at run time which GPIO registers to write data to. Another example is that Arduino keeps track of time, it defines some interrupts by default and all this functionality requires some space. You'll notice that if you extend the program, the foot print will only change slightly.&#xD;&#xA;&#xD;&#xA;I personally like to program controllers with bare minimum, without &quot;bloat&quot;, but you'll quickly enter the world of EE.SE and SO because several easy to use functions will no longer work out of the box. There are some alternative libraries for pinMode and digitalWrite that compile into a smaller footprint, but come with other disadvantages like for example static compiled pins (where `led` cannot be a variable, but is a constant).&#xD;&#xA;&#xD;&#xA;" />
  <row Id="830" PostHistoryTypeId="2" PostId="346" RevisionGUID="6b1b00c4-9421-4ad7-beba-a7b30e7d9c6c" CreationDate="2014-02-22T05:33:04.717" UserId="60" Text="You should consider using [sdfatlib](http://code.google.com/p/sdfatlib/). This is currently supported version. Where an early version of this was the predecessor the IDE's stock SD library. SdFat better supports newer and larger SdCards, along with more features." />
  <row Id="831" PostHistoryTypeId="2" PostId="347" RevisionGUID="8d5e3fff-24f9-4abc-8b9c-464a03b49698" CreationDate="2014-02-22T05:58:42.613" UserId="60" Text="The YUN is a combo. Part Arduino and Part OpenWRT(Linux). Your question is in reference to the Arduino. Where this is actually a ATmega32u4 similar to a Leonardo and not an UNO(ATmega328p). The 32u4(Leo) communicates via Virtual Serial Ports over the USB *(short answer: this needs to be supported)* , where the UNO has a real Serial Port (aka UART). Below are builds statistics of the different boards types for the AVR processors.&#xD;&#xA;&#xD;&#xA;Note on the UNO there is an external chip that converts USB to the Serial port's DTR pin which toggles the ATmega328's reset pin when connected causing a reboot to the bootloader. In contrast the Leo/Yun's USB to Serial is in implemented in the firmware of the 32u4. Hence in order to remotely reboot the Leo or YUN's 32u4 chip the firmware loaded must always support the USB client side driver. Which consumes approximately 4K. &#xD;&#xA;&#xD;&#xA;If the USB was NOT needed and no other library resources were called as in the case of BareMinimum.ino on an UNO, only approximately 466 bytes are needed for the core Arduino Library.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;compile stats of BareMinimum.ino on a UNO(ATmega328p)&#xD;&#xA;&#xD;&#xA;    Sketch uses 466 bytes (1%) of program storage space. Maximum is 32,256 bytes.&#xD;&#xA;    Global variables use 9 bytes (0%) of dynamic memory, leaving 2,039 bytes for local variables. Maximum is 2,048 bytes.&#xD;&#xA;&#xD;&#xA;compile stats of BareMinimum.ino on a Leonardo(ATmega32u4)&#xD;&#xA;&#xD;&#xA;    Sketch uses 4,554 bytes (15%) of program storage space. Maximum is 28,672 bytes.&#xD;&#xA;    Global variables use 151 bytes (5%) of dynamic memory, leaving 2,409 bytes for local variables. Maximum is 2,560 bytes.&#xD;&#xA;&#xD;&#xA;compile stats of BareMinimum.ino on a Yun(ATmega32u4)&#xD;&#xA;&#xD;&#xA;    Sketch uses 4,548 bytes (15%) of program storage space. Maximum is 28,672 bytes.&#xD;&#xA;    Global variables use 151 bytes (5%) of dynamic memory, leaving 2,409 bytes for local variables. Maximum is 2,560 bytes.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="832" PostHistoryTypeId="6" PostId="337" RevisionGUID="c1e21243-50fe-4fdf-b6a1-e52aa514608a" CreationDate="2014-02-22T07:18:36.337" UserId="65" Comment="edited tags" Text="&lt;programming&gt;&lt;performance&gt;" />
  <row Id="833" PostHistoryTypeId="2" PostId="348" RevisionGUID="ed91adf8-34ee-4a85-9cb1-08db715e84db" CreationDate="2014-02-22T07:31:10.457" UserId="84" Text="It's been a long time I've been looking for a good answer to this question.&#xD;&#xA;&#xD;&#xA;Typically, any Arduino project but the simplest one will include:&#xD;&#xA;&#xD;&#xA;- the main source code file `MyProject.ino`&#xD;&#xA;- libraries specific to the project (`MyProjectLibrary1.h`, `MyProjectLibrary1.cpp`...)&#xD;&#xA;- third-party libraries (generally free open source, added manually to Arduino libraries directory)&#xD;&#xA;- schematics, PCB diagrams&#xD;&#xA;- documentation&#xD;&#xA;- ...&#xD;&#xA;&#xD;&#xA;All this makes it hard to keep the whole code and doc of one project under Source Code Management (e.g. on *Subversion*, *Git* or *Github*).&#xD;&#xA;&#xD;&#xA;Managing source control of your project means managing the version of all files used by the project including 3rd-party libraries.&#xD;&#xA;&#xD;&#xA;Now for a single project, I need to define a directory structure that:&#xD;&#xA;&#xD;&#xA;- includes all project files as described above&#xD;&#xA;- I can entirely commit to a Source Code Management tool (including 3rd-party dependencies)&#xD;&#xA;- I can checkout anywhere on my hard drive and build the project from there (does it have to be a single location as imposed by Arduino IDE)&#xD;&#xA;- I can zip into a self-contained archive that I can send to a friend for him to build as easily as possible (no extra manual download)&#xD;&#xA;&#xD;&#xA;What I find particularly tricky with Arduino projects is the management of external libraries dependencies. Java projects developers have [maven][1] repositories for that and that helps a lot in managing all external deps. But we don't have an equivalent system for Arduino libraries.&#xD;&#xA;&#xD;&#xA;I would be interested to know how other arduino project makers deal with these aspects in their own projects.&#xD;&#xA;&#xD;&#xA;Also note that I am open to changing my development process, including my IDE (currently I use eclipse with the arduino plugin most of the time, and I check it can work with the Arduino IDE).&#xD;&#xA;&#xD;&#xA;  [1]: http://maven.apache.org" />
  <row Id="834" PostHistoryTypeId="1" PostId="348" RevisionGUID="ed91adf8-34ee-4a85-9cb1-08db715e84db" CreationDate="2014-02-22T07:31:10.457" UserId="84" Text="How to organize my arduino projects structure for easy source control?" />
  <row Id="835" PostHistoryTypeId="3" PostId="348" RevisionGUID="ed91adf8-34ee-4a85-9cb1-08db715e84db" CreationDate="2014-02-22T07:31:10.457" UserId="84" Text="&lt;project&gt;&lt;structure&gt;&lt;version-control&gt;" />
  <row Id="836" PostHistoryTypeId="2" PostId="349" RevisionGUID="945af174-1a8c-45f0-8007-c214656682ab" CreationDate="2014-02-22T08:11:33.753" UserId="65" Text="[Cybergibbons's answer][1] describes quite nicely the assembly code generation and the differences amongst the two techniques. This is intended to be a complementary answer looking at the issue in terms of *practical* differences, i.e. how much of a difference either approach will make in terms of *execution time*.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;##Code Variations &#xD;&#xA;I did a [small analysis][2] involving the following variations:&#xD;&#xA;&#xD;&#xA;- Basic `void loop()` (which gets inlined on compilation)&#xD;&#xA;- Un-inlined `void loop()` (using `__attribute__ ((noinline))`)&#xD;&#xA;- Loop with `while(1)` (which gets optimized)&#xD;&#xA;- Loop with un-optimized `while(1)` (by adding `__asm__ __volatile__(&quot;&quot;);`. This is a `nop` instruction that prevents optimization of the loop without resulting in additional overheads of a `volatile` variable)&#xD;&#xA;- An un-inlined `void loop()` with optimized `while(1)`&#xD;&#xA;- An un-inlined `void loop()` with un-optimized `while(1)`&#xD;&#xA;&#xD;&#xA;The sketches can be found [here][3].&#xD;&#xA;&#xD;&#xA;##Experiment&#xD;&#xA;I ran each of these sketches for 30 seconds, thereby accumulating [300 data points each][4]. There was a 100 millisecond `delay` call in each loop (without which [bad things happen][5]). &#xD;&#xA;&#xD;&#xA;##Results&#xD;&#xA;I then calculated the mean execution times of each loop, subtracted 100 milliseconds from each and then plotted the results. &#xD;&#xA;&#xD;&#xA;[![][6]][7]&#xD;&#xA;&#xD;&#xA;#Conclusion&#xD;&#xA;&#xD;&#xA;- A `while(1)` loop is faster than the looping of `void loop`. &#xD;&#xA;- The time difference between the un-optimized code and default Arduino  optimized code is insignificant *practically*. You will be better off compiling manually using `avr-gcc` and using your own optimisation flags rather than depending on the Arduino IDE to help you with it (if you need microsecond optimisations). &#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**NOTE:** The actual time values are not of significance here, the difference between them is. The ~90 microseconds of execution time include a call to `Serial.println`, `micros` and `delay`.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/questions/337/would-an-infinite-loop-inside-loop-perform-faster#339&#xD;&#xA;  [2]: http://github.com/AsheeshR/Arduino-Loop-Analysis&#xD;&#xA;  [3]: http://github.com/AsheeshR/Arduino-Loop-Analysis/tree/master/Code/Sketches&#xD;&#xA;  [4]: http://github.com/AsheeshR/Arduino-Loop-Analysis/tree/master/Data&#xD;&#xA;  [5]: http://electronics.stackexchange.com/q/12300/18583&#xD;&#xA;  [6]: http://raw2.github.com/AsheeshR/Arduino-Loop-Analysis/master/Figures/timeplot.png&#xD;&#xA;  [7]: http://github.com/AsheeshR/Arduino-Loop-Analysis/blob/master/Data/Munged/runtime.csv" />
  <row Id="837" PostHistoryTypeId="6" PostId="348" RevisionGUID="2a98047f-10f1-497c-be35-34a373586d26" CreationDate="2014-02-22T08:13:44.607" UserId="65" Comment="edited tags" Text="&lt;project&gt;&lt;version-control&gt;" />
  <row Id="838" PostHistoryTypeId="5" PostId="349" RevisionGUID="568ca202-ea85-4f84-90a8-847ec715a4a9" CreationDate="2014-02-22T08:17:25.463" UserId="65" Comment="added 137 characters in body" Text="[Cybergibbons's answer][1] describes quite nicely the assembly code generation and the differences amongst the two techniques. This is intended to be a complementary answer looking at the issue in terms of *practical* differences, i.e. how much of a difference either approach will make in terms of *execution time*.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;##Code Variations &#xD;&#xA;I did a [small analysis][2] involving the following variations:&#xD;&#xA;&#xD;&#xA;- Basic `void loop()` (which gets inlined on compilation)&#xD;&#xA;- Un-inlined `void loop()` (using `__attribute__ ((noinline))`)&#xD;&#xA;- Loop with `while(1)` (which gets optimized)&#xD;&#xA;- Loop with un-optimized `while(1)` (by adding `__asm__ __volatile__(&quot;&quot;);`. This is a `nop` instruction that prevents optimization of the loop without resulting in additional overheads of a `volatile` variable)&#xD;&#xA;- An un-inlined `void loop()` with optimized `while(1)`&#xD;&#xA;- An un-inlined `void loop()` with un-optimized `while(1)`&#xD;&#xA;&#xD;&#xA;The sketches can be found [here][3].&#xD;&#xA;&#xD;&#xA;##Experiment&#xD;&#xA;I ran each of these sketches for 30 seconds, thereby accumulating [300 data points each][4]. There was a 100 millisecond `delay` call in each loop (without which [bad things happen][5]). &#xD;&#xA;&#xD;&#xA;##Results&#xD;&#xA;I then calculated the mean execution times of each loop, subtracted 100 milliseconds from each and then plotted the results. &#xD;&#xA;&#xD;&#xA;[![][6]][7]&#xD;&#xA;&#xD;&#xA;#Conclusion&#xD;&#xA;&#xD;&#xA;- An un-optimised `while(1)` loop within `void loop` is faster than a compiler optimised  `void loop`. &#xD;&#xA;- The time difference between the un-optimized code and default Arduino  optimized code is insignificant *practically*. You will be better off compiling manually using `avr-gcc` and using your own optimisation flags rather than depending on the Arduino IDE to help you with it (if you need microsecond optimisations). &#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**NOTE:** The actual time values are not of significance here, the difference between them is. The ~90 microseconds of execution time include a call to `Serial.println`, `micros` and `delay`.&#xD;&#xA;&#xD;&#xA;**NOTE2:** This was done using the Arduino IDE and the default compiler flags that it supplies.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/questions/337/would-an-infinite-loop-inside-loop-perform-faster#339&#xD;&#xA;  [2]: http://github.com/AsheeshR/Arduino-Loop-Analysis&#xD;&#xA;  [3]: http://github.com/AsheeshR/Arduino-Loop-Analysis/tree/master/Code/Sketches&#xD;&#xA;  [4]: http://github.com/AsheeshR/Arduino-Loop-Analysis/tree/master/Data&#xD;&#xA;  [5]: http://electronics.stackexchange.com/q/12300/18583&#xD;&#xA;  [6]: http://raw2.github.com/AsheeshR/Arduino-Loop-Analysis/master/Figures/timeplot.png&#xD;&#xA;  [7]: http://github.com/AsheeshR/Arduino-Loop-Analysis/blob/master/Data/Munged/runtime.csv" />
  <row Id="839" PostHistoryTypeId="2" PostId="350" RevisionGUID="4c70b47b-cbb0-4f1d-b43d-e486bcde9a49" CreationDate="2014-02-22T12:51:58.380" UserId="42" Text="Rather than using microprocessor-specific low-level programming, I was able to get a suitable signal using the core `tone()` function:&#xD;&#xA;&#xD;&#xA;    tone(11, 2000000);&#xD;&#xA;&#xD;&#xA;It can be used to generate a 50% duty cycle square wave of a custom frequency on any individual GPIO pin (I'm using 11 in this case). Given the name, it's obviously designed for producing simple audio output, and 2 MHz is way above the range of human hearing.&#xD;&#xA;&#xD;&#xA;The documentation doesn't list any upper limit on the frequency though, and the code it's based on doesn't appear to introduce any limitations. With that said, it clearly can't run faster than the internal timer it's based on (which I think will typically be 8 or 16 MHz).&#xD;&#xA;&#xD;&#xA;It seems reasonable to assume that it will be in-sync with the microprocessor's internal clock, although I haven't been able to confirm that empirically as I don't have suitable equipment at home. Similarly, I haven't been able to confirm that it's *actually* producing a 2 MHz signal, but the LCD display is working properly so it's likely to be in the right vicinity. I had previously tried running it from regular PWM, but that didn't work, so frequency is obviously important here.&#xD;&#xA;&#xD;&#xA;The signal can be stopped by calling:&#xD;&#xA;&#xD;&#xA;    noTone(11);&#xD;&#xA;&#xD;&#xA;There are a couple of caveats to be aware of when using `tone()`. First of all, it can only work on a single pin at a time, so you can't generate multiple signals with it. And secondly, it will prevent some PWM output from working properly (on pins 3 and 11, according to the documentation). This is because it has to reconfigure one of the internal timers which is normally used for PWM." />
  <row Id="840" PostHistoryTypeId="6" PostId="332" RevisionGUID="cf60ea6a-a90e-4a7d-a979-54f09b9333da" CreationDate="2014-02-22T13:49:18.563" UserId="65" Comment="edited tags" Text="&lt;stepper&gt;&lt;motor&gt;" />
  <row Id="841" PostHistoryTypeId="5" PostId="327" RevisionGUID="6c9f7d2b-a104-40b8-b56d-e51d25ee7802" CreationDate="2014-02-22T13:53:10.110" UserId="65" Comment="The relation is in terms of magnitude, not subsets." Text="One important fact about C and C++ languages is that their respective standards do not define the size (in bytes) of integral and floating point number types.&#xD;&#xA;&#xD;&#xA;They just define minimal ranges and relation between these ranges, e.g.&#xD;&#xA;&#xD;&#xA;    range(short) &lt;= range(int) &lt; range(long)&#xD;&#xA;&#xD;&#xA;So the size of e.g. an `int` will typically depend on:&#xD;&#xA;&#xD;&#xA;- the target platform (processor)&#xD;&#xA;- the compiler itself&#xD;&#xA;" />
  <row Id="843" PostHistoryTypeId="5" PostId="348" RevisionGUID="ed35420a-7243-4c24-a1a0-2b695bf83c90" CreationDate="2014-02-22T17:26:58.043" UserId="35" Comment="fixed grammar, spelling" Text="It's been a long time I've been looking for a good answer to this question.&#xD;&#xA;&#xD;&#xA;Typically, any Arduino project but the simplest one will include:&#xD;&#xA;&#xD;&#xA;- The main source code file `MyProject.ino`&#xD;&#xA;- Libraries specific to the project (`MyProjectLibrary1.h`, `MyProjectLibrary1.cpp`...)&#xD;&#xA;- Third-party libraries (generally free open source, added manually to Arduino libraries directory)&#xD;&#xA;- Schematics, PCB diagrams&#xD;&#xA;- Documentation&#xD;&#xA;- ...&#xD;&#xA;&#xD;&#xA;All this makes it hard to keep the whole code and doc of one project under Source Code Management (e.g. on Subversion, Git or GitHub).&#xD;&#xA;&#xD;&#xA;Managing source control of your project means managing the version of all files used by the project including 3rd-party libraries.&#xD;&#xA;&#xD;&#xA;Now for a single project, I need to define a directory structure that:&#xD;&#xA;&#xD;&#xA;- Includes all project files as described above&#xD;&#xA;- I can entirely commit to a Source Code Management tool (including 3rd-party dependencies)&#xD;&#xA;- I can checkout anywhere on my hard drive and build the project from there (does it have to be a single location as imposed by Arduino IDE)&#xD;&#xA;- I can zip into a self-contained archive that I can send to a friend for him to build as easily as possible (no extra manual download)&#xD;&#xA;&#xD;&#xA;What I find particularly tricky with Arduino projects is the management of external libraries dependencies. Java projects developers have [maven][1] repositories for that and that helps a lot in managing all external deps. But we don't have an equivalent system for Arduino libraries.&#xD;&#xA;&#xD;&#xA;I would be interested to know how other Arduino project makers deal with these aspects in their own projects.&#xD;&#xA;&#xD;&#xA;Also note that I am open to changing my development process, including my IDE (currently I use Eclipse with the Arduino plugin most of the time, and it can work with the Arduino IDE).&#xD;&#xA;&#xD;&#xA;  [1]: http://maven.apache.org" />
  <row Id="844" PostHistoryTypeId="4" PostId="348" RevisionGUID="ed35420a-7243-4c24-a1a0-2b695bf83c90" CreationDate="2014-02-22T17:26:58.043" UserId="35" Comment="fixed grammar, spelling" Text="How to organize my Arduino project's structure for easy source control?" />
  <row Id="845" PostHistoryTypeId="24" PostId="348" RevisionGUID="ed35420a-7243-4c24-a1a0-2b695bf83c90" CreationDate="2014-02-22T17:26:58.043" Comment="Proposed by 35 approved by -1, 83 edit id of 68" />
  <row Id="846" PostHistoryTypeId="5" PostId="348" RevisionGUID="e3a85161-f248-4e89-bc08-f6527eba6654" CreationDate="2014-02-22T17:26:58.043" UserId="84" Comment="fixed grammar, spelling" Text="It's been a long time I've been looking for a good answer to this question.&#xD;&#xA;&#xD;&#xA;Typically, any Arduino project but the simplest one will include:&#xD;&#xA;&#xD;&#xA;- The main source code file `MyProject.ino`&#xD;&#xA;- Libraries specific to the project (`MyProjectLibrary1.h`, `MyProjectLibrary1.cpp`...)&#xD;&#xA;- Third-party libraries (generally free open source, added manually to Arduino libraries directory)&#xD;&#xA;- Schematics, PCB diagrams&#xD;&#xA;- Documentation&#xD;&#xA;- ...&#xD;&#xA;&#xD;&#xA;All this makes it hard to keep the whole code and doc of one project under Source Code Management (e.g. on Subversion, Git or GitHub).&#xD;&#xA;&#xD;&#xA;Managing source control of your project means managing the version of all files used by the project including 3rd-party libraries.&#xD;&#xA;&#xD;&#xA;Now for a single project, I need to define a directory structure that:&#xD;&#xA;&#xD;&#xA;- Includes all project files as described above&#xD;&#xA;- I can entirely commit to a Source Code Management tool (including 3rd-party dependencies)&#xD;&#xA;- I can checkout anywhere on my hard drive and build the project from there (does it have to be a single location as imposed by Arduino IDE)&#xD;&#xA;- I can zip into a self-contained archive that I can send to a friend for him to build as easily as possible (no extra manual download)&#xD;&#xA;&#xD;&#xA;What I find particularly tricky with Arduino projects is the management of external libraries dependencies. Java projects developers have [maven][1] repositories for that and that helps a lot in managing all external deps. But we don't have an equivalent system for Arduino libraries.&#xD;&#xA;&#xD;&#xA;I would be interested to know how other Arduino project makers deal with these aspects in their own projects.&#xD;&#xA;&#xD;&#xA;Also note that I am open to changing my development process, including my IDE (currently I use Eclipse with the Arduino plugin most of the time, and then I ensure my projects can also work directly with the Arduino IDE).&#xD;&#xA;&#xD;&#xA;  [1]: http://maven.apache.org" />
  <row Id="847" PostHistoryTypeId="4" PostId="348" RevisionGUID="e3a85161-f248-4e89-bc08-f6527eba6654" CreationDate="2014-02-22T17:26:58.043" UserId="84" Comment="fixed grammar, spelling" Text="How to organize my Arduino projects' structure for easy source control?" />
  <row Id="848" PostHistoryTypeId="2" PostId="351" RevisionGUID="6e94c939-9038-4b9a-b087-96b31a48f1ff" CreationDate="2014-02-22T18:38:39.317" UserId="11" Text="The simplest way to do this is to copy the header and code files of the library into your source directory and include them.&#xD;&#xA;&#xD;&#xA;    myproject/&#xD;&#xA;        myproject.ino&#xD;&#xA;        somelib.h&#xD;&#xA;        somelib.cpp&#xD;&#xA;&#xD;&#xA;In your code, you can do `include &quot;somelib.h&quot;`&#xD;&#xA;&#xD;&#xA;The down side to this is that the libraries must be in the same folder, not sub folders, so it makes your directory look messy." />
  <row Id="849" PostHistoryTypeId="5" PostId="351" RevisionGUID="714c7ec8-77af-43b3-a3a9-d9231b9782ba" CreationDate="2014-02-22T19:59:51.550" UserId="11" Comment="added 465 characters in body" Text="The simplest way to do this is to copy the header and code files of the library into your source directory and include them.&#xD;&#xA;&#xD;&#xA;    myproject/&#xD;&#xA;        myproject.ino&#xD;&#xA;        somelib.h&#xD;&#xA;        somelib.cpp&#xD;&#xA;&#xD;&#xA;In your code, you can do `include &quot;somelib.h&quot;`&#xD;&#xA;&#xD;&#xA;The down side to this is that the libraries must be in the same folder, not sub folders, so it makes your directory look messy.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Regarding the directory structure of my entire project, including schematics and documentation, mine usually looks like this:&#xD;&#xA;&#xD;&#xA;    myproject/&#xD;&#xA;      schematics/ - eagle files or whatever you may have&#xD;&#xA;      docs/       - include relevant datasheets here&#xD;&#xA;      test/       - any test cases or other code to test parts of the system.&#xD;&#xA;      myproject/  - since Arduino code must be in a directory of the same name&#xD;&#xA;        myproject.ino&#xD;&#xA;        ...&#xD;&#xA;&#xD;&#xA;" />
  <row Id="850" PostHistoryTypeId="2" PostId="352" RevisionGUID="d014ce79-16f2-42b8-af51-0be48dc41989" CreationDate="2014-02-22T22:25:54.133" UserId="35" Text="As Federico Fissore says above, the Yún can only handle HTTPS (or SSL, whatever you want to call it) on the Linux side of the Yún.&#xD;&#xA;&#xD;&#xA;The first way to do it is using Python with Python OpenSSL. The way you do this is by issuing the following commands via SSH or YunSerialTerminal:&#xD;&#xA;&#xD;&#xA;    opkg update&#xD;&#xA;    opkg install python-openssl&#xD;&#xA;&#xD;&#xA;`opkg update` will make sure the package list is up-to-date, and then `opkg install` installs Python OpenSSL. And then you can talk to the Arduino using Python. [This page on the Arduino website][1] should help you in using Python with Arduino.&#xD;&#xA;&#xD;&#xA;You could also use `curl` with the `-k` option in your sketch. For example:&#xD;&#xA;&#xD;&#xA;    Process process;&#xD;&#xA;    process.runShellCommand(&quot;curl -k http://example.net&quot;);&#xD;&#xA;    while(p.running()); // this waits for the command to be done before continuing&#xD;&#xA;&#xD;&#xA;Also, if you want to download a file, you could use `wget`. This would require you to upgrade `wget` by again issuing these commands via SSH or YunSerialTerminal:&#xD;&#xA;&#xD;&#xA;    opkg update&#xD;&#xA;    opkg upgrade wget&#xD;&#xA;&#xD;&#xA;And then you can just do this in your sketch:&#xD;&#xA;&#xD;&#xA;    Process process;&#xD;&#xA;    process.runShellCommand(&quot;wget http://example.net&quot;);&#xD;&#xA;    while(p.running()); // this waits for the command to be done before continuing&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/interfacing/python#.Uwki4_kiEw8" />
  <row Id="851" PostHistoryTypeId="2" PostId="353" RevisionGUID="3c60d508-c282-43d7-9182-e6923d6fc313" CreationDate="2014-02-23T00:31:46.827" UserId="220" Text="I have a clone of a Mega 2560, and the Chinese manufacture apparently had a broken shift key. To my annoyance, whenever I connect it to my computer it reads, `arduino compatible mega 2560`. With my extreme *annoyance* with *slightly* misspelled or incorrectly capitalised English, it has been very distracting to me.&#xD;&#xA;&#xD;&#xA;However, the reason that I'm asking this question is for more than how to rename it to be capitalised. Think of how many projects could be simplified by this! Or for many Arduinos, you can label they physically and then rename them `Arduino #1`, etc. so you can tell which port it is on using device manager. If you designed a product with Arduino, then you can even rename it to your product name.&#xD;&#xA;&#xD;&#xA;**I would imagine that there would be an easy way to do this by reburning the firmware to the [Insert USB chip model #### here].** I've seen it done for keyboards on the Uno, so I would imagine that you could modify it somehow." />
  <row Id="852" PostHistoryTypeId="1" PostId="353" RevisionGUID="3c60d508-c282-43d7-9182-e6923d6fc313" CreationDate="2014-02-23T00:31:46.827" UserId="220" Text="How can I rename how my Arduino shows up on the computer?" />
  <row Id="853" PostHistoryTypeId="3" PostId="353" RevisionGUID="3c60d508-c282-43d7-9182-e6923d6fc313" CreationDate="2014-02-23T00:31:46.827" UserId="220" Text="&lt;arduino-mega&gt;" />
  <row Id="854" PostHistoryTypeId="2" PostId="354" RevisionGUID="c5825ff3-87f5-4257-899a-0e48a1667e37" CreationDate="2014-02-23T00:37:25.183" UserId="35" Text="Another very cool screen is the official [Arduino TFT LCD Screen][1]. ([Datasheet][2] if you're curious.)&#xD;&#xA;&#xD;&#xA;It's a 1.77&quot; screen, with a resolution of 160x128. It has a micro-SD slot in it, which is easily accessible. It is a color screen, with up to 18 bit per pixel. &#xD;&#xA;&#xD;&#xA;The extremely nice thing with this screen is that since it's officially supported, you don't need to do anything extra to support it. The [official Arduino TFT library][3] works perfectly with it. However, according to [Jameco][4]:&#xD;&#xA;&#xD;&#xA;&gt; Library Update: There is a known issue with the TFT library supplied&#xD;&#xA;&gt; in IDE versions 1.0.5 and 1.5.4 Beta. You will need to replace the&#xD;&#xA;&gt; library. We have zipped up the updated TFT library for both versions&#xD;&#xA;&gt; available here. Just delete the existing library and copy in the&#xD;&#xA;&gt; replacement for the appropriate IDE version and restart the IDE. (IDE&#xD;&#xA;&gt; v1.0.5 or v1.5.4)&#xD;&#xA;&#xD;&#xA;So beside that minor fix, everything should be easy and quick to work with. [This page][3] has some code samples which should make it easy to work with.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://store.arduino.cc/index.php?main_page=product_info&amp;products_id=288#.UwlAY_kiEw8&#xD;&#xA;  [2]: http://arduino.cc/documents/datasheets/A000096_Datasheet_HTF0177SN-01-SPEC.pdf&#xD;&#xA;  [3]: http://arduino.cc/en/Reference/TFTLibrary#.UwlB__kiEw8&#xD;&#xA;  [4]: http://www.jameco.com/1/1/52373-a000096-tft-lcd-screen-runs-5vdc-shields.html" />
  <row Id="855" PostHistoryTypeId="6" PostId="88" RevisionGUID="800e8743-cac9-4b4c-a33c-85d1c9f28a66" CreationDate="2014-02-23T01:45:25.570" UserId="65" Comment="edited tags" Text="&lt;uno&gt;&lt;pins&gt;&lt;current&gt;" />
  <row Id="857" PostHistoryTypeId="2" PostId="355" RevisionGUID="f27f91b0-460a-4999-803a-16ea67ece07d" CreationDate="2014-02-23T02:40:20.173" UserId="65" Text="The Arduino Uno board has limited RAM which means it has a limited call stack available. Sometimes, recursion is the only quick option to implement a certain algorithm. So, given that the call stack is severely limited, what would be a way to find out that given a certain program running on the board, exactly how many recursive calls can you afford before there is a stack overflow?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="858" PostHistoryTypeId="1" PostId="355" RevisionGUID="f27f91b0-460a-4999-803a-16ea67ece07d" CreationDate="2014-02-23T02:40:20.173" UserId="65" Text="How much can I recurse? How much can I recurse? How much ca!@#QFSD@$RFW" />
  <row Id="859" PostHistoryTypeId="3" PostId="355" RevisionGUID="f27f91b0-460a-4999-803a-16ea67ece07d" CreationDate="2014-02-23T02:40:20.173" UserId="65" Text="&lt;programming&gt;&lt;sram&gt;" />
  <row Id="860" PostHistoryTypeId="5" PostId="355" RevisionGUID="bf60444f-2c52-40b8-a077-72bcc10a7c87" CreationDate="2014-02-23T02:45:37.733" UserId="65" Comment="added 24 characters in body" Text="The Arduino Uno board has limited RAM which means it has a limited call stack available. Sometimes, recursion is the only quick option to implement a certain algorithm. So, given that the call stack is severely limited, what would be a way to find out that given a certain program running on the board, exactly how many recursive calls can you afford before there is a stack overflow (and bad things happen)?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="861" PostHistoryTypeId="2" PostId="356" RevisionGUID="4476bde7-4bc8-4242-80dd-30fed2213eeb" CreationDate="2014-02-23T05:06:01.823" UserId="35" Text="I'd like to be able to use Python from a sketch. According to [the Arduino website](http://playground.arduino.cc/interfacing/python#.Uwl-r6go6aw), one can use PySerial from a computer to talk with an Arduino via Python. &#xA;&#xA;It looks like from that page you can also use various API's to execute Python directly on the Arduino. However, I'd like to know if you can execute Python directly from a sketch. It would be nice because then you could execute Python directly from a sketch, and not all of it would have to be written in Python.&#xA;&#xA;If this is not possible, is there an easy way to execute Python on an Arduino? Looking at the various API's it was hard to determine exactly how to execute the `.py` scripts." />
  <row Id="862" PostHistoryTypeId="1" PostId="356" RevisionGUID="4476bde7-4bc8-4242-80dd-30fed2213eeb" CreationDate="2014-02-23T05:06:01.823" UserId="35" Text="How can I use Python from a sketch?" />
  <row Id="863" PostHistoryTypeId="3" PostId="356" RevisionGUID="4476bde7-4bc8-4242-80dd-30fed2213eeb" CreationDate="2014-02-23T05:06:01.823" UserId="35" Text="&lt;programming&gt;&lt;python&gt;&lt;sketch&gt;" />
  <row Id="864" PostHistoryTypeId="2" PostId="357" RevisionGUID="6be33a29-c4a2-4308-9cce-6f4902dc3947" CreationDate="2014-02-23T05:44:37.530" UserId="11" Text="&gt; It looks like from that page you can also use various API's to execute&#xD;&#xA;&gt; Python directly on the Arduino.&#xD;&#xA;&#xD;&#xA;I don't see that, at all. All those links show you how to communicate with the Arduino over serial using Python on the host side.&#xD;&#xA;&#xD;&#xA;You'd need a python interpreter to be able to run python on the Arduino. There is the [Python On A Chip][1] project and it seems like they have support for the Mega.&#xD;&#xA;&#xD;&#xA;&gt; 2010/09/01 (1bdb8d31f27b) New platform: Arduino Mega.&#xD;&#xA;&#xD;&#xA;Some more info from the [PyMite page][2]:&#xD;&#xA;&#xD;&#xA;&gt; any device in the AtMega family which meets these requirements: 20KiB&#xD;&#xA;&gt; Flash and 4K RAM, will run today&#xD;&#xA;&#xD;&#xA;I doubt you'll find anything that'll let you mix Arduino and Python code in the same sketch.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://code.google.com/p/python-on-a-chip/&#xD;&#xA;  [2]: https://wiki.python.org/moin/PyMite" />
  <row Id="865" PostHistoryTypeId="2" PostId="358" RevisionGUID="921f77c3-9a94-45c2-8784-c071710d58ce" CreationDate="2014-02-23T06:05:49.080" UserId="83" Text="This string is contained in the FT232 USB to UART interface chip and the manufacturer has released [the FT_PROG tool](http://www.ftdichip.com/Support/Utilities.htm) to reprogram it. But do take not of the warning on their website: &quot;**PLEASE NOTE - The use of some of these utilities by an end user may result in a device being rendered useless**&quot;. Another word of warning is to **ensure there is only one device connected with an FTDI-chip**.&#xD;&#xA;&#xD;&#xA;Just an impression of the mprog tool:&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/8outD.jpg" />
  <row Id="866" PostHistoryTypeId="2" PostId="359" RevisionGUID="8626aecd-c767-4c43-aa23-593846e79c38" CreationDate="2014-02-23T06:30:01.247" UserId="83" Text="Recursion is bad practice on a microcontroller as you already stated yourself and you probably want to avoid it whenever possible. On [the Arduino site there are some examples and libraries available for checking free RAM size](http://playground.arduino.cc/Code/AvailableMemory). You can for example use this to figure out when to break recursion or a bit trickier/riskier to profile your sketch and hard code the limit in it. This profile would be required for every change in your program and for every change in Arduino tool chain." />
  <row Id="867" PostHistoryTypeId="2" PostId="360" RevisionGUID="6b17cf00-8589-4c71-941f-c5ba740e8cc7" CreationDate="2014-02-23T10:07:26.880" UserId="42" Text="It depends on the function.&#xD;&#xA;&#xD;&#xA;Every time a function is called, a new frame is pushed onto the stack. It will usually contain various critical items, potentially including:&#xD;&#xA;&#xD;&#xA; * Return address (the point in the code from which the function was called).&#xD;&#xA; * The local instance pointer (`this`) if calling a member function.&#xD;&#xA; * Parameters passed into the function.&#xD;&#xA; * Register values which need to be restored when the function ends.&#xD;&#xA; * Space for local variables inside the called function.&#xD;&#xA;&#xD;&#xA;As you can see, the stack space required for a given call depends on the function. For example, if you write a recursive function which only takes an `int` parameter and uses no local variables, it won't need much more than a few bytes on the stack. That means you can recursively call it far more than a function which takes several parameters and uses a lot of local variables (which will eat up the stack much quicker).&#xD;&#xA;&#xD;&#xA;Obviously the state of the stack depends on what else is going on in the code. If you start a recursion directly within the standard `loop()` function, then there probably won't be a lot on the stack already. However, if you start it nested several levels deep in other functions, then there won't be as much room. That will affect how many times you can recurse without exhausting the stack.&#xD;&#xA;&#xD;&#xA;It's worth noting that tail recursion optimisation exists on some compilers (although I'm not sure if avr-gcc supports it). If the recursive call is the very last thing in a function, it means it is sometimes possible to avoid altering the stack frame at all. The compiler can just re-use the existing frame, since the 'parent' call (so to speak) is finished using it. That will mean you can theoretically keep recursing as much as you like, so long as your function doesn't call anything else." />
  <row Id="868" PostHistoryTypeId="2" PostId="361" RevisionGUID="66d1dfbb-3dd9-46c0-a9e7-9fb581bbea4a" CreationDate="2014-02-23T10:17:40.737" UserId="84" Text="If you really want to recurse (and as @jippie said it is a bad idea; subliminal message:  **don't do it**) and want to know how much you can recurse, then you will have to perform some calculation and experiments; also you generally will have only an approximation of it as it depends a lot on the memory state at the time your recursive function will be called.&#xD;&#xA;&#xD;&#xA;For this, you should first know how SRAM is organized inside AVR-based Arduino (it won't apply to e.g. the Arduino Galileo by Intel). The following diagram from Adafruit shows it clearly:&#xD;&#xA;&#xD;&#xA;![SRAM organization][1]&#xD;&#xA;&#xD;&#xA;Then you need to know the total size of your SRAM (depends on Atmel MCU, hence what kind of Arduino board you have).&#xD;&#xA;&#xD;&#xA;On this diagram, it is easy to find out ths size of **Static Data** block as it is known at compile-time and won't change later on.&#xD;&#xA;&#xD;&#xA;The **Heap** size can be more difficult to know as it can vary at runtime, depending on dynamic memory allocations (`malloc` or `new`) performed by your sketch or the libraries it uses. Using dynamic memory is quite rare on Arduino, but some standard functions do it (type `String` uses it, I think).&#xD;&#xA;&#xD;&#xA;For the **Stack** size, it will also vary during runtime, based on the current depth of function calls (each function call takes 2 bytes on the Stack to store the address of the caller) and the number and size of local variables including passed arguments (that are also stored on the **Stack**) for all the functions called until now.&#xD;&#xA;&#xD;&#xA;So let's suppose your `recurse()` function uses 12 bytes for its local variables and arguments, then each call to this function (the first one from an external caller and the recursive ones) will use `12+2` bytes.&#xD;&#xA;&#xD;&#xA;If we suppose that:&#xD;&#xA;&#xD;&#xA; - you are on Arduino UNO (SRAM = 2K)&#xD;&#xA; - your sketch does not use dynamic memory allocation (no **Heap**)&#xD;&#xA; - you know the size of your **Static Data** (let's say 132 bytes)&#xD;&#xA; - when your `recurse()` function is called from your sketch, the current **Stack** is 128 bytes long&#xD;&#xA;&#xD;&#xA;Then you are left with `2048 - 132 - 128 = 1788` available bytes on the **Stack**. The number of recursive calls to your function is thus `1788 / 14 = 127`, including the initial call (which is not a recursive one).&#xD;&#xA;&#xD;&#xA;As you can see, this is very difficult, but not impossible to find what you want.&#xD;&#xA;&#xD;&#xA;A simpler way to get the stack size available before `recurse()` is called would be to use the following function (found on Adafruit learning center; I have not tested it myself):&#xD;&#xA;&#xD;&#xA;    int freeRam () &#xD;&#xA;    {&#xD;&#xA;      extern int __heap_start, *__brkval; &#xD;&#xA;      int v; &#xD;&#xA;      return (int) &amp;v - (__brkval == 0 ? (int) &amp;__heap_start : (int) __brkval); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I strongly encourage you to read [this article][2] at Adafruit learning center.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/kosMi.gif&#xD;&#xA;  [2]: http://learn.adafruit.com/memories-of-an-arduino/you-know-you-have-a-memory-problem-when-dot-dot-dot" />
  <row Id="869" PostHistoryTypeId="2" PostId="362" RevisionGUID="bf720c5c-2234-4f39-842d-39e1fc28c7b8" CreationDate="2014-02-23T11:23:48.887" UserId="84" Text="Currently; when I start a new Arduino project with some new hardware, the first thing I do is to look for 3rd-party libraries that bring Arduino support for this hardware.&#xD;&#xA;&#xD;&#xA;The first places I look are:&#xD;&#xA;&#xD;&#xA;- [The Arduino Playground][1]&#xD;&#xA;- [GitHub][2]&#xD;&#xA;- [Google][3]&#xD;&#xA;&#xD;&#xA;Generally I find either no support library or several different libraries (it's quite rare to find only one) in different locations with different levels of documentation, different levels of testing...&#xD;&#xA;&#xD;&#xA;Once I have found the library I need (sometimes I need to try several), I download it to my Arduino libraries folder, I use it and I forget it.&#xD;&#xA;&#xD;&#xA;I find this process cumbersome:&#xD;&#xA;&#xD;&#xA;- manual search with different possible options, not always well documented&#xD;&#xA;- manual download and install to Arduino libraries&#xD;&#xA;- no version control in the process (all versions of a library have the same name and thus cannot coexist in the Arduino library folder).&#xD;&#xA;&#xD;&#xA;I wish there was a central repository with all available libraries for arduino, with:&#xD;&#xA;&#xD;&#xA;- description (supported hardware, supported boards)&#xD;&#xA;- source code&#xD;&#xA;- documentation&#xD;&#xA;- versions&#xD;&#xA;&#xD;&#xA;And a tool (Arduino IDE or external) to access this repository at project build time.&#xD;&#xA;&#xD;&#xA;A kind of [maven][4] for Arduino in fact.&#xD;&#xA;&#xD;&#xA;I have seen several discussions once took place on Arduino forum, but it seems they led nowhere:&#xD;&#xA;&#xD;&#xA;- [Arduino Libraries Census and Repository][5]&#xD;&#xA;- [Arduino Library downloader][6]&#xD;&#xA;- [Arduino Library downloader (2)][7]&#xD;&#xA;&#xD;&#xA;Are there other options, that are made it to something usable (from the community or individuals, why not)?&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/&#xD;&#xA;  [2]: https://github.com/&#xD;&#xA;  [3]: http://www.google.com&#xD;&#xA;  [4]: http://maven.apache.org&#xD;&#xA;  [5]: http://forum.arduino.cc/index.php?topic=73531.0&#xD;&#xA;  [6]: http://forum.arduino.cc/index.php/topic,1460.0.html&#xD;&#xA;  [7]: http://forum.arduino.cc/index.php/topic,63215.0.html" />
  <row Id="870" PostHistoryTypeId="1" PostId="362" RevisionGUID="bf720c5c-2234-4f39-842d-39e1fc28c7b8" CreationDate="2014-02-23T11:23:48.887" UserId="84" Text="Where can I find a central repository of all available Arduino libraries?" />
  <row Id="871" PostHistoryTypeId="3" PostId="362" RevisionGUID="bf720c5c-2234-4f39-842d-39e1fc28c7b8" CreationDate="2014-02-23T11:23:48.887" UserId="84" Text="&lt;library&gt;&lt;repository&gt;" />
  <row Id="872" PostHistoryTypeId="6" PostId="362" RevisionGUID="155d87f6-fb08-43bc-a49e-5bc15d57b928" CreationDate="2014-02-23T13:11:33.853" UserId="65" Comment="edited tags" Text="&lt;library&gt;" />
  <row Id="873" PostHistoryTypeId="33" PostId="296" RevisionGUID="afb1c8b4-839c-4389-8a26-bd05a39ae28d" CreationDate="2014-02-23T14:24:08.237" UserId="37" Comment="1" />
  <row Id="874" PostHistoryTypeId="2" PostId="363" RevisionGUID="8d93f104-8218-4448-99da-55d62e83c5cf" CreationDate="2014-02-23T14:50:01.847" UserId="86" Text="There is none. Unfortunately, you will have to manually search for each library you are interested in.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;If you are interested in creating such a central repository, while it would be awesome, this is not the correct forum in which to do it." />
  <row Id="875" PostHistoryTypeId="2" PostId="364" RevisionGUID="a51ab9c5-5a21-488c-a8b7-b6c20541438c" CreationDate="2014-02-23T14:54:03.270" UserId="86" Text="[I'm going to steal my answer from when I answered this question on the last arduino SE attempt.][5]&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;This is a bit complex. Basically, there are a number of limiting factors:&#xD;&#xA;&#xD;&#xA;The IO lines from the microcontroller (i.e. the analog and digital pins) have both an aggregate (e.g. total) current limit, and an per-pin limit:&#xD;&#xA;&#xD;&#xA;![enter image description here][1]  &#xD;&#xA;&lt;sup&gt;&lt;sub&gt;From the [ATmega328P datasheet][2].&lt;/sub&gt;&lt;/sup&gt;&#xD;&#xA;&#xD;&#xA;However, depending on how you define the Arduino &quot;Pins&quot;, this is not the entire story. &#xD;&#xA;&#xD;&#xA;The 5V pin of the arduino is *not connected through the microcontroller*. As such, it can source significantly more power. When you are powering your arduino from USB, the USB interface limits your total power consumption to 500 mA. This is shared with the devices on the arduino board, so the available power will be somewhat less.  &#xD;&#xA;When you are using an external power supply, through the barrel power connector, you are limited by the local 5V regulator, which is rated for a maximum of **1 Amp**. However, this it also *thermally limited*, meaning that as you draw power, the regulator will heat up. When it overheats, it will shut down temporarily.&#xD;&#xA;&#xD;&#xA;The 3.3V regulated output is able to supply 150 mA max, which is the limit of the 3.3V regulator.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;In Summary&#xD;&#xA;-&#xD;&#xA;&#xD;&#xA; - The *absolute maximum* for any single IO pin is **40 mA** (&lt;sub&gt;&lt;sup&gt;this is the *maximum*. You should never actually pull a full 40 mA from a pin. Basically, it's the threshold at which Atmel can no longer guarantee the chip won't be damaged. You should always ensure you're safely *below* this current limit.&lt;/sub&gt;&lt;/sup&gt;)&#xD;&#xA; - The total current from all the IO pins together is **200 mA max** &#xD;&#xA; - The 5V output pin is good for **~400 mA on USB, ~900 mA when using an external power adapter**&#xD;&#xA;    - The 900 mA is for an adapter that provides ~7V. As the adapter voltage increases, the amount of heat the regulator has to deal with also increases, so the maximum current will drop as the voltage increases. &lt;sub&gt;&lt;sup&gt;This is called *thermal limiting*&lt;/sup&gt;&lt;/sub&gt;&#xD;&#xA; - The 3.3V output is capable of supplying **150 mA**. &#xD;&#xA;   - Note - Any power drawn from the 3.3V rail *has to go through the 5V rail*. Therefore, if you have a 100 mA device on the 3.3V output, you need to *also* count it against the 5V total current.&#xD;&#xA;&#xD;&#xA;**&lt;sub&gt;Note: This does not apply to the Arduino Due, and there are likely some differences for the Arduino Mega. It is likely generally true for any Arduino based off the ATmega328 microcontroller.&lt;/sub&gt;**&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/nLAlB.png&#xD;&#xA;  [2]: http://www.atmel.com/Images/doc8161.pdf&#xD;&#xA;&#xD;&#xA;  [5]: http://electronics.stackexchange.com/questions/67092/how-much-current-can-i-draw-from-the-arduinos-pins/67094#67094" />
  <row Id="876" PostHistoryTypeId="6" PostId="342" RevisionGUID="fc8fda50-bc75-4014-8a60-d0beee7b7343" CreationDate="2014-02-23T14:56:34.517" UserId="220" Comment="SD card is easier to understand for newbies" Text="&lt;fat&gt;&lt;sd-card&gt;" />
  <row Id="877" PostHistoryTypeId="24" PostId="342" RevisionGUID="fc8fda50-bc75-4014-8a60-d0beee7b7343" CreationDate="2014-02-23T14:56:34.517" Comment="Proposed by 220 approved by 261 edit id of 70" />
  <row Id="879" PostHistoryTypeId="6" PostId="60" RevisionGUID="50535c7c-c0c7-4f59-9260-4b3022e62598" CreationDate="2014-02-23T15:22:16.377" UserId="220" Comment="Electronics is too vague and only used once, a more specific tag should be used like damage prevention" Text="&lt;safety&gt;" />
  <row Id="880" PostHistoryTypeId="24" PostId="60" RevisionGUID="50535c7c-c0c7-4f59-9260-4b3022e62598" CreationDate="2014-02-23T15:22:16.377" Comment="Proposed by 220 approved by 8, 65 edit id of 72" />
  <row Id="881" PostHistoryTypeId="6" PostId="269" RevisionGUID="79de6f7b-1400-49d5-b95f-6dee07130ccb" CreationDate="2014-02-23T15:22:44.050" UserId="220" Comment="Removed tags that will never be relevant to any other question" Text="&lt;uno&gt;&lt;sensors&gt;&lt;arduino-mega&gt;" />
  <row Id="882" PostHistoryTypeId="24" PostId="269" RevisionGUID="79de6f7b-1400-49d5-b95f-6dee07130ccb" CreationDate="2014-02-23T15:22:44.050" Comment="Proposed by 220 approved by 8, 65 edit id of 71" />
  <row Id="883" PostHistoryTypeId="2" PostId="365" RevisionGUID="7f017cc3-d446-4dbf-aa1d-815a75b7bfb6" CreationDate="2014-02-23T15:32:18.337" UserId="8" Text="I wrote this simple test program:&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      // put your setup code here, to run once:&#xD;&#xA;      Serial.begin(115200);&#xD;&#xA;      recurse(1);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      // put your main code here, to run repeatedly: &#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void recurse(long i) {&#xD;&#xA;      Serial.println(i);&#xD;&#xA;      recurse(i+1);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I compiled it for the Uno, and as i write it has recursed over 1 million times! I don't know, but the compiler may have optimized this program" />
  <row Id="884" PostHistoryTypeId="6" PostId="17" RevisionGUID="3f2a75fb-bff5-4386-b20b-edb53f1bfe25" CreationDate="2014-02-23T15:55:22.557" UserId="220" Comment="`Connection` tag is too vague." Text="&lt;uploading&gt;" />
  <row Id="885" PostHistoryTypeId="24" PostId="17" RevisionGUID="3f2a75fb-bff5-4386-b20b-edb53f1bfe25" CreationDate="2014-02-23T15:55:22.557" Comment="Proposed by 220 approved by 37 edit id of 74" />
  <row Id="886" PostHistoryTypeId="6" PostId="189" RevisionGUID="e2de9816-6a11-4dd3-9863-1c0c99884186" CreationDate="2014-02-23T15:57:02.347" UserId="220" Comment="`Communication` didn't add to the post and `programming` should be `sketch`." Text="&lt;sketch&gt;" />
  <row Id="887" PostHistoryTypeId="24" PostId="189" RevisionGUID="e2de9816-6a11-4dd3-9863-1c0c99884186" CreationDate="2014-02-23T15:57:02.347" Comment="Proposed by 220 approved by 37 edit id of 77" />
  <row Id="888" PostHistoryTypeId="6" PostId="179" RevisionGUID="2bc9e755-b319-4620-8c64-f98c2e235243" CreationDate="2014-02-23T15:57:17.817" UserId="37" Comment="edited tags" Text="&lt;sketch&gt;" />
  <row Id="889" PostHistoryTypeId="2" PostId="366" RevisionGUID="83191d88-d57e-496c-a14b-e4ece2761a31" CreationDate="2014-02-23T16:20:24.350" UserId="37" Text="The [Arduino Playground LibraryList][1] and the [standard library list][2] appear to be the official pages for that.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Main/LibraryList&#xD;&#xA;  [2]: http://arduino.cc/en/Reference/Libraries" />
  <row Id="890" PostHistoryTypeId="6" PostId="340" RevisionGUID="34774d8c-e910-48ba-a6e4-4d8157275e09" CreationDate="2014-02-23T16:28:58.203" UserId="37" Comment="edited tags" Text="&lt;uno&gt;" />
  <row Id="891" PostHistoryTypeId="24" PostId="340" RevisionGUID="34774d8c-e910-48ba-a6e4-4d8157275e09" CreationDate="2014-02-23T16:28:58.203" Comment="Proposed by 37 approved by 262 edit id of 84" />
  <row Id="892" PostHistoryTypeId="6" PostId="37" RevisionGUID="3d16aa10-02b0-497a-afa1-f0f5ad30080e" CreationDate="2014-02-23T16:53:39.687" UserId="220" Comment="Removed a tag that was vague and added a new tag that will be useful for other questions, too." Text="&lt;compile&gt;&lt;sketch-size&gt;" />
  <row Id="893" PostHistoryTypeId="24" PostId="37" RevisionGUID="3d16aa10-02b0-497a-afa1-f0f5ad30080e" CreationDate="2014-02-23T16:53:39.687" Comment="Proposed by 220 approved by -1, 65 edit id of 79" />
  <row Id="894" PostHistoryTypeId="6" PostId="37" RevisionGUID="8bc077b6-a478-4ebf-ad4b-007e1dc82089" CreationDate="2014-02-23T16:53:39.687" UserId="60" Comment="Removed a tag that was vague and added a new tag that will be useful for other questions, too. kept memory as the question is about resource of chip and not sketch" Text="&lt;compile&gt;&lt;memory&gt;&lt;sketch-size&gt;" />
  <row Id="895" PostHistoryTypeId="5" PostId="356" RevisionGUID="d3d44a9c-30c4-460f-bb1e-7c0b417c1ec1" CreationDate="2014-02-23T16:56:03.817" UserId="35" Comment="Updated information" Text="I'd like to be able to use Python from a sketch. According to [the Arduino website][1], one can use PySerial from a computer to talk with an Arduino via Python. &#xD;&#xA;&#xD;&#xA;It looks like from that page you can also use various API's to use Python with an Arduino from a computer. However, I'd like to know if you can execute Python directly from a sketch. It would be nice because then you could execute Python directly from a sketch, and not all of it would have to be written in Python.&#xD;&#xA;&#xD;&#xA;If this is not possible, is there an easy way to execute Python on an Arduino? Looking at the various API's it was hard to determine exactly what they did, and if you could execute a `.py` script from a computer or from anything on the Arduino.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/interfacing/python#.Uwl-r6go6aw" />
  <row Id="896" PostHistoryTypeId="6" PostId="158" RevisionGUID="37f05ad7-699f-4255-a2b4-e27df23d2840" CreationDate="2014-02-23T17:01:20.390" UserId="220" Comment="`Connection` tag is too vague." Text="&lt;i2c&gt;" />
  <row Id="897" PostHistoryTypeId="24" PostId="158" RevisionGUID="37f05ad7-699f-4255-a2b4-e27df23d2840" CreationDate="2014-02-23T17:01:20.390" Comment="Proposed by 220 approved by 8, 65 edit id of 75" />
  <row Id="898" PostHistoryTypeId="6" PostId="279" RevisionGUID="c5ddb5ce-8603-4378-83f2-b3ac29a1ae72" CreationDate="2014-02-23T17:02:30.913" UserId="37" Comment="edited tags" Text="&lt;unique-identifier&gt;" />
  <row Id="899" PostHistoryTypeId="24" PostId="279" RevisionGUID="c5ddb5ce-8603-4378-83f2-b3ac29a1ae72" CreationDate="2014-02-23T17:02:30.913" Comment="Proposed by 37 approved by 8, 65 edit id of 80" />
  <row Id="900" PostHistoryTypeId="6" PostId="156" RevisionGUID="2a86544f-59e7-4554-a9d1-677e623d40f9" CreationDate="2014-02-23T17:02:37.447" UserId="220" Comment="`Connection` tag is too vague." Text="&lt;serial&gt;&lt;safety&gt;&lt;arduino-due&gt;" />
  <row Id="901" PostHistoryTypeId="24" PostId="156" RevisionGUID="2a86544f-59e7-4554-a9d1-677e623d40f9" CreationDate="2014-02-23T17:02:37.447" Comment="Proposed by 220 approved by 8, 65 edit id of 73" />
  <row Id="902" PostHistoryTypeId="2" PostId="367" RevisionGUID="c82802db-25b7-4779-96b8-352d57dbd607" CreationDate="2014-02-23T17:04:46.790" UserId="-1" Text="" />
  <row Id="903" PostHistoryTypeId="2" PostId="368" RevisionGUID="ece877e4-78e1-448c-b761-282b3479bc52" CreationDate="2014-02-23T17:04:46.790" UserId="-1" Text="" />
  <row Id="904" PostHistoryTypeId="2" PostId="369" RevisionGUID="fc209500-a122-403b-a0ce-75f309573201" CreationDate="2014-02-23T17:06:23.627" UserId="-1" Text="" />
  <row Id="905" PostHistoryTypeId="2" PostId="370" RevisionGUID="b94dce60-09ce-4e90-bb79-a30f29f83cc7" CreationDate="2014-02-23T17:06:23.627" UserId="-1" Text="" />
  <row Id="906" PostHistoryTypeId="2" PostId="371" RevisionGUID="4ae49fba-0071-4561-9e35-5672c6cfa389" CreationDate="2014-02-23T17:08:06.260" UserId="-1" Text="" />
  <row Id="907" PostHistoryTypeId="2" PostId="372" RevisionGUID="434352ec-4968-4db0-a0e3-c64a5e716dc2" CreationDate="2014-02-23T17:08:06.260" UserId="-1" Text="" />
  <row Id="908" PostHistoryTypeId="2" PostId="373" RevisionGUID="cecfc456-5988-4f18-8470-b0c3f3a07744" CreationDate="2014-02-23T17:10:15.540" UserId="-1" Text="" />
  <row Id="909" PostHistoryTypeId="2" PostId="374" RevisionGUID="c2e46d56-516d-4301-8d47-4c163ccf14bd" CreationDate="2014-02-23T17:10:15.540" UserId="-1" Text="" />
  <row Id="910" PostHistoryTypeId="6" PostId="304" RevisionGUID="8b54459f-02d3-477d-8147-f2c7eecdf9f7" CreationDate="2014-02-23T17:10:44.667" UserId="37" Comment="edited tags" Text="&lt;uno&gt;&lt;clones&gt;&lt;pins&gt;" />
  <row Id="911" PostHistoryTypeId="24" PostId="304" RevisionGUID="8b54459f-02d3-477d-8147-f2c7eecdf9f7" CreationDate="2014-02-23T17:10:44.667" Comment="Proposed by 37 approved by 8, 46 edit id of 81" />
  <row Id="912" PostHistoryTypeId="2" PostId="375" RevisionGUID="221d69a0-1d9c-4ccf-8a36-fdc5daf7abc7" CreationDate="2014-02-23T17:12:34.490" UserId="-1" Text="" />
  <row Id="913" PostHistoryTypeId="2" PostId="376" RevisionGUID="93a7ec3b-7e2b-46de-b144-821828ecb28e" CreationDate="2014-02-23T17:12:34.490" UserId="-1" Text="" />
  <row Id="914" PostHistoryTypeId="5" PostId="156" RevisionGUID="0d6b8317-35b2-4404-ae86-7c800b996cb2" CreationDate="2014-02-23T17:23:39.830" UserId="35" Comment="Fixed grammar, formatted, removed safety tag as this isn't really dealing with a safe way to do things" Text="I'm using a [DigiX][1] (Arduino Due based 3.3V) board to connect to a GPRS/GSM SIM908 breakout board. The SIM908 EVB board has the following pins on its RS232:![RS232 pinout][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I've got all three UART TX lines hooked up to the RX Lines (and RX to TX) on my Arduino but the board keeps resetting, which I would guess is some sort of voltage issue (I turned the board off immediately). However there are three MAX3232s on the underside of the board, which I thought would have made it so I could just connect the lines directly to the Arduino. Does anyone know why this might be happening or how to properly connect these two devices?&#xD;&#xA;&#xD;&#xA;Additional info:&#xD;&#xA;&#xD;&#xA;[Pinout of the DigiX][3].&#xD;&#xA;&#xD;&#xA;[Schematic of the DigiX][4]. &#xD;&#xA;&#xD;&#xA;(The below links are in Chinese):&#xD;&#xA;&#xD;&#xA;Here is [a SIM908 Hardware guide][5].&#xD;&#xA;&#xD;&#xA;[The full schematic of the breakout board][6].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://digistump.com/wiki/digix&#xD;&#xA;  [2]: http://i.imgur.com/muN5cZA.png&#xD;&#xA;  [3]: http://digistump.com/wiki/digix/tutorials/pinout&#xD;&#xA;  [4]: http://digispark.s3.amazonaws.com/DigiX-V1-Final-Production.pdf&#xD;&#xA;  [5]: http://pan.baidu.com/share/link?shareid=1471365276&amp;uk=4130796101&amp;third=15&#xD;&#xA;  [6]: http://pan.baidu.com/share/link?shareid=1470501867&amp;uk=4130796101&amp;third=15" />
  <row Id="915" PostHistoryTypeId="4" PostId="156" RevisionGUID="0d6b8317-35b2-4404-ae86-7c800b996cb2" CreationDate="2014-02-23T17:23:39.830" UserId="35" Comment="Fixed grammar, formatted, removed safety tag as this isn't really dealing with a safe way to do things" Text="Connecting breakout board to Arduino with UART" />
  <row Id="916" PostHistoryTypeId="6" PostId="156" RevisionGUID="0d6b8317-35b2-4404-ae86-7c800b996cb2" CreationDate="2014-02-23T17:23:39.830" UserId="35" Comment="Fixed grammar, formatted, removed safety tag as this isn't really dealing with a safe way to do things" Text="&lt;serial&gt;&lt;arduino-due&gt;" />
  <row Id="917" PostHistoryTypeId="24" PostId="156" RevisionGUID="0d6b8317-35b2-4404-ae86-7c800b996cb2" CreationDate="2014-02-23T17:23:39.830" Comment="Proposed by 35 approved by 46, 65 edit id of 89" />
  <row Id="918" PostHistoryTypeId="2" PostId="377" RevisionGUID="fad54df3-0c70-41f6-bbb4-8829fa63a8d0" CreationDate="2014-02-23T17:44:57.963" UserId="-1" Text="" />
  <row Id="919" PostHistoryTypeId="2" PostId="378" RevisionGUID="93a2c813-d8d4-4bc3-b537-2bde279a828c" CreationDate="2014-02-23T17:44:57.963" UserId="-1" Text="" />
  <row Id="920" PostHistoryTypeId="6" PostId="85" RevisionGUID="5e754a98-e3db-4566-804d-77e4f1539747" CreationDate="2014-02-23T18:56:18.287" UserId="37" Comment="edited tags" Text="&lt;uno&gt;&lt;serial&gt;&lt;uploading&gt;&lt;pins&gt;" />
  <row Id="921" PostHistoryTypeId="24" PostId="85" RevisionGUID="5e754a98-e3db-4566-804d-77e4f1539747" CreationDate="2014-02-23T18:56:18.287" Comment="Proposed by 37 approved by 8, 11 edit id of 83" />
  <row Id="922" PostHistoryTypeId="6" PostId="316" RevisionGUID="a7d0f590-e0cc-46f7-8c92-54410a161617" CreationDate="2014-02-23T18:56:34.133" UserId="220" Comment="`Pins` is the term for GPIO on Arduino." Text="&lt;pins&gt;&lt;interrupt&gt;&lt;input&gt;&lt;isr&gt;" />
  <row Id="923" PostHistoryTypeId="24" PostId="316" RevisionGUID="a7d0f590-e0cc-46f7-8c92-54410a161617" CreationDate="2014-02-23T18:56:34.133" Comment="Proposed by 220 approved by 8, 11 edit id of 78" />
  <row Id="924" PostHistoryTypeId="6" PostId="206" RevisionGUID="daa3ed3f-bf54-4094-a7af-bb0f9315708f" CreationDate="2014-02-23T18:56:36.650" UserId="37" Comment="edited tags" Text="&lt;safety&gt;&lt;pins&gt;&lt;led&gt;&lt;resistor&gt;" />
  <row Id="925" PostHistoryTypeId="24" PostId="206" RevisionGUID="daa3ed3f-bf54-4094-a7af-bb0f9315708f" CreationDate="2014-02-23T18:56:36.650" Comment="Proposed by 37 approved by 8, 11 edit id of 82" />
  <row Id="926" PostHistoryTypeId="6" PostId="221" RevisionGUID="d8c6ace0-2fb9-463f-9a62-ec75a66a2cdd" CreationDate="2014-02-23T18:56:46.587" UserId="220" Comment="`Expansion` tag is too vague: could be with memory, pins, or even a shield. `Memory` is too vague, too. Used `sketch-size` instead. `sram` isn't really relevant, either." Text="&lt;flash&gt;&lt;sketch-size&gt;" />
  <row Id="927" PostHistoryTypeId="24" PostId="221" RevisionGUID="d8c6ace0-2fb9-463f-9a62-ec75a66a2cdd" CreationDate="2014-02-23T18:56:46.587" Comment="Proposed by 220 approved by 8, 11 edit id of 76" />
  <row Id="928" PostHistoryTypeId="6" PostId="331" RevisionGUID="30aae993-2c72-4eb2-b3a1-67cecfada4a1" CreationDate="2014-02-23T18:56:55.103" UserId="220" Comment="Clock should be split down into different groups: RTC/time and the physical oscillator clock" Text="&lt;uno&gt;&lt;lcd&gt;&lt;oscillator-clock&gt;" />
  <row Id="929" PostHistoryTypeId="24" PostId="331" RevisionGUID="30aae993-2c72-4eb2-b3a1-67cecfada4a1" CreationDate="2014-02-23T18:56:55.103" Comment="Proposed by 220 approved by 11, 65 edit id of 92" />
  <row Id="930" PostHistoryTypeId="5" PostId="374" RevisionGUID="3b4244e2-ecd3-4361-8e30-4c8e008e31f1" CreationDate="2014-02-23T19:07:29.223" UserId="220" Comment="added 96 characters in body" Text="the standard USB connection between the Arduino and a computer with a standard USB A to B cable." />
  <row Id="931" PostHistoryTypeId="24" PostId="374" RevisionGUID="3b4244e2-ecd3-4361-8e30-4c8e008e31f1" CreationDate="2014-02-23T19:07:29.223" Comment="Proposed by 220 approved by 11, 48 edit id of 88" />
  <row Id="932" PostHistoryTypeId="5" PostId="378" RevisionGUID="e6479c29-761a-47c3-96c7-b9a551881f2e" CreationDate="2014-02-23T19:07:52.193" UserId="35" Comment="added 208 characters in body" Text="Python is a programming language. Use this tag for questions regarding how to use Python with your Arduino, or on using of pySerial or such software. Also consider using [programming] and other specific tags." />
  <row Id="933" PostHistoryTypeId="24" PostId="378" RevisionGUID="e6479c29-761a-47c3-96c7-b9a551881f2e" CreationDate="2014-02-23T19:07:52.193" Comment="Proposed by 35 approved by 11, 48 edit id of 94" />
  <row Id="934" PostHistoryTypeId="5" PostId="368" RevisionGUID="666e693c-40ef-40c8-98d1-086efc7b4991" CreationDate="2014-02-23T19:08:15.413" UserId="220" Comment="added 89 characters in body" Text="a filesystem that allows files to be stored on a SD card or similar device on an Arduino." />
  <row Id="935" PostHistoryTypeId="24" PostId="368" RevisionGUID="666e693c-40ef-40c8-98d1-086efc7b4991" CreationDate="2014-02-23T19:08:15.413" Comment="Proposed by 220 approved by 11, 48 edit id of 85" />
  <row Id="936" PostHistoryTypeId="5" PostId="377" RevisionGUID="0bded61a-d7cd-4d50-8e9c-14df46f7fcbd" CreationDate="2014-02-23T19:08:17.867" UserId="35" Comment="added 771 characters in body" Text="Python is a programming language. It is often used as a scripting language, but has many other uses. &#xD;&#xA;&#xD;&#xA;Use this tag for questions regarding how to use Python with your Arduino, or on using of pySerial and other software that lets you use Python on an Arduino.&#xD;&#xA;&#xD;&#xA;Also consider using [tag:programming] and other tags more specific to your problem.&#xD;&#xA;&#xD;&#xA;[This page on the Arduino website][1] should help you to get up and running using Python with an Arduino. The main way to use Python with an Arduino is by using [pySerial][2]. pySerial is a desktop program compatible with Windows, Linux and other OS's. It is used to execute Python commands on an Arduino.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/interfacing/python#.Uwl-r6go6aw&#xD;&#xA;  [2]: http://pyserial.sourceforge.net/" />
  <row Id="937" PostHistoryTypeId="24" PostId="377" RevisionGUID="0bded61a-d7cd-4d50-8e9c-14df46f7fcbd" CreationDate="2014-02-23T19:08:17.867" Comment="Proposed by 35 approved by 11, 48 edit id of 93" />
  <row Id="938" PostHistoryTypeId="2" PostId="379" RevisionGUID="092990b0-6a27-403d-b590-8649e69c98a4" CreationDate="2014-02-23T19:34:47.960" UserId="-1" Text="" />
  <row Id="939" PostHistoryTypeId="2" PostId="380" RevisionGUID="cee1c80f-5d59-4aa5-b329-e285b325ea9e" CreationDate="2014-02-23T19:34:47.960" UserId="-1" Text="" />
  <row Id="940" PostHistoryTypeId="2" PostId="381" RevisionGUID="467be1c2-53d2-44d9-a992-4c0077471022" CreationDate="2014-02-23T19:36:50.533" UserId="-1" Text="" />
  <row Id="941" PostHistoryTypeId="2" PostId="382" RevisionGUID="a1db379b-60e8-47e9-8714-e9581316ade3" CreationDate="2014-02-23T19:36:50.533" UserId="-1" Text="" />
  <row Id="942" PostHistoryTypeId="2" PostId="383" RevisionGUID="ea1d490b-f777-4788-8812-a5242146e84d" CreationDate="2014-02-23T19:40:38.510" UserId="-1" Text="" />
  <row Id="943" PostHistoryTypeId="2" PostId="384" RevisionGUID="e3190da1-a117-4171-b018-94663d81fe9a" CreationDate="2014-02-23T19:40:38.510" UserId="-1" Text="" />
  <row Id="944" PostHistoryTypeId="2" PostId="385" RevisionGUID="a4fce779-47fe-484e-8a91-91a49211605c" CreationDate="2014-02-23T19:45:04.910" UserId="-1" Text="" />
  <row Id="945" PostHistoryTypeId="2" PostId="386" RevisionGUID="9d77b49d-2c97-4f40-9cd0-eb85387e52eb" CreationDate="2014-02-23T19:45:04.910" UserId="-1" Text="" />
  <row Id="946" PostHistoryTypeId="2" PostId="387" RevisionGUID="3303fe7e-ec7c-4496-8374-d966236444cf" CreationDate="2014-02-23T19:46:16.137" UserId="-1" Text="" />
  <row Id="947" PostHistoryTypeId="2" PostId="388" RevisionGUID="fc1e74cc-1de5-49a2-816b-7a204dce68e7" CreationDate="2014-02-23T19:46:16.137" UserId="-1" Text="" />
  <row Id="948" PostHistoryTypeId="2" PostId="389" RevisionGUID="e121705b-f90d-409e-b210-973d02450da4" CreationDate="2014-02-23T19:48:51.823" UserId="-1" Text="" />
  <row Id="949" PostHistoryTypeId="2" PostId="390" RevisionGUID="47c36159-d91e-46b8-8dcb-ac7866a00939" CreationDate="2014-02-23T19:48:51.823" UserId="-1" Text="" />
  <row Id="950" PostHistoryTypeId="2" PostId="391" RevisionGUID="02b940ba-a723-462a-9eef-00fcebb4b880" CreationDate="2014-02-23T19:49:59.797" UserId="-1" Text="" />
  <row Id="951" PostHistoryTypeId="2" PostId="392" RevisionGUID="a21a1a88-2869-46d3-a751-64a4637fadd0" CreationDate="2014-02-23T19:49:59.797" UserId="-1" Text="" />
  <row Id="952" PostHistoryTypeId="2" PostId="393" RevisionGUID="6286f4b2-e353-4cd0-bbf7-c6eedf13bc82" CreationDate="2014-02-23T19:51:18.210" UserId="-1" Text="" />
  <row Id="953" PostHistoryTypeId="2" PostId="394" RevisionGUID="855133a7-c844-4e3f-85d3-cd607f51a60f" CreationDate="2014-02-23T19:51:18.210" UserId="-1" Text="" />
  <row Id="954" PostHistoryTypeId="2" PostId="395" RevisionGUID="4bbb1e0b-cc7e-4084-8de3-1f7bd7780d15" CreationDate="2014-02-23T19:56:31.007" UserId="-1" Text="" />
  <row Id="955" PostHistoryTypeId="2" PostId="396" RevisionGUID="00f62074-eba3-4df5-8d0f-c86fb5fc597e" CreationDate="2014-02-23T19:56:31.007" UserId="-1" Text="" />
  <row Id="956" PostHistoryTypeId="2" PostId="397" RevisionGUID="5995fd73-eed1-4cef-891c-7398b8b5bfd5" CreationDate="2014-02-23T19:58:44.503" UserId="-1" Text="" />
  <row Id="957" PostHistoryTypeId="2" PostId="398" RevisionGUID="b6d6d88f-6d68-413c-8fc4-ebe0ef4e8968" CreationDate="2014-02-23T19:58:44.503" UserId="-1" Text="" />
  <row Id="958" PostHistoryTypeId="2" PostId="399" RevisionGUID="fcb9e547-4a92-47ee-bcd2-a3ba756aedf4" CreationDate="2014-02-23T20:16:54.033" UserId="-1" Text="" />
  <row Id="959" PostHistoryTypeId="2" PostId="400" RevisionGUID="01bb7c4d-7ada-4a02-b653-915a514ce259" CreationDate="2014-02-23T20:16:54.033" UserId="-1" Text="" />
  <row Id="960" PostHistoryTypeId="2" PostId="401" RevisionGUID="4adaef9c-7d72-40f4-b4a2-c17950ba0463" CreationDate="2014-02-23T20:19:34.737" UserId="-1" Text="" />
  <row Id="961" PostHistoryTypeId="2" PostId="402" RevisionGUID="96f83d15-0b90-4517-ac2b-4bcb83574c0f" CreationDate="2014-02-23T20:19:34.737" UserId="-1" Text="" />
  <row Id="962" PostHistoryTypeId="5" PostId="386" RevisionGUID="1d89b9b2-ec36-4ac0-9bca-663f12ffc822" CreationDate="2014-02-23T20:36:43.353" UserId="220" Comment="added 102 characters in body" Text="The safety tag is for the well-being of your Arduino, the people and objects around you, and yourself." />
  <row Id="963" PostHistoryTypeId="24" PostId="386" RevisionGUID="1d89b9b2-ec36-4ac0-9bca-663f12ffc822" CreationDate="2014-02-23T20:36:43.353" Comment="Proposed by 220 approved by 11, 83 edit id of 101" />
  <row Id="964" PostHistoryTypeId="5" PostId="380" RevisionGUID="337015f3-2545-4e88-950b-28a5fabab27b" CreationDate="2014-02-23T20:37:23.073" UserId="220" Comment="added 232 characters in body" Text="a &quot;branch&quot; of the Arduino Uno board that has a SMD (surface mount chip) that is smaller and cheaper, but not replaceable. It was developed when there was a shortage of ATMega328-PUs. It acts the same way as a &quot;standard&quot; Arduino Uno." />
  <row Id="965" PostHistoryTypeId="24" PostId="380" RevisionGUID="337015f3-2545-4e88-950b-28a5fabab27b" CreationDate="2014-02-23T20:37:23.073" Comment="Proposed by 220 approved by 11, 83 edit id of 95" />
  <row Id="966" PostHistoryTypeId="5" PostId="394" RevisionGUID="97139871-d7c7-4693-9c65-0c3733806915" CreationDate="2014-02-23T20:37:47.310" UserId="220" Comment="added 198 characters in body" Text="To compile is to convert the code for a sketch into machine readable files that are uploaded to the Arduino. This tag is mostly used for the space and footprint of the files uploaded to the Arduino." />
  <row Id="967" PostHistoryTypeId="24" PostId="394" RevisionGUID="97139871-d7c7-4693-9c65-0c3733806915" CreationDate="2014-02-23T20:37:47.310" Comment="Proposed by 220 approved by 11, 83 edit id of 105" />
  <row Id="968" PostHistoryTypeId="5" PostId="392" RevisionGUID="bc62fdcf-7d50-4be7-8611-848c1d2fce43" CreationDate="2014-02-23T20:39:48.383" UserId="220" Comment="added 115 characters in body" Text="C++ is the standard language used to program the Arduino IDE. Most Arduino code online is written in this language." />
  <row Id="969" PostHistoryTypeId="24" PostId="392" RevisionGUID="bc62fdcf-7d50-4be7-8611-848c1d2fce43" CreationDate="2014-02-23T20:39:48.383" Comment="Proposed by 220 approved by 11, 83 edit id of 104" />
  <row Id="970" PostHistoryTypeId="5" PostId="110" RevisionGUID="8ba49507-6987-4e82-85db-16fe9fd724d4" CreationDate="2014-02-23T20:40:53.357" UserId="220" Comment="added 20 characters in body" Text="Ethernet can be used for communication between an Arduino and a computer, server, or website. For question concerning the Arduino Ethernet board, use the tag &quot;arduino-ethernet&quot; instead." />
  <row Id="971" PostHistoryTypeId="24" PostId="110" RevisionGUID="8ba49507-6987-4e82-85db-16fe9fd724d4" CreationDate="2014-02-23T20:40:53.357" Comment="Proposed by 220 approved by 11, 83 edit id of 100" />
  <row Id="972" PostHistoryTypeId="2" PostId="403" RevisionGUID="71ca6802-8f3f-46aa-9aff-15ec01418e99" CreationDate="2014-02-23T20:42:26.537" UserId="225" Text="I'm currently working on several projects that each require controlling high current devices from an Arduino Uno. One controls stepper motors, one controls solenoid actuators, and one controls relays. &#xD;&#xA;&#xD;&#xA;I'm trying to figure out how to use a single circuit that can be used in each of these applications (and any future projects) that involve controlling higher current devices than the Arduino pins can handle. Prototyping speed, standardized components, and low cost are the driving factors.&#xD;&#xA;&#xD;&#xA;Is there a breakout board, circuit, or component that can be connected to an Arduino pin and used to control a high current device? Ideally with a software controlled potentiometer so that the resistance could be set in the sketch itself." />
  <row Id="973" PostHistoryTypeId="1" PostId="403" RevisionGUID="71ca6802-8f3f-46aa-9aff-15ec01418e99" CreationDate="2014-02-23T20:42:26.537" UserId="225" Text="How can a high current be controlled by an Arduino?" />
  <row Id="974" PostHistoryTypeId="3" PostId="403" RevisionGUID="71ca6802-8f3f-46aa-9aff-15ec01418e99" CreationDate="2014-02-23T20:42:26.537" UserId="225" Text="&lt;pins&gt;&lt;connectivity&gt;" />
  <row Id="976" PostHistoryTypeId="5" PostId="403" RevisionGUID="8816245c-78d7-4bb0-ad77-d58fbedfe3bb" CreationDate="2014-02-23T20:52:55.637" UserId="225" Comment="added 584 characters in body" Text="I'm currently working on several projects that each require controlling high current devices from an Arduino Uno. One controls stepper motors, one controls 12vdc solenoid actuators, and one controls 12vdc relays. &#xD;&#xA;&#xD;&#xA;For example:&#xD;&#xA;    &#xD;&#xA;The Arduino monitors a button, and each time the button is pressed it triggers the solenoid actuator. Because the Arduino is unable to source the current required by the solenoid, a seperate power supply is required with the Arduino controlling a switch (relay, transistor, etc.) that allows the higher current to pass. For the stepper motor, the layout is more complex as there would need to be four pins controlling four separate switches (to maintain interoperability of the circuit). The relay controls an air valve and requires 12vdc as well. &#xD;&#xA;&#xD;&#xA;I'm trying to figure out how to use a single circuit that can be used in each of these applications (and any future projects) that involve controlling higher current devices than the Arduino pins can handle. Prototyping speed, standardized components, and low cost are the driving factors.&#xD;&#xA;&#xD;&#xA;Is there a breakout board, circuit, or component that can be connected to an Arduino pin and used to control a high current device? Ideally with a software controlled potentiometer so that the resistance could be set in the sketch itself." />
  <row Id="978" PostHistoryTypeId="5" PostId="388" RevisionGUID="6054bb6e-eb42-4ce5-bf0a-7daafe11e9ea" CreationDate="2014-02-23T21:00:57.257" UserId="220" Comment="added 63 characters in body" Text="A sketch is compiled code that is uploaded to an Arduino board." />
  <row Id="979" PostHistoryTypeId="24" PostId="388" RevisionGUID="6054bb6e-eb42-4ce5-bf0a-7daafe11e9ea" CreationDate="2014-02-23T21:00:57.257" Comment="Proposed by 220 approved by 42, 83 edit id of 102" />
  <row Id="980" PostHistoryTypeId="5" PostId="382" RevisionGUID="9259bcf4-7a35-41c7-b015-dc5bb4c9d085" CreationDate="2014-02-23T21:01:03.650" UserId="220" Comment="added 219 characters in body" Text="&quot;pins&quot; are like gateways between the Arduino code running on the chip and the components attached to Arduino. It can refer either to the physical connectors on the board, or it can refer to the pins defined in the code." />
  <row Id="981" PostHistoryTypeId="24" PostId="382" RevisionGUID="9259bcf4-7a35-41c7-b015-dc5bb4c9d085" CreationDate="2014-02-23T21:01:03.650" Comment="Proposed by 220 approved by 42, 83 edit id of 96" />
  <row Id="982" PostHistoryTypeId="5" PostId="402" RevisionGUID="4c3ea247-b0b5-4109-a8e5-30b9c2327623" CreationDate="2014-02-23T21:01:16.977" UserId="220" Comment="added 143 characters in body" Text="Emulation is the process of using software to &quot;fake&quot; how a piece of hardware will act in certain circuits with different firmware on the chips." />
  <row Id="983" PostHistoryTypeId="24" PostId="402" RevisionGUID="4c3ea247-b0b5-4109-a8e5-30b9c2327623" CreationDate="2014-02-23T21:01:16.977" Comment="Proposed by 220 approved by 42, 83 edit id of 109" />
  <row Id="984" PostHistoryTypeId="5" PostId="398" RevisionGUID="36998b85-79d8-4788-a942-e806beda2f28" CreationDate="2014-02-23T21:01:57.107" UserId="220" Comment="added 259 characters in body" Text="LCD stands for &quot;Liquid Crystal Display&quot; and is commonly known as a screen. They are found in all flat-screen monitors and televisions. They can make many colors and shapes, but are hard to control. (Note: LED displays still are LCDs with LEDs as a backlight.)" />
  <row Id="985" PostHistoryTypeId="24" PostId="398" RevisionGUID="36998b85-79d8-4788-a942-e806beda2f28" CreationDate="2014-02-23T21:01:57.107" Comment="Proposed by 220 approved by 42, 83 edit id of 107" />
  <row Id="986" PostHistoryTypeId="5" PostId="396" RevisionGUID="60baf44f-f707-48e2-9d78-ffed25617155" CreationDate="2014-02-23T21:02:23.780" UserId="220" Comment="added 398 characters in body" Text="A relay is a part that acts like a switch that can be controlled by an Arduino. They usually are powered by sending current through a coil, which moves a piece of metal to touch a contact within it. (Note there are also solid state relays which act more like a transistor.) The moving parts is why some devices make a &quot;clicking&quot; noise when they turn on/off a light or another device attached to it." />
  <row Id="987" PostHistoryTypeId="24" PostId="396" RevisionGUID="60baf44f-f707-48e2-9d78-ffed25617155" CreationDate="2014-02-23T21:02:23.780" Comment="Proposed by 220 approved by 42, 83 edit id of 106" />
  <row Id="988" PostHistoryTypeId="5" PostId="400" RevisionGUID="aa4e27c3-ea41-4e06-9582-29c8c1e385da" CreationDate="2014-02-23T21:02:34.953" UserId="220" Comment="added 230 characters in body" Text="The ATMega328 is the chip that is the heart of the Arduino Uno. It is popular also as a chip to use to create your own board. Since it is available in the through hole version, it can be placed on a breadboard easily for circuits." />
  <row Id="989" PostHistoryTypeId="24" PostId="400" RevisionGUID="aa4e27c3-ea41-4e06-9582-29c8c1e385da" CreationDate="2014-02-23T21:02:34.953" Comment="Proposed by 220 approved by 42, 83 edit id of 108" />
  <row Id="990" PostHistoryTypeId="5" PostId="390" RevisionGUID="37844717-442a-4616-9737-fb01dac575b5" CreationDate="2014-02-23T21:05:01.360" UserId="220" Comment="added 238 characters in body" Text="Shields are attachments that &quot;snap&quot; onto the Arduino board adding functionality. They are usually the same shape as an Uno/Leonardo/Duemilanove. Some examples are: the Ethernet (includes SD port) shield, motor shields, and sensor shields." />
  <row Id="991" PostHistoryTypeId="24" PostId="390" RevisionGUID="37844717-442a-4616-9737-fb01dac575b5" CreationDate="2014-02-23T21:05:01.360" Comment="Proposed by 220 approved by 42, 83 edit id of 103" />
  <row Id="992" PostHistoryTypeId="5" PostId="374" RevisionGUID="79ab920d-d116-4b9e-a71a-9ddf24ed5193" CreationDate="2014-02-23T21:05:47.130" UserId="220" Comment="Making tag more complete." Text="Serial communication is the standard USB connection between the Arduino and a computer with a standard USB A to B cable." />
  <row Id="993" PostHistoryTypeId="24" PostId="374" RevisionGUID="79ab920d-d116-4b9e-a71a-9ddf24ed5193" CreationDate="2014-02-23T21:05:47.130" Comment="Proposed by 220 approved by 11, 42 edit id of 99" />
  <row Id="994" PostHistoryTypeId="5" PostId="112" RevisionGUID="be455114-2acb-4299-93b7-9895000e4363" CreationDate="2014-02-23T21:05:52.753" UserId="220" Comment="added 138 characters in body" Text="Uploading is the process of updating or changing the sketch on the Arduino board. It does not refer to uploading to a server or a website." />
  <row Id="995" PostHistoryTypeId="24" PostId="112" RevisionGUID="be455114-2acb-4299-93b7-9895000e4363" CreationDate="2014-02-23T21:05:52.753" Comment="Proposed by 220 approved by 42, 83 edit id of 98" />
  <row Id="996" PostHistoryTypeId="5" PostId="403" RevisionGUID="584d751d-fd75-424a-888d-9c4d105725be" CreationDate="2014-02-23T21:07:20.833" UserId="225" Comment="clarified high current; added 23 characters in body" Text="I'm currently working on several projects that each require controlling devices ranging from 800mA to 2A from an Arduino Uno. One controls stepper motors, one controls 12vdc solenoid actuators, and one controls 12vdc pneumatic valves. &#xD;&#xA;&#xD;&#xA;For example:&#xD;&#xA;    &#xD;&#xA;The Arduino monitors a button, and each time the button is pressed it triggers the solenoid actuator. Because the Arduino is unable to source the current required by the solenoid, a seperate power supply is required with the Arduino controlling a switch (relay, transistor, etc.) that allows the higher current to pass. For the stepper motor, the layout is more complex as there would need to be four pins controlling four separate switches (to maintain interoperability of the circuit). The relay controls an air valve and requires 12vdc as well. &#xD;&#xA;&#xD;&#xA;I'm trying to figure out how to use a single circuit that can be used in each of these applications (and any future projects) that involve controlling higher current devices than the Arduino pins can handle. Prototyping speed, standardized components, and low cost are the driving factors.&#xD;&#xA;&#xD;&#xA;Is there a breakout board, circuit, or component that can be connected to an Arduino pin and used to control a high current device? Ideally with a software controlled potentiometer so that the resistance for different projects could be set in the sketch itself." />
  <row Id="998" PostHistoryTypeId="2" PostId="405" RevisionGUID="c2326250-1366-4f9d-a8bc-f22da572c40a" CreationDate="2014-02-23T21:11:35.700" UserId="-1" Text="" />
  <row Id="999" PostHistoryTypeId="2" PostId="406" RevisionGUID="68e68662-e6c1-4599-82fd-8ab761d777f9" CreationDate="2014-02-23T21:11:35.700" UserId="-1" Text="" />
  <row Id="1000" PostHistoryTypeId="5" PostId="403" RevisionGUID="2dfe6a96-5d99-4aae-b3a2-fedc18b6a6fc" CreationDate="2014-02-23T21:24:27.827" UserId="225" Comment="clarified question intent" Text="I'm looking for a broadly applicable solution, one that can be adapted to a variety of projects.&#xD;&#xA;&#xD;&#xA;I'm currently working on several projects that each require controlling devices ranging from 800mA to 2A from an Arduino Uno. One controls stepper motors, one controls 12vdc solenoid actuators, and one controls 12vdc pneumatic valves. &#xD;&#xA;&#xD;&#xA;For example:&#xD;&#xA;    &#xD;&#xA;The Arduino monitors a button, and each time the button is pressed it triggers the solenoid actuator. Because the Arduino is unable to source the current required by the solenoid, a seperate power supply is required with the Arduino controlling a switch (relay, transistor, etc.) that allows the higher current to pass. For the stepper motor, the layout is more complex as there would need to be four pins controlling four separate switches (to maintain interoperability of the circuit). The relay controls an air valve and requires 12vdc as well. &#xD;&#xA;&#xD;&#xA;I'm trying to figure out how to use a single circuit that can be used in each of these applications (and any future projects) that involve controlling higher current devices than the Arduino pins can handle. &#xD;&#xA;&#xD;&#xA;Prototyping speed, standardized components, and low cost are the driving factors. Switching speed, useful life, and noise are also important.&#xD;&#xA;&#xD;&#xA;Is there a breakout board, circuit, or component that can be connected to an Arduino pin and used to control a high current device? Ideally with a software controlled potentiometer so that the resistance for different projects could be set in the sketch itself." />
  <row Id="1001" PostHistoryTypeId="4" PostId="403" RevisionGUID="2dfe6a96-5d99-4aae-b3a2-fedc18b6a6fc" CreationDate="2014-02-23T21:24:27.827" UserId="225" Comment="clarified question intent" Text="How can higher current devices (motors, solenoids, lights, etc.) be controlled by an Arduino?" />
  <row Id="1002" PostHistoryTypeId="2" PostId="407" RevisionGUID="f167525f-3376-47d8-a5ba-eee2ffd38a58" CreationDate="2014-02-23T21:36:40.887" UserId="84" Text="To drive such high currents, you may have to cascade several transistors (you can also use a [Darlington transistor][1]). There are arrays of Darlingtons mounted in a chip (e.g. the ULN2803A has 8 darlington transistors, but is limited to 500mA).&#xD;&#xA;&#xD;&#xA;You probably will have to deal with higher power transistors; as an example I have found STMicroelectronics [TIP110][2] which can support switching a 2A current (4A peak), but it would probably need a heatsink to dissipate heat.&#xD;&#xA;&#xD;&#xA;Note that I wonder if your steppers really need 2A current (are they that big?). For steppers, you can generally find IC that can drive them easily, e.g. the L293D but this one can drive &quot;only&quot; 600mA).&#xD;&#xA;&#xD;&#xA;As a conclusion, I am afraid you will not find a &quot;one size fits all&quot; solution, as all your devices are different and should be driven by the appropriate circuit.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Darlington_transistor&#xD;&#xA;  [2]: http://www.st.com/web/en/resource/technical/document/datasheet/CD00000909.pdf" />
  <row Id="1003" PostHistoryTypeId="2" PostId="408" RevisionGUID="d818c54a-07b1-46ea-b620-44a741cca30c" CreationDate="2014-02-23T21:43:22.787" UserId="42" Text="I've been using a button to interact with a sketch (on my Uno), and it's mostly working fine. However, sometimes it seems to be detecting multiple presses when it's only pressed once.&#xD;&#xA;&#xD;&#xA;It's a small circuit-mounted momentary button, which is normally open. It's connected from +5V directly to an input pin. I've also added a 10K pull-down resistor on the pin to make sure the input isn't left floating.&#xD;&#xA;&#xD;&#xA;Here's a test sketch I've been using, which reports the number of presses to the serial monitor:&#xD;&#xA;&#xD;&#xA;    int oldState = LOW;&#xD;&#xA;    int numPresses = 0;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        pinMode(5, INPUT);&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        const int newState = digitalRead(5);&#xD;&#xA;&#xD;&#xA;        if (newState != oldState) {&#xD;&#xA;            if (newState == HIGH) Serial.println(++numPresses);&#xD;&#xA;            oldState = newState;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Sometimes when I press the button once, the serial monitor shows two presses in a row. It sometimes even reports a press when I *release* the button.&#xD;&#xA;&#xD;&#xA;Is it possible to fix this? Or do I just have a faulty button or pin or something?&#xD;&#xA;" />
  <row Id="1004" PostHistoryTypeId="1" PostId="408" RevisionGUID="d818c54a-07b1-46ea-b620-44a741cca30c" CreationDate="2014-02-23T21:43:22.787" UserId="42" Text="Why does my sketch report too many button presses?" />
  <row Id="1005" PostHistoryTypeId="3" PostId="408" RevisionGUID="d818c54a-07b1-46ea-b620-44a741cca30c" CreationDate="2014-02-23T21:43:22.787" UserId="42" Text="&lt;pins&gt;&lt;button&gt;&lt;input&gt;" />
  <row Id="1006" PostHistoryTypeId="2" PostId="409" RevisionGUID="350b38b4-94d9-4385-a127-a256b3720f61" CreationDate="2014-02-23T22:05:29.407" UserId="225" Text="The button contacts themselves are probably bouncing in and out of contact, which is causing the circuit to open and close multiple times, even though the button position isn't changing. &#xD;&#xA;&#xD;&#xA;It's a common problem with buttons and would be the first thing I would check. In order to fix this, you need to de-bounce the button. There are various ways in which to accomplish this, some of which can be done in the sketch itself.&#xD;&#xA;&#xD;&#xA;A good solution is code that measures the duration of each button state and only registers a change in state if the current duration is greater than the desired duration. That option should be used for more complex projects. The code for it will be project specific and likely use sketch defined variables, but an example of what needs to be done can be found [here][1]. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Tutorial/Debounce&#xD;&#xA;&#xD;&#xA;If the sketch is very basic or you just want to make sure that bounce is the problem, you can add a short delay after the button state changes. For example: &#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        const int newState = digitalRead(5);&#xD;&#xA;&#xD;&#xA;        if (newState != oldState) {&#xD;&#xA;            if (newState == HIGH) Serial.println(++numPresses);&#xD;&#xA;            oldState = newState;&#xD;&#xA;            delay(10) //Adjust the delay length to be as short as possible without triggering errors&#xD;&#xA;        }&#xD;&#xA;    }    &#xD;&#xA;&#xD;&#xA;" />
  <row Id="1007" PostHistoryTypeId="2" PostId="410" RevisionGUID="debe48e8-dac2-4386-8794-5ec216302bec" CreationDate="2014-02-23T22:11:03.883" UserId="84" Text="This is your button **bouncing** which is quite usual behavior; it has nothing to do with button quality.&#xD;&#xA;&#xD;&#xA;There are 2 ways to &quot;debounce&quot; a button: by hardware or by software.&#xD;&#xA;&#xD;&#xA;Personally, I prefer by hardware; just google for `button debouncing circuit` and you should find many examples.&#xD;&#xA;&#xD;&#xA;If you don't have the necessary components available, you can use software debouncing.&#xD;&#xA;&#xD;&#xA;By software, you have an example [here][1] on Arduino web site.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Tutorial/Debounce" />
  <row Id="1008" PostHistoryTypeId="5" PostId="356" RevisionGUID="c741d589-44cc-4e21-af9a-9a1d1889c41f" CreationDate="2014-02-23T22:14:56.190" UserId="35" Comment="added 3 characters in body" Text="I'd like to be able to use Python from a sketch. According to [the Arduino playground][1], one can use PySerial from a computer to talk with an Arduino via Python. &#xD;&#xA;&#xD;&#xA;It looks like from that page you can also use various API's to use Python with an Arduino from a computer. However, I'd like to know if you can execute Python directly from a sketch. It would be nice because then you could execute Python directly from a sketch, and not all of it would have to be written in Python.&#xD;&#xA;&#xD;&#xA;If this is not possible, is there an easy way to execute Python on an Arduino? Looking at the various API's it was hard to determine exactly what they did, and if you could execute a `.py` script from a computer or from anything on the Arduino.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/interfacing/python#.Uwl-r6go6aw" />
  <row Id="1009" PostHistoryTypeId="2" PostId="411" RevisionGUID="b465a3b6-8eb0-40c6-96ff-8fff18298dc3" CreationDate="2014-02-23T22:35:02.897" UserId="11" Text="# Contact Bounce&#xD;&#xA;This is known as contact bounce and happens when the metal contacts in the button or switch bounce against each other when you push it. The microcontroller is fast enough to pick up these bounces and, as far as it's concerned, you're toggling the switch many times in as much as 10 milliseconds of time.&#xD;&#xA;&#xD;&#xA;Different switches and buttons will have a different amount of contact bounce, and even one switch will behave differently between two presses.&#xD;&#xA;&#xD;&#xA;Here's a button press captured on a scope (image from [Maxim][1]):&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;At 2ms/div we don't see a stable signal until 6ms after initial contact!&#xD;&#xA;&#xD;&#xA;# Solutions&#xD;&#xA;&#xD;&#xA;## Add a delay&#xD;&#xA;&#xD;&#xA;The absolute simplest solution is to introduce a short delay after you read the button input. This will prevent the code from picking up any bounces and when it resumes, the signal should be stable.&#xD;&#xA;&#xD;&#xA;    if (digitalRead(A3) == 0) {&#xD;&#xA;        // do something here&#xD;&#xA;        delay(500);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;In the example above, I delay 500ms after reading the state of the pin. The button is normally high so when I press it down, the state of the pin goes to logic 0. I pick that up in the code and do something and then wait at least 500ms before continuing.&#xD;&#xA;&#xD;&#xA;Obviously, this code will just halt for half a second every time you push a button, which may or may not be acceptable in your application. You can decrease the amount of delay depending on the contact bounce time of your switch, too, but I play it safe here.&#xD;&#xA;&#xD;&#xA;# Ignore button presses too close to each other&#xD;&#xA;&#xD;&#xA;Similar to the solution above but instead of adding a hard delay, you use the `millis()` function to keep track of when the last time the switch was triggered. Every time you see a switch trigger, you compare against the time and, if not enough time has elapsed (say like 500ms in my previous example), you ignore it.&#xD;&#xA;&#xD;&#xA;This solves the problem of having to use `delay()` in your code.&#xD;&#xA;&#xD;&#xA;# Switch debouncer IC&#xD;&#xA;&#xD;&#xA;There are things like the [MAX6816][3] which is an IC that you put in between your switch and microcontroller input. It will denounce the signal for you. At a price of $1.62 @1k you'll probably never use this.&#xD;&#xA;&#xD;&#xA;## Other&#xD;&#xA;&#xD;&#xA;There are many solutions to this problem... I always do it in software, but some others include using a [latch or capacitor][4].&#xD;&#xA;&#xD;&#xA;[Debounce Code – one post to rule them all][5]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.maximintegrated.com/app-notes/index.mvp/id/159&#xD;&#xA;  [2]: http://i.stack.imgur.com/ZrNMs.gif&#xD;&#xA;  [3]: http://www.maximintegrated.com/datasheet/index.mvp/id/1896&#xD;&#xA;  [4]: http://tech.thetonegod.com/debounce/debounce.html&#xD;&#xA;  [5]: http://hackaday.com/2010/11/09/debounce-code-one-post-to-rule-them-all/" />
  <row Id="1010" PostHistoryTypeId="5" PostId="23" RevisionGUID="a48dce98-7278-4cfa-b5a0-adeb36f058e3" CreationDate="2014-02-23T23:16:22.553" UserId="35" Comment="added 816 characters in body" Text="The Arduino Yún is a microcontroller board based on the ATmega32u4 and the Atheros AR9331. The Atheros processor supports a Linux distribution based on OpenWRT named Linino. The board has built-in Ethernet and WiFi support, a USB-A port, micro-SD card slot, 20 digital input/output pins (of which 7 can be used as PWM outputs and 12 as analog inputs), a 16 MHz crystal oscillator, a micro USB connection, an ICSP header, and a 3 reset buttons. (From http://arduino.cc/en/Main/ArduinoBoardYun)&#xD;&#xA;&#xD;&#xA;The main differences between the Yún and other Arduinos is that the Yún contains an onboard WiFi antenna used to program the board wirelessly, connect to the internet in sketches, or see various information about the board. The Yún also contains a Linux side, which is different because most boards only have one onboard processor. The Yún has two onboard processors; one for the system and one for the Linux part. One can connect to the Linux side of the Yún via [a Bridge library][1]. Python 2.7 is also included with the Yún.&#xD;&#xA;&#xD;&#xA;*Only* use this tag if your question is *specific* to the Yún, and not a general Arduino question. Also consider using other related tags such as [tag:programming] or [tag:pins] more specific to your problem.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/YunBridgeLibrary#.UwpmrfkiEw8" />
  <row Id="1011" PostHistoryTypeId="24" PostId="23" RevisionGUID="a48dce98-7278-4cfa-b5a0-adeb36f058e3" CreationDate="2014-02-23T23:16:22.553" Comment="Proposed by 35 approved by 8, 42 edit id of 113" />
  <row Id="1012" PostHistoryTypeId="5" PostId="405" RevisionGUID="3ce1a289-7268-43ee-a029-f0c5f31044d6" CreationDate="2014-02-23T23:16:28.133" UserId="35" Comment="added 273 characters in body" Text="Use this tag for questions regarding how to get the time on an Arduino, how to create or use clocks with an Arduino, or anything that time would be a substantial part of the problem/question. &#xD;&#xA;&#xD;&#xA;Also consider using [tag:programming] or other tags specific to your problem." />
  <row Id="1013" PostHistoryTypeId="24" PostId="405" RevisionGUID="3ce1a289-7268-43ee-a029-f0c5f31044d6" CreationDate="2014-02-23T23:16:28.133" Comment="Proposed by 35 approved by 8, 42 edit id of 111" />
  <row Id="1014" PostHistoryTypeId="5" PostId="384" RevisionGUID="1ef8db5c-7b6b-4139-9d88-14e603fbd021" CreationDate="2014-02-23T23:16:34.540" UserId="220" Comment="added 168 characters in body" Text="A library is a file that can be included into the code to add new instructions by combining many existing instructions and creating one easy to use instruction to call." />
  <row Id="1015" PostHistoryTypeId="24" PostId="384" RevisionGUID="1ef8db5c-7b6b-4139-9d88-14e603fbd021" CreationDate="2014-02-23T23:16:34.540" Comment="Proposed by 220 approved by 8, 83 edit id of 97" />
  <row Id="1016" PostHistoryTypeId="5" PostId="406" RevisionGUID="cd740fd0-8890-41e9-9406-2f4701bea6a5" CreationDate="2014-02-23T23:16:41.197" UserId="35" Comment="added 236 characters in body" Text="Use this tag for questions regarding how to get the time on an Arduino, how to create or use clocks with an Arduino, or anything that has time as a substantial factor in it. Also consider using [programming] or other more specific tags." />
  <row Id="1017" PostHistoryTypeId="24" PostId="406" RevisionGUID="cd740fd0-8890-41e9-9406-2f4701bea6a5" CreationDate="2014-02-23T23:16:41.197" Comment="Proposed by 35 approved by 8, 42 edit id of 112" />
  <row Id="1018" PostHistoryTypeId="6" PostId="249" RevisionGUID="0175f56f-5ff6-449f-aa35-809644ff7f7e" CreationDate="2014-02-23T23:16:58.043" UserId="220" Comment="Added more specific tag for &quot;wireless.&quot;" Text="&lt;remote-control&gt;&lt;ir&gt;" />
  <row Id="1019" PostHistoryTypeId="24" PostId="249" RevisionGUID="0175f56f-5ff6-449f-aa35-809644ff7f7e" CreationDate="2014-02-23T23:16:58.043" Comment="Proposed by 220 approved by 8, 83 edit id of 110" />
  <row Id="1020" PostHistoryTypeId="5" PostId="24" RevisionGUID="10f012bf-3eba-4d27-947f-a294ce424863" CreationDate="2014-02-23T23:17:03.917" UserId="35" Comment="added 185 characters in body" Text="The Arduino Yún is a microcontroller board based on the ATmega32u4 and the Atheros AR9331. Use this tag for questions specifically regarding the Yún, and not just general Arduino usage." />
  <row Id="1021" PostHistoryTypeId="24" PostId="24" RevisionGUID="10f012bf-3eba-4d27-947f-a294ce424863" CreationDate="2014-02-23T23:17:03.917" Comment="Proposed by 35 approved by 8, 42 edit id of 114" />
  <row Id="1022" PostHistoryTypeId="2" PostId="412" RevisionGUID="5c907570-9793-480f-81d2-e8304402ffc5" CreationDate="2014-02-24T00:55:35.033" UserId="225" Text="I'm working on a free space optics project to send data wirelessly between two points. To accomplish this I'm using an IR LED connected to an Arduino Uno that pulses with a 56khz carrier frequency for the transmitter and a second Arduino with a 56khz IR detector module for the receiver.&#xD;&#xA;&#xD;&#xA;I tried using delayMicroseconds() between pin high and pin low commands in order to create the carrier frequency. This kind of works, but the frequency isn't always the same and any additional delays for pulsing the signal (i.e. the time required to call the function and decrementing) can change it.&#xD;&#xA;&#xD;&#xA;Reading the datasheet for the Atmega328 it appears that there is a way to set a more accurate pulse using the chips timers. Is that possible, and if so, how do you create a 56khz pulse using the timers?" />
  <row Id="1023" PostHistoryTypeId="1" PostId="412" RevisionGUID="5c907570-9793-480f-81d2-e8304402ffc5" CreationDate="2014-02-24T00:55:35.033" UserId="225" Text="How can an Arduino output a specific (i.e. 56khz) carrier frequency?" />
  <row Id="1024" PostHistoryTypeId="3" PostId="412" RevisionGUID="5c907570-9793-480f-81d2-e8304402ffc5" CreationDate="2014-02-24T00:55:35.033" UserId="225" Text="&lt;arduino-uno&gt;&lt;ir&gt;&lt;timers&gt;" />
  <row Id="1026" PostHistoryTypeId="6" PostId="57" RevisionGUID="024b57aa-9a08-48f4-90b5-27d6c075493b" CreationDate="2014-02-24T01:26:02.357" UserId="37" Comment="tag cleanup" Text="&lt;uploading&gt;&lt;data-transfer&gt;" />
  <row Id="1027" PostHistoryTypeId="24" PostId="57" RevisionGUID="024b57aa-9a08-48f4-90b5-27d6c075493b" CreationDate="2014-02-24T01:26:02.357" Comment="Proposed by 37 approved by 11, 42 edit id of 115" />
  <row Id="1028" PostHistoryTypeId="2" PostId="414" RevisionGUID="c08d1c1f-5154-4cb8-9821-158b5b3570a9" CreationDate="2014-02-24T02:06:06.347" UserId="37" Text="While looking at sketches other people have written, I occasionally come across code that looks somewhat like this:&#xD;&#xA;&#xD;&#xA;    TCCR1A = 0;&#xD;&#xA;    TCCR1B = 0;&#xD;&#xA;    &#xD;&#xA;    TCNT1 = 34286;&#xD;&#xA;    TCCR1B |= (1 &lt;&lt; CS12);&#xD;&#xA;    TIMSK1 |= (1 &lt;&lt; TOIE1);&#xD;&#xA;&#xD;&#xA;All I know is that is has something to with timing/timers (I think). How can I decipher—and create—code like this? What are `TCCR1A`, `TCCR1B`, `TCNT1`, `CS12`, `TIMSK1`, and `TOIE1`?" />
  <row Id="1029" PostHistoryTypeId="1" PostId="414" RevisionGUID="c08d1c1f-5154-4cb8-9821-158b5b3570a9" CreationDate="2014-02-24T02:06:06.347" UserId="37" Text="Weird looking code, somthing to do with timers I think" />
  <row Id="1030" PostHistoryTypeId="3" PostId="414" RevisionGUID="c08d1c1f-5154-4cb8-9821-158b5b3570a9" CreationDate="2014-02-24T02:06:06.347" UserId="37" Text="&lt;timers&gt;&lt;programming&gt;" />
  <row Id="1031" PostHistoryTypeId="2" PostId="415" RevisionGUID="b1719cb8-583d-438b-ab91-ec712bbbf063" CreationDate="2014-02-24T03:07:29.873" UserId="8" Text="`TCCR1A` is timer/counter 1 control register A&#xD;&#xA;&#xD;&#xA;`TCCR1B` is timer/counter 1 control register B&#xD;&#xA;&#xD;&#xA;`TCNT1` is timer/counter 1's counter value&#xD;&#xA;&#xD;&#xA;`CS12` is the 3rd clock select bit for timer/counter 1&#xD;&#xA;&#xD;&#xA;`TIMSK1` is timer/counter 1's interrupt mask register&#xD;&#xA;&#xD;&#xA;`TOIE1` is the timer/counter 1 overflow interrupt enable&#xD;&#xA;&#xD;&#xA;So, the code enables timer/counter 1 at 62.5 kHz and sets the value to 34286. Then it enable the overflow interrupt so when it reaches 65535, it will trigger the interrupt function, most likely labelled as `ISR(timer0_overflow_vect)" />
  <row Id="1032" PostHistoryTypeId="5" PostId="415" RevisionGUID="f0439499-5419-4ad1-9af5-299e2d12df5e" CreationDate="2014-02-24T03:37:58.120" UserId="11" Comment="added 1 characters in body" Text="`TCCR1A` is timer/counter 1 control register A&#xD;&#xA;&#xD;&#xA;`TCCR1B` is timer/counter 1 control register B&#xD;&#xA;&#xD;&#xA;`TCNT1` is timer/counter 1's counter value&#xD;&#xA;&#xD;&#xA;`CS12` is the 3rd clock select bit for timer/counter 1&#xD;&#xA;&#xD;&#xA;`TIMSK1` is timer/counter 1's interrupt mask register&#xD;&#xA;&#xD;&#xA;`TOIE1` is the timer/counter 1 overflow interrupt enable&#xD;&#xA;&#xD;&#xA;So, the code enables timer/counter 1 at 62.5 kHz and sets the value to 34286. Then it enable the overflow interrupt so when it reaches 65535, it will trigger the interrupt function, most likely labelled as `ISR(timer0_overflow_vect)`" />
  <row Id="1033" PostHistoryTypeId="2" PostId="416" RevisionGUID="d4c3c049-f0c3-413e-9ab5-5416264baca3" CreationDate="2014-02-24T03:54:06.270" UserId="86" Text="This isn't weird looking. It's what normal MCU code actually looks like.&#xD;&#xA;&#xD;&#xA;*Arduino* code is the weird stuff, with functions that access the MCU control registers indirectly. While this is somewhat &quot;nicer&quot; looking, it's also much slower, and uses a lot more program space.&#xD;&#xA;&#xD;&#xA;The mysterious constants are all described in great detail in the [ATmega328P datasheet][1], which you really should read if you're interested in doing anything more then occationally toggling pins on an arduino.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/Images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet.pdf" />
  <row Id="1034" PostHistoryTypeId="5" PostId="416" RevisionGUID="bf95b1ca-3f23-4d4d-8b59-5ab06905df5c" CreationDate="2014-02-24T04:01:35.323" UserId="86" Comment="added 1055 characters in body" Text="This isn't weird looking. It's what normal MCU code actually looks like.&#xD;&#xA;&#xD;&#xA;*Arduino* code is the weird stuff, with functions that access the MCU control registers indirectly. While this is somewhat &quot;nicer&quot; looking, it's also much slower, and uses a lot more program space.&#xD;&#xA;&#xD;&#xA;The mysterious constants are all described in great detail in the [ATmega328P datasheet][1], which you really should read if you're interested in doing anything more then occationally toggling pins on an arduino.&#xD;&#xA;&#xD;&#xA;Select excerpts from the datasheet linked above:  &#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;![enter image description here][3]&#xD;&#xA;![enter image description here][4]&#xD;&#xA;&#xD;&#xA;So, for example, `TIMSK1 |= (1 &lt;&lt; TOIE1);` sets the bit `TOIE1` in `TIMSK1`. This is achieved by shifting binary 1 (`0b00000001`) to the left by `TOIE1` bits, with `TOIE1` being defined in a header file as 0. This is then bitwise ORed into the current value of `TIMSK1`, which effectively set this one bit high.&#xD;&#xA;&#xD;&#xA;Looking at the documentation for bit 0 of `TIMSK1`, we can see it is described as  &#xD;&#xA;&#xD;&#xA;&gt; When this bit is written to one, and the I-flag in the Status Register&#xD;&#xA;&gt; is set (interrupts globally enabled), the Timer/Counter1 Overflow&#xD;&#xA;&gt; interrupt is enabled. The corresponding Interrupt Vector (See&#xD;&#xA;&gt; ”Interrupts” on page 57) is executed when the TOV1 Flag, located in&#xD;&#xA;&gt; TIFR1, is set.&#xD;&#xA;&#xD;&#xA;All the other lines should be interpreted in the same manner.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/Images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet.pdf&#xD;&#xA;  [2]: http://i.stack.imgur.com/przAI.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/P3Yu2.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/faCfk.png" />
  <row Id="1035" PostHistoryTypeId="5" PostId="416" RevisionGUID="17721245-7993-410b-bf06-c87997519ff9" CreationDate="2014-02-24T04:07:59.950" UserId="86" Comment="added 1055 characters in body" Text="This isn't weird looking. It's what normal MCU code actually looks like.&#xD;&#xA;&#xD;&#xA;*Arduino* code is the weird stuff, with functions that access the MCU control registers indirectly. While this is somewhat &quot;nicer&quot; looking, it's also much slower, and uses a lot more program space.&#xD;&#xA;&#xD;&#xA;The mysterious constants are all described in great detail in the [ATmega328P datasheet][1], which you really should read if you're interested in doing anything more then occationally toggling pins on an arduino.&#xD;&#xA;&#xD;&#xA;Select excerpts from the datasheet linked above:  &#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;![enter image description here][3]&#xD;&#xA;![enter image description here][4]&#xD;&#xA;&#xD;&#xA;So, for example, `TIMSK1 |= (1 &lt;&lt; TOIE1);` sets the bit `TOIE1` in `TIMSK1`. This is achieved by shifting binary 1 (`0b00000001`) to the left by `TOIE1` bits, with `TOIE1` being defined in a header file as 0. This is then bitwise ORed into the current value of `TIMSK1`, which effectively set this one bit high.&#xD;&#xA;&#xD;&#xA;Looking at the documentation for bit 0 of `TIMSK1`, we can see it is described as  &#xD;&#xA;&#xD;&#xA;&gt; When this bit is written to one, and the I-flag in the Status Register&#xD;&#xA;&gt; is set (interrupts globally enabled), the Timer/Counter1 Overflow&#xD;&#xA;&gt; interrupt is enabled. The corresponding Interrupt Vector (See&#xD;&#xA;&gt; ”Interrupts” on page 57) is executed when the TOV1 Flag, located in&#xD;&#xA;&gt; TIFR1, is set.&#xD;&#xA;&#xD;&#xA;All the other lines should be interpreted in the same manner.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Some notes:&#xD;&#xA;&#xD;&#xA;You may also see things like `TIMSK1 |= _BV(TOIE1);`. `_BV()` is a [commonly used macro][5] originally from the [AVR libc implementation][6]. `_BV(TOIE1)` is functionally identical to `(1 &lt;&lt; TOIE1)`, with the benefit of better readability.&#xD;&#xA;&#xD;&#xA;Also, you may also see lines such as: `TIMSK1 &amp;= ~(1 &lt;&lt; TOIE1);` or `TIMSK1 &amp;= ~_BV(TOIE1);`. This has the opposite function of `TIMSK1 |= _BV(TOIE1);`, in that it *unsets* the bit `TOIE1` in `TIMSK1`. This is achieved by taking the bit-mask produced by `_BV(TOIE1)`, performing a bitwise NOT operation on it (`~`), and then ANDing `TIMSK1` by this NOTed value (which is 0b11111110).&#xD;&#xA;&#xD;&#xA;Note that in all these cases, the value of things like `(1 &lt;&lt; TOIE1)` or `_BV(TOIE1)` are fully resolved at *compile time*, so they functionally reduce to a simple constant, and therefore take no execution time to compute at runtime.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/Images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet.pdf&#xD;&#xA;  [2]: http://i.stack.imgur.com/przAI.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/P3Yu2.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/faCfk.png&#xD;&#xA;  [5]: http://www.nongnu.org/avr-libc/user-manual/FAQ.html#faq_use_bv&#xD;&#xA;  [6]: http://www.nongnu.org/avr-libc/user-manual/index.html" />
  <row Id="1036" PostHistoryTypeId="5" PostId="416" RevisionGUID="f06f3299-e95a-400c-89b4-3c47a4ac0234" CreationDate="2014-02-24T04:17:05.493" UserId="86" Comment="added 1055 characters in body" Text="This isn't weird looking. It's what normal MCU code actually looks like.&#xD;&#xA;&#xD;&#xA;*Arduino* code is the weird stuff, with functions that access the MCU control registers indirectly. While this is somewhat &quot;nicer&quot; looking, it's also much slower, and uses a lot more program space.&#xD;&#xA;&#xD;&#xA;The mysterious constants are all described in great detail in the [ATmega328P datasheet][1], which you really should read if you're interested in doing anything more then occationally toggling pins on an arduino.&#xD;&#xA;&#xD;&#xA;Select excerpts from the datasheet linked above:  &#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;![enter image description here][3]&#xD;&#xA;![enter image description here][4]&#xD;&#xA;&#xD;&#xA;So, for example, `TIMSK1 |= (1 &lt;&lt; TOIE1);` sets the bit `TOIE1` in `TIMSK1`. This is achieved by shifting binary 1 (`0b00000001`) to the left by `TOIE1` bits, with `TOIE1` being defined in a header file as 0. This is then bitwise ORed into the current value of `TIMSK1`, which effectively set this one bit high.&#xD;&#xA;&#xD;&#xA;Looking at the documentation for bit 0 of `TIMSK1`, we can see it is described as  &#xD;&#xA;&#xD;&#xA;&gt; When this bit is written to one, and the I-flag in the Status Register&#xD;&#xA;&gt; is set (interrupts globally enabled), the Timer/Counter1 Overflow&#xD;&#xA;&gt; interrupt is enabled. The corresponding Interrupt Vector (See&#xD;&#xA;&gt; ”Interrupts” on page 57) is executed when the TOV1 Flag, located in&#xD;&#xA;&gt; TIFR1, is set.&#xD;&#xA;&#xD;&#xA;All the other lines should be interpreted in the same manner.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Some notes:&#xD;&#xA;&#xD;&#xA;You may also see things like `TIMSK1 |= _BV(TOIE1);`. `_BV()` is a [commonly used macro][5] originally from the [AVR libc implementation][6]. `_BV(TOIE1)` is functionally identical to `(1 &lt;&lt; TOIE1)`, with the benefit of better readability.&#xD;&#xA;&#xD;&#xA;Also, you may also see lines such as: `TIMSK1 &amp;= ~(1 &lt;&lt; TOIE1);` or `TIMSK1 &amp;= ~_BV(TOIE1);`. This has the opposite function of `TIMSK1 |= _BV(TOIE1);`, in that it *unsets* the bit `TOIE1` in `TIMSK1`. This is achieved by taking the bit-mask produced by `_BV(TOIE1)`, performing a bitwise NOT operation on it (`~`), and then ANDing `TIMSK1` by this NOTed value (which is 0b11111110).&#xD;&#xA;&#xD;&#xA;Note that in all these cases, the value of things like `(1 &lt;&lt; TOIE1)` or `_BV(TOIE1)` are fully resolved at *compile time*, so they functionally reduce to a simple constant, and therefore take no execution time to compute at runtime.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Properly written code will *generally* have comments inline with the code that detail what the registers being assigned to do. Here is a fairly simple soft-SPI routine I wrote recently:&#xD;&#xA;&#xD;&#xA;    uint8_t transactByteADC(uint8_t outByte)&#xD;&#xA;    {&#xD;&#xA;    	// Transfers one byte to the ADC, and receives one byte at the same time&#xD;&#xA;    	// does nothing with the chip-select&#xD;&#xA;    	// MSB first, data clocked on the rising edge&#xD;&#xA;    &#xD;&#xA;    	uint8_t loopCnt;&#xD;&#xA;    	uint8_t retDat = 0;&#xD;&#xA;    &#xD;&#xA;    	for (loopCnt = 0; loopCnt &lt; 8; loopCnt++)&#xD;&#xA;    	{&#xD;&#xA;    		if (outByte &amp; 0x80)			// if current bit is high&#xD;&#xA;    			PORTC |= _BV(ADC_MOSI);		// set data line&#xD;&#xA;    		else&#xD;&#xA;    			PORTC &amp;= ~(_BV(ADC_MOSI));	// else unset it&#xD;&#xA;    &#xD;&#xA;    		outByte &lt;&lt;= 1;				// and shift the output data over for the next iteration&#xD;&#xA;    		retDat &lt;&lt;= 1;				// shift over the data read back&#xD;&#xA;    		&#xD;&#xA;    		PORTC |= _BV(ADC_SCK);			// Set the clock high&#xD;&#xA;    &#xD;&#xA;    		if (PINC &amp; _BV(ADC_MISO))		// sample the input line&#xD;&#xA;    			retDat |= 0x01;			// and set the bit in the retval if the input is high&#xD;&#xA;    		&#xD;&#xA;    		PORTC &amp;= ~(_BV(ADC_SCK));		// set clock low&#xD;&#xA;    	}&#xD;&#xA;    	return retDat;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;`PORTC` is the register that controls the value of output pins within `PORTC` of the ATmega328P. `PINC` is the register where the *input* values of `PORTC` are available. Fundamentally, things like this are what happen internally when you use the `digitalWrite` or `digitalRead` functions. However, there is a look-up operation that converts the arduino &quot;pin numbers&quot; into actual hardware pin numbers, which takes somewhere in the realm of 50 clock cycles. As you can probably guess, if you're trying to go fast, wasting 50 clock cycles on an operation that should only require 1 is a bit ridiculous.&#xD;&#xA;&#xD;&#xA;The above function probably takes somewhere in the realm of 100-200 clock cycles to transfer 8 bits. This entails 24 pin-writes, and 8 reads. This is many, many times faster then using the `digital{stuff}` functions.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/Images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet.pdf&#xD;&#xA;  [2]: http://i.stack.imgur.com/przAI.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/P3Yu2.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/faCfk.png&#xD;&#xA;  [5]: http://www.nongnu.org/avr-libc/user-manual/FAQ.html#faq_use_bv&#xD;&#xA;  [6]: http://www.nongnu.org/avr-libc/user-manual/index.html&#xD;&#xA;" />
  <row Id="1037" PostHistoryTypeId="5" PostId="416" RevisionGUID="9f9ba425-2b3e-4950-89cb-912b6ec97d11" CreationDate="2014-02-24T05:03:54.433" UserId="86" Comment="added 940 characters in body" Text="This isn't weird looking. It's what normal MCU code actually looks like.&#xD;&#xA;&#xD;&#xA;What you have here is an example of the concept of *memory-mapped peripherals*. Basically, the MCU hardware has special locations in the SRAM address space of the MCU assigned to it. If you write to these addresses, the bits of the byte written to address *n* control the behaviour of peripheral *m*.   &#xD;&#xA;&#xD;&#xA;Basically, certain banks of memory literally have little wires running from the SRAM cell to the hardware. If you write a &quot;1&quot; to this bit in that byte, it sets this SRAM cell to a logical high, which then turns on some portion of the hardware.&#xD;&#xA;&#xD;&#xA;If you look into the headers for the MCU, there are great big tables of keyword&lt;-&gt;address mappings. This is how things like `TCCR1B` etc... are resolved at compile time.&#xD;&#xA;&#xD;&#xA;This memory-mapping mechanism is extremely broadly used in MCUs. The ATmega MCU in the arduino use it, as do PIC, ARM, MSP430, STM32 and STM8 MCU series, as well as lots of MCUs I'm not immediately familiar with. &#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;*Arduino* code is the weird stuff, with functions that access the MCU control registers indirectly. While this is somewhat &quot;nicer&quot; looking, it's also much slower, and uses a lot more program space.&#xD;&#xA;&#xD;&#xA;The mysterious constants are all described in great detail in the [ATmega328P datasheet][1], which you really should read if you're interested in doing anything more then occationally toggling pins on an arduino.&#xD;&#xA;&#xD;&#xA;Select excerpts from the datasheet linked above:  &#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;![enter image description here][3]&#xD;&#xA;![enter image description here][4]&#xD;&#xA;&#xD;&#xA;So, for example, `TIMSK1 |= (1 &lt;&lt; TOIE1);` sets the bit `TOIE1` in `TIMSK1`. This is achieved by shifting binary 1 (`0b00000001`) to the left by `TOIE1` bits, with `TOIE1` being defined in a header file as 0. This is then bitwise ORed into the current value of `TIMSK1`, which effectively set this one bit high.&#xD;&#xA;&#xD;&#xA;Looking at the documentation for bit 0 of `TIMSK1`, we can see it is described as  &#xD;&#xA;&#xD;&#xA;&gt; When this bit is written to one, and the I-flag in the Status Register&#xD;&#xA;&gt; is set (interrupts globally enabled), the Timer/Counter1 Overflow&#xD;&#xA;&gt; interrupt is enabled. The corresponding Interrupt Vector (See&#xD;&#xA;&gt; ”Interrupts” on page 57) is executed when the TOV1 Flag, located in&#xD;&#xA;&gt; TIFR1, is set.&#xD;&#xA;&#xD;&#xA;All the other lines should be interpreted in the same manner.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Some notes:&#xD;&#xA;&#xD;&#xA;You may also see things like `TIMSK1 |= _BV(TOIE1);`. `_BV()` is a [commonly used macro][5] originally from the [AVR libc implementation][6]. `_BV(TOIE1)` is functionally identical to `(1 &lt;&lt; TOIE1)`, with the benefit of better readability.&#xD;&#xA;&#xD;&#xA;Also, you may also see lines such as: `TIMSK1 &amp;= ~(1 &lt;&lt; TOIE1);` or `TIMSK1 &amp;= ~_BV(TOIE1);`. This has the opposite function of `TIMSK1 |= _BV(TOIE1);`, in that it *unsets* the bit `TOIE1` in `TIMSK1`. This is achieved by taking the bit-mask produced by `_BV(TOIE1)`, performing a bitwise NOT operation on it (`~`), and then ANDing `TIMSK1` by this NOTed value (which is 0b11111110).&#xD;&#xA;&#xD;&#xA;Note that in all these cases, the value of things like `(1 &lt;&lt; TOIE1)` or `_BV(TOIE1)` are fully resolved at *compile time*, so they functionally reduce to a simple constant, and therefore take no execution time to compute at runtime.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Properly written code will *generally* have comments inline with the code that detail what the registers being assigned to do. Here is a fairly simple soft-SPI routine I wrote recently:&#xD;&#xA;&#xD;&#xA;    uint8_t transactByteADC(uint8_t outByte)&#xD;&#xA;    {&#xD;&#xA;    	// Transfers one byte to the ADC, and receives one byte at the same time&#xD;&#xA;    	// does nothing with the chip-select&#xD;&#xA;    	// MSB first, data clocked on the rising edge&#xD;&#xA;    &#xD;&#xA;    	uint8_t loopCnt;&#xD;&#xA;    	uint8_t retDat = 0;&#xD;&#xA;    &#xD;&#xA;    	for (loopCnt = 0; loopCnt &lt; 8; loopCnt++)&#xD;&#xA;    	{&#xD;&#xA;    		if (outByte &amp; 0x80)			// if current bit is high&#xD;&#xA;    			PORTC |= _BV(ADC_MOSI);		// set data line&#xD;&#xA;    		else&#xD;&#xA;    			PORTC &amp;= ~(_BV(ADC_MOSI));	// else unset it&#xD;&#xA;    &#xD;&#xA;    		outByte &lt;&lt;= 1;				// and shift the output data over for the next iteration&#xD;&#xA;    		retDat &lt;&lt;= 1;				// shift over the data read back&#xD;&#xA;    		&#xD;&#xA;    		PORTC |= _BV(ADC_SCK);			// Set the clock high&#xD;&#xA;    &#xD;&#xA;    		if (PINC &amp; _BV(ADC_MISO))		// sample the input line&#xD;&#xA;    			retDat |= 0x01;			// and set the bit in the retval if the input is high&#xD;&#xA;    		&#xD;&#xA;    		PORTC &amp;= ~(_BV(ADC_SCK));		// set clock low&#xD;&#xA;    	}&#xD;&#xA;    	return retDat;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;`PORTC` is the register that controls the value of output pins within `PORTC` of the ATmega328P. `PINC` is the register where the *input* values of `PORTC` are available. Fundamentally, things like this are what happen internally when you use the `digitalWrite` or `digitalRead` functions. However, there is a look-up operation that converts the arduino &quot;pin numbers&quot; into actual hardware pin numbers, which takes somewhere in the realm of 50 clock cycles. As you can probably guess, if you're trying to go fast, wasting 50 clock cycles on an operation that should only require 1 is a bit ridiculous.&#xD;&#xA;&#xD;&#xA;The above function probably takes somewhere in the realm of 100-200 clock cycles to transfer 8 bits. This entails 24 pin-writes, and 8 reads. This is many, many times faster then using the `digital{stuff}` functions.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/Images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet.pdf&#xD;&#xA;  [2]: http://i.stack.imgur.com/przAI.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/P3Yu2.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/faCfk.png&#xD;&#xA;  [5]: http://www.nongnu.org/avr-libc/user-manual/FAQ.html#faq_use_bv&#xD;&#xA;  [6]: http://www.nongnu.org/avr-libc/user-manual/index.html&#xD;&#xA;" />
  <row Id="1038" PostHistoryTypeId="5" PostId="306" RevisionGUID="0a578cf3-82a3-4766-9dfb-faad13ca472d" CreationDate="2014-02-24T06:06:24.673" UserId="11" Comment="added 82 characters in body" Text="Error checking is actually very easy and there is an AVR lib that does this in a one liner.     &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Read up on  [`util/crc16.h`][1] and you should be good to go in no time with the included examples.&#xD;&#xA;    &#xD;&#xA;CRC is quite robust and fast for simple applications.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.nongnu.org/avr-libc/user-manual/group__util__crc.html" />
  <row Id="1039" PostHistoryTypeId="4" PostId="414" RevisionGUID="10ac078e-612d-43b4-8fea-74378e3e9d27" CreationDate="2014-02-24T09:38:06.547" UserId="84" Comment="Changed title into a real question" Text="Could someone explain this weird looking code, used to setup timers?" />
  <row Id="1040" PostHistoryTypeId="24" PostId="414" RevisionGUID="10ac078e-612d-43b4-8fea-74378e3e9d27" CreationDate="2014-02-24T09:38:06.547" Comment="Proposed by 84 approved by 11, 42 edit id of 116" />
  <row Id="1042" PostHistoryTypeId="2" PostId="417" RevisionGUID="38c83eba-5d97-4f5c-a980-5a6439a83eda" CreationDate="2014-02-24T12:02:04.777" UserId="42" Text="I've found [`tone()`][1] useful for generating high frequency pulses on any pin. It should be able to handle 56 KHz.&#xD;&#xA;&#xD;&#xA;The difficulty will obviously be combining it with your data signal. I don't think you could do that in software without resorting to low level code. It should be pretty easy in hardware though, since it's digital.&#xD;&#xA;&#xD;&#xA;All you'd need to do is output your data signal on a different pin, and then combine it with the carrier using an AND gate. The combined signal can go straight to your IR transmitter.&#xD;&#xA;&#xD;&#xA;If you don't have an AND gate handy then it's quite simple to make your own using a pair of transistors. Just search online for &quot;transistor and gate&quot;.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/Tone#.UwsyD2J_t8E" />
  <row Id="1043" PostHistoryTypeId="2" PostId="418" RevisionGUID="23caff8b-f8e0-4b8d-ab36-33c919b9d449" CreationDate="2014-02-24T12:23:42.077" UserId="42" Text="I currently have an Uno (which operates at 5v), and I'm looking at buying a Due (which only operates at 3.3v). I'd like to make them communicate via Serial or SPI or similar, but presumably connecting them directly isn't an option (I guess the Due's pins would get damaged).&#xD;&#xA;&#xD;&#xA;Is there any way to make the connection safe? Or is there an alternative form of communication I could safely use between them instead?" />
  <row Id="1044" PostHistoryTypeId="1" PostId="418" RevisionGUID="23caff8b-f8e0-4b8d-ab36-33c919b9d449" CreationDate="2014-02-24T12:23:42.077" UserId="42" Text="How can a 5v Uno talk to a 3.3v Due?" />
  <row Id="1045" PostHistoryTypeId="3" PostId="418" RevisionGUID="23caff8b-f8e0-4b8d-ab36-33c919b9d449" CreationDate="2014-02-24T12:23:42.077" UserId="42" Text="&lt;uno&gt;&lt;pins&gt;&lt;serial&gt;&lt;due&gt;&lt;voltage-level&gt;" />
  <row Id="1046" PostHistoryTypeId="2" PostId="419" RevisionGUID="a60f37c5-0a16-41db-b5c2-40fbb662e88a" CreationDate="2014-02-24T13:36:42.870" UserId="83" Text="- For a 5V logic output to a 3V3 logic input, you can use a resistive divider to lower the voltage.&#xD;&#xA;- When unloaded, a 3V3 logic output is just enough to drive a 5V logic input. Check the AVR datasheet for the exact voltages (0.6 × Vcc = 3V, found under DC Characteristics in the datasheet).&#xD;&#xA;&#xD;&#xA;In other words, with a little bit of special care it may just work.&#xD;&#xA;&#xD;&#xA;To construct a more reliable situation, use a level shifter. There are several listed on [this page](http://www.nxp.com/products/logic/level_shifters_translators/#products) but other manufacturers make similar devices.&#xD;&#xA;&#xD;&#xA;[This document](http://www.nxp.com/documents/application_note/AN10441.pdf) describes how a MOSFET can be used to convert logic levels between different supply voltages." />
  <row Id="1047" PostHistoryTypeId="5" PostId="419" RevisionGUID="3ae13960-25a8-45d4-9a50-266e2490a400" CreationDate="2014-02-24T14:34:57.913" UserId="83" Comment="added 16 characters in body" Text="- For a 5V logic output to a 3V3 logic input, you can use a resistive divider to lower the voltage.&#xD;&#xA;- When unloaded, a 3V3 logic output is just enough to drive a 5V logic input. Check the AVR datasheet for the exact voltages (0.6 × Vcc = 3V, found under DC Characteristics in the datasheet).&#xD;&#xA;&#xD;&#xA;In other words, with a little bit of special care it may just work.&#xD;&#xA;&#xD;&#xA;To construct a more reliable and bidirectional solution, use a level shifter. There are several listed on [this page](http://www.nxp.com/products/logic/level_shifters_translators/#products) but other manufacturers make similar devices.&#xD;&#xA;&#xD;&#xA;[This document](http://www.nxp.com/documents/application_note/AN10441.pdf) describes how a MOSFET can be used to bidirectionally convert logic levels between different supply voltages." />
  <row Id="1048" PostHistoryTypeId="5" PostId="46" RevisionGUID="e2fd868a-da4e-4b99-8455-722d71cf45cf" CreationDate="2014-02-24T14:35:00.370" UserId="42" Comment="added 1357 characters in body" Text="The process of programming consists of several stages, including editing the source code, managing libraries and build events, compiling/linking the program (or sketch), and debugging the program when it is running. In the case of Arduino, it typically also involves uploading the sketch to a device.&#xD;&#xA;&#xD;&#xA;Each part of this process is often managed by a separate program. These are often command-line based, and can be quite difficult to learn. However, an Integrated Development Environment combines everything into one application, and often automates several common tasks. This simplifies the programmer's workflow, allowing him/her to focus more on the project at hand.&#xD;&#xA;&#xD;&#xA;The official [Arduino software][1] is a very light-weight IDE, based on the [Processing Development Environment][2]. It includes all of the essential functionality for writing and uploading Arduino sketches, but lacks several features which are found in more sophisticated applications.&#xD;&#xA;&#xD;&#xA;Many users prefer more mainstream IDEs, which can have plug-ins or extensions to support Arduino. This includes Eclipse, Visual Studio, and XCode. More information about alternative IDEs can be found on [this question][3].&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/Software&#xD;&#xA;  [2]: http://www.processing.org/&#xD;&#xA;  [3]: http://arduino.stackexchange.com/questions/40/what-are-the-other-ides-for-arduino" />
  <row Id="1049" PostHistoryTypeId="24" PostId="46" RevisionGUID="e2fd868a-da4e-4b99-8455-722d71cf45cf" CreationDate="2014-02-24T14:35:00.370" Comment="Proposed by 42 approved by 48, 83 edit id of 117" />
  <row Id="1050" PostHistoryTypeId="2" PostId="420" RevisionGUID="3405fd3e-c380-4e87-b9dd-deaae8dcadb2" CreationDate="2014-02-24T14:36:05.793" UserId="60" Text="Any state of change on any pin configured as digital input can create an interrupt. Unlike the unique vectors for the interrupts causes by INT1 or INT2 the PinChangeInt feature uses a common vector and then Interrupt Service Routine (aka ISR) for this vector needs to then determine which pin changed. &#xD;&#xA;&#xD;&#xA;Fortunately [PinChangeInt Library](http://playground.arduino.cc/Main/PinChangeInt) makes this easy.&#xD;&#xA;&#xD;&#xA;    PCintPort::attachInterrupt(PIN, burpcount,RISING); // attach a PinChange Interrupt to our pin on the rising edge&#xD;&#xA;    // (RISING, FALLING and CHANGE all work with this library)&#xD;&#xA;    // and execute the function burpcount when that pin changes" />
  <row Id="1051" PostHistoryTypeId="34" PostId="296" RevisionGUID="845e3692-0ef7-4657-8d69-3d793c056ea1" CreationDate="2014-02-24T14:54:29.333" UserId="37" Comment="1" />
  <row Id="1058" PostHistoryTypeId="2" PostId="421" RevisionGUID="0779bdd4-5b6e-4b77-a4b4-a5b6758f459d" CreationDate="2014-02-24T16:53:23.563" UserId="62" Text="I'm currently working with the `Talon SR Speed Controller` and it requires a specific Input PWM Signal of `1-2 ms @ 333 Hz` and an input resolution of `10-bit (1024 steps)`. Currently I use the `Servo` library to handle these requirements, but was having some issues of the motors jumping their dead-band from forwards to backwards really fast causing the motors to rock back and forwards a few millimeters. If the `servo1.write(pwmValue);` isn't my issues please let me know?&#xD;&#xA;&#xD;&#xA;If there is a way to specifically achieve the 333Hz PWM signal for 4 motors of the same Uno or Due (most likely will transfer to a Due in a few days) I would like to implement that.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;From my understand I can modify the timers registers for the arduino specifically, but don't know exactly how to do that or to achieve 333Hz. If someone could please help me understand this I would greatly appreciate it.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Speed SR  Speed Controller Information:**&#xD;&#xA;&#xD;&#xA;    Input voltage 6-28 VDC&#xD;&#xA;    Continuous current 60 A&#xD;&#xA;    Peak current 100 A&#xD;&#xA;    Input PWM signal 1-2 ms @ 333 Hz&#xD;&#xA;    Input resolution 10-bit (1024 steps)&#xD;&#xA;    Output resolution 10-bit (1024 steps)&#xD;&#xA;    Output switching frequency 15 kHz&#xD;&#xA;    4% neutral dead band" />
  <row Id="1059" PostHistoryTypeId="1" PostId="421" RevisionGUID="0779bdd4-5b6e-4b77-a4b4-a5b6758f459d" CreationDate="2014-02-24T16:53:23.563" UserId="62" Text="Generating PWM signal 1-2 ms @ 333 Hz" />
  <row Id="1060" PostHistoryTypeId="3" PostId="421" RevisionGUID="0779bdd4-5b6e-4b77-a4b4-a5b6758f459d" CreationDate="2014-02-24T16:53:23.563" UserId="62" Text="&lt;arduino-uno&gt;&lt;arduino-due&gt;&lt;pwm&gt;" />
  <row Id="1061" PostHistoryTypeId="6" PostId="4" RevisionGUID="1c02cb3d-63a3-4105-bc06-14508ec79541" CreationDate="2014-02-24T17:17:50.090" UserId="48" Comment="edited tags" Text="&lt;ethernet&gt;&lt;arduino-yun&gt;&lt;web&gt;&lt;https&gt;" />
  <row Id="1062" PostHistoryTypeId="2" PostId="422" RevisionGUID="62766b6e-7dc9-4349-9d6f-a5ec0f429273" CreationDate="2014-02-24T20:45:44.093" UserId="84" Text="It is indeed possible to generate a 56KHz signal with an Arduino **timer**.&#xD;&#xA;&#xD;&#xA;A timer actually can be seen as a special register, in the MCU, that holds a value (starting at 0) that gets incremented at a frequency that is the MCU clock frequency (16MHz on UNO), possibility divided by a factor called *prescaler*. When that value reaches a limit, called **Compare Match**, that you specify, then 2 things happen:&#xD;&#xA;&#xD;&#xA;- the timer register value is reset to 0&#xD;&#xA;- one **ISR** (Interrupt Service Routine) callback function gets called (you can define it to point to your own code).&#xD;&#xA;&#xD;&#xA;The idea is to use that ISR to change the output of a logical pin every time it is called (`HIGH`, then `LOW`, then `HIGH`...)&#xD;&#xA;&#xD;&#xA;Now, in order to generate a 56KHz square wave, you'll need your ISR to be called `56000 * 2` times per second (`* 2` because you need to change the output value twice per period).&#xD;&#xA;&#xD;&#xA;You can choose the prescaler value you want for a timer among the following list:&#xD;&#xA;&#xD;&#xA;- 1 (clock frequency is not divided, hence 16MHz)&#xD;&#xA;- 8 (clock frequency is divided by 8, hence 2MHz)&#xD;&#xA;- 64&#xD;&#xA;- 256&#xD;&#xA;- 1024&#xD;&#xA;&#xD;&#xA;There are 2 sizes of timers/counters on UNO (they are called *timer/counter* actually): 8 bits and 16 bits.&#xD;&#xA;&#xD;&#xA;On UNO (Atmega328P), you have 3 timers overall, but some may be used by the Arduino core library or other libraries used in your sketches (you'll have to check that by youself):&#xD;&#xA;&#xD;&#xA;- timer0 (8-bit)&#xD;&#xA;- timer1 (16-bit)&#xD;&#xA;- timer2 (8-bit): this one has more prescaling options (1, 8, 32, 64, 128, 256, 1024)&#xD;&#xA;&#xD;&#xA;Now you need to generate a 56KHz wave from 16MHz, hence, without prescaling, you would need to count to:&#xD;&#xA;&#xD;&#xA;`16000000 / (56000 * 2) - 1 = 141.857` (`- 1` because a timer counts from 0 to this value and resets only **after** it has been reached)&#xD;&#xA;&#xD;&#xA;From this calculation, we can draw 2 observations:&#xD;&#xA;&#xD;&#xA; 1. `141.857` is not an integer and thus you won't be able to generate a wave of exactly 56KHz&#xD;&#xA; 2. Without prescaling, you need a 16-bit timer as 285 is not representable as an 8-bit unsigned integer&#xD;&#xA;&#xD;&#xA;From now you have 2 options:&#xD;&#xA;&#xD;&#xA; 1. Use a 16-bit timer (**timer1**), use prescaler = 1, and select `142` as the Compare Match; that will give you the following frequency: `16000000 / (2 * (142 + 1)) = 55944Hz`&#xD;&#xA; 2. Use an 8-bit timer (**timer0**), use prescaler = 8, and select `17` as the Compare Match; that will give less precision with the following frequency: `16000000 / (8 * 2 * (17 + 1)) = 55555Hz` which is still within the required range.&#xD;&#xA;&#xD;&#xA;Now, regarding how to write your sketch for that, I advise you to check out [this instructable][1] which is very complete and very interesting to read.&#xD;&#xA;&#xD;&#xA;Of course, [ATmega328P complete datasheet][2] is also important if you want to understand, in the slightest details, what you are doing.&#xD;&#xA;&#xD;&#xA;Some important notes: &#xD;&#xA;&#xD;&#xA;- an ISR is executed with disabled interrupts and must thus be as short as possible. In particular, there are several functions from the Arduino library that shall not be called from an ISR.&#xD;&#xA;- Arduino UNO clock is not very accurate (it uses a ceramic resonator instead of a quartz, which would have been much more accurate), so this means the output frequency will shift further.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.instructables.com/id/Arduino-Timer-Interrupts/?ALLSTEPS&#xD;&#xA;  [2]: http://www.atmel.ch/Images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet.pdf" />
  <row Id="1064" PostHistoryTypeId="5" PostId="417" RevisionGUID="8d11af0a-c731-4f5d-81be-292ba4085849" CreationDate="2014-02-24T21:23:34.093" UserId="42" Comment="Added a note about accuracy." Text="I've found [`tone()`][1] useful for generating high frequency pulses on any pin. It should be able to handle 56 KHz. *(Edit: As noted by jfpoilpret, the closest you could actually get on a 16 MHz Arduino is about 55.944 KHz)*&#xD;&#xA;&#xD;&#xA;The difficulty will obviously be combining it with your data signal. I don't think you could do that in software without resorting to low level code. It should be pretty easy in hardware though, since it's digital.&#xD;&#xA;&#xD;&#xA;All you'd need to do is output your data signal on a different pin, and then combine it with the carrier using an AND gate. The combined signal can go straight to your IR transmitter.&#xD;&#xA;&#xD;&#xA;If you don't have an AND gate handy then it's quite simple to make your own using a pair of transistors. Just search online for &quot;transistor and gate&quot;.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/Tone#.UwsyD2J_t8E" />
  <row Id="1065" PostHistoryTypeId="2" PostId="423" RevisionGUID="34c700fa-c6dc-4423-80a4-9c2ccd1eec44" CreationDate="2014-02-25T01:01:42.260" UserId="-1" Text="" />
  <row Id="1066" PostHistoryTypeId="2" PostId="424" RevisionGUID="4e8eb1de-a3a1-442a-84c0-ebcc30ad05b5" CreationDate="2014-02-25T01:01:42.260" UserId="-1" Text="" />
  <row Id="1067" PostHistoryTypeId="2" PostId="425" RevisionGUID="accbaf84-5574-4675-b34e-9fd0cb63ee8a" CreationDate="2014-02-25T01:03:54.677" UserId="-1" Text="" />
  <row Id="1068" PostHistoryTypeId="2" PostId="426" RevisionGUID="59e905a2-9cb5-4453-9a8e-6e98ce66fffc" CreationDate="2014-02-25T01:03:54.677" UserId="-1" Text="" />
  <row Id="1076" PostHistoryTypeId="6" PostId="74" RevisionGUID="edfd3e50-a325-4804-bc40-6c6d1e7c9268" CreationDate="2014-02-25T01:44:59.277" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;arduino-uno&gt;&lt;enclosure&gt;&lt;cooling&gt;" />
  <row Id="1077" PostHistoryTypeId="24" PostId="74" RevisionGUID="edfd3e50-a325-4804-bc40-6c6d1e7c9268" CreationDate="2014-02-25T01:44:59.277" Comment="Proposed by 220 approved by 99 edit id of 140" />
  <row Id="1080" PostHistoryTypeId="6" PostId="136" RevisionGUID="15aba6f8-3405-4323-8d3b-ed4d98a41177" CreationDate="2014-02-25T01:57:19.203" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;arduino-uno&gt;&lt;revisions&gt;" />
  <row Id="1081" PostHistoryTypeId="24" PostId="136" RevisionGUID="15aba6f8-3405-4323-8d3b-ed4d98a41177" CreationDate="2014-02-25T01:57:19.203" Comment="Proposed by 220 approved by 33, 65 edit id of 134" />
  <row Id="1082" PostHistoryTypeId="6" PostId="39" RevisionGUID="2f356102-7a4e-4095-8825-1e38c4d520e6" CreationDate="2014-02-25T01:57:21.940" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;ethernet&gt;&lt;arduino-uno&gt;&lt;shields&gt;" />
  <row Id="1083" PostHistoryTypeId="24" PostId="39" RevisionGUID="2f356102-7a4e-4095-8825-1e38c4d520e6" CreationDate="2014-02-25T01:57:21.940" Comment="Proposed by 220 approved by 33 edit id of 143" />
  <row Id="1084" PostHistoryTypeId="6" PostId="129" RevisionGUID="de0dae9f-8ea0-4c68-936b-a1e6e5e995f7" CreationDate="2014-02-25T02:40:16.173" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;arduino-uno&gt;&lt;atmega328&gt;" />
  <row Id="1085" PostHistoryTypeId="24" PostId="129" RevisionGUID="de0dae9f-8ea0-4c68-936b-a1e6e5e995f7" CreationDate="2014-02-25T02:40:16.173" Comment="Proposed by 220 approved by 37 edit id of 136" />
  <row Id="1086" PostHistoryTypeId="2" PostId="429" RevisionGUID="6afd6f04-622d-426f-a3f5-579d469d81ad" CreationDate="2014-02-25T02:53:22.187" UserId="131" Text="I'm building a weather station with two UNOs, using NRF24l01+ radios. Communications are fine. I'm sending a STRUCT from one to the other. The STRUCT has three elements:&#xD;&#xA;&#xD;&#xA;        struct weather {&#xD;&#xA;          float tempData;&#xD;&#xA;          float humData;&#xD;&#xA;          float pressData;&#xD;&#xA;        };&#xD;&#xA;        weather wData = {0, 0, 0};&#xD;&#xA;&#xD;&#xA;I then populate the STRUCT with values from my DHT22 Temperature Sensor and my BMP085 pressure sensor.&#xD;&#xA;&#xD;&#xA;        float c = dht.readTemperature();&#xD;&#xA;        wData.tempData = (c * 9/5) + 32;&#xD;&#xA;        wData.humData = dht.readHumidity();&#xD;&#xA;&#xD;&#xA;        sensors_event_t event;&#xD;&#xA;        bmp.getEvent(&amp;event);&#xD;&#xA;        wData.pressData = (0.0295 * event.pressure);&#xD;&#xA;&#xD;&#xA;Now I send it via the NRF24L01+.&#xD;&#xA;&#xD;&#xA;        radio.write(&amp;wData, sizeof(wData);&#xD;&#xA;&#xD;&#xA;On the receiving Uno I have this.&#xD;&#xA;&#xD;&#xA;        struct weather {&#xD;&#xA;          float tempData;&#xD;&#xA;          float humData;&#xD;&#xA;          float pressData;&#xD;&#xA;        };&#xD;&#xA;      &#xD;&#xA;        weather wData = {0, 0, 0};&#xD;&#xA;      &#xD;&#xA;        radio.read( &amp;wData, sizeof(wData) );&#xD;&#xA;        Serial.println(wData.tempData);&#xD;&#xA;        Serial.println(wData.humData);&#xD;&#xA;        Serial.println(wData.pressData);&#xD;&#xA;&#xD;&#xA;I get results similar to this:&#xD;&#xA;&#xD;&#xA;        Temp = 75.43&#xD;&#xA;        Hum = 35.76&#xD;&#xA;        Press = 0.00&#xD;&#xA;&#xD;&#xA;The first two are correct. The final one is not. I can change the order and the first two will always be correct, but the last element is always 0.00. For example:&#xD;&#xA;&#xD;&#xA;       Hum = 35.76&#xD;&#xA;       Press = 30.14&#xD;&#xA;       Temp = 0.00&#xD;&#xA;&#xD;&#xA;I know I'm missing something here with my code but I can't find it. Anyone have some suggestions?&#xD;&#xA;" />
  <row Id="1087" PostHistoryTypeId="1" PostId="429" RevisionGUID="6afd6f04-622d-426f-a3f5-579d469d81ad" CreationDate="2014-02-25T02:53:22.187" UserId="131" Text="Last Element of a STRUCT disappearing" />
  <row Id="1088" PostHistoryTypeId="3" PostId="429" RevisionGUID="6afd6f04-622d-426f-a3f5-579d469d81ad" CreationDate="2014-02-25T02:53:22.187" UserId="131" Text="&lt;struct&gt;&lt;missing&gt;&lt;element&gt;" />
  <row Id="1090" PostHistoryTypeId="6" PostId="193" RevisionGUID="16cd80af-96df-4934-8279-a0a1e6209556" CreationDate="2014-02-25T02:56:38.447" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;programming&gt;&lt;sketch&gt;&lt;arduino-uno&gt;&lt;arduino-leonardo&gt;" />
  <row Id="1091" PostHistoryTypeId="24" PostId="193" RevisionGUID="16cd80af-96df-4934-8279-a0a1e6209556" CreationDate="2014-02-25T02:56:38.447" Comment="Proposed by 220 approved by 8 edit id of 131" />
  <row Id="1092" PostHistoryTypeId="6" PostId="340" RevisionGUID="9783fea0-2f2f-49f3-9e6a-8692f039f73d" CreationDate="2014-02-25T02:57:11.497" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;arduino-uno&gt;&lt;lcd&gt;" />
  <row Id="1093" PostHistoryTypeId="24" PostId="340" RevisionGUID="9783fea0-2f2f-49f3-9e6a-8692f039f73d" CreationDate="2014-02-25T02:57:11.497" Comment="Proposed by 220 approved by 8, 65 edit id of 123" />
  <row Id="1094" PostHistoryTypeId="6" PostId="28" RevisionGUID="97ab4169-0897-4edd-8246-9364f605998d" CreationDate="2014-02-25T04:54:13.770" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;arduino-uno&gt;&lt;matlab&gt;" />
  <row Id="1095" PostHistoryTypeId="24" PostId="28" RevisionGUID="97ab4169-0897-4edd-8246-9364f605998d" CreationDate="2014-02-25T04:54:13.770" Comment="Proposed by 220 approved by 25 edit id of 145" />
  <row Id="1096" PostHistoryTypeId="6" PostId="153" RevisionGUID="bc5de367-0b10-41cf-aa2c-fcf9c43a5c6b" CreationDate="2014-02-25T05:01:21.340" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;arduino-uno&gt;&lt;testing&gt;" />
  <row Id="1097" PostHistoryTypeId="24" PostId="153" RevisionGUID="bc5de367-0b10-41cf-aa2c-fcf9c43a5c6b" CreationDate="2014-02-25T05:01:21.340" Comment="Proposed by 220 approved by 8, 77 edit id of 133" />
  <row Id="1098" PostHistoryTypeId="6" PostId="56" RevisionGUID="52eb56c6-165b-438a-abc0-de47b08d33f7" CreationDate="2014-02-25T05:01:27.153" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;arduino-uno&gt;&lt;unit-test&gt;" />
  <row Id="1099" PostHistoryTypeId="24" PostId="56" RevisionGUID="52eb56c6-165b-438a-abc0-de47b08d33f7" CreationDate="2014-02-25T05:01:27.153" Comment="Proposed by 220 approved by 77 edit id of 141" />
  <row Id="1100" PostHistoryTypeId="2" PostId="430" RevisionGUID="73aa51ee-c6bf-42d2-8076-69d65b741c7d" CreationDate="2014-02-25T05:44:28.927" UserId="33" Text="Will it still run on less than 5 volts? Will it break?" />
  <row Id="1101" PostHistoryTypeId="1" PostId="430" RevisionGUID="73aa51ee-c6bf-42d2-8076-69d65b741c7d" CreationDate="2014-02-25T05:44:28.927" UserId="33" Text="What will happen if I give my Arduino Uno more or less than 5 volts?" />
  <row Id="1102" PostHistoryTypeId="3" PostId="430" RevisionGUID="73aa51ee-c6bf-42d2-8076-69d65b741c7d" CreationDate="2014-02-25T05:44:28.927" UserId="33" Text="&lt;arduino-uno&gt;&lt;power&gt;&lt;safety&gt;" />
  <row Id="1103" PostHistoryTypeId="5" PostId="108" RevisionGUID="4c1f4574-d4e5-4a28-9859-2b4520de8cc8" CreationDate="2014-02-25T06:32:21.537" UserId="35" Comment="added 255 characters in body" Text="The Arduino Uno is the most common and one of the newest Arduinos, based on the ATmega328 microcontroller. Use this tag when asking a question specific to an Uno, not just a general Arduino question. Also consider using more specific tags to your problem." />
  <row Id="1104" PostHistoryTypeId="24" PostId="108" RevisionGUID="4c1f4574-d4e5-4a28-9859-2b4520de8cc8" CreationDate="2014-02-25T06:32:21.537" Comment="Proposed by 35 approved by 8, 83 edit id of 148" />
  <row Id="1105" PostHistoryTypeId="6" PostId="331" RevisionGUID="0c19fa9b-9bf6-45c7-88da-cb269baf5cbd" CreationDate="2014-02-25T06:32:32.693" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;arduino-uno&gt;&lt;lcd&gt;&lt;oscillator-clock&gt;" />
  <row Id="1106" PostHistoryTypeId="24" PostId="331" RevisionGUID="0c19fa9b-9bf6-45c7-88da-cb269baf5cbd" CreationDate="2014-02-25T06:32:32.693" Comment="Proposed by 220 approved by 8, 83 edit id of 124" />
  <row Id="1107" PostHistoryTypeId="6" PostId="132" RevisionGUID="e90f3a3f-0098-4f8d-a90f-f45fcd9e4837" CreationDate="2014-02-25T06:32:37.477" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;pins&gt;&lt;arduino-uno&gt;" />
  <row Id="1108" PostHistoryTypeId="24" PostId="132" RevisionGUID="e90f3a3f-0098-4f8d-a90f-f45fcd9e4837" CreationDate="2014-02-25T06:32:37.477" Comment="Proposed by 220 approved by 8, 83 edit id of 135" />
  <row Id="1109" PostHistoryTypeId="6" PostId="117" RevisionGUID="82205402-18ef-4ae9-aca0-6564b68fc400" CreationDate="2014-02-25T06:32:41.647" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;pins&gt;&lt;arduino-uno&gt;" />
  <row Id="1110" PostHistoryTypeId="24" PostId="117" RevisionGUID="82205402-18ef-4ae9-aca0-6564b68fc400" CreationDate="2014-02-25T06:32:41.647" Comment="Proposed by 220 approved by 8, 83 edit id of 137" />
  <row Id="1111" PostHistoryTypeId="6" PostId="85" RevisionGUID="63d549cf-45a3-4640-8717-51f05515273f" CreationDate="2014-02-25T06:32:45.650" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;serial&gt;&lt;pins&gt;&lt;uploading&gt;&lt;arduino-uno&gt;" />
  <row Id="1112" PostHistoryTypeId="24" PostId="85" RevisionGUID="63d549cf-45a3-4640-8717-51f05515273f" CreationDate="2014-02-25T06:32:45.650" Comment="Proposed by 220 approved by 8, 83 edit id of 139" />
  <row Id="1113" PostHistoryTypeId="6" PostId="210" RevisionGUID="9f48d057-b7aa-4488-8803-3bf6d4052499" CreationDate="2014-02-25T06:32:49.447" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;arduino-uno&gt;&lt;pwm&gt;&lt;arduino-leonardo&gt;&lt;analogwrite&gt;" />
  <row Id="1114" PostHistoryTypeId="24" PostId="210" RevisionGUID="9f48d057-b7aa-4488-8803-3bf6d4052499" CreationDate="2014-02-25T06:32:49.447" Comment="Proposed by 220 approved by 8, 83 edit id of 130" />
  <row Id="1115" PostHistoryTypeId="6" PostId="269" RevisionGUID="b3e5cd74-e99c-473c-b8bb-a7fd9df87d7b" CreationDate="2014-02-25T06:32:52.103" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;arduino-uno&gt;&lt;sensors&gt;&lt;arduino-mega&gt;" />
  <row Id="1116" PostHistoryTypeId="24" PostId="269" RevisionGUID="b3e5cd74-e99c-473c-b8bb-a7fd9df87d7b" CreationDate="2014-02-25T06:32:52.103" Comment="Proposed by 220 approved by 8, 83 edit id of 127" />
  <row Id="1117" PostHistoryTypeId="6" PostId="286" RevisionGUID="8d00cca4-e5ff-40d1-8b0e-d94b099c1815" CreationDate="2014-02-25T06:32:54.930" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;arduino-uno&gt;&lt;threads&gt;" />
  <row Id="1118" PostHistoryTypeId="24" PostId="286" RevisionGUID="8d00cca4-e5ff-40d1-8b0e-d94b099c1815" CreationDate="2014-02-25T06:32:54.930" Comment="Proposed by 220 approved by 8, 83 edit id of 126" />
  <row Id="1119" PostHistoryTypeId="6" PostId="418" RevisionGUID="829f1b5c-ecf9-4e35-9acb-d1f307c778ab" CreationDate="2014-02-25T06:32:57.523" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;serial&gt;&lt;pins&gt;&lt;arduino-uno&gt;&lt;due&gt;&lt;voltage-level&gt;" />
  <row Id="1120" PostHistoryTypeId="24" PostId="418" RevisionGUID="829f1b5c-ecf9-4e35-9acb-d1f307c778ab" CreationDate="2014-02-25T06:32:57.523" Comment="Proposed by 220 approved by 8, 83 edit id of 122" />
  <row Id="1121" PostHistoryTypeId="5" PostId="107" RevisionGUID="fb87f4db-c674-4bde-84a6-c89da8b118ec" CreationDate="2014-02-25T06:34:09.577" UserId="35" Comment="added 287 characters in body" Text="The Arduino Uno is the most common and one of the newest Arduino boards. It has 14 digital I/O pins and 6 analog input pins. There are three different versions of the Uno: R1, R2, and R3.&#xD;&#xA;&#xD;&#xA; - Microcontroller: ATmega328&#xD;&#xA; - Operating Voltage: 5V&#xD;&#xA; - Input Voltage (recommended): 7-12V&#xD;&#xA; - Input Voltage (limits): 6-20V&#xD;&#xA; - Digital I/O Pins: 14 (of which 6 provide PWM output)&#xD;&#xA; - Analog Input Pins: 6&#xD;&#xA; - DC Current per I/O Pin: 40 mA&#xD;&#xA; - DC Current for 3.3V Pin: 50 mA&#xD;&#xA; - Flash Memory: 32 KB (ATmega328) of which 0.5 KB used by bootloader&#xD;&#xA; - SRAM: 2 KB (ATmega328)&#xD;&#xA; - EEPROM: 1 KB (ATmega328)&#xD;&#xA; - Clock Speed: 16 MHz&#xD;&#xA;&#xD;&#xA;[Official Arduino Uno][1] page.&#xD;&#xA;&#xD;&#xA;The main limitation with the Uno is the Uno's lack of SRAM or flash memory. However, the Uno is the most commonly used Arduino board. It is $30, and is compatible with many shields.&#xD;&#xA;&#xD;&#xA;Also consider using more specific tags to your problem, such as [tag:programming] or [tag:serial].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardUno" />
  <row Id="1122" PostHistoryTypeId="24" PostId="107" RevisionGUID="fb87f4db-c674-4bde-84a6-c89da8b118ec" CreationDate="2014-02-25T06:34:09.577" Comment="Proposed by 35 approved by 8, 83 edit id of 147" />
  <row Id="1123" PostHistoryTypeId="6" PostId="12" RevisionGUID="41377fa0-f790-4e2c-8049-3b6c0318e2d8" CreationDate="2014-02-25T06:34:13.593" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;arduino-uno&gt;&lt;firmware&gt;" />
  <row Id="1124" PostHistoryTypeId="24" PostId="12" RevisionGUID="41377fa0-f790-4e2c-8049-3b6c0318e2d8" CreationDate="2014-02-25T06:34:13.593" Comment="Proposed by 220 approved by 8, 83 edit id of 146" />
  <row Id="1125" PostHistoryTypeId="6" PostId="188" RevisionGUID="98d90be9-d6a2-4ac5-bbbf-76c171cc82f7" CreationDate="2014-02-25T06:34:23.437" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;programming&gt;&lt;arduino-uno&gt;" />
  <row Id="1126" PostHistoryTypeId="24" PostId="188" RevisionGUID="98d90be9-d6a2-4ac5-bbbf-76c171cc82f7" CreationDate="2014-02-25T06:34:23.437" Comment="Proposed by 220 approved by 8, 83 edit id of 132" />
  <row Id="1127" PostHistoryTypeId="6" PostId="304" RevisionGUID="e997e1d2-07bd-4a04-a89f-846d56f27fb6" CreationDate="2014-02-25T06:34:32.143" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;pins&gt;&lt;arduino-uno&gt;&lt;clones&gt;" />
  <row Id="1128" PostHistoryTypeId="24" PostId="304" RevisionGUID="e997e1d2-07bd-4a04-a89f-846d56f27fb6" CreationDate="2014-02-25T06:34:32.143" Comment="Proposed by 220 approved by 8, 83 edit id of 125" />
  <row Id="1129" PostHistoryTypeId="6" PostId="224" RevisionGUID="2559c782-7117-4f85-aad5-9acda9f83041" CreationDate="2014-02-25T06:34:36.940" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;uploading&gt;&lt;arduino-uno&gt;" />
  <row Id="1130" PostHistoryTypeId="24" PostId="224" RevisionGUID="2559c782-7117-4f85-aad5-9acda9f83041" CreationDate="2014-02-25T06:34:36.940" Comment="Proposed by 220 approved by 8, 83 edit id of 129" />
  <row Id="1131" PostHistoryTypeId="5" PostId="376" RevisionGUID="6b71804d-053a-4061-be24-35c7a2afc470" CreationDate="2014-02-25T06:34:51.817" UserId="220" Comment="added 199 characters in body" Text="A clone is a legal, Arduino-like board developed by a 3rd party using the original schematics for the board (with a few minor adjustments). If significant changes are made, it is called a derivative." />
  <row Id="1132" PostHistoryTypeId="24" PostId="376" RevisionGUID="6b71804d-053a-4061-be24-35c7a2afc470" CreationDate="2014-02-25T06:34:51.817" Comment="Proposed by 220 approved by 8, 83 edit id of 121" />
  <row Id="1133" PostHistoryTypeId="5" PostId="426" RevisionGUID="4fb3445a-8080-4f7a-a784-fbce6ab75299" CreationDate="2014-02-25T06:35:09.707" UserId="220" Comment="added 265 characters in body" Text="Linux is an open source operating system (OS) that is lightweight and runs on many systems. It also runs on the Arduino Yún. There are different &quot;flavors&quot; or &quot;distros&quot; (distributions and changes made by different groups) of Linux such as Ubuntu, Debian, and Fedora." />
  <row Id="1134" PostHistoryTypeId="24" PostId="426" RevisionGUID="4fb3445a-8080-4f7a-a784-fbce6ab75299" CreationDate="2014-02-25T06:35:09.707" Comment="Proposed by 220 approved by 8, 83 edit id of 120" />
  <row Id="1135" PostHistoryTypeId="6" PostId="88" RevisionGUID="a9e064a0-dc99-4f11-a25b-f7a301fa542a" CreationDate="2014-02-25T06:35:14.613" UserId="220" Comment="Merging the two Uno tags... it should be with &quot;Arduino&quot;- see meta." Text="&lt;pins&gt;&lt;arduino-uno&gt;&lt;current&gt;" />
  <row Id="1136" PostHistoryTypeId="24" PostId="88" RevisionGUID="a9e064a0-dc99-4f11-a25b-f7a301fa542a" CreationDate="2014-02-25T06:35:14.613" Comment="Proposed by 220 approved by 8, 83 edit id of 138" />
  <row Id="1138" PostHistoryTypeId="2" PostId="432" RevisionGUID="7e9209b6-7697-46fb-8c2c-424e32bb5aeb" CreationDate="2014-02-25T06:50:47.410" UserId="225" Text="I have a wireless home router that I would like to use to communicate with an Arduino. Is it possible to connect my Arduino Uno to the router via the ethernet port and then communicate with it wirelessly over my home network? If so, how would this be accomplished?" />
  <row Id="1139" PostHistoryTypeId="1" PostId="432" RevisionGUID="7e9209b6-7697-46fb-8c2c-424e32bb5aeb" CreationDate="2014-02-25T06:50:47.410" UserId="225" Text="How can I connect to an Arduino using WiFi?" />
  <row Id="1140" PostHistoryTypeId="3" PostId="432" RevisionGUID="7e9209b6-7697-46fb-8c2c-424e32bb5aeb" CreationDate="2014-02-25T06:50:47.410" UserId="225" Text="&lt;arduino-uno&gt;&lt;wifi&gt;" />
  <row Id="1141" PostHistoryTypeId="5" PostId="407" RevisionGUID="58a461f3-ed7b-44b2-9bf3-dd86449eaddb" CreationDate="2014-02-25T06:59:25.793" UserId="84" Comment="Added MOSFET as a serious option" Text="To drive such high currents, you may have to cascade several transistors (you can also use a [Darlington transistor][1]). There are arrays of Darlingtons mounted in a chip (e.g. the ULN2803A has 8 darlington transistors, but is limited to 500mA).&#xD;&#xA;&#xD;&#xA;You probably will have to deal with higher power transistors; as an example I have found STMicroelectronics [TIP110][2] which can support switching a 2A current (4A peak), but it would probably need a heatsink to dissipate heat.&#xD;&#xA;&#xD;&#xA;Note that I wonder if your steppers really need 2A current (are they that big?). For steppers, you can generally find IC that can drive them easily, e.g. the L293D but this one can drive &quot;only&quot; 600mA).&#xD;&#xA;&#xD;&#xA;As a conclusion, I am afraid you will not find a &quot;one size fits all&quot; solution, as all your devices are different and should be driven by the appropriate circuit.&#xD;&#xA;&#xD;&#xA;**Edit:**&#xD;&#xA;&#xD;&#xA;Since oversizing is not an issue in your prototyping case, then you could go with a **MOSFET** instead of usual bipolar transistors. A MOSFET will be able to drive higher currents and voltages than standard transistors. &#xD;&#xA;&#xD;&#xA;The downside is you can use it as a switch only (like e.g. a relay) and thus can't really **drive** the exact power for your devices. I guess that does not matter for a Stepper motor, or a Solenoid, but that may be important for driving lights for instance.&#xD;&#xA;&#xD;&#xA;However, the good point is that you can still use PWM for that as the MOSFET switching speed is good enough for such purposes.&#xD;&#xA;&#xD;&#xA;Regarding price, there are many diferent kinds of MOSFET out there, but I guess you can find one that fits yours needs (12V, 2A) for less than $1.&#xD;&#xA;&#xD;&#xA;I advise you to take a look at [this great article][3] about this topic.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Darlington_transistor&#xD;&#xA;  [2]: http://www.st.com/web/en/resource/technical/document/datasheet/CD00000909.pdf&#xD;&#xA;  [3]: http://bildr.org/2012/03/rfp30n06le-arduino/" />
  <row Id="1142" PostHistoryTypeId="2" PostId="433" RevisionGUID="17587356-5b15-43fd-991d-44c8ce181842" CreationDate="2014-02-25T07:03:02.160" UserId="83" Text="Will it break at &lt; 5V? Not likely. &#xD;&#xA;&#xD;&#xA;- Check the datasheet for the IC's on the board and find the minimum power supply voltage the device works at.&#xD;&#xA;- At typical ATmega328 Safe Operating Area (under &quot;Speed grades&quot; in the datasheet) specifies approximately 4.1V for 16MHz.&#xD;&#xA;- If you require to use the USB interface, you'll have to check the datasheet for that chip too.&#xD;&#xA;&#xD;&#xA;Will it break at &gt; 5V? Depends on where you apply it.&#xD;&#xA;&#xD;&#xA;- V(IN) should work fine for 7-20VDC as it is fed through an on board regulator. Notice though that the regulator has to dissipate the excess voltage and can get pretty hot when you draw a fair bit of current. The regulator will fail if the voltage goes over 20V or gets too hot too often;&#xD;&#xA;- +5V should work fine up to 5V, and I personally wouldn't worry if an external supply delivers up to 5.5V unloaded. Above that 5.5V you will probably release the magic blue smoke." />
  <row Id="1144" PostHistoryTypeId="5" PostId="424" RevisionGUID="f9f671ee-769b-4868-a540-9d8163ffdf62" CreationDate="2014-02-25T07:38:06.007" UserId="220" Comment="added 302 characters in body" Text="IR stands for infrared and is a type of light not visible to the naked eye. Some cameras, however, do see it. It usually shows up as a purplish or reddish color (hence the name). It is the medium that most modern TV remotes use to communicate. That is the reason you have to point the remote at the TV." />
  <row Id="1145" PostHistoryTypeId="24" PostId="424" RevisionGUID="f9f671ee-769b-4868-a540-9d8163ffdf62" CreationDate="2014-02-25T07:38:06.007" Comment="Proposed by 220 approved by 11, 83 edit id of 119" />
  <row Id="1146" PostHistoryTypeId="6" PostId="418" RevisionGUID="efd53552-381c-4f08-aff4-40dc789266a6" CreationDate="2014-02-25T07:47:25.397" UserId="84" Comment="Changed due to arduino-due (consistent tagging is expected throughout the site)" Text="&lt;arduino-uno&gt;&lt;serial&gt;&lt;pins&gt;&lt;arduino-due&gt;&lt;voltage-level&gt;" />
  <row Id="1147" PostHistoryTypeId="24" PostId="418" RevisionGUID="efd53552-381c-4f08-aff4-40dc789266a6" CreationDate="2014-02-25T07:47:25.397" Comment="Proposed by 84 approved by 11, 83 edit id of 149" />
  <row Id="1149" PostHistoryTypeId="5" PostId="215" RevisionGUID="63ae4813-5060-40e3-811f-a0c398a69552" CreationDate="2014-02-25T11:41:30.783" UserId="46" Comment="Removed reference to uninitialized variables as per Fake Name comments." Text="First, let's see a few examples of what can go wrong.&#xD;&#xA;&#xD;&#xA;# Uninitialized variables #&#xD;&#xA;&#xD;&#xA;    int status;&#xD;&#xA;    pinMode(13, OUTPUT);&#xD;&#xA;    digitalWrite(13, status);&#xD;&#xA;&#xD;&#xA;Although the variable status is not explicitly initialized by the code above, the C++ compiler does that for you. It sets it as zero. So, even though it's not explicit in the code, we know that the led won't be lit. However, it's not considered good practice to rely on that behaviour. Try and assign values to your variables as it makes the code clearer.&#xD;&#xA;&#xD;&#xA;# Memory overflow #&#xD;&#xA;&#xD;&#xA;    int array[10];&#xD;&#xA;    int v = array[100];&#xD;&#xA;    array[-100] = 10;&#xD;&#xA;&#xD;&#xA;The first problem here is that you don't know what will be assigned to v, but worse is that you don't know what you messed up with the assignment to position -100 of `array`. The good news is that you only messed up with RAM and not with the EEPROM, thus your program is safe.&#xD;&#xA;&#xD;&#xA;# Jump to an illegal instruction #&#xD;&#xA;&#xD;&#xA;    void doSomething( void ) { &#xD;&#xA;        for (int i = 0; i &lt; 1000; i++); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void setup () &#xD;&#xA;    {&#xD;&#xA;        void (*funcPtr)( void );&#xD;&#xA;&#xD;&#xA;        funcPtr = &amp;doSomething;&#xD;&#xA;        funcPtr(); // calls doSomething();&#xD;&#xA;&#xD;&#xA;        funcPtr = NULL;&#xD;&#xA;        funcPtr(); // undefined behavior&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The first call to `funcPtr()` will actually be a call to `doSomething()`. Calls like the second one may lead to undefined behavior. In this case, it will continue execution from memory address 0, which seems to be the start of the sketch (I just tested and that's equivalent to a soft boot - it doesn't even go through the bootloader). &#xD;&#xA;&#xD;&#xA;# Other bad things that may happen #&#xD;&#xA;&#xD;&#xA;Well, you can run out of RAM, for example. What else. In any case, I think your program will keep running, probably not the way you intended it to.&#xD;&#xA;&#xD;&#xA;# Kinds of Protection #&#xD;&#xA;&#xD;&#xA;In computer systems, problems like these are usually dealt with at various levels:&#xD;&#xA;&#xD;&#xA;1. By the compiler&#xD;&#xA;1. By the programming language runtime (as in Java for example). &#xD;&#xA;1. By the operating system or the processor (if your memory access a position outside the boundaries of the address space reserved to your program, the OS or the processor may have safety mechanisms to prevent that)&#xD;&#xA;&#xD;&#xA;Arduinos only have limited protection of the compiler, and probably nothing else. The good news is that they aren't multi-tasked, so the only program being affected is yours. In any case, any of those bugs will lead to erratic behavior.&#xD;&#xA;&#xD;&#xA;# The Answers #&#xD;&#xA;&#xD;&#xA;The assumptions are the all of the problems I stated above are runtime problems.&#xD;&#xA;&#xD;&#xA;&gt; What happens if there is a runtime error in a program? &#xD;&#xA;&#xD;&#xA;The program will continue and what happens will depend on the side-effects of the runtime error. A call to the null function pointer will probably make the program jump to an unknown location.&#xD;&#xA;&#xD;&#xA;&gt; Will execution of the program just stop?&#xD;&#xA;&#xD;&#xA;No, it will keep going as if nothing extraordinary happened, probably doing what you didn't intend it to do. It may reset or act erratically. It may turn some inputs into outputs and burn a sensor or two (but that's *highly unlikely*).&#xD;&#xA;&#xD;&#xA;&gt; Is there some way I get the Arduino to tell me what the error is?&#xD;&#xA;&#xD;&#xA;I don't think so. As I said earlier, the protection mechanisms aren't there. There's no runtime support from the language, no OS, no hardware checks for out-of-bounds memory access (the bootloader doesn't count as either). You just have to be careful with your program and probably set your own safety nets. &#xD;&#xA;&#xD;&#xA;The reason for the lack of protection is probably because Arduino controllers are too cheap, have too little memory, and should not run anything too important (yes, there seems to be a disclaimer by AVR somewhere for you not to use the MCUs normally used by Arduino in life support systems).&#xD;&#xA;" />
  <row Id="1150" PostHistoryTypeId="2" PostId="434" RevisionGUID="34175bce-51c8-4509-9eb5-dc5201612bf7" CreationDate="2014-02-25T13:38:13.100" UserId="232" Text="I am new to the world of Arduinos but have a new project going with a MultiWii Flight controller. With the MultiWii comes a software for showing all data that is measured from the sensors (acceleration, velocity, , roll, pitch, etc) which is nice but I would like to have/extract this data (call raw data or something) from all sensors (i.e. the data plotting everything, in numbers). Maybe it is the simplest thing to do, and I guess I have to set up some serial connection between the controller and tell it to send this data somehow but I do not know where to start so any guidance and help is appreciated. Thanks. " />
  <row Id="1151" PostHistoryTypeId="1" PostId="434" RevisionGUID="34175bce-51c8-4509-9eb5-dc5201612bf7" CreationDate="2014-02-25T13:38:13.100" UserId="232" Text="Arduino MultiWii Flight Controller, raw data" />
  <row Id="1152" PostHistoryTypeId="3" PostId="434" RevisionGUID="34175bce-51c8-4509-9eb5-dc5201612bf7" CreationDate="2014-02-25T13:38:13.100" UserId="232" Text="&lt;serial&gt;&lt;sensors&gt;&lt;raw&gt;&lt;data&gt;&lt;send&gt;" />
  <row Id="1153" PostHistoryTypeId="5" PostId="432" RevisionGUID="f8436ddf-3b56-4ba9-8063-6af9c259a811" CreationDate="2014-02-25T14:37:42.333" UserId="225" Comment="refined question" Text="I'm working on building a solar powered, Arduino based weather station. The weather station consists of a temperature sensor and a photoresistor, and I plan to add an anemometer in the future. I would like to connect the weather station to my wireless network so that I can retrieve the sensor data from my computer without having to run wires (I live in a rental).&#xD;&#xA;&#xD;&#xA;What are the different options for connecting the Arduino to WiFi? I've looked at ethernet shields, WiFi shields, and something called Xbee, but I don't understand what each of them are for. &#xD;&#xA;&#xD;&#xA;I also have a wireless home router that I could use. Is it possible to connect my Arduino Uno to the router via the ethernet or USB port and then receive data from and send commands to the Arduino wirelessly over my home network? If so, how would this be accomplished? &#xD;&#xA;&#xD;&#xA;I currently have a bare Arduino Uno." />
  <row Id="1154" PostHistoryTypeId="9" PostId="129" RevisionGUID="33dd67bb-0f1f-4fc6-bc78-bfc310997720" CreationDate="2014-02-25T14:44:18.710" UserId="37" Comment="Rollback to [c7de40c1-15ff-44f6-9b12-71c01a0bf4f3]" Text="&lt;uno&gt;&lt;atmega328&gt;" />
  <row Id="1155" PostHistoryTypeId="9" PostId="129" RevisionGUID="a388488c-c0d0-4c7b-bcaf-1a822bb55be3" CreationDate="2014-02-25T14:47:02.720" UserId="37" Comment="Rollback to [de0dae9f-8ea0-4c68-936b-a1e6e5e995f7]" Text="&lt;arduino-uno&gt;&lt;atmega328&gt;" />
  <row Id="1156" PostHistoryTypeId="5" PostId="432" RevisionGUID="a80c39bc-612b-4e51-8c41-bbd8954afb49" CreationDate="2014-02-25T15:24:38.660" UserId="225" Comment="clarified ethernet port location" Text="I'm working on building a solar powered, Arduino based weather station. The weather station consists of a temperature sensor and a photoresistor, and I plan to add an anemometer in the future. I would like to connect the weather station to my wireless network so that I can retrieve the sensor data from my computer without having to run wires (I live in a rental).&#xD;&#xA;&#xD;&#xA;What are the different options for connecting the Arduino to WiFi? I've looked at ethernet shields, WiFi shields, and something called Xbee, but I don't understand what each of them are for. &#xD;&#xA;&#xD;&#xA;I also have a wireless home router that I could use. Is it possible to connect my Arduino Uno to the router via the routers ethernet or USB port and then receive data from and send commands to the Arduino wirelessly over my home network? If so, how would this be accomplished? &#xD;&#xA;&#xD;&#xA;I currently have a bare Arduino Uno." />
  <row Id="1157" PostHistoryTypeId="2" PostId="435" RevisionGUID="d23368b1-e4c0-4590-ad5a-3cf156fec845" CreationDate="2014-02-25T16:08:19.570" UserId="131" Text="Modified my `struct` by changing the first two elements from `float` to `int`.&#xD;&#xA;&#xD;&#xA;    struct weather {&#xD;&#xA;      int tempData;&#xD;&#xA;      int humData;&#xD;&#xA;      float pressData;&#xD;&#xA;    }&#xD;&#xA;    weather wData;&#xD;&#xA;&#xD;&#xA;**Everything transmits fine now.** I don't really need the precision of a `float` for temperature and humidity. However, I would still like to find the problem. Could there be some problem with the size of three `floats` versus two `ints` and a `float`? `Serial.print(sizeof(wData))` is `12` when all elements are `floats` and `8` when using two `int` and a `float`. My understanding is the NRF24L01+ has a transmit and receive buffer of 32 bytes.&#xD;&#xA;" />
  <row Id="1158" PostHistoryTypeId="5" PostId="16" RevisionGUID="d007e5a4-9963-44a7-89bc-18362f9e6000" CreationDate="2014-02-25T16:09:25.280" UserId="37" Comment="added excerpt, added specs" Text="The Arduino Uno is the most common and one of the newest Arduinos, based on the ATmega328 microcontroller. Use this tag when asking a question specific to an Uno, not just a general Arduino question. Also consider using more specific tags to your problem." />
  <row Id="1159" PostHistoryTypeId="24" PostId="16" RevisionGUID="d007e5a4-9963-44a7-89bc-18362f9e6000" CreationDate="2014-02-25T16:09:25.280" Comment="Proposed by 37 approved by 42, 48 edit id of 152" />
  <row Id="1160" PostHistoryTypeId="5" PostId="15" RevisionGUID="c5d6d452-9270-475b-befa-e2dbc631bd65" CreationDate="2014-02-25T16:09:35.890" UserId="37" Comment="added excerpt, added specs" Text="The Arduino Uno is a microcontroller board based on the ATmega328. It has 14 digital input/output pins (of which 6 can be used as PWM outputs), 6 analog inputs, a 16 MHz ceramic resonator, a USB connection, a power jack, an ICSP header, and a reset button. It contains everything needed to support the microcontroller; simply connect it to a computer with a USB cable or power it with a AC-to-DC adapter or battery to get started.&#xD;&#xA;The Uno differs from all preceding boards in that it does not use the FTDI USB-to-serial driver chip. Instead, it features the Atmega16U2 (Atmega8U2 up to version R2) programmed as a USB-to-serial converter.&#xD;&#xA;&#xD;&#xA;Specs:&#xD;&#xA;&#xD;&#xA; - Microcontroller: ATmega328&#xD;&#xA; - Operating Voltage: 5V&#xD;&#xA; - Input Voltage (recommended): 7-12V&#xD;&#xA; - Input Voltage (limits): 6-20V&#xD;&#xA; - Digital I/O Pins: 14 (of which 6 provide PWM output)&#xD;&#xA; - Analog Input Pins: 6&#xD;&#xA; - DC Current per I/O Pin: 40 mA&#xD;&#xA; - DC Current for 3.3V Pin: 50 mA&#xD;&#xA; - Flash Memory: 32 KB (ATmega328) of which 0.5 KB used by bootloader&#xD;&#xA; - SRAM: 2 KB (ATmega328)&#xD;&#xA; - EEPROM: 1 KB (ATmega328)&#xD;&#xA; - Clock Speed: 16 MHz&#xD;&#xA;&#xD;&#xA;From http://arduino.cc/en/Main/ArduinoBoardUno" />
  <row Id="1161" PostHistoryTypeId="24" PostId="15" RevisionGUID="c5d6d452-9270-475b-befa-e2dbc631bd65" CreationDate="2014-02-25T16:09:35.890" Comment="Proposed by 37 approved by 42, 48 edit id of 151" />
  <row Id="1162" PostHistoryTypeId="2" PostId="436" RevisionGUID="20059f5d-37f3-4b1a-b6b3-fb01c64e14fe" CreationDate="2014-02-25T18:05:46.643" UserId="11" Text="You have a few options for connecting your Arduino to the network/Internet.&#xD;&#xA;&#xD;&#xA;## Ethernet&#xD;&#xA;&#xD;&#xA;Something like the [Arduino Ethernet Shield][1] allows you to plug in an Ethernet cable from the wall or router into your Arduino. Obviously, the main limitation is that your device is now tethered by the cable. For outdoor use, I wouldn't do this.&#xD;&#xA;&#xD;&#xA;## WiFi&#xD;&#xA;&#xD;&#xA;The [Arduino WiFi Shield][2] allows you to connect to your home WiFi network. This is just like the Ethernet except its now wireless.&#xD;&#xA;&#xD;&#xA;## RF&#xD;&#xA;&#xD;&#xA;If you have a lot of sensors or other devices that need to communicate with each other, the best option is usually an RF module. You have many options here, XBee being one of them. Check out the [Sparkfun XBee Buying Guide][3] to look at all the options available. And that's just XBee. There are many other wireless options available, at all sorts of prices.&#xD;&#xA;&#xD;&#xA;The thing with RF is that none of these will connect to the Internet. You will have all your devices communicate with each other or a base station, which will then be connected to the network by either a WiFi or Ethernet module.&#xD;&#xA;&#xD;&#xA;## Wireless Router Serial&#xD;&#xA;&#xD;&#xA;Depending on what kind of wireless router you use, you can have the Arduino communicate directly with it and use that as your connection to a network.&#xD;&#xA;&#xD;&#xA;* [Arduino - Cheap wifi connectivity][4]&#xD;&#xA;* [Converting your Ethernet Shield to a wireless shield][5]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoEthernetShield&#xD;&#xA;  [2]: http://arduino.cc/en/Main/ArduinoWiFiShield&#xD;&#xA;  [3]: https://www.sparkfun.com/pages/xbee_guide&#xD;&#xA;  [4]: http://www.thebmwz3.co.uk/article.php?story=20120611144749730&#xD;&#xA;  [5]: http://hackanerd.wordpress.com/2013/07/06/how-to-make-a-simple-arduino-wireless-shield/" />
  <row Id="1163" PostHistoryTypeId="6" PostId="37" RevisionGUID="df9fce91-7123-4355-89a7-21934f7f6abf" CreationDate="2014-02-25T18:46:34.767" UserId="48" Comment="edited tags" Text="&lt;compile&gt;&lt;sketch-size&gt;" />
  <row Id="1164" PostHistoryTypeId="6" PostId="408" RevisionGUID="f07d2a27-0105-4a26-aca5-883d43614ea0" CreationDate="2014-02-25T18:47:00.427" UserId="48" Comment="edited tags" Text="&lt;pins&gt;&lt;button&gt;" />
  <row Id="1165" PostHistoryTypeId="6" PostId="316" RevisionGUID="8fc04266-e1ab-45ca-a0b4-bed0d9f0b34f" CreationDate="2014-02-25T18:47:15.817" UserId="48" Comment="edited tags" Text="&lt;pins&gt;&lt;interrupt&gt;&lt;isr&gt;" />
  <row Id="1167" PostHistoryTypeId="2" PostId="437" RevisionGUID="c7833036-ee32-44f6-8260-2edf23f2883c" CreationDate="2014-02-25T21:24:20.040" UserId="136" Text="I have implemented [a library][1], based on the Paeaetech one linked to above, but tidying up defines, fixing the listed issue, adding lookup table based CRC and support for passively powered sensors.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/cybergibbons/DS2482_OneWire" />
  <row Id="1169" PostHistoryTypeId="2" PostId="438" RevisionGUID="f403008c-ce14-4592-b314-fc8e2ce2f177" CreationDate="2014-02-25T22:48:32.067" UserId="136" Text="I am working with some code for remote temperature sensor nodes. They turn the debug interface on and off depending on if anything is conneced to the serial port or not.&#xD;&#xA;&#xD;&#xA;The code is on Github [here][1]. Line 111 is the line of interest:&#xD;&#xA;&#xD;&#xA;    if (Serial) debug = 1; else debug=0; //if serial UART to USB is connected show debug O/P.&#xD;&#xA;&#xD;&#xA;So, a simple question. On a hardware and software level, how does this work? I can't see anything in HardwareSerial or Stream that would return true/false if anything was connected or not.&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/openenergymonitor/emonTH/blob/master/emonTH_DHT22_DS18B20/emonTH_DHT22_DS18B20.ino" />
  <row Id="1170" PostHistoryTypeId="1" PostId="438" RevisionGUID="f403008c-ce14-4592-b314-fc8e2ce2f177" CreationDate="2014-02-25T22:48:32.067" UserId="136" Text="How does this line detect if a serial interface is connected?" />
  <row Id="1171" PostHistoryTypeId="3" PostId="438" RevisionGUID="f403008c-ce14-4592-b314-fc8e2ce2f177" CreationDate="2014-02-25T22:48:32.067" UserId="136" Text="&lt;serial&gt;&lt;library&gt;" />
  <row Id="1172" PostHistoryTypeId="2" PostId="439" RevisionGUID="1c7e8507-28b1-418b-a394-894b0f70eef1" CreationDate="2014-02-25T22:51:03.030" UserId="136" Text="If I upload a sketch that sends serial data, I immediately see the TX/RX LEDs flash once the sketch is uploaded. If I then start the serial monitor, the sketch appears to restart.&#xD;&#xA;&#xD;&#xA;Why is this?" />
  <row Id="1173" PostHistoryTypeId="1" PostId="439" RevisionGUID="1c7e8507-28b1-418b-a394-894b0f70eef1" CreationDate="2014-02-25T22:51:03.030" UserId="136" Text="Why does starting the serial monitor restart the sketch?" />
  <row Id="1174" PostHistoryTypeId="3" PostId="439" RevisionGUID="1c7e8507-28b1-418b-a394-894b0f70eef1" CreationDate="2014-02-25T22:51:03.030" UserId="136" Text="&lt;serial&gt;&lt;ide&gt;" />
  <row Id="1175" PostHistoryTypeId="5" PostId="439" RevisionGUID="178fbeea-bc54-48bf-805a-7a50e8ddfe95" CreationDate="2014-02-25T23:03:04.737" UserId="136" Comment="added 2 characters in body" Text="If I upload any sketch that sends serial data, I immediately see the TX/RX LEDs flash once the sketch is uploaded. If I then start the serial monitor, the sketch appears to restart.&#xD;&#xA;&#xD;&#xA;Why is this?" />
  <row Id="1176" PostHistoryTypeId="5" PostId="438" RevisionGUID="d46acb37-8241-4781-8ce9-1945157016a2" CreationDate="2014-02-25T23:16:44.950" UserId="136" Comment="added 57 characters in body" Text="I am working with some code for remote temperature sensor nodes. They turn the debug interface on and off depending on if anything is conneced to the serial port or not.&#xD;&#xA;&#xD;&#xA;The code is on Github [here][1]. Line 111 is the line of interest:&#xD;&#xA;&#xD;&#xA;    if (Serial) debug = 1; else debug=0; //if serial UART to USB is connected show debug O/P.&#xD;&#xA;&#xD;&#xA;So, a simple question. On a hardware and software level, how does this work? I can't see anything in HardwareSerial or Stream that would return true/false if anything was connected or not.&#xD;&#xA;&#xD;&#xA;edit - don't answer this, as it doesn't appear to work!&#xD;&#xA;  [1]: https://github.com/openenergymonitor/emonTH/blob/master/emonTH_DHT22_DS18B20/emonTH_DHT22_DS18B20.ino" />
  <row Id="1177" PostHistoryTypeId="5" PostId="439" RevisionGUID="1e179fa1-ad50-41c8-b143-961c78cc7cbe" CreationDate="2014-02-25T23:21:12.110" UserId="136" Comment="Add example sketch" Text="If I upload any sketch that sends serial data, I immediately see the TX/RX LEDs flash once the sketch is uploaded. If I then start the serial monitor, the sketch appears to restart.&#xD;&#xA;&#xD;&#xA;A bare minimum sketch that shows this behaviour:&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;        Serial.println(&quot;Setup&quot;);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      Serial.println(&quot;Loop&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Tested with several boards and Mac and Windows versions of the IDE.&#xD;&#xA;&#xD;&#xA;Example output - it goes back to &quot;Setup&quot; when I open the serial monitor:&#xD;&#xA;&#xD;&#xA;![Restart][1]&#xD;&#xA;&#xD;&#xA;Why is this?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/mokWb.png" />
  <row Id="1178" PostHistoryTypeId="2" PostId="440" RevisionGUID="6deb8cb5-e031-4531-9e88-1cad1c3d6ebc" CreationDate="2014-02-26T00:02:20.497" UserId="11" Text="The Arduino uses the [RTS (Request To Send)][1] (and I think [DTR (Data Terminal Ready)][2]) signals to auto-reset. If you get a serial terminal that allows you to change the flow control settings you can change this functionality.&#xD;&#xA;&#xD;&#xA;The Arduino terminal doesn't give you a lot of options and that's the default. Others will allow you to configure a lot more. Setting the flow control to none will allow you to connect/disconnect from the serial without resetting your board. it's quite useful for debugging when you want to be able to just plug in the connector and see the output without having to start the sketch over.&#xD;&#xA;&#xD;&#xA;Another way to disable the auto reset is to put a pull up resistor on the reset pin.&#xD;&#xA;&#xD;&#xA;[Disabling Auto Reset On Serial Connection][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/RS-232_RTS/CTS#RTS.2FCTS_handshaking&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Data_Terminal_Ready&#xD;&#xA;  [3]: http://playground.arduino.cc/Main/DisablingAutoResetOnSerialConnection" />
  <row Id="1179" PostHistoryTypeId="5" PostId="438" RevisionGUID="10c11d47-ae3d-4e51-9cda-1b4af971c644" CreationDate="2014-02-26T00:26:53.380" UserId="136" Comment="Add test code" Text="I am working with some code for remote temperature sensor nodes. They turn the debug interface on and off depending on if anything is conneced to the serial port or not.&#xD;&#xA;&#xD;&#xA;The code is on Github [here][1]. Line 111 is the line of interest:&#xD;&#xA;&#xD;&#xA;    if (Serial) debug = 1; else debug=0; //if serial UART to USB is connected show debug O/P.&#xD;&#xA;&#xD;&#xA;So, a simple question. On a hardware and software level, how does this work? I can't see anything in HardwareSerial or Stream that would return true/false if anything was connected or not.&#xD;&#xA;&#xD;&#xA;Note that I am not confident that it actually works. This simple test indicates it doesn't work as the LED flashes regardless of the presence of a serial adapter or connection:&#xD;&#xA;&#xD;&#xA;    boolean debug;&#xD;&#xA;    &#xD;&#xA;    const int toggle = 6;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      if (Serial) debug = 1; else debug = 0;&#xD;&#xA;      &#xD;&#xA;      pinMode(toggle, OUTPUT);&#xD;&#xA;      digitalWrite(toggle, LOW);&#xD;&#xA;      &#xD;&#xA;      if (debug)&#xD;&#xA;      {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;        Serial.println(&quot;Setup&quot;);&#xD;&#xA;        digitalWrite(toggle, HIGH);&#xD;&#xA;        delay(1000);&#xD;&#xA;        digitalWrite(toggle, LOW);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      if (debug)&#xD;&#xA;      {&#xD;&#xA;        Serial.println(&quot;Loop&quot;);&#xD;&#xA;        digitalWrite(toggle, HIGH);&#xD;&#xA;        delay(1000);&#xD;&#xA;        digitalWrite(toggle, LOW);&#xD;&#xA;        delay(1000);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/openenergymonitor/emonTH/blob/master/emonTH_DHT22_DS18B20/emonTH_DHT22_DS18B20.ino" />
  <row Id="1180" PostHistoryTypeId="2" PostId="441" RevisionGUID="85ec7516-1b4f-4ad1-acd4-9df1ee578f6a" CreationDate="2014-02-26T01:00:08.327" UserId="42" Text="There are lots of ways to switch higher loads, and jfpoilpret has described some good options. I'll summarise a couple of relay-based solutions, which are mainly appropriate for comparatively slow switching speeds (i.e. not usually suitable for PWM).&#xD;&#xA;&#xD;&#xA;**Solid State Relays**  &#xD;&#xA;Solid State Relays (SSRs) are effectively semiconductor-based switches. They come in a wide variety of configurations, depending on your requirements, but the key factor is that they have no moving parts. This means they can be very reliable in the long run if used properly.&#xD;&#xA;&#xD;&#xA;Internally, they are usually comprised of MOSFETs and thyristors or similar. This can let them achieve fairly high switching speeds in theory. In practice though, the more power it's designed for, the harder it is to switch quickly. That means high speed + high power can get quite expensive.&#xD;&#xA;&#xD;&#xA;A critical factor to bear in mind is that you'll usually need a different type of SSR if you intended to switch AC instead of DC. It's also good to note that some will come with a built-in opto-isolator or similar to keep your power supplies separate.&#xD;&#xA;&#xD;&#xA;**Electro Mechanical Relays**  &#xD;&#xA;This is the more 'traditional' approach. An Electro Mechanical Relay (EMR) is a fairly simple component, containing a mechanical switch, controlled by a electromagnetic coil. If the switch is normally open, the coil pulls it closed when a control current is applied. In contrast, a normally-closed switch would be pulled open when a control current is applied.&#xD;&#xA;&#xD;&#xA;There are a number of advantages of EMRs over things like SSRs. The most obvious is cost -- their simplicity makes them quite cheap, and the cost doesn't rise so sharply for higher-power versions. Additionally, the control and load are inherently isolated, and they don't care whether you're switching AC or DC.&#xD;&#xA;&#xD;&#xA;There are several disadvantages though. The mechanical aspect means that EMRs are usually much slower than non-mechanical switching solutions, and can suffer from contact bounce. Additionally, they can physically wear out, and they can be affected by things like shocks, vibrations, and (potentially) other magnetic fields.&#xD;&#xA;&#xD;&#xA;When designing a circuit to use an EMR, it's essential to be aware of back-EMF (electromotive force). When a control current is applied, the coil acts as an inductor, storing charge electromagnetically. When the control current is stopped, the stored charge can surge back through the control circuit, creating a large negative voltage spike (potentially much larger than what was originally applied).&#xD;&#xA;&#xD;&#xA;This spike can unfortunately damage/destroy any attached components or microcontroller pins. It is typically prevented/mitigated by putting a diode *in reverse* across the relay's control contacts. In this context, it's sometimes known as a flyback diode, and it allows the EMF to dissipate safely.&#xD;&#xA;" />
  <row Id="1181" PostHistoryTypeId="2" PostId="442" RevisionGUID="dbd1fa67-bf76-4462-b604-cd05ae52a57e" CreationDate="2014-02-26T01:02:07.103" UserId="-1" Text="" />
  <row Id="1182" PostHistoryTypeId="2" PostId="443" RevisionGUID="37a1253e-e956-467b-882b-6f508e977db0" CreationDate="2014-02-26T01:02:07.103" UserId="-1" Text="" />
  <row Id="1183" PostHistoryTypeId="2" PostId="444" RevisionGUID="426f230d-bf1a-483f-85d1-cc6e2644f245" CreationDate="2014-02-26T01:04:26.900" UserId="-1" Text="" />
  <row Id="1184" PostHistoryTypeId="2" PostId="445" RevisionGUID="e1d8083e-009a-4455-b493-9c38d6f74d26" CreationDate="2014-02-26T01:04:26.900" UserId="-1" Text="" />
  <row Id="1185" PostHistoryTypeId="2" PostId="446" RevisionGUID="1b9c3c56-7d0b-4c59-9df9-6e5ece418759" CreationDate="2014-02-26T01:05:36.360" UserId="-1" Text="" />
  <row Id="1186" PostHistoryTypeId="2" PostId="447" RevisionGUID="8d048e46-a6cc-430b-a495-6e2043fd397a" CreationDate="2014-02-26T01:05:36.360" UserId="-1" Text="" />
  <row Id="1187" PostHistoryTypeId="2" PostId="448" RevisionGUID="686fcbf0-28f2-4e10-b429-553279d2a60f" CreationDate="2014-02-26T01:06:49.990" UserId="-1" Text="" />
  <row Id="1188" PostHistoryTypeId="2" PostId="449" RevisionGUID="7ce4a071-5934-4f36-a866-5445c4d22638" CreationDate="2014-02-26T01:06:49.990" UserId="-1" Text="" />
  <row Id="1189" PostHistoryTypeId="2" PostId="450" RevisionGUID="69373c5a-2f13-4127-9f31-d7637626b285" CreationDate="2014-02-26T01:19:04.780" UserId="42" Text="You're right -- it doesn't work in most cases, and will almost always return true. The one board where it's actually functional is the Leonardo. According to the [official documentation][1]:&#xD;&#xA;&#xD;&#xA;&gt; On the Leonardo, **if (Serial)** indicates wether or not the USB CDC serial connection is open. For all other instances, including **if (Serial1)** on the Leonardo, this will always returns true.&#xD;&#xA;&#xD;&#xA;Basic serial connections (used by most Arduinos) usually don't care if anything is actually listening. It's not uncommon for embedded devices to send debug info by serial even when nothing is receiving it. This has the advantage that the code's timing and behaviour won't change when debugging, which could cause all sorts of problems if you're trying to diagnose a problem reported in the field.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Serial/IfSerial" />
  <row Id="1190" PostHistoryTypeId="10" PostId="430" RevisionGUID="52d54566-5595-4bb3-84a8-06285a6b4ef6" CreationDate="2014-02-26T02:44:41.467" UserId="-1" Comment="104" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:65,&quot;DisplayName&quot;:&quot;AsheeshR&quot;},{&quot;Id&quot;:37,&quot;DisplayName&quot;:&quot;The Guy with The Hat&quot;},{&quot;Id&quot;:3,&quot;DisplayName&quot;:&quot;Butzke&quot;},{&quot;Id&quot;:220,&quot;DisplayName&quot;:&quot;Annonomus Person&quot;},{&quot;Id&quot;:35,&quot;DisplayName&quot;:&quot;hichris123&quot;}]}" />
  <row Id="1194" PostHistoryTypeId="5" PostId="445" RevisionGUID="bb51adcb-f9d3-4d97-9bbb-65a2e4e8eed4" CreationDate="2014-02-26T06:45:46.357" UserId="220" Comment="added 252 characters in body" Text="SD cards are often used with the Arduino Ethernet Shield. They stand for &quot;secure digital cards&quot; and fit into one's palm. They range from 256MB to 128GB, although most Arduinos only use 4GB. There are also SD micro cards, a smaller version of the cards." />
  <row Id="1195" PostHistoryTypeId="24" PostId="445" RevisionGUID="bb51adcb-f9d3-4d97-9bbb-65a2e4e8eed4" CreationDate="2014-02-26T06:45:46.357" Comment="Proposed by 220 approved by 42, 83 edit id of 154" />
  <row Id="1196" PostHistoryTypeId="5" PostId="449" RevisionGUID="4c15db07-342e-4fd7-a18c-19b0376add5b" CreationDate="2014-02-26T06:46:00.200" UserId="220" Comment="added 126 characters in body" Text="Use this tag to refer to the volume of electricity traveling through any given wire at any given time. It is measured in amps." />
  <row Id="1197" PostHistoryTypeId="24" PostId="449" RevisionGUID="4c15db07-342e-4fd7-a18c-19b0376add5b" CreationDate="2014-02-26T06:46:00.200" Comment="Proposed by 220 approved by 11, 83 edit id of 156" />
  <row Id="1198" PostHistoryTypeId="5" PostId="443" RevisionGUID="4e68398f-62fb-4510-80cb-69fd1d010571" CreationDate="2014-02-26T06:46:14.593" UserId="220" Comment="added 285 characters in body" Text="Heat is referring to overheating a chip with too much voltage or current, thus producing heat. It often makes a blueish smoke when the chip exploded from pressure. Use this tag for how to cool the chips and/or how far you can push a certain chip before it will have a reduced lifespan." />
  <row Id="1199" PostHistoryTypeId="24" PostId="443" RevisionGUID="4e68398f-62fb-4510-80cb-69fd1d010571" CreationDate="2014-02-26T06:46:14.593" Comment="Proposed by 220 approved by 42, 83 edit id of 153" />
  <row Id="1200" PostHistoryTypeId="2" PostId="451" RevisionGUID="fb79d386-5b02-40ef-aee7-29fdcc8943d1" CreationDate="2014-02-26T07:16:15.087" UserId="86" Text="I recently wanted to do exactly this. Since there is no nice way to do so, I wound up [writing a patch][1] for the [Stino][2] sublime-text arduino plugin to do exactly this. It's subsequently been accepted, so it should be in any up-to-date Stino installs.&#xD;&#xA;&#xD;&#xA;This adds a new option to Stino:  &#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;Using this mode produces compilation results like the following:  &#xD;&#xA;&#xD;&#xA;For a Uno:&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 172 bytes (of a 32256 byte maximum, 0.53 percent).  &#xD;&#xA;&gt; Estimated memory use: 0 bytes (of a 1024 byte maximum, 0.00 percent).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;For a leonardo&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 240 bytes (of a 28672 byte maximum, 0.84 percent).  &#xD;&#xA;&gt; Estimated memory use: 0 bytes (of a 2560 byte maximum, 0.00 percent).&#xD;&#xA;&#xD;&#xA;Note that the memory reports are actually incorrect, but that's a [separate issue][4].&#xD;&#xA;&#xD;&#xA;The code used for the above is:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    int main()&#xD;&#xA;    {&#xD;&#xA;    	while (1)&#xD;&#xA;    	{&#xD;&#xA;    &#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Some notes:&#xD;&#xA;&#xD;&#xA; - You ain't writing a &quot;Sketch&quot; anymore, not that you ever actually *do* write a sketch. You write **programs**. Period. I don't care what the Arduino wackos want to say, they don't get to redefine terms.&#xD;&#xA; - All interrupt management is manual. This means no `milis()` or similar.&#xD;&#xA; - You *can* still use the arduino serial libraries and so forth, if you want. You do have to `#include &lt;Arduino.h&gt;`.&#xD;&#xA; - You define `main`. You don't ever return from `main`. If you want setup stuff, it goes before the `while (1)`.&#xD;&#xA; - If you're still using the arduino-shitty-flaming-pile-of-shit editor/two-macro-buttons thing, you should switch. Have you tried [Stino][5]? Or ANYTHING else? Hell, even [Eclipse][6] is better (and that doesn't get said often).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/Robot-Will/Stino/pull/123&#xD;&#xA;  [2]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [3]: http://i.stack.imgur.com/9p7tO.png&#xD;&#xA;  [4]: https://github.com/Robot-Will/Stino/pull/127&#xD;&#xA;  [5]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [6]: http://www.baeyens.it/eclipse/" />
  <row Id="1201" PostHistoryTypeId="5" PostId="451" RevisionGUID="c396967b-d6b5-4ca4-9446-6bd7da091a85" CreationDate="2014-02-26T07:22:12.237" UserId="86" Comment="added 243 characters in body" Text="I recently wanted to do exactly this. Since there is no nice way to do so, I wound up [writing a patch][1] for the [Stino][2] sublime-text arduino plugin to do exactly this. It's subsequently been accepted, so it should be in any up-to-date Stino installs.&#xD;&#xA;&#xD;&#xA;This adds a new option to Stino:  &#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;Using this mode produces compilation results like the following:  &#xD;&#xA;&#xD;&#xA;For a Uno:&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 172 bytes (of a 32256 byte maximum, 0.53 percent).  &#xD;&#xA;&gt; Estimated memory use: 0 bytes (of a 1024 byte maximum, 0.00 percent).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;For a leonardo&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 240 bytes (of a 28672 byte maximum, 0.84 percent).  &#xD;&#xA;&gt; Estimated memory use: 0 bytes (of a 2560 byte maximum, 0.00 percent).&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Actually *programming* the leonardo with the above compiled output is *probably* a bad idea, as it *might* break the auto-reset functionality, but you *could*, if you wanted. Hat-tip to mpflaga for noting this in his answer.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;Note that the memory reports are actually incorrect, but that's a [separate issue][4].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The code used for the above is:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    int main()&#xD;&#xA;    {&#xD;&#xA;    	while (1)&#xD;&#xA;    	{&#xD;&#xA;    &#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Some notes:&#xD;&#xA;&#xD;&#xA; - You ain't writing a &quot;Sketch&quot; anymore, not that you ever actually *do* write a sketch. You write **programs**. Period. I don't care what the Arduino wackos want to say, they don't get to redefine terms.&#xD;&#xA; - All interrupt management is manual. This means no `milis()` or similar.&#xD;&#xA; - You *can* still use the arduino serial libraries and so forth, if you want. You do have to `#include &lt;Arduino.h&gt;`.&#xD;&#xA; - You define `main`. You don't ever return from `main`. If you want setup stuff, it goes before the `while (1)`.&#xD;&#xA; - If you're still using the arduino-shitty-flaming-pile-of-shit editor/two-macro-buttons thing, you should switch. Have you tried [Stino][5]? Or ANYTHING else? Hell, even [Eclipse][6] is better (and that doesn't get said often).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/Robot-Will/Stino/pull/123&#xD;&#xA;  [2]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [3]: http://i.stack.imgur.com/9p7tO.png&#xD;&#xA;  [4]: https://github.com/Robot-Will/Stino/pull/127&#xD;&#xA;  [5]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [6]: http://www.baeyens.it/eclipse/" />
  <row Id="1202" PostHistoryTypeId="2" PostId="452" RevisionGUID="58892d99-4c36-4bac-bd14-9e59923da16e" CreationDate="2014-02-26T08:45:43.817" UserId="136" Text="I've traditionally used a text editor with avr-gcc and makefiles for working with Arduino boards. I'm now trying to develop projects for the wider Arduino user-base, so I am trying to use the Arduino libraries and common IDEs for ease of use.&#xD;&#xA;&#xD;&#xA;I started using Stino, but then found out that the Arduino IDE has some toolchain &quot;quirks&quot; that mean I will need to test everything in Arduino IDE expressly.&#xD;&#xA;&#xD;&#xA;Since starting to use it more, I have found it frequently hangs or crashes. The triggers for this are:&#xD;&#xA;&#xD;&#xA; - Creating a new sketch takes about 15s, and shows me the OS X beach&#xD;&#xA;   ball. &#xD;&#xA; - Saving a sketch takes about 15s. &#xD;&#xA; - Going to File-&gt;Examples frequently crashes the IDE - I need to force quit.&#xD;&#xA; - Going to&#xD;&#xA;   File-&gt;Sketchbook always crashes the IDE. &#xD;&#xA; - It sometimes randomly hangs.&#xD;&#xA;&#xD;&#xA;I don't have any other stability issues and other Java based IDEs like Pycharm work flawlessly.&#xD;&#xA;&#xD;&#xA;I have installed numerous libraries, including the entire Teensyduino suite (which is a lot of libraries!). Outside of that, no changes have been made.&#xD;&#xA;&#xD;&#xA;Is this a common issue? Is there any logging or anyway I can try and work out what is causing this issue?" />
  <row Id="1203" PostHistoryTypeId="1" PostId="452" RevisionGUID="58892d99-4c36-4bac-bd14-9e59923da16e" CreationDate="2014-02-26T08:45:43.817" UserId="136" Text="Why does my Arduino IDE hang/crash so often?" />
  <row Id="1204" PostHistoryTypeId="3" PostId="452" RevisionGUID="58892d99-4c36-4bac-bd14-9e59923da16e" CreationDate="2014-02-26T08:45:43.817" UserId="136" Text="&lt;arduino-ide&gt;" />
  <row Id="1205" PostHistoryTypeId="2" PostId="453" RevisionGUID="02778744-ef33-49a7-ab41-4a9c949387e7" CreationDate="2014-02-26T11:40:33.883" UserId="296" Text="There is one from Brazil called MariaMole: http://dalpix.com/mariamole&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;------&#xD;&#xA;&#xD;&#xA;Curiously, Maria-Mole is the name of a very popular candy in Brazil:&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/MCDH0.jpg" />
  <row Id="1206" PostHistoryTypeId="2" PostId="454" RevisionGUID="6ccfe94d-0fc2-4b40-bf81-ff3c0baed27a" CreationDate="2014-02-26T12:14:39.230" UserId="296" Text="You can use [Charlieplexing][1]. With this technique you can directly drive `n*(n-1)` LED's from n pins. So with 3 pins you can drive 6 LED's, 4 pins - 12 LED's, 5 pins - 20 LED's and so on.&#xD;&#xA;&#xD;&#xA;Exemple: &#xD;&#xA;&#xD;&#xA;Six LED's on 3 Pins&#xD;&#xA;&#xD;&#xA;    PINS	    LEDS&#xD;&#xA;    0 1 2	1 2 3 4 5 6&#xD;&#xA;    0 0 0	0 0 0 0 0 0&#xD;&#xA;    0 1 Z	1 0 0 0 0 0&#xD;&#xA;    1 0 Z	0 1 0 0 0 0&#xD;&#xA;    Z 0 1	0 0 1 0 0 0&#xD;&#xA;    Z 1 0	0 0 0 1 0 0&#xD;&#xA;    0 Z 1	0 0 0 0 1 0&#xD;&#xA;    1 Z 0	0 0 0 0 0 1&#xD;&#xA;    0 0 1	0 0 1 0 1 0&#xD;&#xA;    0 1 0	1 0 0 1 0 0&#xD;&#xA;    0 1 1	1 0 0 0 1 0&#xD;&#xA;    1 0 0	0 1 0 0 0 1&#xD;&#xA;    1 0 1	0 1 1 0 0 0&#xD;&#xA;    1 1 0	0 0 0 1 0 1&#xD;&#xA;    1 1 1	0 0 0 0 0 0&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;You can see a better tutorial [here][3].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Charlieplexing&#xD;&#xA;  [2]: http://i.stack.imgur.com/Bq6H5.png&#xD;&#xA;  [3]: http://www.pcbheaven.com/wikipages/Charlieplexing/" />
  <row Id="1207" PostHistoryTypeId="5" PostId="234" RevisionGUID="2981f140-2ef1-40ea-9c21-8e1122834028" CreationDate="2014-02-26T12:59:59.163" UserId="194" Comment="if/then" Text="There is one mechanism that can get MCU from erratic state and it's the **watchdog timer**. If you're implementing some code that will repeatedly run in a loop, that will not run anytime longer than some fixed time, you can set this time as watchdog period and enable the timer. &#xD;&#xA;&#xD;&#xA;Then, you have to repeatedly reset the timer in the loop. If your code freezes at some condition loop that will never end, then the watchdog will count to zero and eventually reset the MCU.&#xD;&#xA;&#xD;&#xA;This way you are losing data, but if you run the AVR WDT in interrupt mode, you can store some data before resetting the MCU.&#xD;&#xA;&#xD;&#xA;So the watchdog timer can guard your code from occasional unintended endles loops." />
  <row Id="1208" PostHistoryTypeId="2" PostId="455" RevisionGUID="fb998a74-92d3-45c8-aab9-4f0efdef19d7" CreationDate="2014-02-26T14:20:39.883" UserId="37" Text="Every time I open the `Tools` menu, the IDE freezes for a few seconds. Why is that? It happens on both of my computers, and nothing I do makes a difference in how long it takes. I've tried restarting the IDE, unplugging my Uno, and many other things, but nothing helps." />
  <row Id="1209" PostHistoryTypeId="1" PostId="455" RevisionGUID="fb998a74-92d3-45c8-aab9-4f0efdef19d7" CreationDate="2014-02-26T14:20:39.883" UserId="37" Text="Why does opening the Tools menu take so long?" />
  <row Id="1210" PostHistoryTypeId="3" PostId="455" RevisionGUID="fb998a74-92d3-45c8-aab9-4f0efdef19d7" CreationDate="2014-02-26T14:20:39.883" UserId="37" Text="&lt;arduino-ide&gt;" />
  <row Id="1211" PostHistoryTypeId="5" PostId="455" RevisionGUID="92756ee8-27f4-42d5-a077-c09f11831643" CreationDate="2014-02-26T14:29:32.220" UserId="37" Comment="added 46 characters in body" Text="Every time I open the `Tools` menu, the IDE freezes for a few seconds. Why is that? It happens on both of my computers, and nothing I do makes a difference in how long it takes. I've tried restarting the IDE, unplugging my Uno, and many other things, but nothing helps.&#xD;&#xA;&#xD;&#xA;I'm on windows, running IDE version 1.0.2." />
  <row Id="1212" PostHistoryTypeId="5" PostId="453" RevisionGUID="1dc45d0f-1f8e-447d-9768-d956524bc7d1" CreationDate="2014-02-26T14:32:25.543" UserId="42" Comment="Removed off-topic comment/image" Text="There is one from Brazil called MariaMole: http://dalpix.com/mariamole" />
  <row Id="1213" PostHistoryTypeId="5" PostId="447" RevisionGUID="0f012602-1301-4aea-864a-d0233c1f6282" CreationDate="2014-02-26T14:53:12.503" UserId="220" Comment="added 166 characters in body" Text="Threads are different processes that a device runs at once. Unless it has multiple cores, it has to switch between the threads to ensure that all the threads get ran." />
  <row Id="1214" PostHistoryTypeId="24" PostId="447" RevisionGUID="0f012602-1301-4aea-864a-d0233c1f6282" CreationDate="2014-02-26T14:53:12.503" Comment="Proposed by 220 approved by 83, 8 edit id of 155" />
  <row Id="1215" PostHistoryTypeId="2" PostId="456" RevisionGUID="b818bd08-025e-4d82-a968-89a586c4d5f1" CreationDate="2014-02-26T15:01:23.067" UserId="27" Text="It's an RXTX issue. RXTX is the native serial library used to make the IDE talk to the boards.&#xD;&#xA;&#xD;&#xA;Some fixes are available in the 1.5 series but I suggest switching to the latest [1.5.6 release][1] as RXTX was replaced by [JSSC][2], a more modern and simpler library.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/Software#toc3&#xD;&#xA;  [2]: https://code.google.com/p/java-simple-serial-connector/" />
  <row Id="1216" PostHistoryTypeId="2" PostId="457" RevisionGUID="328d6ed9-3872-4f94-a41e-bf34e2a3a3f9" CreationDate="2014-02-26T15:08:50.183" UserId="65" Text="While it may not be possible to detect whether a device is connected to the Arduino serial connection or not, it is possible to *enable the debug messages over the serial connection* based on the presence of a device on the serial connection.&#xD;&#xA;&#xD;&#xA;Considering that you will be using the debug interface of your sketch only when connected to a computer capable of serial communication, it is possible to incorporate a simple test into the sketch based on which debug mode is enabled or not.&#xD;&#xA;&#xD;&#xA;When the sketch starts, you can check to see if any data is available on the Serial connection or not. If there is, then a device is present and debugging can be enabled. On the computer side, everytime you want to start the debugging mode on the Arduino, simply send a byte over the serial connection during the `setup` phase and sit back.&#xD;&#xA;&#xD;&#xA;Here is a sample sketch showing the same:&#xD;&#xA;&#xD;&#xA;    int debug = 0;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      pinMode(13, OUTPUT);&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;&#xD;&#xA;      //Wait for four seconds or till data is available on serial, &#xD;&#xA;      //whichever occurs first.&#xD;&#xA;      while(Serial.available()==0 &amp;&amp; millis()&lt;4000);&#xD;&#xA;&#xD;&#xA;      //On timeout or availability of data, we come here.&#xD;&#xA;      if(Serial.available()&gt;0)&#xD;&#xA;      {&#xD;&#xA;        //If data is available, we enter here.&#xD;&#xA;        int test = Serial.read(); //We then clear the input buffer&#xD;&#xA;&#xD;&#xA;        Serial.println(&quot;DEBUG&quot;); //Give feedback indicating mode&#xD;&#xA;&#xD;&#xA;        debug = 1; //Enable debug&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      if(debug==1) Serial.println(&quot;ON&quot;);&#xD;&#xA;      digitalWrite(13,HIGH);&#xD;&#xA;      delay(1000);&#xD;&#xA;      if(debug==1) Serial.println(&quot;OFF&quot;);&#xD;&#xA;      digitalWrite(13,LOW);&#xD;&#xA;      delay(1000); &#xD;&#xA;    }" />
  <row Id="1218" PostHistoryTypeId="2" PostId="458" RevisionGUID="050bbba3-5abd-43a2-8370-20cf15f8ad41" CreationDate="2014-02-26T15:38:12.647" UserId="275" Text="Frederico Fissore already pointed out that this delay is due to the serial libraries. From a functional perspective: The Arduino IDE tries to enumerate all available COM ports which simply takes some time. &#xD;&#xA;&#xD;&#xA;Quote from the official [troubleshooting guide][1]:&#xD;&#xA;&#xD;&#xA;&gt; **Why does do the Arduino software and the Tools menu take a long time to open (on Windows)?**&#xD;&#xA;&#xD;&#xA;&gt; If the Arduino software takes a long time to start up and appears to freeze when you try to open the Tools menu, there by a conflict with another device on your system. The Arduino software, on startup and when you open the Tools menu, tries to get a list of all the COM ports on your computer. It's possible that a COM port created by one of the devices on your computer slows down this process. Take a look in the Device Manager. Try disabling the devices that provide COM ports (e.g. Bluetooth devices).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/de/Guide/Troubleshooting#toc14" />
  <row Id="1219" PostHistoryTypeId="5" PostId="456" RevisionGUID="c30a5758-ece2-4574-a48d-bf8d327d4c88" CreationDate="2014-02-26T15:42:13.710" UserId="27" Comment="Added reference to github issues and a brief explanation of the problem" Text="It's an RXTX issue. RXTX is the native serial library used to make the IDE talk to the boards.&#xD;&#xA;&#xD;&#xA;On some Windows installation, with some Bluetooth things (both dongles or integrated), when enumerating serial devices, these dongles scan the air for remote serial devices. Hence, the IDE stays stuck, waiting for RXTX serial device enumeration to end. This issue has been acknowledged a lot of times, see for example [#1375][1], [#532][2], [#200][3] and [#143][4]&#xD;&#xA;&#xD;&#xA;Some fixes are available in the 1.5 series but I suggest switching to the latest [1.5.6 release][5] as RXTX was replaced by [JSSC][6], a more modern and simpler library.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/arduino/Arduino/issues/1375&#xD;&#xA;  [2]: https://github.com/arduino/Arduino/issues/532&#xD;&#xA;  [3]: https://github.com/arduino/Arduino/issues/200&#xD;&#xA;  [4]: https://github.com/arduino/Arduino/issues/143&#xD;&#xA;  [5]: http://arduino.cc/en/Main/Software#toc3&#xD;&#xA;  [6]: https://code.google.com/p/java-simple-serial-connector/" />
  <row Id="1220" PostHistoryTypeId="5" PostId="456" RevisionGUID="742e1d99-a992-4d58-8713-d2d4955095a1" CreationDate="2014-02-26T15:47:41.693" UserId="27" Comment="Added reference to github issues and a brief explanation of the problem" Text="It's an RXTX issue. RXTX is the native serial library used to make the IDE talk to the boards.&#xD;&#xA;&#xD;&#xA;On some Windows installation, with some Bluetooth things (both dongles or integrated), when enumerating serial devices, these dongles scan the air for remote serial devices. Hence, the IDE stays stuck, waiting for RXTX serial device enumeration to end. This issue has been acknowledged a lot of times, see for example [#1375][1], [#532][2], [#200][3] and [#143][4]&#xD;&#xA;&#xD;&#xA;As far as I understand, this issue does not affect linux or mac because of the different way the scan occurs. On linux it's a plain filtered file listing of `/dev`. Similarly it's on mac. On windows, it uses native API calls.&#xD;&#xA;&#xD;&#xA;Some fixes are available in the 1.5 series but I suggest switching to the latest [1.5.6 release][5] as RXTX was replaced by [JSSC][6], a more modern and simpler library.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/arduino/Arduino/issues/1375&#xD;&#xA;  [2]: https://github.com/arduino/Arduino/issues/532&#xD;&#xA;  [3]: https://github.com/arduino/Arduino/issues/200&#xD;&#xA;  [4]: https://github.com/arduino/Arduino/issues/143&#xD;&#xA;  [5]: http://arduino.cc/en/Main/Software#toc3&#xD;&#xA;  [6]: https://code.google.com/p/java-simple-serial-connector/" />
  <row Id="1221" PostHistoryTypeId="5" PostId="438" RevisionGUID="93eb3ac0-9cce-4559-bd9a-673654270ee8" CreationDate="2014-02-26T16:15:30.337" UserId="275" Comment="added direct link to respective coding line and minor language improvements" Text="I am working with some code for remote temperature sensor nodes. They turn the debug interface on and off depending on if anything is conneced to the serial port or not.&#xD;&#xA;&#xD;&#xA;The code is on Github [here][1]. Line [111][2] is the line of interest:&#xD;&#xA;&#xD;&#xA;    if (Serial) debug = 1; else debug=0; //if serial UART to USB is connected show debug O/P.&#xD;&#xA;&#xD;&#xA;So, a simple question: On a hardware and software level, how does this work? I can't see anything in HardwareSerial or Stream that would return true/false if anything was connected or not.&#xD;&#xA;&#xD;&#xA;Note that I am not confident that it actually works. This simple test indicates it doesn't work as the LED flashes regardless of the presence of a serial adapter or connection:&#xD;&#xA;&#xD;&#xA;    boolean debug;&#xD;&#xA;    &#xD;&#xA;    const int toggle = 6;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      if (Serial) debug = 1; else debug = 0;&#xD;&#xA;      &#xD;&#xA;      pinMode(toggle, OUTPUT);&#xD;&#xA;      digitalWrite(toggle, LOW);&#xD;&#xA;      &#xD;&#xA;      if (debug)&#xD;&#xA;      {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;        Serial.println(&quot;Setup&quot;);&#xD;&#xA;        digitalWrite(toggle, HIGH);&#xD;&#xA;        delay(1000);&#xD;&#xA;        digitalWrite(toggle, LOW);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      if (debug)&#xD;&#xA;      {&#xD;&#xA;        Serial.println(&quot;Loop&quot;);&#xD;&#xA;        digitalWrite(toggle, HIGH);&#xD;&#xA;        delay(1000);&#xD;&#xA;        digitalWrite(toggle, LOW);&#xD;&#xA;        delay(1000);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/openenergymonitor/emonTH/blob/master/emonTH_DHT22_DS18B20/emonTH_DHT22_DS18B20.ino&#xD;&#xA;  [2]: https://github.com/openenergymonitor/emonTH/blob/40b8d4d42ad301b7877c1f5f18d492cc0e4317a9/emonTH_DHT22_DS18B20/emonTH_DHT22_DS18B20.ino#L111" />
  <row Id="1222" PostHistoryTypeId="4" PostId="438" RevisionGUID="93eb3ac0-9cce-4559-bd9a-673654270ee8" CreationDate="2014-02-26T16:15:30.337" UserId="275" Comment="added direct link to respective coding line and minor language improvements" Text="How does this code line detect if a serial interface is connected?" />
  <row Id="1223" PostHistoryTypeId="24" PostId="438" RevisionGUID="93eb3ac0-9cce-4559-bd9a-673654270ee8" CreationDate="2014-02-26T16:15:30.337" Comment="Proposed by 275 approved by 65, 42 edit id of 157" />
  <row Id="1224" PostHistoryTypeId="5" PostId="453" RevisionGUID="26bfa43d-8e4a-4dd2-a08f-28676360e104" CreationDate="2014-02-26T16:22:09.850" UserId="296" Comment="put more info" Text="There is one from Brazil called **MariaMole**: http://dalpix.com/mariamole&#xD;&#xA;&#xD;&#xA;According to the author, like the original Arduino environment, the MariaMole facilitates the creation of software for the Arduino. However, while the original Arduino IDE has limitations to make life easier for beginners, MariaMole brings features that more advanced users are accustomed to find in professional IDEs, such as:&#xD;&#xA;&#xD;&#xA; - Runs over Arduino install&#xD;&#xA; - Workspace support multiple projects at the same time&#xD;&#xA; - Multiple serial port consoles at the same time&#xD;&#xA; - Files use open-formats&#xD;&#xA; - Building process configurable&#xD;&#xA; - Imports Arduino examples and sketches&#xD;&#xA; - Easily import Arduino libraries&#xD;&#xA; - Color-themes" />
  <row Id="1225" PostHistoryTypeId="5" PostId="457" RevisionGUID="19013aeb-7358-4082-99af-a9ab3bcd6b48" CreationDate="2014-02-26T16:26:28.817" UserId="65" Comment="Added language highlighting" Text="While it may not be possible to detect whether a device is connected to the Arduino serial connection or not, it is possible to *enable the debug messages over the serial connection* based on the presence of a device on the serial connection.&#xD;&#xA;&#xD;&#xA;Considering that you will be using the debug interface of your sketch only when connected to a computer capable of serial communication, it is possible to incorporate a simple test into the sketch based on which debug mode is enabled or not.&#xD;&#xA;&#xD;&#xA;When the sketch starts, you can check to see if any data is available on the Serial connection or not. If there is, then a device is present and debugging can be enabled. On the computer side, everytime you want to start the debugging mode on the Arduino, simply send a byte over the serial connection during the `setup` phase and sit back.&#xD;&#xA;&#xD;&#xA;Here is a sample sketch showing the same:&#xD;&#xA;&#xD;&#xA;&lt;!-- language: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;    int debug = 0;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      pinMode(13, OUTPUT);&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;&#xD;&#xA;      //Wait for four seconds or till data is available on serial, &#xD;&#xA;      //whichever occurs first.&#xD;&#xA;      while(Serial.available()==0 &amp;&amp; millis()&lt;4000);&#xD;&#xA;&#xD;&#xA;      //On timeout or availability of data, we come here.&#xD;&#xA;      if(Serial.available()&gt;0)&#xD;&#xA;      {&#xD;&#xA;        //If data is available, we enter here.&#xD;&#xA;        int test = Serial.read(); //We then clear the input buffer&#xD;&#xA;&#xD;&#xA;        Serial.println(&quot;DEBUG&quot;); //Give feedback indicating mode&#xD;&#xA;&#xD;&#xA;        debug = 1; //Enable debug&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      if(debug==1) Serial.println(&quot;ON&quot;);&#xD;&#xA;      digitalWrite(13,HIGH);&#xD;&#xA;      delay(1000);&#xD;&#xA;      if(debug==1) Serial.println(&quot;OFF&quot;);&#xD;&#xA;      digitalWrite(13,LOW);&#xD;&#xA;      delay(1000); &#xD;&#xA;    }" />
  <row Id="1226" PostHistoryTypeId="2" PostId="459" RevisionGUID="0d24f3fc-051b-4bbd-890d-ccde7da53827" CreationDate="2014-02-26T18:24:45.643" UserId="304" Text="I've been working with xbee on the arduino and raspberry pi for a few months now. Whilst it does have it's issues and quirks, it is a great tool in the communication chain. It's not perfect but given the mesh side of it, for me it reaches further than my wifi and can even be more reliable (my raspberry pi with wifi occasionally drops out, however the connected xbee continues to function in the background. &#xD;&#xA;&#xD;&#xA;Specifically in my case it allows for a serial connection between my devices (being several arduinos, a raspberry pi (coordinator) and my mac (used primarily for monitoring but also occasionally injecting serial data)). In this case it's perfect. It doesn't allow internet access or access beyond the xbee framework, but that suits me perfectly since implementation is as simple as Serial.print and Serial.read with no Ethernet overhead. " />
  <row Id="1227" PostHistoryTypeId="2" PostId="460" RevisionGUID="7c692d44-2203-4b23-a622-be59a5fb6e0d" CreationDate="2014-02-26T18:32:42.870" UserId="307" Text="I'm just a tinkerer learning Arduino with my son and I was surprised that when I plugged the USB cord back in to the Arduino the program was still running and I thought to myself, &quot;it's a good thing I didn't just blow anything up.&quot;&#xD;&#xA;&#xD;&#xA;So, what's the normal way people call it a day with these things?  Do you usually load up the bare-bones do nothing sketch or just unplug everything?" />
  <row Id="1228" PostHistoryTypeId="1" PostId="460" RevisionGUID="7c692d44-2203-4b23-a622-be59a5fb6e0d" CreationDate="2014-02-26T18:32:42.870" UserId="307" Text="How to reset arduino uno" />
  <row Id="1229" PostHistoryTypeId="3" PostId="460" RevisionGUID="7c692d44-2203-4b23-a622-be59a5fb6e0d" CreationDate="2014-02-26T18:32:42.870" UserId="307" Text="&lt;safety&gt;" />
  <row Id="1230" PostHistoryTypeId="2" PostId="461" RevisionGUID="78693a38-54ff-4389-bc64-6c112a9edfa9" CreationDate="2014-02-26T18:37:12.460" UserId="28" Text="When booted, the Arduino will run whatever program was put on it last. Solution: Don't turn it on if you don't want it to run.&#xD;&#xA;&#xD;&#xA;When out of the box, the Arduino usually runs the Blink program. So you can just load that and call it a day if you want to &quot;reset&quot; it.&#xD;&#xA;&#xD;&#xA;Or have a loop program with a sleep command.&#xD;&#xA;&#xD;&#xA;If you've been messing with the USB bootloader via the icsp pins, this isn't enough though, you'll need to reinstall the bootloader. But if you've been uploading programs via usb or directly using a programmer, there is no issue with uploading Blink or some other dummy program to reset it. " />
  <row Id="1231" PostHistoryTypeId="2" PostId="462" RevisionGUID="7b1fd95d-dba9-4e96-bb35-d01e94e30ecb" CreationDate="2014-02-26T19:19:25.700" UserId="311" Text="Which devices are similar to Arduino?&#xD;&#xA;No a greater/lower hardware, but the similar." />
  <row Id="1232" PostHistoryTypeId="1" PostId="462" RevisionGUID="7b1fd95d-dba9-4e96-bb35-d01e94e30ecb" CreationDate="2014-02-26T19:19:25.700" UserId="311" Text="Which are the competitors of the Arduino?" />
  <row Id="1233" PostHistoryTypeId="3" PostId="462" RevisionGUID="7b1fd95d-dba9-4e96-bb35-d01e94e30ecb" CreationDate="2014-02-26T19:19:25.700" UserId="311" Text="&lt;power&gt;" />
  <row Id="1234" PostHistoryTypeId="2" PostId="463" RevisionGUID="40988030-c571-44a7-9213-175481a54cf1" CreationDate="2014-02-26T19:30:38.163" UserId="310" Text="Since you're new to Arduino, I'd suggest beginning with a basic interfacing arduino activity. Once you understand reading and writing digital and analog signals it's pretty much plain sailing from there. You may want to invest some time and a bit of cash in a beginners course on Udemy (try PEter Dalmaris' course [https://www.udemy.com/arduino-sbs/][1]) it's a good start. From there, talking to the MultiWii should be a piece of cake. Also, check out [http://www.multiwii.com/connecting-elements][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.udemy.com/arduino-sbs/&#xD;&#xA;  [2]: http://www.multiwii.com/connecting-elements" />
  <row Id="1235" PostHistoryTypeId="5" PostId="462" RevisionGUID="6094627f-d937-4095-bb46-4e40fde2aaa2" CreationDate="2014-02-26T20:18:30.403" UserId="275" Comment="language improvements" Text="Which devices are similar to Arduino boards? Please only list devices / competitors that are comparable in terms of hardware." />
  <row Id="1236" PostHistoryTypeId="4" PostId="462" RevisionGUID="6094627f-d937-4095-bb46-4e40fde2aaa2" CreationDate="2014-02-26T20:18:30.403" UserId="275" Comment="language improvements" Text="Which are the competitors of the Arduino boards?" />
  <row Id="1237" PostHistoryTypeId="24" PostId="462" RevisionGUID="6094627f-d937-4095-bb46-4e40fde2aaa2" CreationDate="2014-02-26T20:18:30.403" Comment="Proposed by 275 approved by 42, 11 edit id of 158" />
  <row Id="1238" PostHistoryTypeId="2" PostId="464" RevisionGUID="38c8b648-63c7-4ffa-bf89-bc406559285c" CreationDate="2014-02-26T20:50:09.260" UserId="307" Text="I only get to work on my arduino every few weeks, so sometimes and get interrupted a lot by small children, so if I completely forget what is on the firmware, then I unplug the pins (because I haven't got anything soldered on there) should I be 100% certain I'm not going to fry my board?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1239" PostHistoryTypeId="1" PostId="464" RevisionGUID="38c8b648-63c7-4ffa-bf89-bc406559285c" CreationDate="2014-02-26T20:50:09.260" UserId="307" Text="Can you fry an arduino with nothing plugged in to it?" />
  <row Id="1240" PostHistoryTypeId="3" PostId="464" RevisionGUID="38c8b648-63c7-4ffa-bf89-bc406559285c" CreationDate="2014-02-26T20:50:09.260" UserId="307" Text="&lt;safety&gt;" />
  <row Id="1241" PostHistoryTypeId="2" PostId="465" RevisionGUID="19079c53-cb06-4291-8841-ab3bf8a4d895" CreationDate="2014-02-26T20:54:24.323" UserId="316" Text="Arduinos are far from bulletproof but with nothing connected (apart from a power source of course) I doubt it will come to harm. If in doubt, upload Blink to it.&#xD;&#xA;&#xD;&#xA;There are rugged Arduino-compatibles. One of them has a rather obvious name." />
  <row Id="1242" PostHistoryTypeId="6" PostId="464" RevisionGUID="2aac5497-c9bf-41c7-a5c0-0344a3c4da51" CreationDate="2014-02-26T21:09:18.667" UserId="307" Comment="edited tags" Text="&lt;safety&gt;" />
  <row Id="1245" PostHistoryTypeId="2" PostId="468" RevisionGUID="b0d93129-a8e3-4116-9dbd-cdd793b734d2" CreationDate="2014-02-26T21:24:59.653" UserId="310" Text="There is a brilliant open source, web based IDE called [Codebender][1]&#xD;&#xA;&#xD;&#xA;It is like Github for Arduino and has a great community working from it with thousands of examples and the dev team are exceptional.&#xD;&#xA;&#xD;&#xA;With codebender, you can:&#xD;&#xA;&#xD;&#xA; - program an existing sketch to your device &#xD;&#xA; - clone an existing sketch&#xD;&#xA; - modfy it to your needs &#xD;&#xA; - share your work with the world &#xD;&#xA; - embed code in your website, blog, or tutorials&#xD;&#xA;&#xD;&#xA;Cross-platform&#xD;&#xA;Works on Windows, Mac &amp; Linux, Firefox &amp; Chrome&#xD;&#xA;&#xD;&#xA;Codebender supports Windows (from Windows XP up to Windows 8.1, yes, even Vista :P), Mac OS X 10.6-10.9, and Linux and works within all major browsers&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://codebender.cc" />
  <row Id="1246" PostHistoryTypeId="2" PostId="469" RevisionGUID="81c7cb28-a35d-4563-88ac-d1032536feda" CreationDate="2014-02-26T21:33:30.393" UserId="28" Text="It's generally a good idea not to try to take input from a pin configured as `pinMode(OUTPUT)` and vice versa. In addition, I prefer not to take input from tristated pins, though this is harmless.&#xD;&#xA;&#xD;&#xA;In general none of the above makes a real difference (just a form of caution), Arduinos are well-protected from software issues.&#xD;&#xA;&#xD;&#xA;There are, however, [many ways to fry an Arduino via hardware.][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://electronics.stackexchange.com/a/67151/8144" />
  <row Id="1247" PostHistoryTypeId="2" PostId="470" RevisionGUID="83957a2d-dded-49f5-b07c-91d9e7186e12" CreationDate="2014-02-26T21:37:38.717" UserId="317" Text="I am working on a design project for school (non-capstone non-electrical engineering project) where we are building a system to remotely control a winch on a boat that will lower an [independently operating meter][1] to specified depths using a pressure transducer (controlled from the shore).&#xD;&#xA;&#xD;&#xA;My current idea is to have an arduino collecting data from the pressure transducer while being connected to the winch (adjusting it up/down as needed, based on the desired inputted depth). The arduino would then be connected to the a Raspberry Pi B via USB. The Raspberry Pi would then communicate via wifi USB adapter to a router @ 2.5 GHz 802.11n on the shore, which would then communicate with the laptop on the shore. The important thing is that the laptop on the shore will be recording data as well as changing the input depth for the arduino. &#xD;&#xA;&#xD;&#xA;Arduino &lt;==&gt; Raspberry Pi &lt;==&gt; Router &lt;==&gt; Laptop on shore&#xD;&#xA;&#xD;&#xA;I saw [this information][2] talking about connecting to an arduino via wifi, but I was unable to determine the potential range. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;A [related project][3] using a boat that uses the Xbee shield. &#xD;&#xA;&#xD;&#xA;Once concern is that we will not be able to specifically point any antenna on the boat back to shore, so we are looking for a non-direction-oriented solution. &#xD;&#xA;&#xD;&#xA;I was wondering what potential ways I could communicate back to the shore to control the winch depth (output display on shore showing depth, then being able to change the depth from shore). Furthermore, I was wondering if my setup would be feasible and what your suggestions might be.&#xD;&#xA;&#xD;&#xA;Thanks!&#xD;&#xA;&#xD;&#xA;  [1]: http://www.hydroscientificwest.com/cms/upload_pic/resize_1348258228.jpg&#xD;&#xA;  [3]: http://abersailbot.co.uk/about-the-boat/" />
  <row Id="1248" PostHistoryTypeId="1" PostId="470" RevisionGUID="83957a2d-dded-49f5-b07c-91d9e7186e12" CreationDate="2014-02-26T21:37:38.717" UserId="317" Text="How can I transmit data to/from arduino from up to ~750 ft away?" />
  <row Id="1249" PostHistoryTypeId="3" PostId="470" RevisionGUID="83957a2d-dded-49f5-b07c-91d9e7186e12" CreationDate="2014-02-26T21:37:38.717" UserId="317" Text="&lt;wifi&gt;&lt;raspberry-pi&gt;" />
  <row Id="1250" PostHistoryTypeId="2" PostId="471" RevisionGUID="55f721f3-bd13-4645-b34f-f8f75698651d" CreationDate="2014-02-26T21:50:32.867" UserId="220" Text="## 100% certain? No. 99.9999[Repeating]%? Yes*&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Due to a problem in the base 10 system, it can be proven that any number that has 9 repeating rounds up.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;Here's a couple problems you could run into:&#xD;&#xA;&#xD;&#xA; - Using pins `0` and `1` when connected to USB (wouldn't damage it, the USB chip if on a board with a separate USB chip would probably ignore the &quot;corrupted&quot; data.)&#xD;&#xA; - You never mentioned your board. If it's a Uno and you modified your USB firmware, there might be some issues reflashing your board if you forget that you flashed it with a keyboard firmware. **It won't damage it, but you may think it's bricked if you forget to reflash it.**&#xD;&#xA; - If you only disconnect a couple pins and leave others in, it may give wierd results and fry the Arduino or whatever is partially attached&#xD;&#xA; - If you make any physical modifications to the board&#xD;&#xA;&#xD;&#xA;The second to last one is the one you really have to worry about. I have seen previous discussions about destroying a board with a sketch, but nothing has been suggested.&#xD;&#xA;&#xD;&#xA;If you *do* use pins `0` and `1` I would imagine that you could hold the reset button when uploading (confirmation needed). There has to be a way to do it, or those pins would be disconnected. However, that's not in the scope of this question." />
  <row Id="1251" PostHistoryTypeId="2" PostId="472" RevisionGUID="fa9dd8b8-9752-46dd-99cd-a400b90e2d28" CreationDate="2014-02-26T21:57:15.830" UserId="83" Text="Although the controllers on an Arduino are pretty well protected, they can still be damaged by ESD (Electro Static Discharge). The same effect that makes a crispy sound when you pull off your woolen sweater in the winter, or after walking with rubber shoes on a carpet and you touch someone else or a metal and grounded object and you feel a pick. Static electricity can damage the controller. It may get completely broken, or it may function 'most of the time' or lifetime may be shortened.&#xD;&#xA;&#xD;&#xA;An Arduino is also easily killed with an piezo gas lighter, just make the spark near the copper traces that feed directly in the controller. This is largely the same effect as above. &#xD;&#xA;&#xD;&#xA;Again, the controllers themselves are pretty well protected, don't worry too much about them. But with kids running around (on their rubber shoes) better make sure they don't accidentally draw a spark from their little finger to your Arduino. The protective metallic bag is best, but putting it away in a cupboard or box should do the trick equally well.&#xD;&#xA;&#xD;&#xA;As a general rule of thumb, the faster the electronics, the more sensitive it is for ESD.&#xD;&#xA;" />
  <row Id="1252" PostHistoryTypeId="5" PostId="469" RevisionGUID="2914fef1-3eb6-4ac5-8b11-4e461dfe2951" CreationDate="2014-02-26T22:02:41.297" UserId="28" Comment="added 104 characters in body" Text="It's generally a good idea not to try to take input from a pin configured as `pinMode(OUTPUT)` and vice versa. In addition, I prefer not to take input from tristated pins. Both of these cases are harmless, but it's good practice not to do so, especially since they _can_ cause issues when coupled with some hardware.&#xD;&#xA;&#xD;&#xA;In general, Arduinos are protected from software issues. You can't burnout an Arduino with just faulty software.&#xD;&#xA;&#xD;&#xA;There are, however, [many ways to fry an Arduino via hardware.][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://electronics.stackexchange.com/a/67151/8144" />
  <row Id="1253" PostHistoryTypeId="5" PostId="472" RevisionGUID="4aa47014-6b9f-402d-81b2-5d39770976a5" CreationDate="2014-02-26T22:02:59.813" UserId="83" Comment="added 123 characters in body" Text="Although the controllers on an Arduino are pretty well protected, they can still be damaged by ESD (Electro Static Discharge). The same effect that makes a crispy sound when you pull off your woolen sweater in the winter, or after walking with rubber shoes on a carpet and you touch someone else or a metal and grounded object and you feel a pick. Static electricity can damage the controller. It may get completely broken, or it may function 'most of the time' or lifetime may be shortened.&#xD;&#xA;&#xD;&#xA;An Arduino is also easily killed with an piezo gas lighter, just make the spark near the copper traces that feed directly in the controller. This is largely the same effect as above. &#xD;&#xA;&#xD;&#xA;Again, the controllers themselves are pretty well protected, don't worry too much about them. But with kids running around (on their rubber shoes) better make sure they don't accidentally draw a spark from their little finger to your Arduino. The protective metallic bag is best, but putting it away in a cupboard or box should do the trick equally well.&#xD;&#xA;&#xD;&#xA;As a general rule of thumb, the faster the electronics, the more sensitive it is for ESD. A Due is probably more sensitive than a UNO or a MEGA. But with normal, avoiding static electricity, use you should be OK.&#xD;&#xA;" />
  <row Id="1254" PostHistoryTypeId="5" PostId="214" RevisionGUID="eabd3c86-9aed-4647-96c4-d61798803b71" CreationDate="2014-02-26T22:04:25.550" UserId="35" Comment="added more information, formatted the excerpt better" Text="Inter-Integrated Circuit (I²C) is a bus for low speed peripherals. Use this tag for questions regarding how to use I²C with an Arduino, or for problems with I²C and your Arduino." />
  <row Id="1255" PostHistoryTypeId="24" PostId="214" RevisionGUID="eabd3c86-9aed-4647-96c4-d61798803b71" CreationDate="2014-02-26T22:04:25.550" Comment="Proposed by 35 approved by 2 edit id of 160" />
  <row Id="1256" PostHistoryTypeId="5" PostId="213" RevisionGUID="8786c9a4-e9e2-47c6-9d3a-ea75c2176109" CreationDate="2014-02-26T22:04:32.127" UserId="35" Comment="added more information, formatted the excerpt better" Text="Inter-Integrated Circuit (I²C) is a bus for low speed peripherals. It was invented by Philips, but many companies have created devices using the I²C protocol. &#xD;&#xA;&#xD;&#xA;Use this tag for questions regarding how to use I²C with an Arduino, or for problems with I²C and your Arduino.&#xD;&#xA;&#xD;&#xA;See the [Wikipedia article for more info](http://en.wikipedia.org/wiki/I%C2%B2C)." />
  <row Id="1257" PostHistoryTypeId="24" PostId="213" RevisionGUID="8786c9a4-e9e2-47c6-9d3a-ea75c2176109" CreationDate="2014-02-26T22:04:32.127" Comment="Proposed by 35 approved by 2 edit id of 159" />
  <row Id="1258" PostHistoryTypeId="2" PostId="473" RevisionGUID="94c5417c-186f-4fdb-bb87-581190c8b528" CreationDate="2014-02-26T22:09:57.103" UserId="37" Text="I was instructed to &quot;burn the bootloader&quot; to my Arduino to fix an error I was getting. How can I do this? (And what exactly is the bootloader?)" />
  <row Id="1259" PostHistoryTypeId="1" PostId="473" RevisionGUID="94c5417c-186f-4fdb-bb87-581190c8b528" CreationDate="2014-02-26T22:09:57.103" UserId="37" Text="How do I burn the bootloader?" />
  <row Id="1260" PostHistoryTypeId="3" PostId="473" RevisionGUID="94c5417c-186f-4fdb-bb87-581190c8b528" CreationDate="2014-02-26T22:09:57.103" UserId="37" Text="&lt;bootloader&gt;" />
  <row Id="1261" PostHistoryTypeId="2" PostId="474" RevisionGUID="aaf3366b-c43c-47e7-9f66-55480dbd2b5e" CreationDate="2014-02-26T22:09:57.103" UserId="37" Text="The bootloader is a small program that is (almost) always on an Arduino. It manages uploading and starting the sketches you make, and blinks the pin 13 LED whenever the board resets.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;To burn the bootloader:&#xD;&#xA;&#xD;&#xA; 1. Obtain an [AVR ISP][1], [USBtinyISP][2], [ParallelProgrammer][3], or [another Arduino board][4]. This will be your ISP.&#xD;&#xA; 2. Unless otherwise instructed, connect the ISP to the ICSP pins on your board.&#xD;&#xA; 3. Power your board with either a USB cable or an external power supply.&#xD;&#xA; 4. Make sure you selected the correct board that you are burning to at `Tools ► Board ►` in the IDE. Double-check this even if you could upload programs correctly; uploading doesn't always require the right board.&#xD;&#xA; 5. Select the appropriate programmer at `Tools ► Programmer ►`.&#xD;&#xA; 6. Click `Tools ► Burn Bootloader`, and wait. It shouldn't take more than a minute, and often takes only a few seconds.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Sources:&#xD;&#xA;&#xD;&#xA; - http://arduino.cc/en/Hacking/Bootloader&#xD;&#xA; - http://arduino.cc/en/Guide/Environment&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/tools/MATUREAVRISP.aspx&#xD;&#xA;  [2]: http://learn.adafruit.com/usbtinyisp&#xD;&#xA;  [3]: http://arduino.cc/en/Hacking/ParallelProgrammer&#xD;&#xA;  [4]: http://arduino.cc/en/Tutorial/ArduinoISP" />
  <row Id="1262" PostHistoryTypeId="6" PostId="462" RevisionGUID="aa06fe6d-761b-4cb6-b9ae-21e9d45a6730" CreationDate="2014-02-26T22:11:03.900" UserId="84" Comment="`power`was obviously not the right tag for that question" Text="&lt;clones&gt;&lt;compatible&gt;&lt;boards&gt;" />
  <row Id="1263" PostHistoryTypeId="24" PostId="462" RevisionGUID="aa06fe6d-761b-4cb6-b9ae-21e9d45a6730" CreationDate="2014-02-26T22:11:03.900" Comment="Proposed by 84 approved by -1 edit id of 161" />
  <row Id="1264" PostHistoryTypeId="6" PostId="462" RevisionGUID="5875446b-94a7-49c2-b5d8-5a4b9c1b8073" CreationDate="2014-02-26T22:11:03.900" UserId="11" Comment="`power`was obviously not the right tag for that question" Text="&lt;clones&gt;" />
  <row Id="1265" PostHistoryTypeId="2" PostId="475" RevisionGUID="c663ef8a-4d3c-425f-9c5b-afb2112dd2d6" CreationDate="2014-02-26T22:24:30.690" UserId="37" Text="Here's a few I know of:&#xD;&#xA;&#xD;&#xA; - [SainSmart UNO][2]&#xD;&#xA; - [Parallax Propeller][3]&#xD;&#xA; - [BeagleBoard][4]&#xD;&#xA; - [Raspberry Pi][5]&#xD;&#xA; - Probably most of [these][1]&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.seeedstudio.com/depot/Arduino-Compatible-c-6_7/&#xD;&#xA;  [2]: http://www.sainsmart.com/sainsmart-uno-r3-atmega328-au-development-board-compatible-with-arduino-uno-r3.html&#xD;&#xA;  [3]: http://www.parallax.com/catalog/microcontrollers/propeller&#xD;&#xA;  [4]: http://beagleboard.org/Products&#xD;&#xA;  [5]: http://www.raspberrypi.org/" />
  <row Id="1267" PostHistoryTypeId="2" PostId="476" RevisionGUID="39795351-63d2-4282-954a-cfad94cadfa9" CreationDate="2014-02-26T22:40:31.687" UserId="79" Text="I see &quot;Arduino&quot; becoming a metonym for user-friendly embedded development platforms.&lt;br&gt;*A more accurate description is [synechdoche][1], example: Kleenex.* I like this question &amp; wish I could have asked this early on in my Arduino development! Because I see Arduino as a synechdote, this could lead to too broad of an answer, but I will try giving a highlights kind of answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;There is a Wiki [List of Arduino boards and compatible systems][2] which I just read and like enough I may need to figure out how to contribute &amp; edit wikis.&#xD;&#xA;&#xD;&#xA;Aspects of the question I'll try to answer:&lt;br&gt;&#xD;&#xA;1) **architecture** which could be a synonym for processor type.&lt;br&gt;&#xD;&#xA;2) **pin locations** aka the all important *pinouts*.&lt;br&gt;&#xD;&#xA;3) **developer environment** how to make it work.&lt;br&gt;&#xD;&#xA;4) **offshoots** where things get very interesting.&lt;br&gt;&#xD;&#xA;&#xD;&#xA;&lt;hr&gt;&#xD;&#xA;&lt;hr&gt;&#xD;&#xA;&#xD;&#xA;##Architecture&#xD;&#xA;&quot;Arduinos&quot; are based on AVR processors. There are a couple variants, easy to research.&lt;br&gt;&#xD;&#xA;AVR **ATmega** based processors, which Arduino initiated from.&lt;br&gt;&#xD;&#xA;**Netduino** and its myriad of offshoots. These have more RAM and clock speed.&lt;br&gt;&#xD;&#xA;**ChipKIT** and others in the [Non ATMega section of the wiki][3], usually with more RAM and clock speed.&lt;br&gt;&#xD;&#xA;**Entirely different embedded platforms** Like raspberry PI, beagle, etc.&#xD;&#xA;&#xD;&#xA;&lt;hr&gt;&#xD;&#xA;&lt;hr&gt;&#xD;&#xA;&#xD;&#xA;##Pin Locations&#xD;&#xA;This is the physical interface to the processor and I believe the heart of most problems I read about while researching my own projects. Sadly, I couldn't even say what pins do what, as I never use &quot;stock&quot; Arduino boards anymore.&#xD;&#xA;&#xD;&#xA;*Pin function* is what matters and should be the name of this part. Don't obsess on the pin number. Each pin can have multiple uses. This is rooted from embedded design needing to be as compact as possible while maximizing usefulness. [These amazing pinout graphics][4] help illustrate.&#xD;&#xA;&#xD;&#xA;&lt;hr&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;##Developer Environment&#xD;&#xA;The Arduino IDE (based on [processing][5]) is the supported default way to compile code and upload into Arduinos. To help deal with the synechdoche-ism of Arduino, Majenko created [UECIDE][6] to allow one place to program and delpoy to all your &quot;Arduino boards&quot; regardless of architecture. &#xD;&#xA;&#xD;&#xA;If you google AVR freaks, you learn this can be done via the command line, too.&#xD;&#xA;&#xD;&#xA;The NETduino and other NET platforms use Microsoft's &quot;dot NET&quot; tools to program the platform. The methodology behind this is a bit different and rubs classical embedded engineers the wrong way. The .NET platforms require compiled host software on the board. The modules in your Visual environment must have a matching version. Your code gets compiled into platform independent .NET objects, which then get downloaded to then interpreted on the platform. People making NET based boards are usually good about explaining the tool chain and development process.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;hr&gt;&#xD;&#xA;&lt;hr&gt;&#xD;&#xA;&#xD;&#xA;##Offshoots&#xD;&#xA;Here's where user-friendly embedded design really shines. People love the Arduino and want mostly the same thing but with some mods or &quot;improvements&quot;. &#xD;&#xA;&#xD;&#xA;*Ruggedino* is one that an electrical engineer has electrically hardened the original design to better resist common user mistakes which could damage the AVR processor.&#xD;&#xA;&#xD;&#xA;*Freeduino* has a model called the eleven which comes with a prototype area on the board so it's easy to use custom circuits in your sketches. This brand also believes in gold contacts, which suffer heat saturation better than the way original Arduinos are made. &#xD;&#xA;&#xD;&#xA;*Seeedstudio* (with 3 es) is great because they make a Mega that has Uno pinout, so you get more RAM. And their PCBs are red.&#xD;&#xA;&#xD;&#xA;*ChipKIT* platform get my love for maintaining Arduino pinout faithfully while bringing a processor with incredible resources to our universe. They give us these extra pins by having two row headers. They add another host of pins on the inside of the standard pins. This (and 32K of RAM) helped me greatly with my ambitious [project][7].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Synechdoche&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/List_of_Arduino_boards_and_compatible_systems&#xD;&#xA;  [3]: http://en.wikipedia.org/wiki/List_of_Arduino_boards_and_compatible_systems#Non-ATmega_boards&#xD;&#xA;  [4]: http://forum.arduino.cc/index.php/topic,146315.0.html&#xD;&#xA;  [5]: http://processing.org/&#xD;&#xA;  [6]: http://uecide.org/&#xD;&#xA;  [7]: http://forums.adafruit.com/viewtopic.php?f=22&amp;t=44710" />
  <row Id="1268" PostHistoryTypeId="5" PostId="475" RevisionGUID="b2ff71df-29a1-4962-be30-699db10dc591" CreationDate="2014-02-26T22:49:28.487" UserId="37" Comment="added 162 characters in body" Text="Here's a few I know of:&#xD;&#xA;&#xD;&#xA; - [SainSmart UNO][2]&#xD;&#xA; - [Parallax Propeller][3]&#xD;&#xA; - Probably most of [these][1]&#xD;&#xA;&#xD;&#xA;These are more small computers rather than microcontrollers, but they can still accomplish mostly the same tasks with the same electronics, at comparable prices:&#xD;&#xA;&#xD;&#xA; - [BeagleBoard][4]&#xD;&#xA; - [Raspberry Pi][5]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.seeedstudio.com/depot/Arduino-Compatible-c-6_7/&#xD;&#xA;  [2]: http://www.sainsmart.com/sainsmart-uno-r3-atmega328-au-development-board-compatible-with-arduino-uno-r3.html&#xD;&#xA;  [3]: http://www.parallax.com/catalog/microcontrollers/propeller&#xD;&#xA;  [4]: http://beagleboard.org/Products&#xD;&#xA;  [5]: http://www.raspberrypi.org/" />
  <row Id="1269" PostHistoryTypeId="5" PostId="465" RevisionGUID="ae32ba4f-68c4-4609-a62a-138b7126dbc0" CreationDate="2014-02-26T23:08:36.880" UserId="316" Comment="added 49 characters in body" Text="Arduinos are far from bulletproof but with nothing connected (apart from a power source of course) I doubt it will come to harm. If in doubt, upload Blink to it.&#xD;&#xA;&#xD;&#xA;There are rugged Arduino-compatibles. One of them has a rather [obvious name](http://ruggedcircuits.com/html/ruggeduino.html)" />
  <row Id="1270" PostHistoryTypeId="2" PostId="477" RevisionGUID="2a5511b0-9123-41b7-8c02-156614355813" CreationDate="2014-02-26T23:21:30.520" UserId="320" Text="I use &lt;a href=&quot;https://www.spark.io&quot;&gt;Spark Core&lt;/a&gt; which is a very easy to use Arduino programming platform. This platform was built on the primus that WiFi should be easy to use and cheap. Can even program the Spark Core from anywhere, any time.&#xA;" />
  <row Id="1271" PostHistoryTypeId="6" PostId="470" RevisionGUID="6574f51d-838d-443d-b287-a8d619819f47" CreationDate="2014-02-27T01:09:18.677" UserId="84" Comment="Removed `raspberri-pi` which actually is not part of the question" Text="&lt;wifi&gt;" />
  <row Id="1272" PostHistoryTypeId="24" PostId="470" RevisionGUID="6574f51d-838d-443d-b287-a8d619819f47" CreationDate="2014-02-27T01:09:18.677" Comment="Proposed by 84 approved by 42, 11 edit id of 162" />
  <row Id="1273" PostHistoryTypeId="2" PostId="478" RevisionGUID="5019ab67-eca4-4fd5-b4d1-2885658403fa" CreationDate="2014-02-27T01:23:53.087" UserId="323" Text="Comparable in what way?&#xA;&#xA;There's the stm32 nucleo and discovery boards.  In fact the nucleo is (hardware) compatible with arduino shields.  " />
  <row Id="1274" PostHistoryTypeId="5" PostId="201" RevisionGUID="eb80b6bc-adb8-46ed-a26e-59154de40404" CreationDate="2014-02-27T02:07:25.017" UserId="65" Comment="Added code highlighting " Text="`ardprintf` is a function that I hacked together which simulates `printf` over the serial connection. This function (given at the bottom) can be pasted in the beginning of the files where the function is needed. It should not create any conflicts.&#xD;&#xA;&#xD;&#xA;It can be called similar to `printf`. See it in action in this example:&#xD;&#xA;&lt;!-- language-all: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      int l=2;&#xD;&#xA;      char *j = &quot;test&quot;;&#xD;&#xA;      long k = 123456789;&#xD;&#xA;      char s = 'g';&#xD;&#xA;      float f = 2.3;&#xD;&#xA;    &#xD;&#xA;      ardprintf(&quot;test %d %l %c %s %f&quot;, l, k, s, j, f);&#xD;&#xA;    &#xD;&#xA;      delay(5000);&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The output as expected is:&#xD;&#xA;&#xD;&#xA;    test 2 123456789 g test 2.30&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;The function prototype is:&#xD;&#xA;&#xD;&#xA;    int ardprintf(char *, ...);&#xD;&#xA;&#xD;&#xA;It returns the number of arguments detected in the function call. &#xD;&#xA;&#xD;&#xA;This is the function definition:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #ifndef ARDPRINTF&#xD;&#xA;    #define ARDPRINTF&#xD;&#xA;    #define ARDBUFFER 16&#xD;&#xA;    #include &lt;stdarg.h&gt;&#xD;&#xA;    #include &lt;Arduino.h&gt;&#xD;&#xA;&#xD;&#xA;    int ardprintf(char *str, ...)&#xD;&#xA;    {&#xD;&#xA;      int i, count=0, j=0, flag=0;&#xD;&#xA;      char temp[ARDBUFFER+1];&#xD;&#xA;      for(i=0; str[i]!='\0';i++)  if(str[i]=='%')  count++;&#xD;&#xA;      &#xD;&#xA;      va_list argv;&#xD;&#xA;      va_start(argv, count);&#xD;&#xA;      for(i=0,j=0; str[i]!='\0';i++)&#xD;&#xA;      {&#xD;&#xA;        if(str[i]=='%')&#xD;&#xA;        {&#xD;&#xA;          temp[j] = '\0';&#xD;&#xA;          Serial.print(temp);&#xD;&#xA;          j=0;&#xD;&#xA;          temp[0] = '\0';&#xD;&#xA;          &#xD;&#xA;          switch(str[++i])&#xD;&#xA;          {&#xD;&#xA;            case 'd': Serial.print(va_arg(argv, int));&#xD;&#xA;                      break;&#xD;&#xA;            case 'l': Serial.print(va_arg(argv, long));&#xD;&#xA;                      break;&#xD;&#xA;            case 'f': Serial.print(va_arg(argv, double));&#xD;&#xA;                      break;&#xD;&#xA;            case 'c': Serial.print((char)va_arg(argv, int));&#xD;&#xA;                      break;&#xD;&#xA;            case 's': Serial.print(va_arg(argv, char *));&#xD;&#xA;                      break;&#xD;&#xA;            default:  ;&#xD;&#xA;          };&#xD;&#xA;        }&#xD;&#xA;        else &#xD;&#xA;        {&#xD;&#xA;          temp[j] = str[i];&#xD;&#xA;          j = (j+1)%ARDBUFFER;&#xD;&#xA;          if(j==0) &#xD;&#xA;          {&#xD;&#xA;            temp[ARDBUFFER] = '\0';&#xD;&#xA;            Serial.print(temp);&#xD;&#xA;            temp[0]='\0';&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      };&#xD;&#xA;      Serial.println();&#xD;&#xA;      return count + 1;&#xD;&#xA;    }&#xD;&#xA;    #undef ARDBUFFER&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;**To print the `%` character, use `%%`.*&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Now, available on [Github gists][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://gist.github.com/AsheeshR/9004783" />
  <row Id="1275" PostHistoryTypeId="2" PostId="479" RevisionGUID="0a06f213-7cfe-42c3-be64-d1ca7488b51b" CreationDate="2014-02-27T04:19:35.337" UserId="304" Text="I usually (painfully) stick with multiple lines of `Serial.print` but when it becomes convoluted I go back to `sprintf`. It's annoying in that you have to have an available buffer for it. &#xD;&#xA;&#xD;&#xA;Usage is as simple (??) as:&#xD;&#xA;&#xD;&#xA;    char buffer[35]; // you have to be aware of how long your data can be&#xD;&#xA;                     // not forgetting unprintable and null term chars&#xD;&#xA;    sprintf(buffer,&quot;var1:%i\tvar2:%i\tvar3:%i&quot;,var1,var2,var3);&#xD;&#xA;    Serial.println(buffer);&#xD;&#xA;&#xD;&#xA;A word of warning though, it doesn't (by default) support floating types. " />
  <row Id="1276" PostHistoryTypeId="2" PostId="480" RevisionGUID="571e89b0-63ab-48f6-87dd-35e00bbd5e30" CreationDate="2014-02-27T04:22:01.400" UserId="304" Text="I wouldn't normally put two answers to a question, but I only just found [this][1] today, where you can use printf without any buffer. (Caveat: I haven't yet tried it, and it's not mine, refer to link above)&#xD;&#xA;&#xD;&#xA;    // Function that printf and related will use to print&#xD;&#xA;    int serial_putchar(char c, FILE* f) {&#xD;&#xA;        if (c == '\n') serial_putchar('\r', f);&#xD;&#xA;        return Serial.write(c) == 1? 0 : 1;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    FILE serial_stdout;&#xD;&#xA;    &#xD;&#xA;    void setup(){&#xD;&#xA;        Serial.begin(115200);&#xD;&#xA;    &#xD;&#xA;        // Set up stdout&#xD;&#xA;        fdev_setup_stream(&amp;serial_stdout, serial_putchar, NULL, _FDEV_SETUP_WRITE);&#xD;&#xA;        stdout = &amp;serial_stdout;&#xD;&#xA;        &#xD;&#xA;        printf(&quot;My favorite number is %6d!&quot;, 12);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This still has the floating point limitation.&#xD;&#xA;&#xD;&#xA;  [1]: http://forum.arduino.cc/index.php/topic,120440.0.html" />
  <row Id="1277" PostHistoryTypeId="5" PostId="480" RevisionGUID="a4a5045a-9310-4f3d-ade7-ee1f790ce57b" CreationDate="2014-02-27T04:54:54.903" UserId="304" Comment="changed serial speed to reflect what I've seen most people use, plus included a sample in the main loop" Text="I wouldn't normally put two answers to a question, but I only just found [this][1] today, where you can use printf without any buffer. &#xD;&#xA;&#xD;&#xA;    // Function that printf and related will use to print&#xD;&#xA;    int serial_putchar(char c, FILE* f) {&#xD;&#xA;        if (c == '\n') serial_putchar('\r', f);&#xD;&#xA;        return Serial.write(c) == 1? 0 : 1;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    FILE serial_stdout;&#xD;&#xA;    &#xD;&#xA;    void setup(){&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;    &#xD;&#xA;        // Set up stdout&#xD;&#xA;        fdev_setup_stream(&amp;serial_stdout, serial_putchar, NULL, _FDEV_SETUP_WRITE);&#xD;&#xA;        stdout = &amp;serial_stdout;&#xD;&#xA;        &#xD;&#xA;        printf(&quot;My favorite number is %6d!\n&quot;, 12);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      static long hex = 0;&#xD;&#xA;      static long dec = 0;&#xD;&#xA;      if (millis()%300==0){&#xD;&#xA;        printf(&quot;millis(): %ld\tcounter: %ld (%02X)\n&quot;, millis(), dec++, hex++);&#xD;&#xA;        delay(1);    &#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This still has the floating point limitation.&#xD;&#xA;&#xD;&#xA;edit: I thought I would do a little testing on this, and it works quite well. I added a better test to the loop with formatted output. &#xD;&#xA;&#xD;&#xA;  [1]: http://forum.arduino.cc/index.php/topic,120440.0.html" />
  <row Id="1278" PostHistoryTypeId="5" PostId="480" RevisionGUID="c2dfd628-0fc7-4cb9-8cd7-3391965a5e5a" CreationDate="2014-02-27T05:03:51.203" UserId="304" Comment="fixed sample code" Text="I wouldn't normally put two answers to a question, but I only just found [this][1] today, where you can use printf without any buffer. &#xD;&#xA;&#xD;&#xA;    // Function that printf and related will use to print&#xD;&#xA;    int serial_putchar(char c, FILE* f) {&#xD;&#xA;        if (c == '\n') serial_putchar('\r', f);&#xD;&#xA;        return Serial.write(c) == 1? 0 : 1;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    FILE serial_stdout;&#xD;&#xA;    &#xD;&#xA;    void setup(){&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;    &#xD;&#xA;        // Set up stdout&#xD;&#xA;        fdev_setup_stream(&amp;serial_stdout, serial_putchar, NULL, _FDEV_SETUP_WRITE);&#xD;&#xA;        stdout = &amp;serial_stdout;&#xD;&#xA;        &#xD;&#xA;        printf(&quot;My favorite number is %6d!\n&quot;, 12);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      static long counter = 0;&#xD;&#xA;      if (millis()%300==0){&#xD;&#xA;        printf(&quot;millis(): %ld\tcounter: %ld (%02X)\n&quot;, millis(), counter, counter++);&#xD;&#xA;        delay(1);    &#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This still has the floating point limitation.&#xD;&#xA;&#xD;&#xA;edit: I thought I would do a little testing on this, and it works quite well. I added a better test to the loop with formatted output. &#xD;&#xA;&#xD;&#xA;  [1]: http://forum.arduino.cc/index.php/topic,120440.0.html" />
  <row Id="1279" PostHistoryTypeId="2" PostId="481" RevisionGUID="95b4e242-fb7e-4bdd-b8ab-9af3bf6c4633" CreationDate="2014-02-27T08:50:03.343" UserId="136" Text="There are a number of considerations that need to be made when considering any wireless communication solution over long distances and over water.&#xD;&#xA;&#xD;&#xA;WiFi is capable of working over long distances especially with higher power cards (1W ones are now readily available) and directional antenna (anything from 3dBi to 30dBi of gain). There are advantages and disadvantages to using WiFi like this for your purposes:&#xD;&#xA;&#xD;&#xA; - WiFi uses 2.4GHz which is attenuated by the presence of water and water vapour. If you are close to the surface of the water surface, this can cause variable range with weather conditions - even slight choppiness can massively increase the humidity close to the surface.&#xD;&#xA; - WiFi is a fairly heavyweight protocol that has several layers that need setting up each time a connection is made. This takes time and means marginal connections will have zero throughput.&#xD;&#xA; - WiFi is intended to have high throughput (&gt;1MBps) and doesn't degrade gracefully below this point. There isn't often a need to shift data this fast on an Arduino project.&#xD;&#xA; - Directional antenna on boats can be hard work. The more gain an antenna has, the more directional it is, which in turn means you need to aim it better. Even mild rocking can make this difficult to impossible. It depends if you are on a smooth pond or the sea really.&#xD;&#xA;&#xD;&#xA;If you do want to go with WiFi, Ubiquiti make some neat products like the Nanostation that allow long range connections to be set-up over long ranges.&#xD;&#xA;&#xD;&#xA;Personally I would stay away from 2.4GHz near water, and go with one of the other ISM bands. Depending on your location, this could mean 315MHzm 433MHz, 868MHz, or 915MHz. The lower frequencies are suited to longer ranges. There are a lot of different solutions in this space, all of which have ups and downs. &#xD;&#xA;&#xD;&#xA;The Hope RFM12B is a very popular small RF board that has several easy to use libraries available - I use Jeelib personally. These are just capable of the 750ft range you require. They are available in all most ISM bands, and personally I have found the 868MHz best outdoors, whilst the 434MHz is better indoors.&#xD;&#xA;&#xD;&#xA;The newer Hope RFM69W is a similar board but with more functionality and more power. It has 13dBm (20mW) of power vs 0dBm (1mW) of power on the RFM12B. I have been seeing an increase in range of ~50-100% with these boards.&#xD;&#xA;&#xD;&#xA;The RFM69HW is a high power version has 20dBm (100mW) of power. I haven't range tested this, but would expect up to 3-4 times the range of an RFM12B.&#xD;&#xA;&#xD;&#xA;It's important to note that these are transceivers so that they can send and receive, which means you can acknowledge if packets have been received.&#xD;&#xA;&#xD;&#xA;There are boards like the nRF2401L which use 2.4GHz, but use a much lighter weight protocol than WiFi so work better on marginal ranges. They have the same disadvantage of water impacting range.&#xD;&#xA;&#xD;&#xA;I don't like Xbee at all. The boards are overpriced and I find the range isn't great.&#xD;&#xA;&#xD;&#xA;You could also &quot;roll your own&quot; and use simple 434/868/915MHz on-off-keyed (OOK) transmitter/receivers. Protocol design isn't easy though, and you lose a lot of hidden functionality that the more advanced boards have." />
  <row Id="1280" PostHistoryTypeId="5" PostId="481" RevisionGUID="21384e1f-437a-428d-a9ba-f73c1cb79bca" CreationDate="2014-02-27T09:06:54.977" UserId="136" Comment="Linkified everything." Text="There are a number of considerations that need to be made when considering any wireless communication solution over long distances and over water.&#xD;&#xA;&#xD;&#xA;WiFi is capable of working over long distances especially with higher power cards ([1W ones are now readily available][1]) and directional antenna (anything from [3dBi][2] to [30dBi][3] of gain). There are advantages and disadvantages to using WiFi like this for your purposes:&#xD;&#xA;&#xD;&#xA; - WiFi uses 2.4GHz which is attenuated by the presence of water and water vapour. If you are close to the surface of the water surface, this can cause variable range with weather conditions increasing humidity and spray - even slight choppiness can massively increase the humidity close to the surface.&#xD;&#xA; - WiFi is a fairly heavyweight protocol that has several layers that need setting up each time a connection is made. This takes time and means marginal connections will have zero throughput as they will never get setup.&#xD;&#xA; - WiFi is intended to have high throughput (&gt;1MBps) and doesn't degrade gracefully below this point. There isn't often a need to shift data this fast on an Arduino project. Speed and range are a trade-off.&#xD;&#xA; - Directional antenna on boats can be hard work. The more gain an antenna has, the more directional it is, which in turn means you need to aim it better. Even mild rocking can make this difficult to impossible. It depends if you are on a smooth pond or the sea really.&#xD;&#xA;&#xD;&#xA;If you do want to go with WiFi, Ubiquiti make some neat products like the [Nanostation][4] that allow long range connections to be set-up over long ranges.&#xD;&#xA;&#xD;&#xA;Personally I would stay away from 2.4GHz near water, and go with one of the other ISM bands. Depending on your location, this could mean 315MHz 433MHz, 868MHz, or 915MHz. It depends which region of the world you are in which ones you are allowed to use.&#xD;&#xA;&#xD;&#xA;These lower frequencies are suited to longer ranges and penetrating object and water. There are a lot of different solutions in this space, all of which have ups and downs. &#xD;&#xA;&#xD;&#xA;The [Hope RFM12B][5] is a very popular small RF board that has several easy to use libraries available - I use [Jeelib][6] personally. These are just capable of the 750ft range you require. They are available in all most ISM bands, and personally I have found the 868MHz best outdoors, whilst the 434MHz is better indoors.&#xD;&#xA;&#xD;&#xA;The newer [Hope RFM69W][7] is a similar board but with more functionality and more power. It has 13dBm (20mW) of power vs 0dBm (1mW) of power on the RFM12B. I have been seeing an increase in range of ~50-100% with these boards.&#xD;&#xA;&#xD;&#xA;The [RFM69HW][8] is a high power version has 20dBm (100mW) of power. I haven't range tested this, but would expect up to 3-4 times the range of an RFM12B.&#xD;&#xA;&#xD;&#xA;It's important to note that these are transceivers so that they can send and receive, which means you can acknowledge if packets have been received.&#xD;&#xA;&#xD;&#xA;There are boards like the [nRF2401L][9] which use 2.4GHz, but use a much lighter weight protocol than WiFi so work better on marginal ranges. They are dirt cheap (~£2). They have the same disadvantage of water impacting range.&#xD;&#xA;&#xD;&#xA;I don't like Xbee at all. The boards are overpriced and I find the range isn't great even with the higher powered modules.&#xD;&#xA;&#xD;&#xA;You could also &quot;roll your own&quot; and use simple 434/868/915MHz on-off-keyed (OOK) [transmitter][10]/[receivers][11]. Protocol design isn't easy though, and you lose a lot of hidden functionality that the more advanced boards have.&#xD;&#xA;&#xD;&#xA;  [1]: https://www.google.co.uk/search?client=safari&amp;rls=en&amp;q=Alfa%20AWUS036H%201000mW&amp;ie=UTF-8&amp;oe=UTF-8&amp;gws_rd=cr&amp;ei=lf0OU_ubJsGM0AW_1oGACw&#xD;&#xA;  [2]: http://uk.tp-link.com/products/details/?categoryid=2473&amp;model=TL-ANT2403N&#xD;&#xA;  [3]: http://uk.tp-link.com/products/details/?categoryid=2474&amp;model=TL-ANT5830B&#xD;&#xA;  [4]: http://www.ubnt.com/nanostation&#xD;&#xA;  [5]: https://www.sparkfun.com/products/9582&#xD;&#xA;  [6]: https://github.com/jcw/jeelib&#xD;&#xA;  [7]: http://www.hoperf.com/rf/fsk_module/RFM69W.htm&#xD;&#xA;  [8]: http://www.hoperf.com/rf/fsk_module/RFM69HW.htm&#xD;&#xA;  [9]: http://playground.arduino.cc/InterfacingWithHardware/Nrf2401&#xD;&#xA;  [10]: http://www.coolcomponents.co.uk/rf-link-transmitter-434mhz-781.html&#xD;&#xA;  [11]: http://www.coolcomponents.co.uk/rf-link-receiver-4800bps-434mhz.html" />
  <row Id="1281" PostHistoryTypeId="5" PostId="481" RevisionGUID="71272201-7cbf-44c1-9f39-f3a3f7ce7b6e" CreationDate="2014-02-27T09:19:28.577" UserId="136" Comment="Added another option." Text="There are a number of considerations that need to be made when considering any wireless communication solution over long distances and over water.&#xD;&#xA;&#xD;&#xA;WiFi is capable of working over long distances especially with higher power cards ([1W ones are now readily available][1]) and directional antenna (anything from [3dBi][2] to [30dBi][3] of gain). There are advantages and disadvantages to using WiFi like this for your purposes:&#xD;&#xA;&#xD;&#xA; - WiFi uses 2.4GHz which is attenuated by the presence of water and water vapour. If you are close to the surface of the water surface, this can cause variable range with weather conditions increasing humidity and spray - even slight choppiness can massively increase the humidity close to the surface.&#xD;&#xA; - WiFi is a fairly heavyweight protocol that has several layers that need setting up each time a connection is made. This takes time and means marginal connections will have zero throughput as they will never get setup.&#xD;&#xA; - WiFi is intended to have high throughput (&gt;1MBps) and doesn't degrade gracefully below this point. There isn't often a need to shift data this fast on an Arduino project. Speed and range are a trade-off.&#xD;&#xA; - Directional antenna on boats can be hard work. The more gain an antenna has, the more directional it is, which in turn means you need to aim it better. Even mild rocking can make this difficult to impossible. It depends if you are on a smooth pond or the sea really.&#xD;&#xA;&#xD;&#xA;If you do want to go with WiFi, Ubiquiti make some neat products like the [Nanostation][4] that allow long range connections to be set-up over long ranges.&#xD;&#xA;&#xD;&#xA;Personally I would stay away from 2.4GHz near water, and go with one of the other ISM bands. Depending on your location, this could mean 315MHz 433MHz, 868MHz, or 915MHz. It depends which region of the world you are in which ones you are allowed to use.&#xD;&#xA;&#xD;&#xA;These lower frequencies are suited to longer ranges and penetrating object and water. There are a lot of different solutions in this space, all of which have ups and downs. &#xD;&#xA;&#xD;&#xA;The [Hope RFM12B][5] is a very popular small RF board that has several easy to use libraries available - I use [Jeelib][6] personally. These are just capable of the 750ft range you require. They are available in all most ISM bands, and personally I have found the 868MHz best outdoors, whilst the 434MHz is better indoors.&#xD;&#xA;&#xD;&#xA;The newer [Hope RFM69W][7] is a similar board but with more functionality and more power. It has 13dBm (20mW) of power vs 0dBm (1mW) of power on the RFM12B. I have been seeing an increase in range of ~50-100% with these boards.&#xD;&#xA;&#xD;&#xA;The [RFM69HW][8] is a high power version has 20dBm (100mW) of power. I haven't range tested this, but would expect up to 3-4 times the range of an RFM12B.&#xD;&#xA;&#xD;&#xA;Ciseco, a UK company, also make a series of boards that use CC1110 chips as transceivers. These are in an XBee like form. One of their boards, [the ARF][9], has a power amplifier. These have 26dBm output power (400mW) and in a brief test in a built up area, I have seen a range of about 2km.&#xD;&#xA;&#xD;&#xA;It's important to note that these are transceivers so that they can send and receive, which means you can acknowledge if packets have been received.&#xD;&#xA;&#xD;&#xA;There are boards like the [nRF2401L][10] which use 2.4GHz, but use a much lighter weight protocol than WiFi so work better on marginal ranges. They are dirt cheap (~£2). They have the same disadvantage of water impacting range.&#xD;&#xA;&#xD;&#xA;I don't like Xbee at all. The boards are overpriced and I find the range isn't great even with the higher powered modules.&#xD;&#xA;&#xD;&#xA;You could also &quot;roll your own&quot; and use simple 434/868/915MHz on-off-keyed (OOK) [transmitter][11]/[receivers][12]. Protocol design isn't easy though, and you lose a lot of hidden functionality that the more advanced boards have.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.google.co.uk/search?client=safari&amp;rls=en&amp;q=Alfa%20AWUS036H%201000mW&amp;ie=UTF-8&amp;oe=UTF-8&amp;gws_rd=cr&amp;ei=lf0OU_ubJsGM0AW_1oGACw&#xD;&#xA;  [2]: http://uk.tp-link.com/products/details/?categoryid=2473&amp;model=TL-ANT2403N&#xD;&#xA;  [3]: http://uk.tp-link.com/products/details/?categoryid=2474&amp;model=TL-ANT5830B&#xD;&#xA;  [4]: http://www.ubnt.com/nanostation&#xD;&#xA;  [5]: https://www.sparkfun.com/products/9582&#xD;&#xA;  [6]: https://github.com/jcw/jeelib&#xD;&#xA;  [7]: http://www.hoperf.com/rf/fsk_module/RFM69W.htm&#xD;&#xA;  [8]: http://www.hoperf.com/rf/fsk_module/RFM69HW.htm&#xD;&#xA;  [9]: http://shop.ciseco.co.uk/arf-high-power-radio-transceiver/&#xD;&#xA;  [10]: http://playground.arduino.cc/InterfacingWithHardware/Nrf2401&#xD;&#xA;  [11]: http://www.coolcomponents.co.uk/rf-link-transmitter-434mhz-781.html&#xD;&#xA;  [12]: http://www.coolcomponents.co.uk/rf-link-receiver-4800bps-434mhz.html" />
  <row Id="1283" PostHistoryTypeId="2" PostId="482" RevisionGUID="7de59e40-4214-4b0f-a21c-7c566f282ebd" CreationDate="2014-02-27T11:46:28.300" UserId="206" Text="Though emulator is quite a useful thing to debug a code with no side effects, most real-world applications include some circuitry besides an Arduino. If a microcontroller on Arduino had JTAG interface, it would be pretty straight-forward, but what if it's e.g. Arduino Uno?" />
  <row Id="1284" PostHistoryTypeId="1" PostId="482" RevisionGUID="7de59e40-4214-4b0f-a21c-7c566f282ebd" CreationDate="2014-02-27T11:46:28.300" UserId="206" Text="How do I debug on-chip with Arduino?" />
  <row Id="1285" PostHistoryTypeId="3" PostId="482" RevisionGUID="7de59e40-4214-4b0f-a21c-7c566f282ebd" CreationDate="2014-02-27T11:46:28.300" UserId="206" Text="&lt;ide&gt;&lt;emulation&gt;" />
  <row Id="1286" PostHistoryTypeId="6" PostId="482" RevisionGUID="e31dc3f5-be51-4a30-844a-c0e84b66c0c5" CreationDate="2014-02-27T11:48:25.707" UserId="42" Comment="Added debugging tag" Text="&lt;ide&gt;&lt;emulation&gt;&lt;debugging&gt;" />
  <row Id="1287" PostHistoryTypeId="2" PostId="483" RevisionGUID="8b75d8df-7e62-4df4-b0b7-92bc9e51bb4a" CreationDate="2014-02-27T12:55:32.013" UserId="304" Text="I am playing on a Arduino UNO, you would have to compare the datasheets to determine differences. &#xD;&#xA;&#xD;&#xA;For my research on this answer I am looking at: &#xD;&#xA;&#xD;&#xA;- [Code/PwmFrequency (for a quick rundown)][1]&#xD;&#xA;- [Tutorial/PWM][2]&#xD;&#xA;- [TimerPWMCheatsheet (explains the prescaller and resulting frequencies)][3]&#xD;&#xA;- [varying the pwm frequency of timer0 and timer2][4]&#xD;&#xA;- [feature request: adjustable pwm frequencies][5]&#xD;&#xA;- [pwm frequency library (this is the one you REALLY want)][6]&#xD;&#xA;- and the datasheet for the [ATMega328][7]&#xD;&#xA;&#xD;&#xA;Also:&#xD;&#xA;&#xD;&#xA;- we know PWM pins are D3, D5, D6, D9, D10, D11&#xD;&#xA;- I am using D11 for this since I can attach my oscilloscope to the MOSI pin of the ISCP&#xD;&#xA;- D11 maps to PB3 (MOSI/OC2A/PCINT3) (see datasheet or [this cool gfx][8])&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;## Normal usage ##&#xD;&#xA;First, let's see what happens when we set an arbitrary PWM on pin 11&#xD;&#xA;&#xD;&#xA;    int DUTY = 25;&#xD;&#xA;    analogWrite(11, DUTY * 256 / 100);&#xD;&#xA;&#xD;&#xA;results in:&#xD;&#xA;&#xD;&#xA;1. Freq: ~487Hz&#xD;&#xA;2. Duty: ~25%&#xD;&#xA;3. Time: ~2.05ms&#xD;&#xA;&#xD;&#xA;This first point I will make is that with the given 490Hz the PWM duration is actually 2ms which seems to be close to what you want (you said between 1-2ms), maybe my misunderstanding there.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;## Playing with pre-scalers ##&#xD;&#xA;From several of the links posted above, you will see that you have different pre-scalers available depending on which timer you are using: eg.&#xD;&#xA;&#xD;&#xA;**Pins 5 and 6: controlled by Timer 0 in fast PWM mode (cycle length = 256)**&#xD;&#xA;&#xD;&#xA;    Setting 	Divisor 	Frequency&#xD;&#xA;    0x01 	 	1 	 	    62500&#xD;&#xA;    0x02  		8 	 	    7812.5&#xD;&#xA;    0x03  		64 	 	    976.5625&#xD;&#xA;    0x04 	 	256 	 	244.140625&#xD;&#xA;    0x05 	 	1024 	 	61.03515625&#xD;&#xA;&#xD;&#xA;    TCCR0B = TCCR0B &amp; 0b11111000 | &lt;setting&gt;;&#xD;&#xA;&#xD;&#xA;**Pins 9 and 10: controlled by timer 1 in phase-correct PWM mode (cycle length = 510)**&#xD;&#xA;&#xD;&#xA;    Setting 	Divisor 	Frequency&#xD;&#xA;    0x01 	 	1 	 	    31372.55&#xD;&#xA;    0x02 	 	8 	 	    3921.16&#xD;&#xA;    0x03  		64 	 	    490.20&#xD;&#xA;    0x04  		256 	 	122.55&#xD;&#xA;    0x05 	 	1024 	 	30.64&#xD;&#xA;&#xD;&#xA;    TCCR1B = TCCR1B &amp; 0b11111000 | &lt;setting&gt;;&#xD;&#xA;&#xD;&#xA;**Pins 11 and 3: controlled by timer 2 in phase-correct PWM mode (cycle length = 510)**&#xD;&#xA;&#xD;&#xA;    Setting 	Divisor 	Frequency&#xD;&#xA;    0x01 	 	1  	    	31372.55&#xD;&#xA;    0x02 	 	8 	 	    3921.16&#xD;&#xA;    0x03  		32  		980.39&#xD;&#xA;    0x04 	 	64 	 	    490.20&#xD;&#xA;    0x05 	 	128  		245.10&#xD;&#xA;    0x06  		256  		122.55&#xD;&#xA;    0x07 	 	1024  		30.64&#xD;&#xA;&#xD;&#xA;    TCCR2B = TCCR2B &amp; 0b11111000 | &lt;setting&gt;;&#xD;&#xA;     &#xD;&#xA;    (All frequencies are in Hz and assume a 16000000 Hz system clock.)&#xD;&#xA;&#xD;&#xA;These are relatively simple to setup and use (the setting is at the bottom of each of the above code blocks), but you have to be mindful of playing with the pre-scaler of timer0 (which controls `millis()` and `delay()`). So if you have a choice, steer clear of timer0, or pwm pins 5 and 6.&#xD;&#xA;&#xD;&#xA;Example of using just the inbuilt pre-scalers without any additional libraries:&#xD;&#xA;&#xD;&#xA;    #define PIN 11&#xD;&#xA;    void setup(){&#xD;&#xA;        pinMode(PIN,OUTPUT);  // not absolutely required&#xD;&#xA;        int DUTY = 20;&#xD;&#xA;        TCCR2B = TCCR2B &amp; 0b11111000 | 6;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      static long counter = 0;&#xD;&#xA;      if(millis()%10==0){&#xD;&#xA;          counter++;&#xD;&#xA;          analogWrite(PIN, counter%255);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I know you can manipulate the frequency better than that, and I have been playing with this for hours and then I finally stumbled upon the final link (which believe it or not, I found via YouTube!).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;##Using an External Library##&#xD;&#xA;&#xD;&#xA;To use the PWM library you will need to download it from [Google Code][9], save/import/get it into your library folder, and restart the IDE. Once you do that, you can explicitly set the frequency (within limits, 333Hz is within those limits), and you should be set. &#xD;&#xA;&#xD;&#xA;Code example:&#xD;&#xA;&#xD;&#xA;    #include &lt;PWM.h&gt;&#xD;&#xA;    int32_t frequency = 333;&#xD;&#xA;    &#xD;&#xA;    #define PIN 10&#xD;&#xA;&#xD;&#xA;    void setup(){&#xD;&#xA;        pinMode(PIN,OUTPUT);&#xD;&#xA;        int DUTY = 20;&#xD;&#xA;        InitTimersSafe();                    // won't touch timer0&#xD;&#xA;        SetPinFrequencySafe(PIN,frequency);  // again, not timer0&#xD;&#xA;        pwmWrite(PIN, DUTY * 256 / 100);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;There is even a `pwmWriteHR` which allows for higher resolution, but that does not work with timer2 (which is only an 8-bit timer). &#xD;&#xA;&#xD;&#xA;The matching, non-safe (ie initialises and uses timer0 as well) functions are:&#xD;&#xA;&#xD;&#xA;    InitTimer();  // and&#xD;&#xA;    SetPinFrequencySafe(PIN,frequency);&#xD;&#xA;&#xD;&#xA;The only limitation I have found so far is that it doesn't work with PWM pin D11. I have tested D3, D9 and D10 (they all worked fine), but I did not get around to testing D5 or D6. &#xD;&#xA;&#xD;&#xA;Good luck, I hope this helps.&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Code/PwmFrequency#.Uw7UNfSSxfg&#xD;&#xA;  [2]: http://arduino.cc/en/Tutorial/PWM#.Uw7P6fSSxfh&#xD;&#xA;  [3]: http://playground.arduino.cc/Main/TimerPWMCheatsheet#.Uw8UafSSxfg&#xD;&#xA;  [4]: http://forum.arduino.cc/index.php/topic,16612.0.html&#xD;&#xA;  [5]: http://forum.arduino.cc/index.php/topic,46949.0.html&#xD;&#xA;  [6]: http://forum.arduino.cc/index.php?topic=117425.30&#xD;&#xA;  [7]: http://www.atmel.com/ru/ru/Images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet.pdf&#xD;&#xA;  [8]: http://arduino.cc/en/Hacking/PinMapping168#.Uw7gxfSSxfg&#xD;&#xA;  [9]: http://code.google.com/p/arduino-pwm-frequency-library/downloads/list" />
  <row Id="1288" PostHistoryTypeId="5" PostId="482" RevisionGUID="f629590c-3574-4529-9231-6a7d3e7e8a29" CreationDate="2014-02-27T13:42:37.357" UserId="275" Comment="language improvements" Text="Though an emulator is quite an useful thing to debug code with that has no side effects, most real-world applications do include some circuitry besides an Arduino. If a microcontroller on an Arduino had an JTAG interface, it would be pretty straight-forward, but what if it's e.g. an Arduino Uno?" />
  <row Id="1289" PostHistoryTypeId="24" PostId="482" RevisionGUID="f629590c-3574-4529-9231-6a7d3e7e8a29" CreationDate="2014-02-27T13:42:37.357" Comment="Proposed by 275 approved by -1 edit id of 163" />
  <row Id="1290" PostHistoryTypeId="5" PostId="482" RevisionGUID="558b1ae1-6d1a-4b78-b1e2-2e5398da602a" CreationDate="2014-02-27T13:42:37.357" UserId="42" Comment="language improvements" Text="Though an emulator is quite useful for debugging code that has no side effects, most real-world applications include some circuitry besides the Arduino. If a microcontroller on an Arduino had a JTAG interface, it would be pretty straight-forward, but what if it's e.g. an Arduino Uno?" />
  <row Id="1292" PostHistoryTypeId="2" PostId="484" RevisionGUID="77f35ede-0b0c-4481-80b3-cc837c63edb9" CreationDate="2014-02-27T14:37:49.173" UserId="335" Text="I wan't to make a HID device (preferably keyboard) using an Arduino.&#xD;&#xA;&#xD;&#xA; - Method 1&#xD;&#xA;&#xD;&#xA;To me a preferred method would be to develop an actual Windows device driver so it's detected as a keyboard.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; - Method 2&#xD;&#xA;&#xD;&#xA;At the moment I can have different buttons pressed on the Arduino return different values via serial. Using my current functionality could I write some software layer that could take my serial data and have Windows read it as hid input? If so how would I go about achieving something like this?" />
  <row Id="1293" PostHistoryTypeId="1" PostId="484" RevisionGUID="77f35ede-0b0c-4481-80b3-cc837c63edb9" CreationDate="2014-02-27T14:37:49.173" UserId="335" Text="Arduino as USB HID" />
  <row Id="1294" PostHistoryTypeId="3" PostId="484" RevisionGUID="77f35ede-0b0c-4481-80b3-cc837c63edb9" CreationDate="2014-02-27T14:37:49.173" UserId="335" Text="&lt;serial&gt;" />
  <row Id="1295" PostHistoryTypeId="5" PostId="484" RevisionGUID="43ddb838-e773-4311-800a-3990877e6f66" CreationDate="2014-02-27T14:45:22.947" UserId="335" Comment="added 34 characters in body" Text="I wan't to make a HID device (preferably keyboard) using an Arduino.&#xD;&#xA;&#xD;&#xA; - Method 1&#xD;&#xA;&#xD;&#xA;To me a preferred method would be to develop an actual Windows device driver so it's detected as a keyboard.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; - Method 2&#xD;&#xA;&#xD;&#xA;At the moment I can have different buttons pressed on the Arduino return different values via serial. Using my current functionality could I write some software layer that could take my serial data and have Windows read it as hid input? If so how would I go about achieving something like this?&#xD;&#xA;&#xD;&#xA;NOTE: I'm using an Arduino Uno" />
  <row Id="1296" PostHistoryTypeId="5" PostId="482" RevisionGUID="ed5d447b-a750-461d-afd8-68742991cea4" CreationDate="2014-02-27T15:15:23.190" UserId="206" Comment="[Edit removed during grace period]" Text="Though an emulator is quite useful for debugging code that has no side effects, most real-world applications include some circuitry besides the Arduino. If a microcontroller on an Arduino had a JTAG interface, it would be pretty straight-forward, but what if it's e.g. an Arduino Uno?" />
  <row Id="1297" PostHistoryTypeId="5" PostId="16" RevisionGUID="cab0f0a1-6e8b-4730-80cf-8532bd2275aa" CreationDate="2014-02-27T15:25:05.967" UserId="65" Comment="Removed unnecessary stuff; &quot;Use more tags&quot; doesnt need to be mentioned." Text="The Arduino Uno is the most common and one of the newest Arduinos, based on the ATmega328 microcontroller. Use this tag when asking a question specific to an Uno, not just a general Arduino question." />
  <row Id="1298" PostHistoryTypeId="24" PostId="16" RevisionGUID="cab0f0a1-6e8b-4730-80cf-8532bd2275aa" CreationDate="2014-02-27T15:25:05.967" Comment="Proposed by 65 approved by 48 edit id of 164" />
  <row Id="1299" PostHistoryTypeId="5" PostId="434" RevisionGUID="dd3c2efd-7a95-404c-abd1-a42f8996458d" CreationDate="2014-02-27T15:25:14.483" UserId="65" Comment="Removed unnecessary tags; Minor edits" Text="I am new to the world of Arduinos but have a new project going with a MultiWii Flight controller. With the MultiWii comes a software for showing all data that is measured from the sensors (acceleration, velocity, roll, pitch, etc) which is nice but I would like to have/extract this data (call raw data or something) from all sensors (i.e. the data plotting everything, in numbers). Maybe it is the simplest thing to do, and I guess I have to set up some serial connection between the controller and tell it to send this data somehow but I do not know where to start so any guidance and help is appreciated." />
  <row Id="1300" PostHistoryTypeId="4" PostId="434" RevisionGUID="dd3c2efd-7a95-404c-abd1-a42f8996458d" CreationDate="2014-02-27T15:25:14.483" UserId="65" Comment="Removed unnecessary tags; Minor edits" Text="Extracting data from Arduino MultiWii Flight Controller" />
  <row Id="1301" PostHistoryTypeId="6" PostId="434" RevisionGUID="dd3c2efd-7a95-404c-abd1-a42f8996458d" CreationDate="2014-02-27T15:25:14.483" UserId="65" Comment="Removed unnecessary tags; Minor edits" Text="&lt;serial&gt;&lt;sensors&gt;" />
  <row Id="1302" PostHistoryTypeId="24" PostId="434" RevisionGUID="dd3c2efd-7a95-404c-abd1-a42f8996458d" CreationDate="2014-02-27T15:25:14.483" Comment="Proposed by 65 approved by 42, 48 edit id of 165" />
  <row Id="1303" PostHistoryTypeId="5" PostId="483" RevisionGUID="759c33ca-3c97-4ba3-989c-1eb88ed6a519" CreationDate="2014-02-27T15:26:49.693" UserId="304" Comment="changed the SetPinFrequency right down the end, I had the SAFE version" Text="I am playing on a Arduino UNO, you would have to compare the datasheets to determine differences. &#xD;&#xA;&#xD;&#xA;For my research on this answer I am looking at: &#xD;&#xA;&#xD;&#xA;- [Code/PwmFrequency (for a quick rundown)][1]&#xD;&#xA;- [Tutorial/PWM][2]&#xD;&#xA;- [TimerPWMCheatsheet (explains the prescaller and resulting frequencies)][3]&#xD;&#xA;- [varying the pwm frequency of timer0 and timer2][4]&#xD;&#xA;- [feature request: adjustable pwm frequencies][5]&#xD;&#xA;- [pwm frequency library (this is the one you REALLY want)][6]&#xD;&#xA;- and the datasheet for the [ATMega328][7]&#xD;&#xA;&#xD;&#xA;Also:&#xD;&#xA;&#xD;&#xA;- we know PWM pins are D3, D5, D6, D9, D10, D11&#xD;&#xA;- I am using D11 for this since I can attach my oscilloscope to the MOSI pin of the ISCP&#xD;&#xA;- D11 maps to PB3 (MOSI/OC2A/PCINT3) (see datasheet or [this cool gfx][8])&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;## Normal usage ##&#xD;&#xA;First, let's see what happens when we set an arbitrary PWM on pin 11&#xD;&#xA;&#xD;&#xA;    int DUTY = 25;&#xD;&#xA;    analogWrite(11, DUTY * 256 / 100);&#xD;&#xA;&#xD;&#xA;results in:&#xD;&#xA;&#xD;&#xA;1. Freq: ~487Hz&#xD;&#xA;2. Duty: ~25%&#xD;&#xA;3. Time: ~2.05ms&#xD;&#xA;&#xD;&#xA;This first point I will make is that with the given 490Hz the PWM duration is actually 2ms which seems to be close to what you want (you said between 1-2ms), maybe my misunderstanding there.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;## Playing with pre-scalers ##&#xD;&#xA;From several of the links posted above, you will see that you have different pre-scalers available depending on which timer you are using: eg.&#xD;&#xA;&#xD;&#xA;**Pins 5 and 6: controlled by Timer 0 in fast PWM mode (cycle length = 256)**&#xD;&#xA;&#xD;&#xA;    Setting 	Divisor 	Frequency&#xD;&#xA;    0x01 	 	1 	 	    62500&#xD;&#xA;    0x02  		8 	 	    7812.5&#xD;&#xA;    0x03  		64 	 	    976.5625&#xD;&#xA;    0x04 	 	256 	 	244.140625&#xD;&#xA;    0x05 	 	1024 	 	61.03515625&#xD;&#xA;&#xD;&#xA;    TCCR0B = TCCR0B &amp; 0b11111000 | &lt;setting&gt;;&#xD;&#xA;&#xD;&#xA;**Pins 9 and 10: controlled by timer 1 in phase-correct PWM mode (cycle length = 510)**&#xD;&#xA;&#xD;&#xA;    Setting 	Divisor 	Frequency&#xD;&#xA;    0x01 	 	1 	 	    31372.55&#xD;&#xA;    0x02 	 	8 	 	    3921.16&#xD;&#xA;    0x03  		64 	 	    490.20&#xD;&#xA;    0x04  		256 	 	122.55&#xD;&#xA;    0x05 	 	1024 	 	30.64&#xD;&#xA;&#xD;&#xA;    TCCR1B = TCCR1B &amp; 0b11111000 | &lt;setting&gt;;&#xD;&#xA;&#xD;&#xA;**Pins 11 and 3: controlled by timer 2 in phase-correct PWM mode (cycle length = 510)**&#xD;&#xA;&#xD;&#xA;    Setting 	Divisor 	Frequency&#xD;&#xA;    0x01 	 	1  	    	31372.55&#xD;&#xA;    0x02 	 	8 	 	    3921.16&#xD;&#xA;    0x03  		32  		980.39&#xD;&#xA;    0x04 	 	64 	 	    490.20&#xD;&#xA;    0x05 	 	128  		245.10&#xD;&#xA;    0x06  		256  		122.55&#xD;&#xA;    0x07 	 	1024  		30.64&#xD;&#xA;&#xD;&#xA;    TCCR2B = TCCR2B &amp; 0b11111000 | &lt;setting&gt;;&#xD;&#xA;     &#xD;&#xA;    (All frequencies are in Hz and assume a 16000000 Hz system clock.)&#xD;&#xA;&#xD;&#xA;These are relatively simple to setup and use (the setting is at the bottom of each of the above code blocks), but you have to be mindful of playing with the pre-scaler of timer0 (which controls `millis()` and `delay()`). So if you have a choice, steer clear of timer0, or pwm pins 5 and 6.&#xD;&#xA;&#xD;&#xA;Example of using just the inbuilt pre-scalers without any additional libraries:&#xD;&#xA;&#xD;&#xA;    #define PIN 11&#xD;&#xA;    void setup(){&#xD;&#xA;        pinMode(PIN,OUTPUT);  // not absolutely required&#xD;&#xA;        int DUTY = 20;&#xD;&#xA;        TCCR2B = TCCR2B &amp; 0b11111000 | 6;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      static long counter = 0;&#xD;&#xA;      if(millis()%10==0){&#xD;&#xA;          counter++;&#xD;&#xA;          analogWrite(PIN, counter%255);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I know you can manipulate the frequency better than that, and I have been playing with this for hours and then I finally stumbled upon the final link (which believe it or not, I found via YouTube!).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;##Using an External Library##&#xD;&#xA;&#xD;&#xA;To use the PWM library you will need to download it from [Google Code][9], save/import/get it into your library folder, and restart the IDE. Once you do that, you can explicitly set the frequency (within limits, 333Hz is within those limits), and you should be set. &#xD;&#xA;&#xD;&#xA;Code example:&#xD;&#xA;&#xD;&#xA;    #include &lt;PWM.h&gt;&#xD;&#xA;    int32_t frequency = 333;&#xD;&#xA;    &#xD;&#xA;    #define PIN 10&#xD;&#xA;&#xD;&#xA;    void setup(){&#xD;&#xA;        pinMode(PIN,OUTPUT);&#xD;&#xA;        int DUTY = 20;&#xD;&#xA;        InitTimersSafe();                    // won't touch timer0&#xD;&#xA;        SetPinFrequencySafe(PIN,frequency);  // again, not timer0&#xD;&#xA;        pwmWrite(PIN, DUTY * 256 / 100);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;There is even a `pwmWriteHR` which allows for higher resolution, but that does not work with timer2 (which is only an 8-bit timer). &#xD;&#xA;&#xD;&#xA;The matching, non-safe (ie initialises and uses timer0 as well) functions are:&#xD;&#xA;&#xD;&#xA;    InitTimer();  // and&#xD;&#xA;    SetPinFrequency(PIN,frequency);&#xD;&#xA;&#xD;&#xA;The only limitation I have found so far is that it doesn't work with PWM pin D11. I have tested D3, D9 and D10 (they all worked fine), but I did not get around to testing D5 or D6. &#xD;&#xA;&#xD;&#xA;Good luck, I hope this helps.&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Code/PwmFrequency#.Uw7UNfSSxfg&#xD;&#xA;  [2]: http://arduino.cc/en/Tutorial/PWM#.Uw7P6fSSxfh&#xD;&#xA;  [3]: http://playground.arduino.cc/Main/TimerPWMCheatsheet#.Uw8UafSSxfg&#xD;&#xA;  [4]: http://forum.arduino.cc/index.php/topic,16612.0.html&#xD;&#xA;  [5]: http://forum.arduino.cc/index.php/topic,46949.0.html&#xD;&#xA;  [6]: http://forum.arduino.cc/index.php?topic=117425.30&#xD;&#xA;  [7]: http://www.atmel.com/ru/ru/Images/Atmel-8271-8-bit-AVR-Microcontroller-ATmega48A-48PA-88A-88PA-168A-168PA-328-328P_datasheet.pdf&#xD;&#xA;  [8]: http://arduino.cc/en/Hacking/PinMapping168#.Uw7gxfSSxfg&#xD;&#xA;  [9]: http://code.google.com/p/arduino-pwm-frequency-library/downloads/list" />
  <row Id="1304" PostHistoryTypeId="5" PostId="212" RevisionGUID="c6c1acf8-5572-4d6c-8116-a36cac18a64f" CreationDate="2014-02-27T15:51:01.533" UserId="304" Comment="It's not the bootloader that determines the PWM frequencies, it's the prescaler. And fixed the wording towards the end." Text="Those aren't the only frequencies available for the PWM signals. However, they are the frequencies as determined by the applied prescaler (which you can readily change as detailed below).&#xD;&#xA;&#xD;&#xA;Each of the 3 pairs of PWM pins is tied to one timer, each of which has its own base frequency, as follows:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 are paired on timer0, with base frequency of 62500Hz&#xD;&#xA;* Pins 9 and 10 are paired on timer1, with base frequency of 31250Hz&#xD;&#xA;* Pins 3 and 11 are paired on timer2, with base frequency of 31250Hz&#xD;&#xA;&#xD;&#xA;Then each set of pins have a number of prescaler values that can be chosen, that will divide the base frequency of that pair of pins. The prescaler values available are:&#xD;&#xA;&#xD;&#xA;* Pins 5 and 6 have prescaler values of 1, 8, 64, 256, and 1024&#xD;&#xA;* Pins 9 and 10 have prescaler values of 1, 8, 64, 256, and 1024&#xD;&#xA;* Pins 3 and 11 have prescaler values of 1, 8, 32, 64, 128, 256, and 1024&#xD;&#xA;&#xD;&#xA;The different combinations yield different frequencies in a given PWM pin. Notice that timer 2 (tied to pins 3 and 11) have more prescaler values available, resulting in more frequencies available.&#xD;&#xA;&#xD;&#xA;Now, why timer 2 is different, that's a separate question.&#xD;&#xA;&#xD;&#xA;Edit: Here's a list of possible PWM frequencies per pin (from [this article](http://arduino-info.wikispaces.com/Arduino-PWM-Frequency)):&#xD;&#xA;&#xD;&#xA;&gt; For pins 6 and 5 (OC0A and OC0B):&#xD;&#xA;&#xD;&#xA;&gt; * If TCCR0B = xxxxx001, frequency is 64kHz&#xD;&#xA;&gt; * If TCCR0B = xxxxx010, frequency is 8 kHz&#xD;&#xA;&gt; * If TCCR0B = xxxxx011, frequency is 1kHz (this is the default from the Diecimila bootloader)&#xD;&#xA;&gt; * If TCCR0B = xxxxx100, frequency is 250Hz&#xD;&#xA;&gt; * If TCCR0B = xxxxx101, frequency is 62.5 Hz&#xD;&#xA; &#xD;&#xA;&gt; For pins 9, 10, 11 and 3 (OC1A, OC1B, OC2A, OC2B):&#xD;&#xA;&#xD;&#xA;&gt; * If TCCRnB = xxxxx001, frequency is 32kHz&#xD;&#xA;&gt; * If TCCRnB = xxxxx010, frequency is 4 kHz&#xD;&#xA;&gt; * If TCCRnB = xxxxx011, frequency is 500Hz (this is the default from the Diecimila bootloader)&#xD;&#xA;&gt; * If TCCRnB = xxxxx100, frequency is 125Hz&#xD;&#xA;&gt; * If TCCRnB = xxxxx101, frequency is 31.25 Hz &#xD;&#xA;&#xD;&#xA;`TCCRnB` is where you set the prescaler bits for timer `n`, replacing `n` by 0, 1 or 2, depending on the timer you want to set. If you are still unsure about bitwise operations, read this [bit math tutorial](http://playground.arduino.cc/Code/BitMath).&#xD;&#xA;&#xD;&#xA;My sources:&#xD;&#xA;&#xD;&#xA;* http://playground.arduino.cc/Code/PwmFrequency&#xD;&#xA;* http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM&#xD;&#xA;* http://arduino.cc/en/Tutorial/PWM&#xD;&#xA;* http://arduino-info.wikispaces.com/Arduino-PWM-Frequency&#xD;&#xA;&#xD;&#xA;Note that there seems to be divergence in those sources about whether pins 9 and 10 have the same behavior as 5 and 6 or 3 and 11, but you get the idea anyway. I'm reading the datashet to try and figure out which is correct, or whether this is a difference between boards.&#xD;&#xA;" />
  <row Id="1305" PostHistoryTypeId="24" PostId="212" RevisionGUID="c6c1acf8-5572-4d6c-8116-a36cac18a64f" CreationDate="2014-02-27T15:51:01.533" Comment="Proposed by 304 approved by 46 edit id of 166" />
  <row Id="1306" PostHistoryTypeId="2" PostId="485" RevisionGUID="7c799ff4-3d0b-4f94-ad8c-d3838bcbaad6" CreationDate="2014-02-27T16:51:23.440" UserId="336" Text="I'm creating a weather station / environmental datalogger and am saving my data to a SD card Breakout. The SD card works fine but I would like to name the files I am saving on it after the date when the readings were taken.I've tryed multiple things but I can't work out how to combine the date from my RTC and put them in a file name. I've tryed this:&#xD;&#xA;&#xD;&#xA;    dataFile = SD.open(String(now.day()) + &quot;-&quot; + String(now.month()) + &quot;-&quot; + String(now.year()) + &quot;.csv,FILE_WRITE);&#xD;&#xA;But this gives me an error -&#xD;&#xA;&#xD;&#xA;    char dateName[13] = {String(now.day()) + &quot;-&quot; + String(now.month()) + &quot;-&quot; + String(now.year()) + &quot;.csv&quot;};&#xD;&#xA; dataFile = SD.open(dateName,FILE_WRITE);&#xD;&#xA;But this gives me this error:&#xD;&#xA;&#xD;&#xA;     cannot convert 'StringSumHelper' to 'char' in initialization&#xD;&#xA;Help! How do I do this? " />
  <row Id="1307" PostHistoryTypeId="1" PostId="485" RevisionGUID="7c799ff4-3d0b-4f94-ad8c-d3838bcbaad6" CreationDate="2014-02-27T16:51:23.440" UserId="336" Text="Combining Strings into a datestamp" />
  <row Id="1308" PostHistoryTypeId="3" PostId="485" RevisionGUID="7c799ff4-3d0b-4f94-ad8c-d3838bcbaad6" CreationDate="2014-02-27T16:51:23.440" UserId="336" Text="&lt;sd-card&gt;&lt;data&gt;" />
  <row Id="1309" PostHistoryTypeId="5" PostId="485" RevisionGUID="7c2231a2-b4a4-4c1c-ba49-dd321a9b4fc7" CreationDate="2014-02-27T16:53:23.810" UserId="42" Comment="Fixed formatting" Text="I'm creating a weather station / environmental datalogger and am saving my data to a SD card Breakout. The SD card works fine but I would like to name the files I am saving on it after the date when the readings were taken.I've tryed multiple things but I can't work out how to combine the date from my RTC and put them in a file name. I've tryed this:&#xD;&#xA;&#xD;&#xA;    dataFile = SD.open(String(now.day()) + &quot;-&quot; + String(now.month()) + &quot;-&quot; + String(now.year()) + &quot;.csv,FILE_WRITE);&#xD;&#xA;But this gives me an error -&#xD;&#xA;&#xD;&#xA;    char dateName[13] = {String(now.day()) + &quot;-&quot; + String(now.month()) + &quot;-&quot; + String(now.year()) + &quot;.csv&quot;};&#xD;&#xA;    dataFile = SD.open(dateName,FILE_WRITE);&#xD;&#xA;&#xD;&#xA;But this gives me this error:&#xD;&#xA;&#xD;&#xA;     cannot convert 'StringSumHelper' to 'char' in initialization&#xD;&#xA;&#xD;&#xA;Help! How do I do this? " />
  <row Id="1310" PostHistoryTypeId="5" PostId="485" RevisionGUID="489c6253-ef70-4d22-a7ec-7ceeaa81de42" CreationDate="2014-02-27T16:56:05.057" UserId="336" Comment="added 1 characters in body" Text="I'm creating a weather station / environmental datalogger and am saving my data to a SD card Breakout. The SD card works fine but I would like to name the files I am saving on it after the date when the readings were taken.I've tryed multiple things but I can't work out how to combine the date from my RTC and put them in a file name. I've tryed this:&#xD;&#xA;&#xD;&#xA;    dataFile = SD.open(String(now.day()) + &quot;-&quot; + String(now.month()) + &quot;-&quot; + String(now.year()) + &quot;.csv&quot;,FILE_WRITE);&#xD;&#xA;But this gives me an error -&#xD;&#xA;&#xD;&#xA;    char dateName[13] = {String(now.day()) + &quot;-&quot; + String(now.month()) + &quot;-&quot; + String(now.year()) + &quot;.csv&quot;};&#xD;&#xA;    dataFile = SD.open(dateName,FILE_WRITE);&#xD;&#xA;&#xD;&#xA;But this gives me this error:&#xD;&#xA;&#xD;&#xA;     cannot convert 'StringSumHelper' to 'char' in initialization&#xD;&#xA;&#xD;&#xA;Help! How do I do this? " />
  <row Id="1311" PostHistoryTypeId="2" PostId="486" RevisionGUID="f3939506-a812-4221-8ee7-7be07ffec5ba" CreationDate="2014-02-27T17:09:34.817" UserId="42" Text="From what I can see in the SD library code, the `open()` method isn't designed to accept a `String` object as a parameter. It only wants a plain old [C-style string][1] (which means a `char` array). That explains why your first example doesn't work -- it's trying to pass a `String` object.&#xD;&#xA;&#xD;&#xA;The second example unfortunately is invalid C++. You simply can't initialise an array like that. What you want to do instead is to build the `String` object, then extract the characters out using `String::toCharArray()`.&#xD;&#xA;&#xD;&#xA;Something like this should work:&#xD;&#xA;&#xD;&#xA;    String filename = String(now.day()) + &quot;-&quot; + String(now.month()) + &quot;-&quot; + String(now.year()) + &quot;.csv&quot;;&#xD;&#xA;    char str[16] = {0};&#xD;&#xA;    filename.toCharArray(str, 16);&#xD;&#xA;    dataFile = SD.open(str, FILE_WRITE);&#xD;&#xA;&#xD;&#xA;I'm not sure what your `now.year()` returns; i.e. if that's a 2 digit or 4 digit year. I've assumed 4 digits, so I've made the `char` array big enough for 15 characters in total, plus an extra null terminator (which is essential for C-style strings).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/String" />
  <row Id="1312" PostHistoryTypeId="2" PostId="487" RevisionGUID="30de0a5e-e828-44dd-9069-4c551434c58c" CreationDate="2014-02-27T17:09:36.373" UserId="65" Text="You need to break the initialization into two lines and use [toCharArray()][1] as shown:&#xD;&#xA;&#xD;&#xA;&lt;!-- language: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;    char dateName[13];&#xD;&#xA;    String(String(now.day()) + &quot;-&quot; + String(now.month()) + &quot;-&quot; + String(now.year()) + &quot;.csv&quot;).toCharArray(dateName, 13);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Then, you can move ahead with opening the file.&#xD;&#xA;&#xD;&#xA;The problem you are seeing is quite literally what the error message says. An initialization of a character array requires a character array. It cannot be initialised with a string object.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/StringToCharArray" />
  <row Id="1313" PostHistoryTypeId="5" PostId="487" RevisionGUID="e885cd3d-eb9b-479f-859e-2e4359e8afd9" CreationDate="2014-02-27T17:15:05.140" UserId="65" Comment="added 21 characters in body" Text="In your second case, you need to break the initialization into two lines and use [toCharArray()][1] as shown:&#xD;&#xA;&#xD;&#xA;&lt;!-- language: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;    char dateName[13];&#xD;&#xA;    String(String(now.day()) + &quot;-&quot; + String(now.month()) + &quot;-&quot; + String(now.year()) + &quot;.csv&quot;).toCharArray(dateName, 13);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Then, you can move ahead with opening the file.&#xD;&#xA;&#xD;&#xA;The problem you are seeing is quite literally what the error message says. An initialization of a character array requires a character array. It cannot be initialised with a string object.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/StringToCharArray" />
  <row Id="1314" PostHistoryTypeId="2" PostId="488" RevisionGUID="bf2e1c46-d297-4481-9ef0-706d7825d4da" CreationDate="2014-02-27T17:27:04.717" UserId="323" Text="I have an espresso machine that gets its water from one of those 5 gallon blue water bottles (I would plumb it, but our water here is WAAAAY too hard).&#xD;&#xA;&#xD;&#xA;If I ever accidentally let the bottle run out of water, the rotary pump in the espresso machine will be ruined, which would be a costly mistake.&#xD;&#xA;&#xD;&#xA;I know that I can install some sort of magnetic float sensor inside the water bottle, but since I have to change it out once every few weeks, having another thing inside the bottle would make changing it out harder, and microbial contamination more likely.  The pump that pumps water out of the bottle forms a tight seal at the lid, and anything running under it or through it would compromise that seal.&#xD;&#xA;&#xD;&#xA;Is there something I could use to detect if the water level is low from the outside of the bottle?  Like a laser sensor?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1315" PostHistoryTypeId="1" PostId="488" RevisionGUID="bf2e1c46-d297-4481-9ef0-706d7825d4da" CreationDate="2014-02-27T17:27:04.717" UserId="323" Text="Best way to determine if a 5 gallon water jug is getting empty" />
  <row Id="1316" PostHistoryTypeId="3" PostId="488" RevisionGUID="bf2e1c46-d297-4481-9ef0-706d7825d4da" CreationDate="2014-02-27T17:27:04.717" UserId="323" Text="&lt;sensors&gt;" />
  <row Id="1317" PostHistoryTypeId="2" PostId="489" RevisionGUID="c2162c33-cfa3-403f-9e51-37bdd8c2c2f2" CreationDate="2014-02-27T19:39:43.403" UserId="343" Text="I am making an interface project that, when plugged into a computer, shows up as both usb flash storage and can type like a keyboard when some physical buttons on the board are pressed. &#xD;&#xA;&#xD;&#xA;I have seen projects that do one or the other, but not both at the same time. &#xD;&#xA;&#xD;&#xA;I have gotten it to work using a usb hub and two chips that are sharing the same storage (since I want the hot-key buttons to type out information stored in the flash drive side as well), with one acting like a HID and one acting as usb storage, but this has a few problems. First, it feels redundant. Second it's difficult to program since every time I plug the mess in it randomly assigns a name to each chip with no easy way of telling which to send the HID code to and with to send the USB Drive code to. I have to plug them in one at a time which wont work once this project is all on the same board. The last problem is the buttons work inconsistently since, im assuming, the two chips are not doing a nice job of sharing access to the text file it's trying to read for the text to 'type out' on the computer.&#xD;&#xA;&#xD;&#xA;Is there a nicer way of doing this that uses one arduino acting in both roles accessing the one flash storage? Thanks!&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1318" PostHistoryTypeId="1" PostId="489" RevisionGUID="c2162c33-cfa3-403f-9e51-37bdd8c2c2f2" CreationDate="2014-02-27T19:39:43.403" UserId="343" Text="Make an Arduino board act as both a usb storage device and a keyboard?" />
  <row Id="1319" PostHistoryTypeId="3" PostId="489" RevisionGUID="c2162c33-cfa3-403f-9e51-37bdd8c2c2f2" CreationDate="2014-02-27T19:39:43.403" UserId="343" Text="&lt;serial&gt;&lt;programming&gt;" />
  <row Id="1320" PostHistoryTypeId="2" PostId="490" RevisionGUID="a7c3c85a-98b1-4081-a053-6e250e59666f" CreationDate="2014-02-27T19:51:07.663" UserId="146" Text="I think you want a [&quot;liquid level switch&quot;][1], possibly also known as a &quot;fluid switch&quot; ... I realize this may not satisfy your requirements, but this is one way to solve the problem for &gt;$10.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.mouser.com/ProductDetail/Hamlin/59630-1-T-02-A/?qs=sGAEpiMZZMun2xR%252b%252bFUzeBXr8YNXGDFf8m4HoboDx0M=&#xD;&#xA;  " />
  <row Id="1321" PostHistoryTypeId="5" PostId="490" RevisionGUID="c1160c68-474d-419b-ae1a-cd4865014b97" CreationDate="2014-02-27T19:57:48.840" UserId="146" Comment="added 390 characters in body" Text="I think you want a [&quot;liquid level switch&quot;][1], possibly also known as a &quot;fluid switch&quot; ... I realize this may not satisfy your requirements, but this is one way to solve the problem for &gt;$10. I would probably hack something together that would put this sensor inline to the bottle. it's probably too hacky, but you could have a disc of plywood the same diameter as the water bottle, with a pipe fitting in the middle where you could mount the switch, so that the water bottle routes water through it so that when it runs low, it would trigger the switch before it runs to the pump.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.mouser.com/ProductDetail/Hamlin/59630-1-T-02-A/?qs=sGAEpiMZZMun2xR%252b%252bFUzeBXr8YNXGDFf8m4HoboDx0M=&#xD;&#xA;  " />
  <row Id="1322" PostHistoryTypeId="5" PostId="490" RevisionGUID="df77e058-76c2-4f1e-8023-c767aba999b7" CreationDate="2014-02-27T20:05:07.483" UserId="146" Comment="added 71 characters in body" Text="I think you want a [&quot;liquid level switch&quot;][2], possibly also known as a &quot;fluid switch&quot; ... I realize this may not satisfy your requirements, but this is one way to solve the problem for &gt;$10. I would probably hack something together that would put this sensor inline to the bottle. it's probably too hacky, but you could have a disc of plywood the same diameter as the water bottle, with a pipe fitting in the middle where you could mount the switch, so that the water bottle routes water through it so that when it runs low, it would trigger the switch before it runs to the pump.&#xD;&#xA;&#xD;&#xA;![inline liquid level switch][1]&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/Y2s79.png&#xD;&#xA;  [2]: http://www.mouser.com/ProductDetail/Hamlin/59630-1-T-02-A/?qs=sGAEpiMZZMun2xR%252b%252bFUzeBXr8YNXGDFf8m4HoboDx0M=" />
  <row Id="1323" PostHistoryTypeId="2" PostId="491" RevisionGUID="b3db0a7a-d456-4add-b365-5e3b42dbc945" CreationDate="2014-02-27T20:08:46.467" UserId="6" Text="It seems to me that if you have pumped out 4.9 gallons you know the jug is close to empty. If an inline flow meter between the pump and the espessso maker is out due to water contact, then maybe you know that an espresso shot takes x amount of water, and once one has called for y shots (and calculated x times y) one is in the danger zone of running out of water? " />
  <row Id="1324" PostHistoryTypeId="2" PostId="492" RevisionGUID="1050656d-e343-4ac1-a820-eec68bc38ab6" CreationDate="2014-02-27T20:54:39.333" UserId="225" Text="**Using a Force Sensor to Measure a Quantity of Water**&#xD;&#xA;&#xD;&#xA;To satisfy your requirement of having the sensor on the exterior of the water container, I would recommend using a force sensor to weigh the bottle at set intervals. A force sensor, such as the FlexiForce A401, is a type of resistor that changes resistance in response to the amount of force applied. While not as accurate as a scale, it should provide enough accuracy (+-3% according to the [datasheet][1]) for the application described.&#xD;&#xA;&#xD;&#xA;The basic procedure would be to hook up the force sensor to the Arduino and first measure the resistance with an empty bottle, then measure again with a full bottle. This will give you an idea of the force that your specific platform is actually applying to the sensor, and you can then fine tune the voltage (as per the datasheet) for your installation. &#xD;&#xA;&#xD;&#xA;A basic tutorial using a similar force sensor with an Arduino can be found [here][2].&#xD;&#xA;&#xD;&#xA;**Other Possibilities**&#xD;&#xA;&#xD;&#xA;  - [Optical Liquid Level Sensors][3]&#xD;&#xA;  - [Ultrasonic Level Monitoring][4]&#xD;&#xA;  - Thermistors and Heating Coils at various levels to Measure the Thermal Mass (i.e. water) near the Sensor&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Pressure/A401-force-sensor.pdf&#xD;&#xA;  [2]: http://bildr.org/2012/11/flexiforce-arduino/&#xD;&#xA;  [3]: http://www.fluidswitch.com/pages/Optical-Liquid-Level-Sensors.htm&#xD;&#xA;  [4]: http://www.cigrjournal.org/index.php/Ejounral/article/viewFile/2343/1823" />
  <row Id="1325" PostHistoryTypeId="5" PostId="143" RevisionGUID="bb05588c-02a0-4f8e-8467-77261593445d" CreationDate="2014-02-27T21:40:10.170" UserId="87" Comment="added 14 characters in body" Text="Before you start to mess with a computer there are basic guidelines to be aware of, such as turn the power off and watch out for static electricity. What guidelines should I be aware of when I work with an Arduino board if I don't want to harm neither myself nor the board. The three kind of activity that requires touching the Arduino and what I'm asking about:&#xD;&#xA;&#xD;&#xA;- Setting up wire, component layout or breadboard.&#xD;&#xA;- Debugging a running setup.&#xD;&#xA;- Moving, mounting up the board somewhere." />
  <row Id="1326" PostHistoryTypeId="2" PostId="493" RevisionGUID="fe62f8a4-b92f-4ac4-888f-868395b06997" CreationDate="2014-02-27T23:29:52.217" UserId="306" Text="I'm trying to parse many variables into a URL so that I can update a website through a simple HTTP API with sensor data. After talking to a buddy of mine, he suggested going with the code below. &#xD;&#xA;&#xD;&#xA;When I put this in, the Arduino Yun boots up. I see the L13 red LED turn on, but then it hoses. When I comment out the `sprintf();` line, everything works fine - except no URL is parsed.&#xD;&#xA;&#xD;&#xA;I've tried to debug to the best of my ability and am looking for thoughts on what may be happening. &#xD;&#xA;&#xD;&#xA;I'm not sure how much code to post without posting the whole 130 line sketch, so I'm just dumping the parts from the `loop` that is trying to piece together the URL.&#xD;&#xA;&#xD;&#xA;          char url[512];&#xD;&#xA;          url[0]='\0';&#xD;&#xA;          float humid, baro, windspeed, raingauge;&#xD;&#xA;          int winddir;&#xD;&#xA;          Serial.print(&quot;humid: &quot;);&#xD;&#xA;          Serial.println(humid);&#xD;&#xA;            Serial.print(&quot;baro: &quot;);&#xD;&#xA;          Serial.println(baro);&#xD;&#xA;            Serial.print(&quot;windspeed: &quot;);&#xD;&#xA;          Serial.println(windspeed);&#xD;&#xA;            Serial.print(&quot;raingauge: &quot;);&#xD;&#xA;          Serial.println(raingauge);&#xD;&#xA;            Serial.print(&quot;winddir: &quot;);&#xD;&#xA;          Serial.println(winddir);&#xD;&#xA;     //sprintf(url,&quot;http://weatherstation.wunderground.com/weatherstation/updateweatherstation.php?ID=123456&amp;PASSWORD=xxxxxx&amp;dateutc=%s&amp;temp=%2.2f&amp;humidity=%2.2f&amp;baromin=%f&amp;winddir=%d&amp;windspeedmph=%3.2f&amp;rainin=%3.2f&amp;softwaretype=Custom%%20Arduino&amp;action=updateraw&quot;,utcDateString,Thermistor(analogRead(0)),humid,baro,winddir,windspeed,raingauge);&#xD;&#xA;            Serial.print(&quot;url: &quot;);&#xD;&#xA;          Serial.println(url);&#xD;&#xA;&#xD;&#xA;    double Thermistor(int RawADC) {&#xD;&#xA;      double Temp;&#xD;&#xA;      Temp = log(11100.0/((1024.0/RawADC-1)));  // Was 10000... Manually dialed down to increase accuracy. 9400 is a good value. Changing again to match wunderground&#xD;&#xA;      Temp = 1 / (0.001129148 + (0.000234125 + (0.0000000876741 * Temp * Temp ))* Temp );&#xD;&#xA;      Temp = Temp - 273.15;            // Convert Kelvin to Celcius&#xD;&#xA;      Temp = (Temp * 9.0)/ 5.0 + 32.0; // Convert Celcius to Fahrenheit&#xD;&#xA;      return Temp;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here's the output from those Serial.prints();&#xD;&#xA;&#xD;&#xA;    humid: 0.00&#xD;&#xA;    baro: 0.00&#xD;&#xA;    windspeed: 0.00&#xD;&#xA;    raingauge: 0.00&#xD;&#xA;    winddir: 0&#xD;&#xA;    url:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I'm not sure how else to debug this because when I uncomment `sprintf();` the Yun locks up and I have to press the `32U4 Reset` button and power cycle the Arduino to get it to work again." />
  <row Id="1327" PostHistoryTypeId="1" PostId="493" RevisionGUID="fe62f8a4-b92f-4ac4-888f-868395b06997" CreationDate="2014-02-27T23:29:52.217" UserId="306" Text="sprintf() locks up Arduino Yun" />
  <row Id="1328" PostHistoryTypeId="3" PostId="493" RevisionGUID="fe62f8a4-b92f-4ac4-888f-868395b06997" CreationDate="2014-02-27T23:29:52.217" UserId="306" Text="&lt;sketch&gt;&lt;yun&gt;" />
  <row Id="1329" PostHistoryTypeId="2" PostId="494" RevisionGUID="67fc5a56-0058-4d90-9158-c9a0544db518" CreationDate="2014-02-27T23:55:27.287" UserId="347" Text="Another option is to measure the current going into the pump; when it runs dry, the current goes up, which generates the heat that fries the pump.&#xD;&#xA;&#xD;&#xA;Or measure the temperature on the pump, but measuring the current will detect the beginning of the pump's meltdown, while the temperature may only detect the middle or end of the meltdown.  :-(&#xD;&#xA;&#xD;&#xA;Or install a current limiter or breaker inline with the pump, just in case everything else fails.  :-)" />
  <row Id="1330" PostHistoryTypeId="5" PostId="493" RevisionGUID="350624f5-8ed1-45fe-b89f-7714bfcbd0a3" CreationDate="2014-02-28T00:24:42.520" UserId="306" Comment="added 255 characters in body" Text="I'm trying to parse many variables into a URL so that I can update a website through a simple HTTP API with sensor data. After talking to a buddy of mine, he suggested going with the code below. &#xD;&#xA;&#xD;&#xA;When I put this in, the Arduino Yun boots up. I see the L13 red LED turn on, but then it hoses. When I comment out the `sprintf();` line, everything works fine - except no URL is parsed.&#xD;&#xA;&#xD;&#xA;I've tried to debug to the best of my ability and am looking for thoughts on what may be happening. &#xD;&#xA;&#xD;&#xA;I'm not sure how much code to post without posting the whole 130 line sketch, so I'm just dumping the parts from the `loop` that is trying to piece together the URL.&#xD;&#xA;&#xD;&#xA;      // Get update time&#xD;&#xA;      Process date;&#xD;&#xA;      date.runShellCommand(&quot;date --utc \&quot;+%Y-%m-%d%%20%H:%M:%S\&quot;&quot;);&#xD;&#xA;      String utcDateString = &quot;&quot;;&#xD;&#xA;      while (date.available()) {&#xD;&#xA;        char d = date.read();&#xD;&#xA;        utcDateString += d;&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;          char url[512];&#xD;&#xA;          url[0]='\0';&#xD;&#xA;          float humid, baro, windspeed, raingauge;&#xD;&#xA;          int winddir;&#xD;&#xA;          Serial.print(&quot;humid: &quot;);&#xD;&#xA;          Serial.println(humid);&#xD;&#xA;            Serial.print(&quot;baro: &quot;);&#xD;&#xA;          Serial.println(baro);&#xD;&#xA;            Serial.print(&quot;windspeed: &quot;);&#xD;&#xA;          Serial.println(windspeed);&#xD;&#xA;            Serial.print(&quot;raingauge: &quot;);&#xD;&#xA;          Serial.println(raingauge);&#xD;&#xA;            Serial.print(&quot;winddir: &quot;);&#xD;&#xA;          Serial.println(winddir);&#xD;&#xA;     //sprintf(url,&quot;http://weatherstation.wunderground.com/weatherstation/updateweatherstation.php?ID=123456&amp;PASSWORD=xxxxxx&amp;dateutc=%s&amp;temp=%2.2f&amp;humidity=%2.2f&amp;baromin=%f&amp;winddir=%d&amp;windspeedmph=%3.2f&amp;rainin=%3.2f&amp;softwaretype=Custom%%20Arduino&amp;action=updateraw&quot;,utcDateString,Thermistor(analogRead(0)),humid,baro,winddir,windspeed,raingauge);&#xD;&#xA;            Serial.print(&quot;url: &quot;);&#xD;&#xA;          Serial.println(url);&#xD;&#xA;&#xD;&#xA;    double Thermistor(int RawADC) {&#xD;&#xA;      double Temp;&#xD;&#xA;      Temp = log(11100.0/((1024.0/RawADC-1)));  // Was 10000... Manually dialed down to increase accuracy. 9400 is a good value. Changing again to match wunderground&#xD;&#xA;      Temp = 1 / (0.001129148 + (0.000234125 + (0.0000000876741 * Temp * Temp ))* Temp );&#xD;&#xA;      Temp = Temp - 273.15;            // Convert Kelvin to Celcius&#xD;&#xA;      Temp = (Temp * 9.0)/ 5.0 + 32.0; // Convert Celcius to Fahrenheit&#xD;&#xA;      return Temp;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here's the output from those Serial.prints();&#xD;&#xA;&#xD;&#xA;    humid: 0.00&#xD;&#xA;    baro: 0.00&#xD;&#xA;    windspeed: 0.00&#xD;&#xA;    raingauge: 0.00&#xD;&#xA;    winddir: 0&#xD;&#xA;    url:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I'm not sure how else to debug this because when I uncomment `sprintf();` the Yun locks up and I have to press the `32U4 Reset` button and power cycle the Arduino to get it to work again." />
  <row Id="1331" PostHistoryTypeId="2" PostId="495" RevisionGUID="8e0b19a8-6237-4b56-8df3-5d8c56aa77c9" CreationDate="2014-02-28T00:54:04.997" UserId="348" Text="Looks like %f isn't wired up for performance reasons.  You can convert floats to strings first using dtostrf()." />
  <row Id="1332" PostHistoryTypeId="5" PostId="495" RevisionGUID="1ff8687f-b424-45da-9931-f745ef21c25b" CreationDate="2014-02-28T01:02:31.777" UserId="11" Comment="added 4 characters in body" Text="Looks like `%f` isn't wired up for performance reasons.  You can convert floats to strings first using `dtostrf()`." />
  <row Id="1333" PostHistoryTypeId="2" PostId="496" RevisionGUID="6aacbfc1-3d5f-41b3-b9b4-3cb09b5f73fb" CreationDate="2014-02-28T01:38:09.093" UserId="350" Text="Honestly - you're overthinking this.&#xD;&#xA;&#xD;&#xA;A dipstick or a float would be all you need.  Once the water level drops below your minimum, the float moves down with the water level and pulls a switch or allows a LDR to see through a hole.  Then do something like turn on a light.&#xD;&#xA;&#xD;&#xA;Less is more." />
  <row Id="1334" PostHistoryTypeId="2" PostId="497" RevisionGUID="d29e118b-a443-4b0c-8253-c46096834225" CreationDate="2014-02-28T01:44:54.170" UserId="349" Text="The Arduino Uno uses the Atmel Atmega328p microcontroller, which only has one debug option, DebugWire.  There are a few tools that can work with it, but the least expensive and most commonly available is the [AVR Dragon][1].&#xD;&#xA;&#xD;&#xA;You can use AVR Studio 6 for this.  You can use the `.elf` file file produced during the Arduino build process directly, but setting up the debugger is a little easier if you port the Arduino program to the AVR Studio.  It's not difficult, but there are a lot of little pieces to deal with.  There are guides online to help you through this.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/tools/AVRDRAGON.aspx" />
  <row Id="1335" PostHistoryTypeId="2" PostId="498" RevisionGUID="66fa6db7-9def-4312-8219-98d2fe109ebc" CreationDate="2014-02-28T01:59:43.327" UserId="349" Text="You're looking to create a USB composite device.  I don't see any examples within the arduino community, but I don't see a reason why you couldn't [use the 16u2 as a composite device][1], it'll just require more effort than you'd normally put into an arduino project.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.google.com/search?q=atmega%2016u2%20composite%20device" />
  <row Id="1337" PostHistoryTypeId="2" PostId="500" RevisionGUID="c9fc22c7-cb07-4ddc-800e-6eff7c69cf97" CreationDate="2014-02-28T05:00:18.687" UserId="356" Text="Whenever light follows a path that takes it from one material to the next, it makes a sharp turn. However, the angle of deviation is different based on the characteristics of the materials.&#xD;&#xA;&#xD;&#xA;You can use this principle.&#xD;&#xA;&#xD;&#xA;Set a LED on the level that you want to be your lowest. When the water is full, its light will follow a certain path across the container and reach its light sensor. When the water gets bellow the level, it will miss it (or you could set up a second sensor if you really wanted to).&#xD;&#xA;&#xD;&#xA;Based on this info, you can know when the water gets too low. Just take appropriate action.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1338" PostHistoryTypeId="5" PostId="500" RevisionGUID="f079199a-4bee-455c-9399-34d6b47c5117" CreationDate="2014-02-28T05:09:10.593" UserId="356" Comment="Added the last comment about the possible ruining of the machine." Text="Whenever light follows a path that takes it from one material to the next, it makes a sharp turn. However, the angle of deviation is different based on the characteristics of the materials.&#xD;&#xA;&#xD;&#xA;You can use this principle.&#xD;&#xA;&#xD;&#xA;Set a LED on the level that you want to be your lowest. When the water is full, its light will follow a certain path across the container and reach its light sensor. When the water gets bellow the level, it will miss it (or you could set up a second sensor if you really wanted to).&#xD;&#xA;&#xD;&#xA;Based on this info, you can know when the water gets too low. Just take appropriate action.&#xD;&#xA;&#xD;&#xA;Watch out on the recommendation to measure the water used. This could be dangerous. You may have a leakage (either now or later) or somebody might tip the machine and spill some water. In either case your water level would be lower than the level you calculate, which would certainly result in your espresso machine be ruined.&#xD;&#xA;" />
  <row Id="1340" PostHistoryTypeId="2" PostId="501" RevisionGUID="1fd8de67-6d39-47c1-be12-0586cfa59d89" CreationDate="2014-02-28T05:28:50.783" UserId="357" Text="In a similar way to the question  &quot;[**best way to determine if a 5 gallon water jug is getting empty**][1]&quot;, I'm looking for a way to measure water in a container. This is so it can be connected to an Arduino for logging and reporting.  But it's a very different container.&#xD;&#xA;&#xD;&#xA;I have a home with the household water supplied from an underground concrete tank (around 3000 US gallons, 11000 litres).  Although there is a float switch cutout when it gets empty (to protect the pump), I'd like to know it's gettting low long before that (as it takes a while before a tanker delivers a fresh load).  Ideally something that measures exactly or in steps (at least in eights of a load), so software can predict when it'll run out based on average usage, and it can be monitored online when away.&#xD;&#xA;&#xD;&#xA;The tank has a heavy concrete hatch, and a small hole that has an existing primitive dipstick, so access is limited.  It's in a harsh desert environment, but the pump room and power are only a few feet away.&#xD;&#xA;&#xD;&#xA;Some ideas I had:&#xD;&#xA;&#xD;&#xA;  - suspend an array of float switches with strings of different lengths from a bar inside the tank, and wire them all back to a controller.  Hard to install, ugly, low tech. Or something similar on a vertical pole.&#xD;&#xA;  - contacts (like a US 2 pin plug) on a vertical pole that again are connected back to a controller (probably using a ribbon cable).  Corrosion/anodes might be a problem, although power could just be a short pulse at times.  Condensation, spiders webs and dead bugs may give false readings.&#xD;&#xA;  - run a fully insulated cable vertically down it, and use as an antenna to send a pulse through, and use the difference between how it works as an antenna in air, and in water, (like an SWR meter) to calculate how far down the water is.&#xD;&#xA;  - ultrasonic (or light?) distance finder mounted under the hatch.  Range needs to be up to 2 metres (6 feet).&#xD;&#xA;  - depth finder (sonar) on a float.  Biggest challenge here is getting the signal out (long cable might get tangled when the tank fills).&#xD;&#xA;&#xD;&#xA;Any other ideas?  Has anybody ever done this?&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/questions/488/best-way-to-determine-if-a-5-gallon-water-jug-is-getting-empty" />
  <row Id="1341" PostHistoryTypeId="1" PostId="501" RevisionGUID="1fd8de67-6d39-47c1-be12-0586cfa59d89" CreationDate="2014-02-28T05:28:50.783" UserId="357" Text="Sensor for underground water tank level" />
  <row Id="1342" PostHistoryTypeId="3" PostId="501" RevisionGUID="1fd8de67-6d39-47c1-be12-0586cfa59d89" CreationDate="2014-02-28T05:28:50.783" UserId="357" Text="&lt;project&gt;" />
  <row Id="1343" PostHistoryTypeId="5" PostId="501" RevisionGUID="669e32b3-d99f-4b4e-8062-d74c5fe453a2" CreationDate="2014-02-28T05:49:51.420" UserId="357" Comment="added wireless" Text="In a similar way to the question  &quot;[**best way to determine if a 5 gallon water jug is getting empty**][1]&quot;, I'm looking for a way to measure water in a container. This is so it can be connected to an Arduino for logging and reporting.  But it's a very different container.&#xD;&#xA;&#xD;&#xA;I have a home with the household water supplied from an underground concrete tank (around 3000 US gallons, 11000 litres).  Although there is a float switch cutout when it gets empty (to protect the pump), I'd like to know it's gettting low long before that (as it takes a while before a tanker delivers a fresh load).  Ideally something that measures exactly or in steps (at least in eights of a load), so software can predict when it'll run out based on average usage, and it can be monitored online when away.&#xD;&#xA;&#xD;&#xA;The tank has a heavy concrete hatch, and a small hole that has an existing primitive dipstick, so access is limited.  It's in a harsh desert environment, but the pump room and power are only a few feet away.&#xD;&#xA;&#xD;&#xA;Some ideas I had:&#xD;&#xA;&#xD;&#xA;  - suspend an array of float switches with strings of different lengths from a bar inside the tank, and wire them all back to a controller.  Hard to install, ugly, low tech. Or something similar on a vertical pole.&#xD;&#xA;  - contacts (like a US 2 pin plug) on a vertical pole that again are connected back to a controller (probably using a ribbon cable).  Corrosion/anodes might be a problem, although power could just be a short pulse at times.  Condensation, spiders webs and dead bugs may give false readings.&#xD;&#xA;  - run a fully insulated cable vertically down it, and use as an antenna to send a pulse through, and use the difference between how it works as an antenna in air, and in water, (like an SWR meter) to calculate how far down the water is.&#xD;&#xA;  - ultrasonic (or light?) distance finder mounted under the hatch.  Range needs to be up to 2 metres (6 feet).&#xD;&#xA;  - depth finder (sonar) on a float.  Biggest challenge here is getting the signal out (long cable might get tangled when the tank fills).&#xD;&#xA;&#xD;&#xA;The last two would be even better if they were wireless (to save running a cable that might get damaged) but I don't think I'd get the battery life I'd like (1 year or more).&#xD;&#xA;&#xD;&#xA;Any other ideas?  Has anybody ever done this?&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/questions/488/best-way-to-determine-if-a-5-gallon-water-jug-is-getting-empty" />
  <row Id="1344" PostHistoryTypeId="2" PostId="502" RevisionGUID="d9ef93f5-08ad-40a6-b0cc-fcf237aa6e94" CreationDate="2014-02-28T06:05:14.713" UserId="186" Text="**Lasers**&#xD;&#xA;&#xD;&#xA;If your blue water bottles are like mine, they are transparent.&#xD;&#xA;&#xD;&#xA;Here's what I would try first:&#xD;&#xA;&#xD;&#xA;I would get a cheap laser, and shine the light horizontally through the bottle.&#xD;&#xA;I would aim the laser through a short [chord][1] -- not pointed directly through the middle of the bottle; perhaps 1/8 turn to the left of center.&#xD;&#xA;&#xD;&#xA;        -------&#xD;&#xA;    L../.......\..........S1&#xD;&#xA;      /         \&#xD;&#xA;     |     o     |        S2&#xD;&#xA;      \         /&#xD;&#xA;       \       /&#xD;&#xA;        -------&#xD;&#xA;    top-down view&#xD;&#xA;&#xD;&#xA;When the bottle is empty, the laser beam will shoot pretty much straight through the bottle -- I would put one photo-sensor S1 there.&#xD;&#xA;&#xD;&#xA;When the bottle is not quite empty, the laser beam will bend ([refract][2]) -- for redundancy, I would put another photo-sensor S2 there.&#xD;&#xA;&#xD;&#xA;As long as the Arduino sees the laser hitting S2 alone, there's still some water in the bottle, at least up to the level of the laser -- turn on the green light.&#xD;&#xA;&#xD;&#xA;Anything else -- light detecting only at S1, or nothing detected at either sensor, or light detected at both sensors (yes, it can happen) -- something doesn't seem right, better have the Arduino turn off the green light and turn on the red light.&#xD;&#xA;&#xD;&#xA;I would start with [the simplest thing that could possibly work][3].&#xD;&#xA;If I'm lucky, it might work.&#xD;&#xA;If not, there's lots of little tricks involved in getting the light where you want it to go.&#xD;&#xA;There's also lots of tricks for blocking sunlight, etc. from going where you don't want it to go.&#xD;&#xA;Little black tubes, red plastic filters,&#xD;&#xA;pulsing the laser at a few kHz,&#xD;&#xA;collimating lenses,&#xD;&#xA;lock-in amplifiers, etc.&#xD;&#xA;&#xD;&#xA;There seem to be lots of tutorials that describe how to detect a laser using Arduino -- see&#xD;&#xA;&#xD;&#xA;* [&quot;Laser Harp&quot;][4]&#xD;&#xA;* [&quot;Laser Timing Gate&quot;][11]&#xD;&#xA;* [&quot;Arduino Laser Tripwire&quot;][5]&#xD;&#xA;* [&quot;Arduino Forum: laser detection&quot;][6]&#xD;&#xA;* [&quot;Arduino security with frickin’ laser&quot;][7]&#xD;&#xA;* [&quot;Arduino self-calibrating laser trip wire&quot;][8]&#xD;&#xA;* [&quot;The Arduino Controlled Laser Security System&quot;][9]&#xD;&#xA;* [&quot;Raspberry Pi &amp; Arduino: laser pointer communication&quot;][10]&#xD;&#xA;* etc.&#xD;&#xA;&#xD;&#xA;(This would probably work just as well with a medium-power LED or &quot;infrared LED&quot; and some careful optical focusing and alignment. But -- lasers!)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/chord_%28geometry%29&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/refraction&#xD;&#xA;  [3]: http://www.artima.com/intv/simplestP.html&#xD;&#xA;  [4]: http://www.radioshack.com/graphics/uc/rsk/Support/ProductManuals/Laser_Harp_Online_Instructions.pdf&#xD;&#xA;  [5]: http://www.instructables.com/id/Arduino-Laser-Tripwire/&#xD;&#xA;  [6]: http://forum.arduino.cc/index.php/topic,13046.0.html&#xD;&#xA;  [7]: http://hackaday.com/2010/01/03/arduino-security-with-frickin-laser/&#xD;&#xA;  [8]: http://keithkay.com/2013/03/03/arduino-self-calibrating-laser-trip-wire/&#xD;&#xA;  [9]: http://makezine.com/projects/the-arduino-controlled-laser-security-system/&#xD;&#xA;  [10]: http://pyevolve.sourceforge.net/wordpress/?p=2383&#xD;&#xA;  [11]: https://www.manylabs.org/project/laserGate/" />
  <row Id="1345" PostHistoryTypeId="2" PostId="503" RevisionGUID="b0956295-fe82-4e37-966a-20893dcd23ef" CreationDate="2014-02-28T07:25:02.660" UserId="89" Text="Is this based on the [SDFat][1] library?&#xD;&#xA;&#xD;&#xA;Then you have to live with short 8.3 filenames for the moment.&#xD;&#xA;&#xD;&#xA;[1]:http://code.google.com/p/sdfatlib/" />
  <row Id="1346" PostHistoryTypeId="5" PostId="486" RevisionGUID="3487ee3a-065a-4118-97a9-653436543df8" CreationDate="2014-02-28T08:24:03.203" UserId="42" Comment="Added note about the filename length issue." Text="*EDIT: As noted by Klaus Warzecha, the SD library may only support 8.3 format filenames (i.e. 8 characters for the name, 3 characters for the extension). The solution may in fact be to ensure that the years is only 2 digits, resulting in names like: `20-12-14.csv`*&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;From what I can see in the SD library code, the `open()` method isn't designed to accept a `String` object as a parameter. It only wants a plain old [C-style string][1] (which means a `char` array). That explains why your first example doesn't work -- it's trying to pass a `String` object.&#xD;&#xA;&#xD;&#xA;The second example unfortunately is invalid C++. You simply can't initialise an array like that. What you want to do instead is to build the `String` object, then extract the characters out using `String::toCharArray()`.&#xD;&#xA;&#xD;&#xA;Something like this should work:&#xD;&#xA;&#xD;&#xA;    String filename = String(now.day()) + &quot;-&quot; + String(now.month()) + &quot;-&quot; + String(now.year()) + &quot;.csv&quot;;&#xD;&#xA;    char str[16] = {0};&#xD;&#xA;    filename.toCharArray(str, 16);&#xD;&#xA;    dataFile = SD.open(str, FILE_WRITE);&#xD;&#xA;&#xD;&#xA;I'm not sure what your `now.year()` returns; i.e. if that's a 2 digit or 4 digit year. I've assumed 4 digits, so I've made the `char` array big enough for 15 characters in total, plus an extra null terminator (which is essential for C-style strings).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/String" />
  <row Id="1347" PostHistoryTypeId="2" PostId="504" RevisionGUID="8cc85d04-cc49-4a81-92e8-5220143d3799" CreationDate="2014-02-28T08:29:06.940" UserId="136" Text="I have a background working on ships where robust and workable tank level gauges are  a huge part of instrumentation available to you. Water is the most forgiving and easiest liquid to measure - it's cool, not too viscous, not corrosive in itself, and easy to clean off. There are a lot of options available to you.&#xD;&#xA;&#xD;&#xA;Personally I would avoid any system which involves immersing anything in liquid if at all possible. Waterproofing isn't easy. I would also try to stay with a tried and tested system.&#xD;&#xA;&#xD;&#xA;So to run through your solutions:&#xD;&#xA;&#xD;&#xA; 1. Multiple float switches - has poor resolution. Would be reliable. You can buy assemblies with LowLow, LowHigh, HighLow, HighHigh float limit switches already on them for maintaining tanks levels, but these are industrial quality with industrial prices.&#xD;&#xA;&#xD;&#xA; 2. This would work, but corrosion is going to be an issue. Resolution limited by how many contacts you have.&#xD;&#xA;&#xD;&#xA; 3. Interesting idea, but would likely require a lot of DSP work. Not a tried and tested method.&#xD;&#xA;&#xD;&#xA; 4. An ultrasonic sensor would be my preferred method. Non-contact, high resolution, range of 2m is easy. Tried and tested system.&#xD;&#xA;&#xD;&#xA; 5. Interesting idea, would require a lot of work. Easier to measure depth of air as per 4 and do the simple maths.&#xD;&#xA;&#xD;&#xA;A few other methods come to mind:&#xD;&#xA;&#xD;&#xA;1. A pressure sensor at the bottom of the tank. This is often used on ships, works well but needs immersion which can be avoided.&#xD;&#xA;&#xD;&#xA;2. Inflow/outflow monitoring. A flow meter on the output can tell you how much you have used. Inferring level like this is prone to errors though.&#xD;&#xA;&#xD;&#xA;There are a million other methods, but they get more and more complex.&#xD;&#xA;&#xD;&#xA;The ultrasound would be a great way to do this. Realistically, you would only need to make measurements at most once every hour, so you could achieve great battery life. The concrete is likely to present a wireless range challenge. Most RF transceivers will get through concrete though, so place the receiver nearby.&#xD;&#xA;&#xD;&#xA;If you want ideas on how it is done, google for ultrasonic *oil* level monitoring - there are loads of wireless commercial solutions." />
  <row Id="1348" PostHistoryTypeId="5" PostId="504" RevisionGUID="800b3633-5c84-429a-b2af-fa0b22a16edc" CreationDate="2014-02-28T08:34:48.887" UserId="136" Comment="Link to example ultrasound sensor." Text="I have a background working on ships where robust and workable tank level gauges are  a huge part of instrumentation available to you. Water is the most forgiving and easiest liquid to measure - it's cool, not too viscous, not corrosive in itself, and easy to clean off. There are a lot of options available to you.&#xD;&#xA;&#xD;&#xA;Personally I would avoid any system which involves immersing anything in liquid if at all possible. Waterproofing isn't easy. I would also try to stay with a tried and tested system.&#xD;&#xA;&#xD;&#xA;So to run through your solutions:&#xD;&#xA;&#xD;&#xA; 1. Multiple float switches - has poor resolution. Would be reliable. You can buy assemblies with LowLow, LowHigh, HighLow, HighHigh float limit switches already on them for maintaining tanks levels, but these are industrial quality with industrial prices.&#xD;&#xA;&#xD;&#xA; 2. This would work, but corrosion is going to be an issue. Resolution limited by how many contacts you have.&#xD;&#xA;&#xD;&#xA; 3. Interesting idea, but would likely require a lot of DSP work. Not a tried and tested method.&#xD;&#xA;&#xD;&#xA; 4. An ultrasonic sensor would be my preferred method. Non-contact, high resolution, range of 2m is easy. Tried and tested system.&#xD;&#xA;&#xD;&#xA; 5. Interesting idea, would require a lot of work. Easier to measure depth of air as per 4 and do the simple maths.&#xD;&#xA;&#xD;&#xA;A few other methods come to mind:&#xD;&#xA;&#xD;&#xA;1. A pressure sensor at the bottom of the tank. This is often used on ships, works well but needs immersion which can be avoided.&#xD;&#xA;&#xD;&#xA;2. Inflow/outflow monitoring. A flow meter on the output can tell you how much you have used. Inferring level like this is prone to errors though.&#xD;&#xA;&#xD;&#xA;There are a million other methods, but they get more and more complex.&#xD;&#xA;&#xD;&#xA;The ultrasound would be a great way to do this. The commonly available [Parallax Ping][1] sensor would do the job. Realistically, you would only need to make measurements at most once every hour, so you could achieve great battery life. The concrete is likely to present a wireless range challenge. Most RF transceivers will get through concrete though, so place the receiver nearby.&#xD;&#xA;&#xD;&#xA;If you want ideas on how it is done, google for ultrasonic *oil* level monitoring - there are loads of wireless commercial solutions.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.parallax.com/product/28015" />
  <row Id="1349" PostHistoryTypeId="2" PostId="505" RevisionGUID="5ba4dffa-3499-49ed-93a2-3e7abd267122" CreationDate="2014-02-28T09:13:41.540" UserId="359" Text="you can use a metal detector like setup&#xD;&#xA;&#xD;&#xA;have a coil with AC next to the bottle and an unpowered coil inside it&#xD;&#xA;&#xD;&#xA;then by measuring the current and/or voltage generated by the second coil you can sense the difference between with water next to it and without" />
  <row Id="1350" PostHistoryTypeId="2" PostId="506" RevisionGUID="12df2355-4a85-4f71-8614-fa816710ed2f" CreationDate="2014-02-28T09:46:51.437" UserId="136" Text="Arduino is an odd hybrid, where some C++ functionality is used in the embedded world - traditionally a C environment. Indeed, a lot of Arduino code is very C like though.&#xD;&#xA;&#xD;&#xA;C has traditionally used #defines for constants. There are a number of reasons for this:&#xD;&#xA;&#xD;&#xA;1. You can't set array sizes using const int.&#xD;&#xA;2. You can't use const int as case statement labels (though this does work in some compilers)&#xD;&#xA;3. You can't initialise a const with another const.&#xD;&#xA;&#xD;&#xA;You can check [this question][1] on StackOverflow for more reasoning.&#xD;&#xA;&#xD;&#xA;So, what should we use for Arduino? I tend towards #define, but I see some code using const and some using a blend.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/1674032/static-const-vs-define-in-c" />
  <row Id="1351" PostHistoryTypeId="1" PostId="506" RevisionGUID="12df2355-4a85-4f71-8614-fa816710ed2f" CreationDate="2014-02-28T09:46:51.437" UserId="136" Text="Is it better to use #define or const int for constants?" />
  <row Id="1352" PostHistoryTypeId="3" PostId="506" RevisionGUID="12df2355-4a85-4f71-8614-fa816710ed2f" CreationDate="2014-02-28T09:46:51.437" UserId="136" Text="&lt;c&gt;&lt;constants&gt;&lt;coding-standards&gt;" />
  <row Id="1353" PostHistoryTypeId="2" PostId="507" RevisionGUID="ac2bf690-1a2d-4146-8ab8-921e79adfdb4" CreationDate="2014-02-28T10:40:05.943" UserId="42" Text="As you've identified, there are certain situations where you're forced to use a `#define`, because the compiler won't allow a `const` variable. Similarly, in some situations you're forced to use variables, such as when you need an array of values (i.e. you can't have an array of `#define`).&#xD;&#xA;&#xD;&#xA;However, there are many other situations where there isn't necessarily a single 'correct' answer. Here are some guidelines which I would follow:&#xD;&#xA;&#xD;&#xA;**Type safety**  &#xD;&#xA;From a general programming point-of-view, `const` variables are usually preferable (where possible). The main reason for that is type-safety.&#xD;&#xA;&#xD;&#xA;A `#define` (preprocessor macro) directly copies the literal value into each location in code, making every usage independent. This can hypothetically result in ambiguities, because the type may end up being resolved differently depending on how/where it's used.&#xD;&#xA;&#xD;&#xA;A `const` variable is only ever one type, which is determined by its declaration, and resolved during initialisation. It will often require an explicit cast before it will behave differently (although there are various situations where it can safely be implicitly type-promoted). At the very least, the compiler can (if configured correctly) emit a more reliable warning when a type issue occurs.&#xD;&#xA;&#xD;&#xA;A possible workaround for this is to include an explicit cast or a type-suffix within a `#define`. For example:&#xD;&#xA;&#xD;&#xA;    #define THE_ANSWER (int8_t)42&#xD;&#xA;    #define NOT_QUITE_PI 3.14f&#xD;&#xA;&#xD;&#xA;That approach can potentially cause syntax problems in some cases though, depending on how it's used.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Memory usage**  &#xD;&#xA;Unlike general purpose computing, memory is obviously at a premium when dealing with something like an Arduino. Using a `const` variable vs. a `#define` can affect where the data is stored in memory, which may force you to use one or the other.&#xD;&#xA;&#xD;&#xA; - `const` variables will (usually) be stored in SRAM, along with all other variables.&#xD;&#xA; - Literal values used in `#define` will often be stored in program space (Flash memory), alongside the sketch itself.&#xD;&#xA;&#xD;&#xA;*(Note that there are various things which can affect exactly how and where something is stored, such as compiler configuration and optimisation.)*&#xD;&#xA;&#xD;&#xA;SRAM and Flash have different limitations (e.g. 2 KB and 32 KB respectively for the Uno). For some applications, it's quite easy to run out of SRAM, so it can be helpful to shift some things into Flash. The reverse is also possible, although probably less common.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**PROGMEM**  &#xD;&#xA;It's possible to get the benefits of type-safety while also storing the data in program space (Flash). This is done using the `PROGMEM` keyword. It doesn't work for all types, but it's commonly used for arrays of integers or strings.&#xD;&#xA;&#xD;&#xA;The general form given in the [**documentation**][1] is as follows:&#xD;&#xA;&#xD;&#xA;    dataType variableName[] PROGMEM = {dataInt0, dataInt1, dataInt3...}; &#xD;&#xA;&#xD;&#xA;String tables are a bit more complicated, but the documentation has full details.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/PROGMEM" />
  <row Id="1354" PostHistoryTypeId="2" PostId="508" RevisionGUID="b03699a9-8334-47a0-aecb-acd66f0009b6" CreationDate="2014-02-28T11:05:39.467" UserId="360" Text="I'm new to electronics and arduino and I have a really easy question.&#xD;&#xA;I have an object with a series of led and I want to turn on and off these leds from my arduino. The input of the led circuit is 24v DC 100mA.&#xD;&#xA;&#xD;&#xA;What I've done is the following:&#xD;&#xA;- I've cut a wire of this object and I connected one end to the collector and the other end to the emitter of a NPN transistor&#xD;&#xA;- I connected the base of the transistor to a digital output (through a 1k resistance)&#xD;&#xA;- I connected the power to the led series while the digital pin was LOW (actually completely disconnected)&#xD;&#xA;&#xD;&#xA;But with no current on the base of the transistor, the led has turned on with all my surprise :)&#xD;&#xA;&#xD;&#xA;I may have completely mis-used these things but I have to try to learn.&#xD;&#xA;So may you help me with this job?&#xD;&#xA;&#xD;&#xA;Many many thanks" />
  <row Id="1355" PostHistoryTypeId="1" PostId="508" RevisionGUID="b03699a9-8334-47a0-aecb-acd66f0009b6" CreationDate="2014-02-28T11:05:39.467" UserId="360" Text="How switch an external circuit with Arduino?" />
  <row Id="1356" PostHistoryTypeId="3" PostId="508" RevisionGUID="b03699a9-8334-47a0-aecb-acd66f0009b6" CreationDate="2014-02-28T11:05:39.467" UserId="360" Text="&lt;power&gt;&lt;transistor&gt;&lt;voltage-level&gt;" />
  <row Id="1357" PostHistoryTypeId="2" PostId="509" RevisionGUID="3660de1e-dbe5-442b-b09c-8b1f6f594041" CreationDate="2014-02-28T12:44:57.123" UserId="83" Text="If I understand your writeup correctly, this is what you have built:&#xD;&#xA;&#xD;&#xA;&lt;!-- Begin schematic: In order to preserve an editable schematic, please&#xD;&#xA;     don't edit this section directly.&#xD;&#xA;     Click the &quot;edit&quot; link below the image in the preview instead. --&gt;&#xD;&#xA;&#xD;&#xA;![schematic](http://i.stack.imgur.com/8zae1.png)&#xD;&#xA;&#xD;&#xA;&lt;!-- End schematic --&gt;&#xD;&#xA;&#xD;&#xA;What you didn't mention in your question is that you made a connection from Arduino ground to the base of the transistor and the seconds circuit's ground connection. I drew the extra lead 'loose' for illustration only, but you see where it should connect. Current needs a return path, it is not sufficient to only have the forward path (from Arduino through R1 and base-Q1). The return path is emitter-Q1 to Arduino-GND.&#xD;&#xA;&#xD;&#xA;Do notice though that the two batteries / power supplies must be floating with respect to each other otherwise you're going to short them out." />
  <row Id="1358" PostHistoryTypeId="5" PostId="505" RevisionGUID="c629f130-d6fd-43d4-bf67-e7ce86c9db43" CreationDate="2014-02-28T13:31:27.123" UserId="359" Comment="added 141 characters in body" Text="you can use a metal detector like setup using the fact that electronic [permittivity][1] of water is different than that of air&#xD;&#xA;&#xD;&#xA;have a coil with AC next to the bottle and an unpowered coil inside it&#xD;&#xA;&#xD;&#xA;then by measuring the current and/or voltage generated by the second coil you can sense the difference between with water next to it and without&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Permitivity" />
  <row Id="1359" PostHistoryTypeId="5" PostId="506" RevisionGUID="0892ad41-8e30-4ebe-8601-7c46f337ae31" CreationDate="2014-02-28T13:42:19.807" UserId="37" Comment="improved formatting, edited tags" Text="Arduino is an odd hybrid, where some C++ functionality is used in the embedded world—traditionally a C environment. Indeed, a lot of Arduino code is very C like though.&#xD;&#xA;&#xD;&#xA;C has traditionally used `#define`s for constants. There are a number of reasons for this:&#xD;&#xA;&#xD;&#xA; 1. You can't set array sizes using `const int`.&#xD;&#xA; 2. You can't use `const int` as case statement labels (though this does work in some compilers)&#xD;&#xA; 3. You can't initialize a `const` with another `const`.&#xD;&#xA;&#xD;&#xA;You can check [this question][1] on StackOverflow for more reasoning.&#xD;&#xA;&#xD;&#xA;So, what should we use for Arduino? I tend towards `#define`, but I see some code using `const` and some using a blend.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/1674032/static-const-vs-define-in-c" />
  <row Id="1360" PostHistoryTypeId="6" PostId="506" RevisionGUID="0892ad41-8e30-4ebe-8601-7c46f337ae31" CreationDate="2014-02-28T13:42:19.807" UserId="37" Comment="improved formatting, edited tags" Text="&lt;programming&gt;&lt;constants&gt;&lt;coding-standards&gt;" />
  <row Id="1361" PostHistoryTypeId="24" PostId="506" RevisionGUID="0892ad41-8e30-4ebe-8601-7c46f337ae31" CreationDate="2014-02-28T13:42:19.807" Comment="Proposed by 37 approved by 136 edit id of 168" />
  <row Id="1362" PostHistoryTypeId="2" PostId="510" RevisionGUID="a56e09fb-cb48-4386-accb-85df3e1d9980" CreationDate="2014-02-28T15:05:36.517" UserId="353" Text="It's important to note that `const int` does **not** behave identically in C and in C++, so in fact several of the objections against it that have been alluded to in the original question and in Peter Bloomfields's extensive answer are not valid:&#xD;&#xA;&#xD;&#xA; - In C++, `const int` constants are compile time values and **can** be used to set array limits, as case labels, etc.&#xD;&#xA; - `const int` constants do not necessarily occupy any storage. Unless you take their address or declare them extern, they will generally just have a compile time existence.&#xD;&#xA;&#xD;&#xA;However, for integer constants, it might often be preferable to use a (named or anonymous) `enum`. I often like this because:&#xD;&#xA;&#xD;&#xA; - It's backward compatible with C.&#xD;&#xA; - It's nearly as type safe as `const int` (every bit as type safe in C++11).&#xD;&#xA; - It provides a natural way of grouping related constants.&#xD;&#xA; - You can even use them for some amount of namespace control.&#xD;&#xA;&#xD;&#xA;So in an idiomatic C++ program, there is no reason whatsoever to use `#define` to define an integer constant. Even if you want to remain C compatible (because of technical requirements, because you're kickin' it old school, or because people you work with prefer it that way), you can still use `enum` and should do so, rather than use `#define`. " />
  <row Id="1363" PostHistoryTypeId="5" PostId="507" RevisionGUID="276810a8-5287-48be-ba28-5a00b6a77e45" CreationDate="2014-02-28T15:50:16.123" UserId="42" Comment="added 129 characters in body" Text="*EDIT: microtherion gives an excellent answer which corrects some of my points here, particularly about memory usage.*&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;As you've identified, there are certain situations where you're forced to use a `#define`, because the compiler won't allow a `const` variable. Similarly, in some situations you're forced to use variables, such as when you need an array of values (i.e. you can't have an array of `#define`).&#xD;&#xA;&#xD;&#xA;However, there are many other situations where there isn't necessarily a single 'correct' answer. Here are some guidelines which I would follow:&#xD;&#xA;&#xD;&#xA;**Type safety**  &#xD;&#xA;From a general programming point-of-view, `const` variables are usually preferable (where possible). The main reason for that is type-safety.&#xD;&#xA;&#xD;&#xA;A `#define` (preprocessor macro) directly copies the literal value into each location in code, making every usage independent. This can hypothetically result in ambiguities, because the type may end up being resolved differently depending on how/where it's used.&#xD;&#xA;&#xD;&#xA;A `const` variable is only ever one type, which is determined by its declaration, and resolved during initialisation. It will often require an explicit cast before it will behave differently (although there are various situations where it can safely be implicitly type-promoted). At the very least, the compiler can (if configured correctly) emit a more reliable warning when a type issue occurs.&#xD;&#xA;&#xD;&#xA;A possible workaround for this is to include an explicit cast or a type-suffix within a `#define`. For example:&#xD;&#xA;&#xD;&#xA;    #define THE_ANSWER (int8_t)42&#xD;&#xA;    #define NOT_QUITE_PI 3.14f&#xD;&#xA;&#xD;&#xA;That approach can potentially cause syntax problems in some cases though, depending on how it's used.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Memory usage**  &#xD;&#xA;Unlike general purpose computing, memory is obviously at a premium when dealing with something like an Arduino. Using a `const` variable vs. a `#define` can affect where the data is stored in memory, which may force you to use one or the other.&#xD;&#xA;&#xD;&#xA; - `const` variables will (usually) be stored in SRAM, along with all other variables.&#xD;&#xA; - Literal values used in `#define` will often be stored in program space (Flash memory), alongside the sketch itself.&#xD;&#xA;&#xD;&#xA;*(Note that there are various things which can affect exactly how and where something is stored, such as compiler configuration and optimisation.)*&#xD;&#xA;&#xD;&#xA;SRAM and Flash have different limitations (e.g. 2 KB and 32 KB respectively for the Uno). For some applications, it's quite easy to run out of SRAM, so it can be helpful to shift some things into Flash. The reverse is also possible, although probably less common.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**PROGMEM**  &#xD;&#xA;It's possible to get the benefits of type-safety while also storing the data in program space (Flash). This is done using the `PROGMEM` keyword. It doesn't work for all types, but it's commonly used for arrays of integers or strings.&#xD;&#xA;&#xD;&#xA;The general form given in the [**documentation**][1] is as follows:&#xD;&#xA;&#xD;&#xA;    dataType variableName[] PROGMEM = {dataInt0, dataInt1, dataInt3...}; &#xD;&#xA;&#xD;&#xA;String tables are a bit more complicated, but the documentation has full details.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/PROGMEM" />
  <row Id="1364" PostHistoryTypeId="2" PostId="511" RevisionGUID="3500e6b4-ffd4-4b73-b8ca-f8da5e927119" CreationDate="2014-02-28T16:14:50.733" UserId="364" Text="This variable:&#xD;&#xA;&#xD;&#xA;    String utcDateString = &quot;&quot;;&#xD;&#xA;&#xD;&#xA;Is a C++ String, not a character array like sprintf() is expecting.  To convert this string to a character array such that sprintf is expecting, you must use .c_str() in your sprintf, i.e.:&#xD;&#xA;&#xD;&#xA;    sprintf(foo,&quot;This is a format for %s&quot;, utcDateString.c_str());&#xD;&#xA;&#xD;&#xA;Doing this should prevent the sprintf line from causing a memory fault.&#xD;&#xA;" />
  <row Id="1365" PostHistoryTypeId="2" PostId="512" RevisionGUID="3eb2b7c6-c27f-4c78-9c1a-05cf0d8e7e28" CreationDate="2014-02-28T16:46:24.083" UserId="-1" Text="" />
  <row Id="1366" PostHistoryTypeId="2" PostId="513" RevisionGUID="47081e81-f8df-431b-b835-ae947dd94df2" CreationDate="2014-02-28T16:46:24.083" UserId="-1" Text="" />
  <row Id="1367" PostHistoryTypeId="2" PostId="514" RevisionGUID="d0f84f7f-c3ec-4ba1-84e9-c93678b6dffe" CreationDate="2014-02-28T16:47:38.107" UserId="-1" Text="" />
  <row Id="1368" PostHistoryTypeId="2" PostId="515" RevisionGUID="b22f3f96-e22a-42aa-9bdb-4cb8b2849efb" CreationDate="2014-02-28T16:47:38.107" UserId="-1" Text="" />
  <row Id="1369" PostHistoryTypeId="2" PostId="516" RevisionGUID="34dce3b2-6b75-4441-8efc-395dcd654247" CreationDate="2014-02-28T16:51:38.830" UserId="-1" Text="" />
  <row Id="1370" PostHistoryTypeId="2" PostId="517" RevisionGUID="fd6816b1-9224-4292-8b71-2ad6f7338179" CreationDate="2014-02-28T16:51:38.830" UserId="-1" Text="" />
  <row Id="1371" PostHistoryTypeId="6" PostId="506" RevisionGUID="6c27506e-a310-4b7a-8dda-c4833531c604" CreationDate="2014-02-28T16:57:09.377" UserId="365" Comment="this question is specifically about c++" Text="&lt;programming&gt;&lt;c++&gt;&lt;constants&gt;&lt;coding-standards&gt;" />
  <row Id="1372" PostHistoryTypeId="24" PostId="506" RevisionGUID="6c27506e-a310-4b7a-8dda-c4833531c604" CreationDate="2014-02-28T16:57:09.377" Comment="Proposed by 365 approved by 136 edit id of 175" />
  <row Id="1373" PostHistoryTypeId="5" PostId="349" RevisionGUID="660048d0-ca24-4cbb-bca6-1c5a70f7359c" CreationDate="2014-02-28T17:02:48.370" UserId="65" Comment="added 102 characters in body" Text="[Cybergibbons's answer][1] describes quite nicely the assembly code generation and the differences amongst the two techniques. This is intended to be a complementary answer looking at the issue in terms of *practical* differences, i.e. how much of a difference either approach will make in terms of *execution time*.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;##Code Variations &#xD;&#xA;I did an [analysis][2] involving the following variations:&#xD;&#xA;&#xD;&#xA;- Basic `void loop()` (which gets inlined on compilation)&#xD;&#xA;- Un-inlined `void loop()` (using `__attribute__ ((noinline))`)&#xD;&#xA;- Loop with `while(1)` (which gets optimized)&#xD;&#xA;- Loop with un-optimized `while(1)` (by adding `__asm__ __volatile__(&quot;&quot;);`. This is a `nop` instruction that prevents optimization of the loop without resulting in additional overheads of a `volatile` variable)&#xD;&#xA;- An un-inlined `void loop()` with optimized `while(1)`&#xD;&#xA;- An un-inlined `void loop()` with un-optimized `while(1)`&#xD;&#xA;&#xD;&#xA;The sketches can be found [here][3].&#xD;&#xA;&#xD;&#xA;##Experiment&#xD;&#xA;I ran each of these sketches for 30 seconds, thereby accumulating [300 data points each][4]. There was a 100 millisecond `delay` call in each loop (without which [bad things happen][5]). &#xD;&#xA;&#xD;&#xA;##Results&#xD;&#xA;I then calculated the mean execution times of each loop, subtracted 100 milliseconds from each and then plotted the results. &#xD;&#xA;&#xD;&#xA;[![][6]][7]&#xD;&#xA;&#xD;&#xA;#Conclusion&#xD;&#xA;&#xD;&#xA;- An un-optimised `while(1)` loop within `void loop` is faster than a compiler optimised  `void loop`. &#xD;&#xA;- The time difference between the un-optimized code and default Arduino  optimized code is insignificant *practically*. You will be better off compiling manually using `avr-gcc` and using your own optimisation flags rather than depending on the Arduino IDE to help you with it (if you need microsecond optimisations). &#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;&#xD;&#xA;**NOTE:** The actual time values are not of significance here, the difference between them is. The ~90 microseconds of execution time includes a call to `Serial.println`, `micros` and `delay`.&#xD;&#xA;&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;&#xD;&#xA;**NOTE2:** This was done using the Arduino IDE and the default compiler flags that it supplies.&#xD;&#xA;&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;&#xD;&#xA;**NOTE3:** Analysis (plot and calculations) was done using R.&#xD;&#xA;&lt;/sub&gt;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/questions/337/would-an-infinite-loop-inside-loop-perform-faster#339&#xD;&#xA;  [2]: http://github.com/AsheeshR/Arduino-Loop-Analysis&#xD;&#xA;  [3]: http://github.com/AsheeshR/Arduino-Loop-Analysis/tree/master/Code/Sketches&#xD;&#xA;  [4]: http://github.com/AsheeshR/Arduino-Loop-Analysis/tree/master/Data&#xD;&#xA;  [5]: http://electronics.stackexchange.com/q/12300/18583&#xD;&#xA;  [6]: http://raw2.github.com/AsheeshR/Arduino-Loop-Analysis/master/Figures/timeplot.png&#xD;&#xA;  [7]: http://github.com/AsheeshR/Arduino-Loop-Analysis/blob/master/Data/Munged/runtime.csv" />
  <row Id="1374" PostHistoryTypeId="2" PostId="518" RevisionGUID="ba4fd272-948a-4b00-b1fe-129ef7f8d719" CreationDate="2014-02-28T17:03:44.967" UserId="42" Text="When reading/trying a [recent answer][1], I was surprised to see that Arduino's `String` class supports the `c_str()` method, just like the C++ `std::string` class. As expected, it appears to get a pointer to the string's contents as a null-terminated `char` array (i.e. C-style string).&#xD;&#xA;&#xD;&#xA;However, (as far as I can see) that method is not mentioned in the official Arduino documentation. Additionally, in all example code I've seen using `String`, a different approach seems to be used. A secondary `char` buffer is setup, and then the contents of the string are copied to it using [`String::toCharArray()`][2]. This obviously requires double the memory, plus an O(n) copy operation.&#xD;&#xA;&#xD;&#xA;It seems like `c_str()` should the preferred approach. Is there some reason why `toCharArray()` is more commonly used?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/a/511/42&#xD;&#xA;  [2]: http://arduino.cc/en/Reference/StringToCharArray" />
  <row Id="1375" PostHistoryTypeId="1" PostId="518" RevisionGUID="ba4fd272-948a-4b00-b1fe-129ef7f8d719" CreationDate="2014-02-28T17:03:44.967" UserId="42" Text="Is it better to use c_str or toCharArray?" />
  <row Id="1376" PostHistoryTypeId="3" PostId="518" RevisionGUID="ba4fd272-948a-4b00-b1fe-129ef7f8d719" CreationDate="2014-02-28T17:03:44.967" UserId="42" Text="&lt;programming&gt;&lt;string&gt;" />
  <row Id="1377" PostHistoryTypeId="6" PostId="518" RevisionGUID="badc458f-defb-4a35-80b6-3521a548dea9" CreationDate="2014-02-28T17:17:54.637" UserId="365" Comment="this question is specifically about C++" Text="&lt;programming&gt;&lt;c++&gt;&lt;string&gt;" />
  <row Id="1378" PostHistoryTypeId="24" PostId="518" RevisionGUID="badc458f-defb-4a35-80b6-3521a548dea9" CreationDate="2014-02-28T17:17:54.637" Comment="Proposed by 365 approved by 42 edit id of 177" />
  <row Id="1379" PostHistoryTypeId="5" PostId="386" RevisionGUID="c8f66008-8256-4ea7-a85a-9804fc3188a3" CreationDate="2014-02-28T19:20:22.983" UserId="65" Comment="Well-being of Arduino is covered by the [tag:damage-prevention] tag" Text="The safety tag is for the well-being of the people and objects around you, and yourself." />
  <row Id="1380" PostHistoryTypeId="24" PostId="386" RevisionGUID="c8f66008-8256-4ea7-a85a-9804fc3188a3" CreationDate="2014-02-28T19:20:22.983" Comment="Proposed by 65 approved by 48 edit id of 170" />
  <row Id="1381" PostHistoryTypeId="5" PostId="513" RevisionGUID="fbbc12b0-77fd-48e2-a2d9-890c91a64a54" CreationDate="2014-02-28T19:20:40.720" UserId="65" Comment="added 134 characters in body" Text="This refers to techniques and practices to to be followed to ensure the correct functioning of the board and its well-being over time." />
  <row Id="1382" PostHistoryTypeId="24" PostId="513" RevisionGUID="fbbc12b0-77fd-48e2-a2d9-890c91a64a54" CreationDate="2014-02-28T19:20:40.720" Comment="Proposed by 65 approved by 48 edit id of 171" />
  <row Id="1383" PostHistoryTypeId="5" PostId="493" RevisionGUID="a9970c99-de30-4960-a2f3-826203c22e97" CreationDate="2014-02-28T19:20:47.733" UserId="365" Comment="this is a C++ question, the model is irrelevant; minor readability improvements" Text="I'm trying to parse many variables into a URL so that I can update a website through a simple HTTP API with sensor data. After talking to a buddy of mine, he suggested going with the code below. &#xD;&#xA;&#xD;&#xA;When I put this in, the Arduino Yun boots up. I see the L13 red LED turn on, but then it hoses. When I comment out the `sprintf();` line, everything works fine — except no URL is parsed.&#xD;&#xA;&#xD;&#xA;I've tried to debug to the best of my ability and am looking for thoughts on what may be happening. &#xD;&#xA;&#xD;&#xA;I'm not sure how much code to post without posting the whole 130 line sketch, so I'm just dumping the parts from the `loop` that is trying to piece together the URL.&#xD;&#xA;&#xD;&#xA;      // Get update time&#xD;&#xA;      Process date;&#xD;&#xA;      date.runShellCommand(&quot;date --utc \&quot;+%Y-%m-%d%%20%H:%M:%S\&quot;&quot;);&#xD;&#xA;      String utcDateString = &quot;&quot;;&#xD;&#xA;      while (date.available()) {&#xD;&#xA;        char d = date.read();&#xD;&#xA;        utcDateString += d;&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;          char url[512];&#xD;&#xA;          url[0]='\0';&#xD;&#xA;          float humid, baro, windspeed, raingauge;&#xD;&#xA;          int winddir;&#xD;&#xA;          Serial.print(&quot;humid: &quot;);&#xD;&#xA;          Serial.println(humid);&#xD;&#xA;            Serial.print(&quot;baro: &quot;);&#xD;&#xA;          Serial.println(baro);&#xD;&#xA;            Serial.print(&quot;windspeed: &quot;);&#xD;&#xA;          Serial.println(windspeed);&#xD;&#xA;            Serial.print(&quot;raingauge: &quot;);&#xD;&#xA;          Serial.println(raingauge);&#xD;&#xA;            Serial.print(&quot;winddir: &quot;);&#xD;&#xA;          Serial.println(winddir);&#xD;&#xA;     //sprintf(url,&quot;http://weatherstation.wunderground.com/weatherstation/updateweatherstation.php?ID=123456&amp;PASSWORD=xxxxxx&amp;dateutc=%s&amp;temp=%2.2f&amp;humidity=%2.2f&amp;baromin=%f&amp;winddir=%d&amp;windspeedmph=%3.2f&amp;rainin=%3.2f&amp;softwaretype=Custom%%20Arduino&amp;action=updateraw&quot;,&#xD;&#xA;    //         utcDateString,Thermistor(analogRead(0)),humid,baro,winddir,windspeed,raingauge);&#xD;&#xA;            Serial.print(&quot;url: &quot;);&#xD;&#xA;          Serial.println(url);&#xD;&#xA;&#xD;&#xA;    double Thermistor(int RawADC) {&#xD;&#xA;      double Temp;&#xD;&#xA;      Temp = log(11100.0/((1024.0/RawADC-1)));  // Was 10000... Manually dialed down to increase accuracy. 9400 is a good value. Changing again to match wunderground&#xD;&#xA;      Temp = 1 / (0.001129148 + (0.000234125 + (0.0000000876741 * Temp * Temp ))* Temp );&#xD;&#xA;      Temp = Temp - 273.15;            // Convert Kelvin to Celcius&#xD;&#xA;      Temp = (Temp * 9.0)/ 5.0 + 32.0; // Convert Celcius to Fahrenheit&#xD;&#xA;      return Temp;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here's the output from those `Serial.print()` calls:&#xD;&#xA;&#xD;&#xA;    humid: 0.00&#xD;&#xA;    baro: 0.00&#xD;&#xA;    windspeed: 0.00&#xD;&#xA;    raingauge: 0.00&#xD;&#xA;    winddir: 0&#xD;&#xA;    url:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I'm not sure how else to debug this because when I uncomment `sprintf();` the Yun locks up and I have to press the `32U4 Reset` button and power cycle the Arduino to get it to work again." />
  <row Id="1384" PostHistoryTypeId="4" PostId="493" RevisionGUID="a9970c99-de30-4960-a2f3-826203c22e97" CreationDate="2014-02-28T19:20:47.733" UserId="365" Comment="this is a C++ question, the model is irrelevant; minor readability improvements" Text="sprintf() to assemble String and float pieces locks up" />
  <row Id="1385" PostHistoryTypeId="6" PostId="493" RevisionGUID="a9970c99-de30-4960-a2f3-826203c22e97" CreationDate="2014-02-28T19:20:47.733" UserId="365" Comment="this is a C++ question, the model is irrelevant; minor readability improvements" Text="&lt;sketch&gt;&lt;c++&gt;" />
  <row Id="1386" PostHistoryTypeId="24" PostId="493" RevisionGUID="a9970c99-de30-4960-a2f3-826203c22e97" CreationDate="2014-02-28T19:20:47.733" Comment="Proposed by 365 approved by 48 edit id of 176" />
  <row Id="1387" PostHistoryTypeId="8" PostId="217" RevisionGUID="15d80075-b3ae-438d-afc9-de10b48215eb" CreationDate="2014-02-28T19:22:55.683" UserId="48" Comment="Rollback to [53012f31-278b-4f94-94ba-a19b9c8e3acc]" Text="" />
  <row Id="1388" PostHistoryTypeId="5" PostId="517" RevisionGUID="0939dc95-e394-4735-a5f1-b134ed1891f7" CreationDate="2014-02-28T19:23:32.063" UserId="65" Comment="added 170 characters in body" Text="This is for questions about the official IDE. The open-source IDE makes it easy to write code and upload it to any Arduino board. It runs on Windows, Mac OS X, and Linux." />
  <row Id="1389" PostHistoryTypeId="24" PostId="517" RevisionGUID="0939dc95-e394-4735-a5f1-b134ed1891f7" CreationDate="2014-02-28T19:23:32.063" Comment="Proposed by 65 approved by 48 edit id of 174" />
  <row Id="1390" PostHistoryTypeId="5" PostId="429" RevisionGUID="86b7488e-f266-4cc3-bf01-4f4185effb4f" CreationDate="2014-02-28T19:23:38.500" UserId="365" Comment="reasonable tags; struct isn't an acronym" Text="I'm building a weather station with two UNOs, using NRF24l01+ radios. Communications are fine. I'm sending a struct from one to the other. The struct has three elements:&#xD;&#xA;&#xD;&#xA;        struct weather {&#xD;&#xA;          float tempData;&#xD;&#xA;          float humData;&#xD;&#xA;          float pressData;&#xD;&#xA;        };&#xD;&#xA;        weather wData = {0, 0, 0};&#xD;&#xA;&#xD;&#xA;I then populate the struct with values from my DHT22 Temperature Sensor and my BMP085 pressure sensor.&#xD;&#xA;&#xD;&#xA;        float c = dht.readTemperature();&#xD;&#xA;        wData.tempData = (c * 9/5) + 32;&#xD;&#xA;        wData.humData = dht.readHumidity();&#xD;&#xA;&#xD;&#xA;        sensors_event_t event;&#xD;&#xA;        bmp.getEvent(&amp;event);&#xD;&#xA;        wData.pressData = (0.0295 * event.pressure);&#xD;&#xA;&#xD;&#xA;Now I send it via the NRF24L01+.&#xD;&#xA;&#xD;&#xA;        radio.write(&amp;wData, sizeof(wData);&#xD;&#xA;&#xD;&#xA;On the receiving Uno I have this.&#xD;&#xA;&#xD;&#xA;        struct weather {&#xD;&#xA;          float tempData;&#xD;&#xA;          float humData;&#xD;&#xA;          float pressData;&#xD;&#xA;        };&#xD;&#xA;      &#xD;&#xA;        weather wData = {0, 0, 0};&#xD;&#xA;      &#xD;&#xA;        radio.read( &amp;wData, sizeof(wData) );&#xD;&#xA;        Serial.println(wData.tempData);&#xD;&#xA;        Serial.println(wData.humData);&#xD;&#xA;        Serial.println(wData.pressData);&#xD;&#xA;&#xD;&#xA;I get results similar to this:&#xD;&#xA;&#xD;&#xA;        Temp = 75.43&#xD;&#xA;        Hum = 35.76&#xD;&#xA;        Press = 0.00&#xD;&#xA;&#xD;&#xA;The first two are correct. The final one is not. I can change the order and the first two will always be correct, but the last element is always 0.00. For example:&#xD;&#xA;&#xD;&#xA;       Hum = 35.76&#xD;&#xA;       Press = 30.14&#xD;&#xA;       Temp = 0.00&#xD;&#xA;&#xD;&#xA;I know I'm missing something here with my code but I can't find it. Anyone have some suggestions?&#xD;&#xA;" />
  <row Id="1391" PostHistoryTypeId="4" PostId="429" RevisionGUID="86b7488e-f266-4cc3-bf01-4f4185effb4f" CreationDate="2014-02-28T19:23:38.500" UserId="365" Comment="reasonable tags; struct isn't an acronym" Text="Last element of a struct disappearing on write/read" />
  <row Id="1392" PostHistoryTypeId="6" PostId="429" RevisionGUID="86b7488e-f266-4cc3-bf01-4f4185effb4f" CreationDate="2014-02-28T19:23:38.500" UserId="365" Comment="reasonable tags; struct isn't an acronym" Text="&lt;c++&gt;&lt;struct&gt;" />
  <row Id="1393" PostHistoryTypeId="24" PostId="429" RevisionGUID="86b7488e-f266-4cc3-bf01-4f4185effb4f" CreationDate="2014-02-28T19:23:38.500" Comment="Proposed by 365 approved by 48 edit id of 178" />
  <row Id="1396" PostHistoryTypeId="5" PostId="451" RevisionGUID="aebd808a-8bd0-47bc-9154-03e4c0fcd041" CreationDate="2014-02-28T22:59:03.303" UserId="42" Comment="Removed inappropriate content" Text="I recently wanted to do exactly this. Since there is no nice way to do so, I wound up [writing a patch][1] for the [Stino][2] sublime-text arduino plugin to do exactly this. It's subsequently been accepted, so it should be in any up-to-date Stino installs.&#xD;&#xA;&#xD;&#xA;This adds a new option to Stino:  &#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;Using this mode produces compilation results like the following:  &#xD;&#xA;&#xD;&#xA;For a Uno:&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 172 bytes (of a 32256 byte maximum, 0.53 percent).  &#xD;&#xA;&gt; Estimated memory use: 0 bytes (of a 1024 byte maximum, 0.00 percent).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;For a leonardo&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 240 bytes (of a 28672 byte maximum, 0.84 percent).  &#xD;&#xA;&gt; Estimated memory use: 0 bytes (of a 2560 byte maximum, 0.00 percent).&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Actually *programming* the leonardo with the above compiled output is *probably* a bad idea, as it *might* break the auto-reset functionality, but you *could*, if you wanted. Hat-tip to mpflaga for noting this in his answer.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;Note that the memory reports are actually incorrect, but that's a [separate issue][4].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The code used for the above is:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    int main()&#xD;&#xA;    {&#xD;&#xA;    	while (1)&#xD;&#xA;    	{&#xD;&#xA;    &#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Some notes:&#xD;&#xA;&#xD;&#xA; - You ain't writing a &quot;Sketch&quot; anymore, not that you ever actually *do* write a sketch. You write **programs**. Period. I don't care what the Arduino wackos want to say, they don't get to redefine terms.&#xD;&#xA; - All interrupt management is manual. This means no `milis()` or similar.&#xD;&#xA; - You *can* still use the arduino serial libraries and so forth, if you want. You do have to `#include &lt;Arduino.h&gt;`.&#xD;&#xA; - You define `main`. You don't ever return from `main`. If you want setup stuff, it goes before the `while (1)`.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/Robot-Will/Stino/pull/123&#xD;&#xA;  [2]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [3]: http://i.stack.imgur.com/9p7tO.png&#xD;&#xA;  [4]: https://github.com/Robot-Will/Stino/pull/127&#xD;&#xA;  [5]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [6]: http://www.baeyens.it/eclipse/" />
  <row Id="1397" PostHistoryTypeId="8" PostId="451" RevisionGUID="61eb027d-b701-4ec3-b5a6-e99ba06f1c25" CreationDate="2014-02-28T23:28:57.167" UserId="86" Comment="Rollback to [c396967b-d6b5-4ca4-9446-6bd7da091a85]" Text="I recently wanted to do exactly this. Since there is no nice way to do so, I wound up [writing a patch][1] for the [Stino][2] sublime-text arduino plugin to do exactly this. It's subsequently been accepted, so it should be in any up-to-date Stino installs.&#xD;&#xA;&#xD;&#xA;This adds a new option to Stino:  &#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;Using this mode produces compilation results like the following:  &#xD;&#xA;&#xD;&#xA;For a Uno:&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 172 bytes (of a 32256 byte maximum, 0.53 percent).  &#xD;&#xA;&gt; Estimated memory use: 0 bytes (of a 1024 byte maximum, 0.00 percent).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;For a leonardo&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 240 bytes (of a 28672 byte maximum, 0.84 percent).  &#xD;&#xA;&gt; Estimated memory use: 0 bytes (of a 2560 byte maximum, 0.00 percent).&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Actually *programming* the leonardo with the above compiled output is *probably* a bad idea, as it *might* break the auto-reset functionality, but you *could*, if you wanted. Hat-tip to mpflaga for noting this in his answer.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;Note that the memory reports are actually incorrect, but that's a [separate issue][4].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The code used for the above is:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    int main()&#xD;&#xA;    {&#xD;&#xA;    	while (1)&#xD;&#xA;    	{&#xD;&#xA;    &#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Some notes:&#xD;&#xA;&#xD;&#xA; - You ain't writing a &quot;Sketch&quot; anymore, not that you ever actually *do* write a sketch. You write **programs**. Period. I don't care what the Arduino wackos want to say, they don't get to redefine terms.&#xD;&#xA; - All interrupt management is manual. This means no `milis()` or similar.&#xD;&#xA; - You *can* still use the arduino serial libraries and so forth, if you want. You do have to `#include &lt;Arduino.h&gt;`.&#xD;&#xA; - You define `main`. You don't ever return from `main`. If you want setup stuff, it goes before the `while (1)`.&#xD;&#xA; - If you're still using the arduino-shitty-flaming-pile-of-shit editor/two-macro-buttons thing, you should switch. Have you tried [Stino][5]? Or ANYTHING else? Hell, even [Eclipse][6] is better (and that doesn't get said often).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/Robot-Will/Stino/pull/123&#xD;&#xA;  [2]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [3]: http://i.stack.imgur.com/9p7tO.png&#xD;&#xA;  [4]: https://github.com/Robot-Will/Stino/pull/127&#xD;&#xA;  [5]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [6]: http://www.baeyens.it/eclipse/" />
  <row Id="1398" PostHistoryTypeId="5" PostId="451" RevisionGUID="70ed01d9-5f50-4025-ae12-688899f7d245" CreationDate="2014-02-28T23:29:46.973" UserId="86" Comment="edited body" Text="I recently wanted to do exactly this. Since there is no nice way to do so, I wound up [writing a patch][1] for the [Stino][2] sublime-text arduino plugin to do exactly this. It's subsequently been accepted, so it should be in any up-to-date Stino installs.&#xD;&#xA;&#xD;&#xA;This adds a new option to Stino:  &#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;Using this mode produces compilation results like the following:  &#xD;&#xA;&#xD;&#xA;For a Uno:&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 172 bytes (of a 32256 byte maximum, 0.53 percent).  &#xD;&#xA;&gt; Estimated memory use: 0 bytes (of a 1024 byte maximum, 0.00 percent).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;For a leonardo&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 240 bytes (of a 28672 byte maximum, 0.84 percent).  &#xD;&#xA;&gt; Estimated memory use: 0 bytes (of a 2560 byte maximum, 0.00 percent).&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Actually *programming* the leonardo with the above compiled output is *probably* a bad idea, as it *might* break the auto-reset functionality, but you *could*, if you wanted. Hat-tip to mpflaga for noting this in his answer.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;Note that the memory reports are actually incorrect, but that's a [separate issue][4].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The code used for the above is:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    int main()&#xD;&#xA;    {&#xD;&#xA;    	while (1)&#xD;&#xA;    	{&#xD;&#xA;    &#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Some notes:&#xD;&#xA;&#xD;&#xA; - You ain't writing a &quot;Sketch&quot; anymore, not that you ever actually *do* write a sketch. You write **programs**. Period. I don't care what the Arduino wackos want to say, they don't get to redefine terms.&#xD;&#xA; - All interrupt management is manual. This means no `milis()` or similar.&#xD;&#xA; - You *can* still use the arduino serial libraries and so forth, if you want. You do have to `#include &lt;Arduino.h&gt;`.&#xD;&#xA; - You define `main`. You don't ever return from `main`. If you want setup stuff, it goes before the `while (1)`.&#xD;&#xA; - If you're still using the arduino-sh**ty-flaming-pile-of-s**t editor/two-macro-buttons thing, you should switch. Have you tried [Stino][5]? Or ANYTHING else? Hell, even [Eclipse][6] is better (and that doesn't get said often).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/Robot-Will/Stino/pull/123&#xD;&#xA;  [2]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [3]: http://i.stack.imgur.com/9p7tO.png&#xD;&#xA;  [4]: https://github.com/Robot-Will/Stino/pull/127&#xD;&#xA;  [5]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [6]: http://www.baeyens.it/eclipse/" />
  <row Id="1399" PostHistoryTypeId="8" PostId="451" RevisionGUID="28805adc-882c-48dd-9719-e9d955a2ecb2" CreationDate="2014-02-28T23:47:38.417" UserId="42" Comment="Rollback to [aebd808a-8bd0-47bc-9154-03e4c0fcd041]" Text="I recently wanted to do exactly this. Since there is no nice way to do so, I wound up [writing a patch][1] for the [Stino][2] sublime-text arduino plugin to do exactly this. It's subsequently been accepted, so it should be in any up-to-date Stino installs.&#xD;&#xA;&#xD;&#xA;This adds a new option to Stino:  &#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;Using this mode produces compilation results like the following:  &#xD;&#xA;&#xD;&#xA;For a Uno:&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 172 bytes (of a 32256 byte maximum, 0.53 percent).  &#xD;&#xA;&gt; Estimated memory use: 0 bytes (of a 1024 byte maximum, 0.00 percent).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;For a leonardo&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 240 bytes (of a 28672 byte maximum, 0.84 percent).  &#xD;&#xA;&gt; Estimated memory use: 0 bytes (of a 2560 byte maximum, 0.00 percent).&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Actually *programming* the leonardo with the above compiled output is *probably* a bad idea, as it *might* break the auto-reset functionality, but you *could*, if you wanted. Hat-tip to mpflaga for noting this in his answer.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;Note that the memory reports are actually incorrect, but that's a [separate issue][4].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The code used for the above is:  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    int main()&#xD;&#xA;    {&#xD;&#xA;    	while (1)&#xD;&#xA;    	{&#xD;&#xA;    &#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Some notes:&#xD;&#xA;&#xD;&#xA; - You ain't writing a &quot;Sketch&quot; anymore, not that you ever actually *do* write a sketch. You write **programs**. Period. I don't care what the Arduino wackos want to say, they don't get to redefine terms.&#xD;&#xA; - All interrupt management is manual. This means no `milis()` or similar.&#xD;&#xA; - You *can* still use the arduino serial libraries and so forth, if you want. You do have to `#include &lt;Arduino.h&gt;`.&#xD;&#xA; - You define `main`. You don't ever return from `main`. If you want setup stuff, it goes before the `while (1)`.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/Robot-Will/Stino/pull/123&#xD;&#xA;  [2]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [3]: http://i.stack.imgur.com/9p7tO.png&#xD;&#xA;  [4]: https://github.com/Robot-Will/Stino/pull/127&#xD;&#xA;  [5]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [6]: http://www.baeyens.it/eclipse/" />
  <row Id="1400" PostHistoryTypeId="14" PostId="451" RevisionGUID="7512a2c0-3382-4226-9df5-a3916ef95be6" CreationDate="2014-02-28T23:48:33.633" UserId="42" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;}]}" />
  <row Id="1401" PostHistoryTypeId="33" PostId="451" RevisionGUID="1b49ee4a-507b-4196-ae56-848422c379f3" CreationDate="2014-02-28T23:48:33.633" UserId="42" Comment="2" />
  <row Id="1402" PostHistoryTypeId="5" PostId="518" RevisionGUID="6985175f-2829-417d-87ea-ab170caeb59a" CreationDate="2014-03-01T00:23:06.717" UserId="42" Comment="Added a missing word" Text="When reading/trying a [recent answer][1], I was surprised to see that Arduino's `String` class supports the `c_str()` method, just like the C++ `std::string` class. As expected, it appears to get a pointer to the string's contents as a null-terminated `char` array (i.e. C-style string).&#xD;&#xA;&#xD;&#xA;However, (as far as I can see) that method is not mentioned in the official Arduino documentation. Additionally, in all example code I've seen using `String`, a different approach seems to be used. A secondary `char` buffer is setup, and then the contents of the string are copied to it using [`String::toCharArray()`][2]. This obviously requires double the memory, plus an O(n) copy operation.&#xD;&#xA;&#xD;&#xA;It seems like `c_str()` should be the preferred approach. Is there some reason why `toCharArray()` is more commonly used?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/a/511/42&#xD;&#xA;  [2]: http://arduino.cc/en/Reference/StringToCharArray" />
  <row Id="1403" PostHistoryTypeId="5" PostId="484" RevisionGUID="138a326b-0e89-4e7f-8cec-05dad2c9de10" CreationDate="2014-03-01T00:23:36.040" UserId="220" Comment="deleted 33 characters in body; edited tags" Text="I want to make a HID device (preferably keyboard) using an Arduino.&#xD;&#xA;&#xD;&#xA; - **Method 1:** To me a preferred method would be to develop an actual Windows device driver so it's detected as a keyboard.&#xD;&#xA;&#xD;&#xA; - **Method 2:** At the moment I can have different buttons pressed on the Arduino return different values via serial. Using my current functionality could I write some software layer that could take my serial data and have Windows read it as hid input? If so how would I go about achieving something like this?" />
  <row Id="1404" PostHistoryTypeId="6" PostId="484" RevisionGUID="138a326b-0e89-4e7f-8cec-05dad2c9de10" CreationDate="2014-03-01T00:23:36.040" UserId="220" Comment="deleted 33 characters in body; edited tags" Text="&lt;arduino-uno&gt;&lt;serial&gt;" />
  <row Id="1405" PostHistoryTypeId="2" PostId="520" RevisionGUID="0a41b287-47ca-4adf-8d3a-fe8c65575101" CreationDate="2014-03-01T00:43:38.637" UserId="42" Text="Use this tag for any questions which relate directly to using text strings in Arduino programming, whether for input, output, storage, or transmission.&#xD;&#xA;&#xD;&#xA;This tag can cover any representation of a string which Arduino will support, including `char` arrays (null-terminated or otherwise), the Arduino `String` class, and the C++ `std::string` class." />
  <row Id="1406" PostHistoryTypeId="2" PostId="521" RevisionGUID="615c6ea8-be4e-4d76-b00e-47dc94e3e4f3" CreationDate="2014-03-01T00:43:38.637" UserId="42" Text="A sequence of characters -- including letters, numbers and symbols -- often used for representing information in a human-readable format." />
  <row Id="1407" PostHistoryTypeId="2" PostId="522" RevisionGUID="fe665251-d786-4155-b7cf-73e792d73e26" CreationDate="2014-03-01T00:52:47.303" UserId="8" Text="The Leonardo can easily be used as a keyboard. There are also special codes to turn the USB-to-Serial chip on newe Unos into a keyboard (see [here](http://www.fourwalledcubicle.com/LUFA.php))&#xD;&#xA;&#xD;&#xA;USB mass storage is another game all together. The [Brondani EasyUSB](https://www.sparkfun.com/products/10155) is a simple chip that exposes 2MB of storage space on both the USB and microcontroller. They say they will be releasing larger capacities.&#xD;&#xA;&#xD;&#xA;The easyUSB also has a serial link built into it from uC to computer.&#xD;&#xA;&#xD;&#xA;If you really want, you can make your own USB stack to handle this on you own, but the pitifully small amount of ram on these chips would prohibit it." />
  <row Id="1408" PostHistoryTypeId="10" PostId="484" RevisionGUID="385e0982-0308-4b0c-8172-0caeed0c1e70" CreationDate="2014-03-01T02:03:05.390" UserId="42" Comment="102" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:65,&quot;DisplayName&quot;:&quot;AsheeshR&quot;},{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;},{&quot;Id&quot;:37,&quot;DisplayName&quot;:&quot;The Guy with The Hat&quot;},{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;},{&quot;Id&quot;:8,&quot;DisplayName&quot;:&quot;TheDoctor&quot;}]}" />
  <row Id="1409" PostHistoryTypeId="5" PostId="47" RevisionGUID="118dbef3-026b-4bbb-bc48-a3b6ebb89540" CreationDate="2014-03-01T02:06:40.770" UserId="11" Comment="added 169 characters in body; deleted 81 characters in body" Text="Integrated Development Environment - software that allows you to write and compile code." />
  <row Id="1410" PostHistoryTypeId="5" PostId="46" RevisionGUID="1c14fa1f-fdc5-4b01-999e-8f6a802bde04" CreationDate="2014-03-01T02:07:05.553" UserId="11" Comment="added 84 characters in body" Text="The process of programming consists of several stages, including editing the source code, managing libraries and build events, compiling/linking the program (or sketch), and debugging the program when it is running. In the case of Arduino, it typically also involves uploading the sketch to a device.&#xD;&#xA;&#xD;&#xA;Each part of this process is often managed by a separate program. These are often command-line based, and can be quite difficult to learn. However, an Integrated Development Environment combines everything into one application, and often automates several common tasks. This simplifies the programmer's workflow, allowing him/her to focus more on the project at hand.&#xD;&#xA;&#xD;&#xA;The official [Arduino software][1] is a very light-weight IDE, based on the [Processing Development Environment][2]. It includes all of the essential functionality for writing and uploading Arduino sketches, but lacks several features which are found in more sophisticated applications.&#xD;&#xA;&#xD;&#xA;Many users prefer more mainstream IDEs, which can have plug-ins or extensions to support Arduino. This includes Eclipse, Visual Studio, and XCode. More information about alternative IDEs can be found on [this question][3].&#xD;&#xA;&#xD;&#xA;If the question is about the Official Arduino IDE use the [tag:arduino-ide] tag.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/Software&#xD;&#xA;  [2]: http://www.processing.org/&#xD;&#xA;  [3]: http://arduino.stackexchange.com/questions/40/what-are-the-other-ides-for-arduino" />
  <row Id="1413" PostHistoryTypeId="2" PostId="523" RevisionGUID="9981dcb7-6d88-4a22-8f34-9ee2ea4fe1f0" CreationDate="2014-03-01T02:09:12.767" UserId="11" Text="A microcontroller board based on the ATmega1280 chip. More information on the official Arduino Website: [Arduino Mega][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/arduinoBoardMega" />
  <row Id="1414" PostHistoryTypeId="2" PostId="524" RevisionGUID="67ccca9b-63c7-4cb6-96f6-51e3bdafa022" CreationDate="2014-03-01T02:09:12.767" UserId="11" Comment="added 96 characters in body" Text="A microcontroller board based on the ATmega1280 chip. Use this tag for questions specifically regarding the Mega, and not just general Arduino usage." />
  <row Id="1415" PostHistoryTypeId="2" PostId="525" RevisionGUID="f6544398-bd1c-40bd-a925-910a7c9b3ff8" CreationDate="2014-03-01T02:53:30.003" UserId="306" Text="Can someone help me understand how the external antenna IPX connector actually stays connected to the Yun? Do I have to &quot;force&quot; it in so it snaps in? I've been somewhat gentle with it in fear I'll break something. However when I get close to getting it in, it just pops back out. &#xD;&#xA;&#xD;&#xA;I've never worked with an IPX connector before, and I'm trying to not break anything. &#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/nadBC.jpg" />
  <row Id="1416" PostHistoryTypeId="1" PostId="525" RevisionGUID="f6544398-bd1c-40bd-a925-910a7c9b3ff8" CreationDate="2014-03-01T02:53:30.003" UserId="306" Text="Arduino Yun external antenna" />
  <row Id="1417" PostHistoryTypeId="3" PostId="525" RevisionGUID="f6544398-bd1c-40bd-a925-910a7c9b3ff8" CreationDate="2014-03-01T02:53:30.003" UserId="306" Text="&lt;arduino-yun&gt;&lt;wifi&gt;" />
  <row Id="1418" PostHistoryTypeId="5" PostId="525" RevisionGUID="c3c43ccf-bafc-4e7d-90ba-7cd58002f49b" CreationDate="2014-03-01T03:06:52.800" UserId="306" Comment="Found adafruit link" Text="Can someone help me understand how the external antenna IPX connector actually stays connected to the Yun? Do I have to &quot;force&quot; it in so it snaps in? I've been somewhat gentle with it in fear I'll break something. However when I get close to getting it in, it just pops back out. &#xD;&#xA;&#xD;&#xA;I've never worked with an IPX connector before, and I'm trying to not break anything. &#xD;&#xA;&#xD;&#xA;EDIT: I may have figured this out. Looks like the socket on the Yun is an IPEX socket, which is female. The cable I have is an IPX/uFL/u.FL connector, which also appears to be female. &#xD;&#xA;&#xD;&#xA;It looks like I need to use an MCX cable adapter as found here: http://www.adafruit.com/products/1532 If someone could confirm this for me, that'd be great. &#xD;&#xA;&#xD;&#xA;Here's a picture of the cable I purchased and my Yun. &#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/nadBC.jpg" />
  <row Id="1419" PostHistoryTypeId="2" PostId="526" RevisionGUID="9f15dd1c-0922-403b-9e7f-d1f907fc3a33" CreationDate="2014-03-01T03:21:43.237" UserId="11" Text="There's a discussion on the Arduino Forum about this:&#xD;&#xA;&#xD;&#xA;[Mystery component on Yun board?][1]&#xD;&#xA;&#xD;&#xA;From what I read it's only for testing purposes.&#xD;&#xA;&#xD;&#xA;&gt; the connector is a MM8430-2610 ([see this][2]). You can plug in a&#xD;&#xA;&gt; MXGS83RK3000/MM126036: once plugged in, the switch connector will turn&#xD;&#xA;&gt; the internal antenna off and use the probe as an external antenna&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://forum.arduino.cc/index.php?topic=188976.0&#xD;&#xA;  [2]: http://www.murata.com/products/catalog/pdf/o33e.pdf" />
  <row Id="1422" PostHistoryTypeId="2" PostId="527" RevisionGUID="937b35ab-0c89-4307-a429-fe7f74d0dbf0" CreationDate="2014-03-01T04:35:24.260" UserId="8" Text="Testing with my Yún, it took quite a bit of force to install the connector. I had to use pliers to get extra leverage, but it eventually snapped in place." />
  <row Id="1423" PostHistoryTypeId="5" PostId="515" RevisionGUID="b9eb7cca-0a82-4006-96a2-f98ffa40d9ae" CreationDate="2014-03-01T05:03:07.383" UserId="65" Comment="added 225 characters in body" Text="A sensor is a converter that measures a physical quantity and converts it into an analog or digital signal which can be read by an Arduino. Use this tag for questions about selecting, connecting, using, and debugging sensors." />
  <row Id="1424" PostHistoryTypeId="24" PostId="515" RevisionGUID="b9eb7cca-0a82-4006-96a2-f98ffa40d9ae" CreationDate="2014-03-01T05:03:07.383" Comment="Proposed by 65 approved by 11 edit id of 179" />
  <row Id="1425" PostHistoryTypeId="2" PostId="528" RevisionGUID="37b8a591-d7a7-4d28-afae-bb3a50c2fcf2" CreationDate="2014-03-01T06:04:16.750" UserId="-1" Text="" />
  <row Id="1426" PostHistoryTypeId="2" PostId="529" RevisionGUID="c3eb612c-83c9-497f-a1e5-80450c8049fd" CreationDate="2014-03-01T06:04:16.750" UserId="-1" Text="" />
  <row Id="1427" PostHistoryTypeId="5" PostId="217" RevisionGUID="bb483140-954c-436c-be6b-2be18a9177d7" CreationDate="2014-03-01T06:15:05.257" UserId="65" Comment="added 160 characters in body" Text="PWM is a form of signal modulation that allows digital output to approximate an analog signal. Use this for questions about using the PWM pins (marked with ~). " />
  <row Id="1428" PostHistoryTypeId="24" PostId="217" RevisionGUID="bb483140-954c-436c-be6b-2be18a9177d7" CreationDate="2014-03-01T06:15:05.257" Comment="Proposed by 65 approved by 11 edit id of 180" />
  <row Id="1429" PostHistoryTypeId="5" PostId="529" RevisionGUID="bd3b6c30-aaaf-491a-a25a-3fa31d80d00b" CreationDate="2014-03-01T06:15:32.667" UserId="65" Comment="added 185 characters in body" Text="Or Electronically Erasable ROM, is a type of memory available on most boards. It is used for storing persistent data. Use the tag for questions about the EEPROM library or the hardware." />
  <row Id="1430" PostHistoryTypeId="24" PostId="529" RevisionGUID="bd3b6c30-aaaf-491a-a25a-3fa31d80d00b" CreationDate="2014-03-01T06:15:32.667" Comment="Proposed by 65 approved by -1 edit id of 181" />
  <row Id="1431" PostHistoryTypeId="5" PostId="529" RevisionGUID="44267ae8-b21a-401a-8635-d5f74887ac24" CreationDate="2014-03-01T06:15:32.667" UserId="11" Comment="deleted 4 characters in body" Text="Electronically Erasable ROM is a type of memory available on most boards. It is used for storing persistent data. Use the tag for questions about the EEPROM library or the hardware." />
  <row Id="1432" PostHistoryTypeId="2" PostId="530" RevisionGUID="4192cd41-aa9b-49c5-85fa-9364163ccce3" CreationDate="2014-03-01T07:41:53.223" UserId="11" Text="" />
  <row Id="1433" PostHistoryTypeId="2" PostId="531" RevisionGUID="1a10f550-716a-4c7d-8883-9bf1c59f136e" CreationDate="2014-03-01T07:41:53.223" UserId="11" Text="WiFi allows devices to wirelessly connect to a network, and the Internet. Use this tag for questions relating to connecting your Arduino to a WiFi network." />
  <row Id="1434" PostHistoryTypeId="2" PostId="532" RevisionGUID="d5f5733d-4dc8-46c5-b825-e5d9b77c4091" CreationDate="2014-03-01T09:46:43.670" UserId="136" Text="I've used enough products with embedded microcontrollers and unresponsive UIs to know that it can make or break a product. Even a slight delay or lag between the button presses and the display updating, or button presses being ignored or double counted, can be extremely frustrating.&#xD;&#xA;&#xD;&#xA;What design patterns can be used to deal with user input (from buttons) and updating displays without causing these issues?&#xD;&#xA;&#xD;&#xA;I currently use the following kind of pattern (this is simplified down to the bare minimum):&#xD;&#xA;&#xD;&#xA;    #include &lt;Bounce.h&gt;&#xD;&#xA;    &#xD;&#xA;    #define GREEN_LED 		6 // Pin for green LED&#xD;&#xA;    &#xD;&#xA;    #define BUTTON_PIN 		15 // Pin for button - uses external pull down so active high&#xD;&#xA;    &#xD;&#xA;    #define DISPLAY_REFRESH_INT 100 // How many MS between display updates&#xD;&#xA;    &#xD;&#xA;    Bounce button = Bounce(BUTTON_PIN, 5);&#xD;&#xA;    &#xD;&#xA;    // To signal between the button read and the display update&#xD;&#xA;    bool ledState = false;&#xD;&#xA;    &#xD;&#xA;    // Used to keep track of last display update&#xD;&#xA;    long displayUpdate = 0;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    	pinMode(GREEN_LED, OUTPUT);&#xD;&#xA;    	pinMode(BUTTON_PIN, INPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    	// Read the button status&#xD;&#xA;    	if (button.update())&#xD;&#xA;    	{&#xD;&#xA;    		if (button.risingEdge())&#xD;&#xA;    		{&#xD;&#xA;    			ledState = !ledState;&#xD;&#xA;    		}&#xD;&#xA;    	}&#xD;&#xA;    	&#xD;&#xA;    	// Update the display periodically&#xD;&#xA;    	if (millis() - displayUpdate &gt; DISPLAY_REFRESH_INT)&#xD;&#xA;    	{&#xD;&#xA;    		displayUpdate = millis();&#xD;&#xA;    &#xD;&#xA;    		digitalWrite(GREEN_LED, ledState);&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;What other options are there? Is it ever worth using pin change interrupts to read buttons (if we are not considering battery life!)." />
  <row Id="1435" PostHistoryTypeId="1" PostId="532" RevisionGUID="d5f5733d-4dc8-46c5-b825-e5d9b77c4091" CreationDate="2014-03-01T09:46:43.670" UserId="136" Text="What design patterns can I use to handle user input and display updating?" />
  <row Id="1436" PostHistoryTypeId="3" PostId="532" RevisionGUID="d5f5733d-4dc8-46c5-b825-e5d9b77c4091" CreationDate="2014-03-01T09:46:43.670" UserId="136" Text="&lt;button&gt;&lt;ui&gt;&lt;display&gt;" />
  <row Id="1437" PostHistoryTypeId="2" PostId="533" RevisionGUID="38c54404-3ff3-4600-8901-3d7f24d8ac30" CreationDate="2014-03-01T10:00:28.807" UserId="136" Text="These are two ways I can hold a variable outside of loop (or any function).&#xD;&#xA;&#xD;&#xA;First, I can declare it with global scope outside of loop:&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    	Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int count = 0;&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    	Serial.println(count);&#xD;&#xA;    	count++;&#xD;&#xA;    &#xD;&#xA;    	delay(250);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I can also declare it static inside the loop:&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    	Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    	static int count = 0;&#xD;&#xA;    &#xD;&#xA;    	Serial.println(count);&#xD;&#xA;    	count++;&#xD;&#xA;    &#xD;&#xA;    	delay(250);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;What difference, if any, will this make?" />
  <row Id="1438" PostHistoryTypeId="1" PostId="533" RevisionGUID="38c54404-3ff3-4600-8901-3d7f24d8ac30" CreationDate="2014-03-01T10:00:28.807" UserId="136" Text="What is the difference between declaring a variable outside of loop and declaring static inside loop?" />
  <row Id="1439" PostHistoryTypeId="3" PostId="533" RevisionGUID="38c54404-3ff3-4600-8901-3d7f24d8ac30" CreationDate="2014-03-01T10:00:28.807" UserId="136" Text="&lt;programming&gt;" />
  <row Id="1440" PostHistoryTypeId="2" PostId="534" RevisionGUID="cabc7fcc-e50d-4e37-bebb-3fdbc3650baa" CreationDate="2014-03-01T10:41:45.680" UserId="378" Text="According to Atmel's documentation: &quot;If a global variable is declared, a unique address in the SRAM will be assigned to this variable at program link time.&quot;&#xD;&#xA;&#xD;&#xA;The complete documetation is here (Tip #2 for global variables): http://www.atmel.com/images/doc8453.pdf&#xD;&#xA;" />
  <row Id="1441" PostHistoryTypeId="2" PostId="535" RevisionGUID="63f70877-779c-4e7b-aca3-cfad1a37ca47" CreationDate="2014-03-01T10:45:19.803" UserId="65" Text="The most basic difference is of scope.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;In the first case, you are declaring a global variable. It is a variable that is accessible in every scope after its definition.&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void inc();&#xD;&#xA;    int count = 0;&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        Serial.println(count);&#xD;&#xA;        count++;&#xD;&#xA;        &#xD;&#xA;        inc();&#xD;&#xA;    &#xD;&#xA;        delay(500);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void inc() //Can edit the value of count&#xD;&#xA;    {&#xD;&#xA;      count=count+1;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;In the second case, you are declaring a static variable with local scope. The variable will persist for the entire program run similar to global variables, but will be accessible only in the code block it is declared in. This is the same example, with only one change. `count` is now declared as a static variable inside `loop`.&#xD;&#xA;&#xD;&#xA;    void inc();&#xD;&#xA;        &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        static int count = 0;&#xD;&#xA;        Serial.println(count);&#xD;&#xA;        count++;&#xD;&#xA;        &#xD;&#xA;        inc();&#xD;&#xA;    &#xD;&#xA;        delay(500);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;This will not compile as the function `inc()` does not have access to `count`." />
  <row Id="1442" PostHistoryTypeId="2" PostId="536" RevisionGUID="eb9dbd4a-3d81-4831-9313-84014899e831" CreationDate="2014-03-01T10:49:55.183" UserId="275" Text="From a functional perspective, both versions generate the same result, since in both cases the value of `count` is stored between the executions of the `loop()` (either because it is a global variable or because it is marked as `static` and therefore keeps its value).&#xD;&#xA;&#xD;&#xA;So the decision which to choose come down to following arguments:&#xD;&#xA;&#xD;&#xA; 1. Generally, in computer science, it is thought to keep your variables as local as possible in terms of **scope**. This usually results in much clearer code with less side-effects and reduces chances of someone else using that global variable screwing up your logic).&#xD;&#xA; 2. Global variables always occupy **memory**, where as locals only do when they are in scope. In your above simple example that makes no real difference, but in bigger and more complex programs it might.&#xD;&#xA; 3. Other points such as better layout for **static analysis** or **optimization** by the compiler might also come into play.&#xD;&#xA; 4. In some special scenarios, there might be issues with reentrancy or the unpredictable initialization order of static elements (not sure about that point, compare this [link][1] though).&#xD;&#xA;&#xD;&#xA;Source: [Similar thread][2] on arduino.cc&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://forum.arduino.cc/index.php?PHPSESSID=nt8h6685309s1vv0voea1rbkd5&amp;topic=74180.msg559158#msg559158&#xD;&#xA;  [2]: http://forum.arduino.cc/index.php?PHPSESSID=i4sdu9bn0f8u2jekn5tl5pbeo1&amp;topic=74180.msg559208#msg559208" />
  <row Id="1443" PostHistoryTypeId="5" PostId="535" RevisionGUID="5004f23c-ca32-4c41-a9f8-c6b08f029372" CreationDate="2014-03-01T11:09:53.580" UserId="65" Comment="added 854 characters in body" Text="The most basic difference is of scope.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;In the first case, you are declaring a global variable. It is a variable that is accessible in every scope after its definition.&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void inc();&#xD;&#xA;    int count = 0;&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        Serial.println(count);&#xD;&#xA;        count++;&#xD;&#xA;        &#xD;&#xA;        inc();&#xD;&#xA;    &#xD;&#xA;        delay(500);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void inc() //Can edit the value of count&#xD;&#xA;    {&#xD;&#xA;      count=count+1;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;In the second case, you are declaring a static variable with local scope. The variable will persist for the entire program run similar to global variables, but will be accessible only in the code block it is declared in. This is the same example, with only one change. `count` is now declared as a static variable inside `loop`.&#xD;&#xA;&#xD;&#xA;    void inc();&#xD;&#xA;        &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        static int count = 0;&#xD;&#xA;        Serial.println(count);&#xD;&#xA;        count++;&#xD;&#xA;        &#xD;&#xA;        inc();&#xD;&#xA;    &#xD;&#xA;        delay(500);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;This will not compile as the function `inc()` does not have access to `count`.&#xD;&#xA;&#xD;&#xA;Global variables, however seemingly useful, come with some pitfalls. These can even cause damage when it comes to writing programs that can interact with the physical surroundings. This a very basic example of something that is quite likely to happen, as soon as programs start getting larger. A function may inadvertently change the state of a global variable.&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    void another_function();&#xD;&#xA;    int state=0;&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        //Keep toggling the state&#xD;&#xA;        Serial.println(state);&#xD;&#xA;        delay(250);&#xD;&#xA;        state=state?0:1;&#xD;&#xA;        &#xD;&#xA;        //Some unrelated function call&#xD;&#xA;        another_function();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void another_function()&#xD;&#xA;    {&#xD;&#xA;      //Inadvertently changes state&#xD;&#xA;      state=1;&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Such cases are very hard to debug. *This* type of problem however, can easily be detected, by simply using a static variable.&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    void another_function();&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        static int state=0;&#xD;&#xA;&#xD;&#xA;        //Keep toggling the state&#xD;&#xA;        Serial.println(state);&#xD;&#xA;        delay(250);&#xD;&#xA;        state=state?0:1;&#xD;&#xA;        &#xD;&#xA;        //Some unrelated function call&#xD;&#xA;        another_function();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void another_function()&#xD;&#xA;    {&#xD;&#xA;      //Results in a compile time error. Saves time.&#xD;&#xA;      state=1;&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="1444" PostHistoryTypeId="5" PostId="536" RevisionGUID="294e3290-29f0-4b7e-839c-807340bb9c14" CreationDate="2014-03-01T11:16:09.533" UserId="275" Comment="added 12 characters in body" Text="From a functional perspective, both versions generate the same result, since in both cases the value of `count` is stored between the executions of the `loop()` (either because it is a global variable or because it is marked as `static` and therefore keeps its value).&#xD;&#xA;&#xD;&#xA;So the decision which to choose come down to following arguments:&#xD;&#xA;&#xD;&#xA; 1. Generally, in computer science, it is thought to keep your variables as local as possible in terms of **scope**. This usually results in much clearer code with less side-effects and reduces chances of someone else using that global variable screwing up your logic).&#xD;&#xA; 2. Global variables always occupy **memory**, where as locals only do when they are in scope. In your above simple example that makes no real difference, but in bigger and more complex programs it might.&#xD;&#xA; 3. Other points such as better layout for **static analysis** or **optimization** by the compiler might also come into play.&#xD;&#xA; 4. In some special scenarios, there might be issues with the unpredictable initialization order of static elements (not sure about that point, compare this [link][1] though).&#xD;&#xA;&#xD;&#xA;Source: [Similar thread][2] on arduino.cc&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://forum.arduino.cc/index.php?PHPSESSID=nt8h6685309s1vv0voea1rbkd5&amp;topic=74180.msg559158#msg559158&#xD;&#xA;  [2]: http://forum.arduino.cc/index.php?PHPSESSID=i4sdu9bn0f8u2jekn5tl5pbeo1&amp;topic=74180.msg559208#msg559208" />
  <row Id="1445" PostHistoryTypeId="5" PostId="536" RevisionGUID="a4013427-f568-478a-833b-f3346aac3414" CreationDate="2014-03-01T11:23:39.563" UserId="275" Comment="added note about balance between memory usage and performance" Text="From a functional perspective, both versions generate the same result, since in both cases the value of `count` is stored between the executions of the `loop()` (either because it is a global variable or because it is marked as `static` and therefore keeps its value).&#xD;&#xA;&#xD;&#xA;So the decision which to choose come down to following arguments:&#xD;&#xA;&#xD;&#xA; 1. Generally, in computer science, it is thought to keep your variables as local as possible in terms of **scope**. This usually results in much clearer code with less side-effects and reduces chances of someone else using that global variable screwing up your logic).&#xD;&#xA; 2. Global variables always occupy **memory**, where as locals only do when they are in scope. In your above simple example that makes no real difference, but in bigger and more complex programs it might and you could save memory. &#xD;&#xA;*However*: If you have a variable in a logic area that is executed very often, consider making it either static or global, since&#xD;&#xA;    otherwise you loose a tiny bit of performance each time that logic&#xD;&#xA;    area is entered since it takes a bit of time to allocate the memory&#xD;&#xA;    for that new variable instance. You need to find a balance between memory load and performance.&#xD;&#xA; 4. Other points such as better layout for **static analysis** or **optimization** by the compiler might also come into play.&#xD;&#xA; 5. In some special scenarios, there might be issues with the unpredictable initialization order of static elements (not sure about that point, compare this [link][1] though).&#xD;&#xA;&#xD;&#xA;Source: [Similar thread][2] on arduino.cc&#xD;&#xA;&#xD;&#xA;  [1]: http://forum.arduino.cc/index.php?PHPSESSID=nt8h6685309s1vv0voea1rbkd5&amp;topic=74180.msg559158#msg559158&#xD;&#xA;  [2]: http://forum.arduino.cc/index.php?PHPSESSID=i4sdu9bn0f8u2jekn5tl5pbeo1&amp;topic=74180.msg559208#msg559208" />
  <row Id="1446" PostHistoryTypeId="2" PostId="537" RevisionGUID="88e68cc1-7cf7-401e-84b1-4c683b1de626" CreationDate="2014-03-01T11:50:10.063" UserId="42" Text="The answer depends on exactly how the sketch is meant to respond to the user interaction.&#xD;&#xA;&#xD;&#xA;**External interrupts**  &#xD;&#xA;If the interaction depends on responding very accurately to the rising or falling edge of an input event (as in your example), then an [external interrupt][1] may be the way to go, if possible.&#xD;&#xA;&#xD;&#xA;This is particularly important if the input event might be shorter that the duration of a call to `loop()`. If that happens, consecutive attempts to poll the input could completely miss the state change. It's quite rare for a user input event to be that short though, unless `loop()` is quite slow to execute.&#xD;&#xA;&#xD;&#xA;External hardware to get help that though, e.g. by having an input which latches until it is read and reset by the microcontroller.&#xD;&#xA;&#xD;&#xA;**Improving polling frequency**  &#xD;&#xA;External interrupts often aren't possible (e.g. because the chip only supports a limited number), or they are simply overkill/unnecessary for a given application.&#xD;&#xA;&#xD;&#xA;In those cases, it may still be possible to improve the timing precision when using polling. One option is to split up all the different parts of the main loop into separate functions. On each successive iteration of `loop()`, it will call the next function, and then wrap round to the first. In between each of those functions, it can poll the button. Here's a simple example:&#xD;&#xA;&#xD;&#xA;    unsigned int g_section = 0;&#xD;&#xA;&#xD;&#xA;    void setup() { }&#xD;&#xA;&#xD;&#xA;    void pollButton()&#xD;&#xA;    {&#xD;&#xA;        //...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void runSection0()&#xD;&#xA;    {&#xD;&#xA;        //...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void runSection1()&#xD;&#xA;    {&#xD;&#xA;        //...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void runSection2()&#xD;&#xA;    {&#xD;&#xA;        //...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        // Poll the button on every pass:&#xD;&#xA;        pollButton();&#xD;&#xA;&#xD;&#xA;        // Execute the next section of the main code:&#xD;&#xA;        switch (g_section)&#xD;&#xA;        {&#xD;&#xA;        case 0: runSection0(); break;&#xD;&#xA;        case 1: runSection1(); break;&#xD;&#xA;        case 2: runSection2(); break;&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        // On the next iteration, run the next section:&#xD;&#xA;        if (++g_section &gt; 2) g_section = 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;One important issue with this approach is that it's very difficult to make each of those `runSectionX()` functions take the same execution time. That can result in the button being polled inconsistently from one iteration to the next. If it's fast enough though, then it shouldn't be too big of a problem.&#xD;&#xA;&#xD;&#xA;**Display update**  &#xD;&#xA;Updating a display is unfortunately often quite slow, compared to many other operations. That means you need to be quite careful where you do it. Inside an Interrupt Service Routine often wouldn't be appropriate, as that could introduce other timing issues in your sketch.&#xD;&#xA;&#xD;&#xA;Realistically, you'd have to do it in the main loop. If you absolutely have to run it quickly though, then it can be included in the faster polling example I've given above -- i.e. update the display on every iteration, the same as polling. You have to be careful to avoid partial updates though.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/questions/316/can-a-function-be-called-automatically-when-an-input-changes/317#317" />
  <row Id="1447" PostHistoryTypeId="5" PostId="508" RevisionGUID="26ea52d1-d063-45ef-bafa-b7f037540308" CreationDate="2014-03-01T13:17:26.133" UserId="220" Comment="deleted 114 characters in body; edited title" Text="I have an object with a series of led and I want to turn on and off these leds from my Arduino. The input of the LED circuit is 24v DC 100mA.&#xD;&#xA;&#xD;&#xA;What I've done is the following:&#xD;&#xA;&#xD;&#xA;- I've cut a wire of this object and I connected one end to the collector and the other end to the emitter of a NPN transistor&#xD;&#xA;- I connected the base of the transistor to a digital output (through a 1k resistance)&#xD;&#xA;- I connected the power to the led series while the digital pin was LOW (actually completely disconnected)&#xD;&#xA;&#xD;&#xA;**But with no current on the base of the transistor, the LED has turned on to my surprise.** I may have completely misused the transistor and other items. How do I fix this circuit?" />
  <row Id="1448" PostHistoryTypeId="4" PostId="508" RevisionGUID="26ea52d1-d063-45ef-bafa-b7f037540308" CreationDate="2014-03-01T13:17:26.133" UserId="220" Comment="deleted 114 characters in body; edited title" Text="How to switch an external circuit with Arduino?" />
  <row Id="1449" PostHistoryTypeId="6" PostId="57" RevisionGUID="a218ad11-ebb0-40d7-bd2a-98879fea9991" CreationDate="2014-03-01T13:22:38.130" UserId="220" Comment="edited tags" Text="&lt;web-service&gt;" />
  <row Id="1450" PostHistoryTypeId="6" PostId="203" RevisionGUID="4464ef17-809c-40a8-9129-20acb56c9a9a" CreationDate="2014-03-01T13:23:17.863" UserId="220" Comment="edited tags" Text="&lt;serial&gt;" />
  <row Id="1451" PostHistoryTypeId="6" PostId="36" RevisionGUID="5f87dfc9-05e0-4735-8181-7292ce4336fa" CreationDate="2014-03-01T13:23:29.430" UserId="220" Comment="edited tags" Text="&lt;web-service&gt;" />
  <row Id="1452" PostHistoryTypeId="2" PostId="538" RevisionGUID="f5a8fd19-12f6-493b-acf9-fde48f58f33b" CreationDate="2014-03-01T13:55:11.313" UserId="379" Text="&gt; It seems like `c_str()` should be the preferred approach. Is there some reason why `toCharArray()` is more commonly used?&#xD;&#xA;&#xD;&#xA;basically, I'd say it's a lack of knowledge from the people doing the codes you've seen. Definitely `c_str()` is better. Though, what I see even more often is the use of character arrays `char*` strings instead of `String` (and I plead guilty of that as well in my own codes).&#xD;&#xA;&#xD;&#xA;And that's because the Arduino library has been built upon a messy set of C and C++ libraries and coding style. Trying to make things easier actually messed them up and complicated them more.&#xD;&#xA;&#xD;&#xA;That's actually why we have new projects like [xpcc][1] trying to make a real and smart use of the C++ abilities in the embedded world.&#xD;&#xA;&#xD;&#xA;[1]:http://xpcc.kreatives-chaos.com" />
  <row Id="1453" PostHistoryTypeId="5" PostId="484" RevisionGUID="2bcb4f79-b78c-4751-b74e-b751b3b4cd05" CreationDate="2014-03-01T14:54:43.380" UserId="379" Comment="rewrote the OP's question so it is open to better answers" Text="Is it possible to build a HID device (like a keyboard) using an Arduino uno?&#xD;&#xA;&#xD;&#xA;At the time being, I have button inputs on the Arduino giving outputs on the serial line. So, how can I transform my current firmware into something that can behave like a HID keyboard?&#xD;&#xA;&#xD;&#xA; - Shall I write a new window device driver?&#xD;&#xA; - Shall I create a software layer that could take my serial data and have windows read it as HID input?&#xD;&#xA; - Is there any better way to achieve this, if it is possible at all?" />
  <row Id="1454" PostHistoryTypeId="24" PostId="484" RevisionGUID="2bcb4f79-b78c-4751-b74e-b751b3b4cd05" CreationDate="2014-03-01T14:54:43.380" Comment="Proposed by 379 approved by 220 edit id of 182" />
  <row Id="1455" PostHistoryTypeId="2" PostId="539" RevisionGUID="b9355bb8-3f44-48a3-9ceb-a99031412e0f" CreationDate="2014-03-01T15:13:27.810" UserId="381" Text="I have 2 Lowpowerlab WaterMote's talking to each other using the 'out of the box' pre-installed sketch that just confirm they're talking to each other. I verified this by opening a COM connection and saw traffic of 'receiving packets...' That was just to show that they are functioning and talking to each other.&#xD;&#xA;&#xD;&#xA;Now, using Arduino IDE on OSX 1.9.x (Lion?) I have loaded the WaterMote sketch (found in Github) on the Moteino with the sensor (not the gateway) as it should be. The traffic looks like its working, except the text being transmitted (number of Gallons) stays the same at 0.02 Gallons.&#xD;&#xA;&#xD;&#xA;SO... I want to Debug the WaterMote sketch, BUT I do not see an option in my Arduino IDE on Mac OSX. Is there a way to debug sketches using Macs? Searching online shows various and preferred options, but mostly on Windows (which I dont have any at home).&#xD;&#xA;&#xD;&#xA;My current setup&#xD;&#xA;&#xD;&#xA; - Moteino Gateway (as out of the box) connected to a Raspberry Pi (with ssh enabled)&#xD;&#xA;  - connected via USB to the RasPi&#xD;&#xA; - Moteino with WaterMote sketch loaded&#xD;&#xA;  - connected via USB to the Macbook Pro&#xD;&#xA;  - Arduino IDE running, but I see strange &quot;[][][]&quot; square output in the Serial connection.&#xD;&#xA;  - I do not know what to make of this since that text is not in the WaterMote sketch.&#xD;&#xA;&#xD;&#xA;Is there a way to debug sketches loaded on Arduino clones using Arduino IDE on Macs?&#xD;&#xA;" />
  <row Id="1456" PostHistoryTypeId="1" PostId="539" RevisionGUID="b9355bb8-3f44-48a3-9ceb-a99031412e0f" CreationDate="2014-03-01T15:13:27.810" UserId="381" Text="How to Debug Arduino sketch on MAC?" />
  <row Id="1457" PostHistoryTypeId="3" PostId="539" RevisionGUID="b9355bb8-3f44-48a3-9ceb-a99031412e0f" CreationDate="2014-03-01T15:13:27.810" UserId="381" Text="&lt;ide&gt;" />
  <row Id="1458" PostHistoryTypeId="2" PostId="540" RevisionGUID="839e5120-1b0a-490e-8175-1304a01325d3" CreationDate="2014-03-01T15:48:15.247" UserId="379" Text="&gt; So... I want to Debug the WaterMote sketch, BUT I do not see an option in my Arduino IDE on Mac OSX. Is there a way to debug sketches using Macs? Searching online shows various and preferred options, but mostly on Windows (which I dont have any at home).&#xD;&#xA;&#xD;&#xA;it's definitely possible to debug a sketch with OSX. But it's definitely an advanced AVR topic, and if you're not experienced enough with embedded programming you should first try to avoid it, except if it is really necessary.&#xD;&#xA;&#xD;&#xA;Debugging a sketch for an Atmega328 implies:&#xD;&#xA;&#xD;&#xA; - running a flasher such as the AVR Dragon, the JTAG ICE 3, the STK500 or the AVR ONE, no cheap flasher implements the `DebugWire` protocol ;&#xD;&#xA; - setting up the debug fuse, which is an operation that can brick your MCU&#xD;&#xA;&#xD;&#xA;If you're using an Atmega32u4 (or alike), you won't be able to do it out of the box, as the 32u4 need a JTAG connection for On Chip Debug.&#xD;&#xA;&#xD;&#xA;Finally, once you got through that, you can bind a `gdb` to the AVR using [avarice](http://avarice.sf.net). I'm not getting you through all that, because I really, really, strongly advise you not to do it until you're experienced enough to know what you're doing.&#xD;&#xA;&#xD;&#xA;&gt;    Moteino with WaterMote sketch loaded&#xD;&#xA;&gt;        connected via USB to the Macbook Pro&#xD;&#xA;&gt;        Arduino IDE running, but I see strange &quot;[][][]&quot; square output in the Serial connection.&#xD;&#xA;&gt;        I do not know what to make of this since that text is not in the WaterMote sketch.&#xD;&#xA;&gt; Is there a way to debug sketches loaded on Arduino clones using Arduino IDE on Macs?&#xD;&#xA;&#xD;&#xA;It is very likely you did not setup the correct baudrate for Serial outputs. Arduino IDE defaults to 9600bps connections, whereas the [watermote source code](https://github.com/LowPowerLab/WaterMote/blob/master/WaterMote.ino#L31) defines a 115200bps connection. When you open the `Serial Monitor` change the setting at the right of the status bar.&#xD;&#xA;&#xD;&#xA;And finally, be sure to uncomment the [`#define SERIAL_EN` line](https://github.com/LowPowerLab/WaterMote/blob/master/WaterMote.ino#L30) to enable the serial communication and debug outputs." />
  <row Id="1459" PostHistoryTypeId="11" PostId="484" RevisionGUID="156a9ce5-4065-423e-ada4-41055388c785" CreationDate="2014-03-01T16:04:14.553" UserId="220" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:65,&quot;DisplayName&quot;:&quot;AsheeshR&quot;},{&quot;Id&quot;:220,&quot;DisplayName&quot;:&quot;Annonomus Person&quot;}]}" />
  <row Id="1460" PostHistoryTypeId="2" PostId="541" RevisionGUID="2a6017ca-2867-48fe-9ffd-d03e002c337f" CreationDate="2014-03-01T16:15:11.903" UserId="379" Text="&gt; Is it possible to build a HID device (like a keyboard) using an Arduino uno?&#xD;&#xA;&#xD;&#xA;yes it is! And there's a great tutorial on how to do that over [here][1]&#xD;&#xA;&#xD;&#xA;&gt; At the time being, I have button inputs on the Arduino giving outputs on the&#xD;&#xA;&gt; serial line. So, how can I transform my current firmware into something that&#xD;&#xA;&gt; can behave like a HID keyboard?&#xD;&#xA;&#xD;&#xA;As the tutorial shows you, you need to transform your firmware code so instead of&#xD;&#xA;printing the events, you actually trigger events. What you need to do, is add to your&#xD;&#xA;code:&#xD;&#xA;&#xD;&#xA;    void triggerKey(uint8_t mod, uint8_t chr) {&#xD;&#xA;        uint8_t buf[8] = {mod, chr, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};&#xD;&#xA;        // press key&#xD;&#xA;        Serial.write(buf, 8);&#xD;&#xA;        // emulate key press delay&#xD;&#xA;        delay(10);&#xD;&#xA;        buf[1] = 0x00;&#xD;&#xA;        // release key&#xD;&#xA;        Serial.write(buf, 8);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;What you're doing here, is send from your main Arduino microcontroller events over&#xD;&#xA;the serial line to the smaller microcontroller that handles USB communication. That&#xD;&#xA;microcontroller will take those key &quot;buffers&quot; and transfer them as USB HID Keyboard&#xD;&#xA;key presses over USB.&#xD;&#xA;&#xD;&#xA;Beware that the key character (`chr` in the code here), is actually a keycode sent&#xD;&#xA;over USB that gets interpreted by your USB HID driver, which then translates it into&#xD;&#xA;a real character using the current layout you've setup for your keyboard.&#xD;&#xA;&#xD;&#xA;The `mod` character is one of the modifier keys you have on the keyboard (&lt;key&gt;shift&lt;/key&gt;,&#xD;&#xA;&lt;key&gt;control&lt;/key&gt;, &lt;key&gt;alt&lt;/key&gt;...), `0x00` being no modifier.&#xD;&#xA;&#xD;&#xA;&gt;  - Shall I write a new window device driver?&#xD;&#xA;&#xD;&#xA;No, you don't need! With the DFU upgrade, your arduino will be seen as a USB keyboard&#xD;&#xA;by windows.&#xD;&#xA;&#xD;&#xA;&gt;  - Shall I create a software layer that could take my serial data and have windows read it as HID input?&#xD;&#xA;&#xD;&#xA;You neither need to do that, and it's actually a very bad idea for many reasons:&#xD;&#xA;&#xD;&#xA; - your solution would not be portable, and thus you'd need to hack something for every platform you may use,&#xD;&#xA; - your solution would imply a lot of new code ; the more code one write, the more bugs is likely to be in your system,&#xD;&#xA; - your solution would be really hackish, as it would behave as a device driver (i.e. *kernel land*) taking input from &#xD;&#xA;   a user program (i.e. *user land*) and is likely to not work, be a hell to debug, and prone for security issues... &#xD;&#xA;   If that's even possible to do!&#xD;&#xA;&#xD;&#xA;&gt; I'm using an Uno, but I'll look at what you posted because last time we considered the DFU update but we're kinda scared of bricking stuff&#xD;&#xA;&#xD;&#xA;Finally you're having concerns, in a comment, about bricking your arduino. Please&#xD;&#xA;believe me and the author of the [article][1] that you **cannot** brick your arduino&#xD;&#xA;doing a firmware flash:&#xD;&#xA;&#xD;&#xA;*NOTE: There is no chance of ‘bricking’ the device using this method. The Arduino bootloader firmware can always be updated using the DFU protocol!*&#xD;&#xA;&#xD;&#xA;In case something gets really badly wrong, and you get a bootloader corruption in the&#xD;&#xA;little AVR (atmega8u2), you still can reflash it [using another arduino][2] or an&#xD;&#xA;[atmel programmer][3] using the 6 pins next to the USB plug.&#xD;&#xA;&#xD;&#xA;In the end, know that the **only** way to brick an AVR, thus an Arduino as well, is &#xD;&#xA;to play with the fuses and reset the programming fuses. And even then, you may use&#xD;&#xA;[HVSP][4] to save your device, though it's often less trouble to just take a new chip.&#xD;&#xA;&#xD;&#xA;[1]:http://mitchtech.net/arduino-usb-hid-keyboard&#xD;&#xA;[2]:http://arduino.cc/en/Tutorial/ArduinoISP&#xD;&#xA;[3]:http://www.atmel.com/tools/avrispmkii.aspx&#xD;&#xA;[4]:http://microtherion.github.io/ScratchMonkey/HVSP.html" />
  <row Id="1461" PostHistoryTypeId="5" PostId="433" RevisionGUID="c577d25d-45db-45b3-84c9-b9ba32fc02bf" CreationDate="2014-03-01T16:27:36.687" UserId="83" Comment="added 465 characters in body" Text="Will it break at &lt; 5V? Not likely.&#xD;&#xA;=&#xD;&#xA;&#xD;&#xA;- Check the datasheet for the IC's on the board and find the minimum power supply voltage the device works at.&#xD;&#xA;- At typical ATmega328 Safe Operating Area (under &quot;Speed grades&quot; in the datasheet) specifies approximately 4.1V for 16MHz.&#xD;&#xA;- If you require to use the USB interface, you'll have to check the datasheet for that chip too.&#xD;&#xA;&#xD;&#xA;Will it run at &lt; 5V? Maybe.&#xD;&#xA;=&#xD;&#xA;- If the supply voltage gets below the minimum operational voltage, the controller may behave erratically. That means it can do anything (un)expected. This value is in the datasheet and probably somewhere around 2.7V.&#xD;&#xA;- If the Brown Out circuit is configured (in fuses), then the controller will switch itself off when supply voltage gets too low to prevent undefined situations. Once the supply voltage returns, it restarts.&#xD;&#xA;&#xD;&#xA;Will it break at &gt; 5V? Depends on where you apply it.&#xD;&#xA;=&#xD;&#xA;- V(IN) should work fine for 7-20VDC as it is fed through an on board regulator. Notice though that the regulator has to dissipate the excess voltage and can get pretty hot when you draw a fair bit of current. The regulator will fail if the voltage goes over 20V or gets too hot too often;&#xD;&#xA;- +5V should work fine up to 5V, and I personally wouldn't worry if an external supply delivers up to 5.5V unloaded. Above that 5.5V you will probably release the magic blue smoke." />
  <row Id="1462" PostHistoryTypeId="6" PostId="501" RevisionGUID="f2e9b3cc-ed6e-4d6b-af52-6b1221e87c65" CreationDate="2014-03-01T18:24:42.170" UserId="11" Comment="edited tags" Text="&lt;sensors&gt;" />
  <row Id="1463" PostHistoryTypeId="6" PostId="485" RevisionGUID="dcfca993-d23e-41d9-8ec8-d06ea314d918" CreationDate="2014-03-01T18:25:01.717" UserId="11" Comment="edited tags" Text="&lt;sd-card&gt;" />
  <row Id="1464" PostHistoryTypeId="6" PostId="439" RevisionGUID="4a514533-81e6-4b74-b301-4e6f9f6425f7" CreationDate="2014-03-01T18:25:54.893" UserId="11" Comment="edited tags" Text="&lt;serial&gt;&lt;arduino-ide&gt;" />
  <row Id="1465" PostHistoryTypeId="5" PostId="47" RevisionGUID="45a68953-4bfb-4ada-82d8-f559f9d9e9f0" CreationDate="2014-03-01T18:26:35.303" UserId="11" Comment="added 75 characters in body" Text="Integrated Development Environment - software that allows you to write and compile code. Use the arduino-ide tag for questions about the official Arduino software." />
  <row Id="1466" PostHistoryTypeId="6" PostId="332" RevisionGUID="326dce85-bacc-4692-96b2-40bba5eb70e5" CreationDate="2014-03-01T18:27:30.450" UserId="11" Comment="edited tags" Text="&lt;motor&gt;" />
  <row Id="1467" PostHistoryTypeId="5" PostId="536" RevisionGUID="1868bacf-3768-4dcc-9956-668ba62e9fdd" CreationDate="2014-03-01T18:39:15.580" UserId="275" Comment="added 243 characters in body" Text="From a functional perspective, both versions generate the same result, since in both cases the value of `count` is stored between the executions of the `loop()` (either because it is a global variable or because it is marked as `static` and therefore keeps its value).&#xD;&#xA;&#xD;&#xA;So the decision which to choose come down to following arguments:&#xD;&#xA;&#xD;&#xA; 1. Generally, in computer science, it is encouraged to keep your variables as local as possible in terms of **scope**. This usually results in much clearer code with less side-effects and reduces chances of someone else using that global variable screwing up your logic). E.g. in your first example, other logic areas might change the `count` value, whereas in the second, only that particular function `loop()`can do so).&#xD;&#xA; 2. Global and static variables always occupy **memory**, where as locals only do when they are in scope. In your above examples that makes no difference (since in one you use a global, in the other a static variable), but in bigger and more complex programs it might and you could save memory using non-static locals. &#xD;&#xA;*However*: If you have a variable in a logic area that is executed very often, consider making it either static or global, since&#xD;&#xA;    otherwise you loose a tiny bit of performance each time that logic&#xD;&#xA;    area is entered, since it takes a bit of time to allocate the memory&#xD;&#xA;    for that new variable instance. You need to find a balance between memory load and performance.&#xD;&#xA; 4. Other points such as better layout for **static analysis** or **optimization** by the compiler might also come into play.&#xD;&#xA; 5. In some special scenarios, there might be issues with the unpredictable initialization order of static elements (not sure about that point, compare this [link][1] though).&#xD;&#xA;&#xD;&#xA;Source: [Similar thread][2] on arduino.cc&#xD;&#xA;&#xD;&#xA;  [1]: http://forum.arduino.cc/index.php?PHPSESSID=nt8h6685309s1vv0voea1rbkd5&amp;topic=74180.msg559158#msg559158&#xD;&#xA;  [2]: http://forum.arduino.cc/index.php?PHPSESSID=i4sdu9bn0f8u2jekn5tl5pbeo1&amp;topic=74180.msg559208#msg559208" />
  <row Id="1468" PostHistoryTypeId="5" PostId="46" RevisionGUID="c2c09372-de67-4728-824d-8c27b38a6134" CreationDate="2014-03-01T19:10:46.180" UserId="275" Comment="layout improvements" Text="The process of programming consists of several stages, including:&#xD;&#xA;&#xD;&#xA; - editing the source code&#xD;&#xA; - managing libraries and build events&#xD;&#xA; - compiling/linking the program (or sketch)&#xD;&#xA; - debugging the program when it is running&#xD;&#xA;&#xD;&#xA;In the case of Arduino, it typically also involves uploading the sketch to a device.&#xD;&#xA;&#xD;&#xA;Each part of this process is often managed by a separate program. These are often command-line based, and can be quite difficult to learn. However, an &lt;b&gt;I&lt;/b&gt;ntegrated &lt;b&gt;D&lt;/b&gt;evelopment &lt;b&gt;E&lt;/b&gt;nvironment (***IDE***) combines everything into one application, and often automates several common tasks. This simplifies the programmer's workflow, allowing him/her to focus more on the project at hand.&#xD;&#xA;&#xD;&#xA;The official [Arduino software][1] is a very light-weight IDE, based on the [Processing Development Environment][2]. It includes all of the essential functionality for writing and uploading Arduino sketches, but lacks several features which are found in more sophisticated applications.&#xD;&#xA;&#xD;&#xA;Many users prefer more mainstream IDEs, which can have plug-ins or extensions to support Arduino. These include Eclipse, Visual Studio, and XCode. More information about alternative IDEs can be found on [this question][3].&#xD;&#xA;&#xD;&#xA;If the question is about the official Arduino IDE use the [tag:arduino-ide] tag.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/Software&#xD;&#xA;  [2]: http://www.processing.org/&#xD;&#xA;  [3]: http://arduino.stackexchange.com/questions/40/what-are-the-other-ides-for-arduino" />
  <row Id="1469" PostHistoryTypeId="24" PostId="46" RevisionGUID="c2c09372-de67-4728-824d-8c27b38a6134" CreationDate="2014-03-01T19:10:46.180" Comment="Proposed by 275 approved by -1 edit id of 184" />
  <row Id="1470" PostHistoryTypeId="5" PostId="46" RevisionGUID="35c4615d-648f-4ab1-8ef9-5ecfdd89c653" CreationDate="2014-03-01T19:10:46.180" UserId="220" Comment="layout improvements" Text="The process of programming consists of several stages, including:&#xD;&#xA;&#xD;&#xA; - editing the source code&#xD;&#xA; - managing libraries and build events&#xD;&#xA; - compiling/linking the program (or sketch)&#xD;&#xA; - debugging the program when it is running&#xD;&#xA;&#xD;&#xA;In the case of Arduino, it typically also involves uploading the sketch to a device.&#xD;&#xA;&#xD;&#xA;Each part of this process is often managed by a separate program. These are often command-line based, and can be quite difficult to learn. However, an &lt;b&gt;I&lt;/b&gt;ntegrated &lt;b&gt;D&lt;/b&gt;evelopment &lt;b&gt;E&lt;/b&gt;nvironment (***IDE***) combines everything into one application, and often automates several common tasks. This simplifies the programmer's workflow, allowing him/her to focus more on the project at hand.&#xD;&#xA;&#xD;&#xA;The official [Arduino software][1] is a very light-weight IDE, based on the [Processing Development Environment][2]. It includes all of the essential functionality for writing and uploading Arduino sketches, but lacks several features which are found in more sophisticated applications.&#xD;&#xA;&#xD;&#xA;Some users prefer more mainstream IDEs, which can have plug-ins or extensions to support Arduino. These include Eclipse, Visual Studio, and XCode. More information about alternative IDEs can be found on [this question][3].&#xD;&#xA;&#xD;&#xA;If the question is about the official Arduino IDE use the [tag:arduino-ide] tag.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/Software&#xD;&#xA;  [2]: http://www.processing.org/&#xD;&#xA;  [3]: http://arduino.stackexchange.com/questions/40/what-are-the-other-ides-for-arduino" />
  <row Id="1471" PostHistoryTypeId="5" PostId="516" RevisionGUID="2393d6c9-c3fc-44db-8b67-042e93931ebe" CreationDate="2014-03-01T19:12:25.457" UserId="275" Comment="linked to the 'ide' tag" Text="This tag is for questions about the official [Arduino IDE][1]. This open-source IDE makes it easy to write code/sketches and upload it/them to any Arduino board. The IDE runs on Windows, Mac OS X and Linux.&#xD;&#xA;&#xD;&#xA;For more information about &lt;b&gt;I&lt;/b&gt;ntegrated &lt;b&gt;D&lt;/b&gt;evelopment &lt;b&gt;E&lt;/b&gt;nvironments in general, see the [tag:ide] tag.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/main/software" />
  <row Id="1472" PostHistoryTypeId="24" PostId="516" RevisionGUID="2393d6c9-c3fc-44db-8b67-042e93931ebe" CreationDate="2014-03-01T19:12:25.457" Comment="Proposed by 275 approved by 11 edit id of 186" />
  <row Id="1473" PostHistoryTypeId="2" PostId="542" RevisionGUID="5e04e32d-7c9b-4164-bfb1-cd79c4e28147" CreationDate="2014-03-01T20:46:42.273" UserId="310" Text="Id go with an ultrasonic detector as Cybergibbons suggests together with a usage/flow monitor (http://www.ebay.com/bhp/water-flow-sensor) so as to understand if there are any losses through leaks etc. I'd use a YUN or Ethernet or shield to call or email you a monthly report / fill a datbase as well as place the order directly to the water supplier as well as cc'ing you." />
  <row Id="1474" PostHistoryTypeId="5" PostId="539" RevisionGUID="53c5e00c-1319-4aff-b89f-ef8b90e89c2b" CreationDate="2014-03-01T21:07:41.930" UserId="381" Comment="added 259 characters in body" Text="I have 2 Lowpowerlab WaterMote's talking to each other using the 'out of the box' pre-installed sketch that just confirm they're talking to each other. I verified this by opening a COM connection and saw traffic of 'receiving packets...' That was just to show that they are functioning and talking to each other.&#xD;&#xA;&#xD;&#xA;Now, using Arduino IDE on OSX 1.9.x (Lion?) I have loaded the WaterMote sketch (found in Github) on the Moteino with the sensor (not the gateway) as it should be. The traffic looks like its working, except the text being transmitted (number of Gallons) stays the same at 0.02 Gallons.&#xD;&#xA;&#xD;&#xA;SO... I want to Debug the WaterMote sketch, BUT I do not see an option in my Arduino IDE on Mac OSX. Is there a way to debug sketches using Macs? Searching online shows various and preferred options, but mostly on Windows (which I dont have any at home).&#xD;&#xA;&#xD;&#xA;My current setup&#xD;&#xA;&#xD;&#xA; - Moteino Gateway (as out of the box) connected to a Raspberry Pi (with ssh enabled)&#xD;&#xA;  - connected via USB to the RasPi&#xD;&#xA; - Moteino with WaterMote sketch loaded&#xD;&#xA;  - connected via USB to the Macbook Pro&#xD;&#xA;  - Arduino IDE running, but I see strange &quot;[][][]&quot; square output in the Serial connection.&#xD;&#xA;  - I do not know what to make of this since that text is not in the WaterMote sketch.&#xD;&#xA;&#xD;&#xA;Is there a way to debug sketches loaded on Arduino clones using Arduino IDE on Macs?&#xD;&#xA;&#xD;&#xA;**EDIT - Adding link to of Debugging articles I found. The rest I closed and not saved since I was not looking for Windows solutions (sorry)**&#xD;&#xA;&#xD;&#xA; - [Visual Micro][1]&#xD;&#xA;&#xD;&#xA;  [1]: http://www.instructables.com/id/Arduino-Debugging-Breakpoints-Tracepoints-and-E/" />
  <row Id="1475" PostHistoryTypeId="2" PostId="543" RevisionGUID="b8dd625c-5987-4d1d-a990-d369ff61254e" CreationDate="2014-03-01T22:24:12.817" UserId="379" Text="The truth is always in the datasheets, the schematics and the code:&#xD;&#xA;&#xD;&#xA;The Arduino UNO actually uses the `/DTR` line to trigger a reset, as you can see on the following datasheet:&#xD;&#xA;&#xD;&#xA;![reset schematic](http://www.m0g.net/stuff/arduino-uno-schematic-reset.png)&#xD;&#xA;&#xD;&#xA;So basically, when the firmware of the Atmega8u2 (on the left) is [pulling the pin 13 low](https://github.com/arduino/Arduino/blob/master/hardware/arduino/firmwares/atmegaxxu2/arduino-usbserial/Arduino-usbserial.c#L234), a reset is triggered for the Atmega328 on the right.&#xD;&#xA;&#xD;&#xA;[Another design](http://arduino.cc/en/uploads/Main/arduino-duemilanove-schematic.pdf) was achieving the same thing using the `DTR` and `RTS` lines of the FTDI component (left) to trigger a reset on the Atmega328 (left).&#xD;&#xA;&#xD;&#xA;To avoid this behavior, a 10μF capacitor between Reset and Ground is enough, but you can also cut the RESET-EN trace to prevent the auto reset.&#xD;&#xA;&#xD;&#xA;That thing does *not* happen with the Arduino [leonardo](http://arduino.cc/en/uploads/Main/arduino-leonardo-schematic_3b.pdf) and [Micro](http://arduino.cc/en/uploads/Main/arduino-micro-schematic.pdf), with the firmware [Caterina](https://github.com/arduino/Arduino/blob/master/hardware/arduino/bootloaders/caterina/Caterina.h) does act on the `DTR` line, but on whether you open a connection at 1200bps. That's because both arduinos have an AVR microcontroller that can directly &quot;talk&quot; on USB. There's actually a topic about [how to trigger a reset](http://arduino.cc/en/Guide/ArduinoLeonardoMicro?from=Guide.ArduinoLeonardo#toc4).&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1476" PostHistoryTypeId="5" PostId="543" RevisionGUID="172aa38b-5025-4d5f-af12-9df684ae23a5" CreationDate="2014-03-01T22:30:23.547" UserId="379" Comment="added 122 characters in body" Text="The truth is always in the datasheets, the schematics and the code:&#xD;&#xA;&#xD;&#xA;The Arduino UNO actually uses the `/DTR` line to trigger a reset, as you can see on the following datasheet:&#xD;&#xA;&#xD;&#xA;![reset schematic](http://www.m0g.net/stuff/arduino-uno-schematic-reset.png)&#xD;&#xA;&#xD;&#xA;So basically, when the firmware of the Atmega8u2 (on the left) is [pulling the pin 13 low](https://github.com/arduino/Arduino/blob/master/hardware/arduino/firmwares/atmegaxxu2/arduino-usbserial/Arduino-usbserial.c#L234), a reset is triggered for the Atmega328 on the right.&#xD;&#xA;&#xD;&#xA;[Another design](http://arduino.cc/en/uploads/Main/arduino-duemilanove-schematic.pdf) was achieving the same thing using the `DTR` and `RTS` lines of the FTDI component (left) to trigger a reset on the Atmega328 (left).&#xD;&#xA;&#xD;&#xA;To avoid this behavior, a 10μF capacitor between Reset and Ground is enough, but you can also cut the RESET-EN trace to prevent the auto reset permanently.&#xD;&#xA;&#xD;&#xA;On the software side, as @sachleen says in his answer, you can control the reset behavior using whether you trigger or not the DTR line.&#xD;&#xA;&#xD;&#xA;That thing does *not* happen with the Arduino [leonardo](http://arduino.cc/en/uploads/Main/arduino-leonardo-schematic_3b.pdf) and [Micro](http://arduino.cc/en/uploads/Main/arduino-micro-schematic.pdf), with the firmware [Caterina](https://github.com/arduino/Arduino/blob/master/hardware/arduino/bootloaders/caterina/Caterina.h) does act on the `DTR` line, but on whether you open a connection at 1200bps. That's because both arduinos have an AVR microcontroller that can directly &quot;talk&quot; on USB. There's actually a topic about [how to trigger a reset](http://arduino.cc/en/Guide/ArduinoLeonardoMicro?from=Guide.ArduinoLeonardo#toc4)." />
  <row Id="1477" PostHistoryTypeId="4" PostId="460" RevisionGUID="9340c782-f196-4bd9-ad85-5ccbfe802995" CreationDate="2014-03-01T22:35:40.673" UserId="379" Comment="added tags ; improved title so it cannot be misleading" Text="How to erase the memory of the arduino uno" />
  <row Id="1478" PostHistoryTypeId="6" PostId="460" RevisionGUID="9340c782-f196-4bd9-ad85-5ccbfe802995" CreationDate="2014-03-01T22:35:40.673" UserId="379" Comment="added tags ; improved title so it cannot be misleading" Text="&lt;arduino-uno&gt;&lt;safety&gt;&lt;memory&gt;&lt;erase&gt;" />
  <row Id="1479" PostHistoryTypeId="24" PostId="460" RevisionGUID="9340c782-f196-4bd9-ad85-5ccbfe802995" CreationDate="2014-03-01T22:35:40.673" Comment="Proposed by 379 approved by 11 edit id of 187" />
  <row Id="1481" PostHistoryTypeId="5" PostId="314" RevisionGUID="5a2bda32-4e85-407a-8880-fdb277ea7a36" CreationDate="2014-03-02T00:20:24.530" UserId="42" Comment="Rewritten to make it clearer what this tag is for" Text="Use this tag for questions regarding programming (writing code) for Arduino. This can include problems with code you've written for Arduino, or questions about how/why Arduino code acts in certain ways.&#xD;&#xA;&#xD;&#xA;Where a question relates to a particular language, you can also use language-specific tags, such as [tag:c++].&#xD;&#xA;&#xD;&#xA;Programming questions which are not specific to Arduino (e.g. general questions about a programming language) should be asked on [**Stack Overflow**](http://www.stackoverflow.com) instead.&#xD;&#xA;&#xD;&#xA;For questions regarding uploading sketches to Arduino devices, please use the [tag:uploading] tag." />
  <row Id="1482" PostHistoryTypeId="5" PostId="315" RevisionGUID="3f84b16e-b200-42fa-9286-a7638c2efa0b" CreationDate="2014-03-02T00:20:24.530" UserId="42" Comment="Rewritten to make it clearer what this tag is for" Text="The process of designing and writing source code as part of a program (or sketch) for Arduino." />
  <row Id="1483" PostHistoryTypeId="2" PostId="544" RevisionGUID="d3921eb9-26b1-436a-97e7-28c1fb010651" CreationDate="2014-03-02T00:35:52.860" UserId="42" Text="There are several different official Arduino boards. In some cases, the board design has been revised, and a new specification/product has been released. They are distinguished by revision number, such as the Uno R2 and the Uno R3.&#xD;&#xA;&#xD;&#xA;This tag can be used for questions about changes between revisions, or the process of revising official board design.&#xD;&#xA;&#xD;&#xA;This tag should *not* be used for questions which relate to one particular revision of a board. Use the relevant revision-specific tag instead, such as [tag:arduino-uno-r3]." />
  <row Id="1484" PostHistoryTypeId="2" PostId="545" RevisionGUID="30176d98-8179-44a4-a489-d557a7a4f4ea" CreationDate="2014-03-02T00:35:52.860" UserId="42" Text="Revisions are different versions of a given Arduino board, such as the Uno R2 and Uno R3." />
  <row Id="1485" PostHistoryTypeId="5" PostId="423" RevisionGUID="1b710110-b13f-4bd2-bd99-db54b50c39f2" CreationDate="2014-03-02T00:50:01.370" UserId="42" Comment="Expanded the excerpt and added a usage note" Text="Use this tag for any question which involves infrared in an Arduino project. This can cover a broad range of topics, so please try to use other tags as well, where appropriate." />
  <row Id="1486" PostHistoryTypeId="5" PostId="424" RevisionGUID="39e4bd22-3f2d-4397-967d-23a794b8a438" CreationDate="2014-03-02T00:50:01.370" UserId="42" Comment="Expanded the excerpt and added a usage note" Text="Infrared (IR) is a form of light which is not visible to the human eye. It can be used in a variety of applications, including remote controls, data transfer, reflectance sensing, and proximity/motion detection." />
  <row Id="1487" PostHistoryTypeId="2" PostId="546" RevisionGUID="3c11f2db-6830-4018-8395-67feeaea4b67" CreationDate="2014-03-02T02:38:25.427" UserId="65" Text="If safety is a major concern, then you should almost always load a stop* sketch onto the board before calling it a day. This would be a good idea, for example, when your board is semi-permanently a part of a larger system. You could do so by: &#xD;&#xA;&#xD;&#xA;- Upload the Bare Minimum sketch found in &lt;kbd&gt;File&lt;/kbd&gt; -&gt;  &lt;kbd&gt;Examples&lt;/kbd&gt; -&gt; &lt;kbd&gt;Basic&lt;/kbd&gt; in the [tag:Arduino-IDE]&#xD;&#xA;- Upload a sketch with a large delay in loop.&#xD;&#xA;&#xD;&#xA;&lt;!-- language: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;    #include &lt;limits.h&gt;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {}&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      delay(ULONG_MAX);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;*Stop is simply figurative. The board doesnt really stop running.&lt;/sub&gt;" />
  <row Id="1494" PostHistoryTypeId="2" PostId="548" RevisionGUID="e5dcb43a-227b-4b8c-9c2e-028244781261" CreationDate="2014-03-02T03:13:06.193" UserId="390" Text="with arduino i cant create a library i have been threw http://arduino.cc/en/Hacking/LibraryTutorial but i cant do it it doesn't work and its not specific enough so can someone tell me how to create a library for arduino or send me a video tutorial for how to create one i cant found any tutorial anywhere but that one above but it doesn't make any sense" />
  <row Id="1495" PostHistoryTypeId="1" PostId="548" RevisionGUID="e5dcb43a-227b-4b8c-9c2e-028244781261" CreationDate="2014-03-02T03:13:06.193" UserId="390" Text="with arduino i cant create a library" />
  <row Id="1496" PostHistoryTypeId="3" PostId="548" RevisionGUID="e5dcb43a-227b-4b8c-9c2e-028244781261" CreationDate="2014-03-02T03:13:06.193" UserId="390" Text="&lt;library&gt;" />
  <row Id="1497" PostHistoryTypeId="5" PostId="548" RevisionGUID="84b72040-d705-4182-9d89-8d9815cda534" CreationDate="2014-03-02T03:15:33.133" UserId="8" Comment="deleted 33 characters in body; edited title" Text="I have been through http://arduino.cc/en/Hacking/LibraryTutorial but i can't do it. It doesn't work and its not specific enough so can someone tell me how to create a library for arduino or send me a video tutorial for how to create one i cant found any tutorial anywhere but that one above but it doesn't make any sense" />
  <row Id="1498" PostHistoryTypeId="4" PostId="548" RevisionGUID="84b72040-d705-4182-9d89-8d9815cda534" CreationDate="2014-03-02T03:15:33.133" UserId="8" Comment="deleted 33 characters in body; edited title" Text="I can't create an Arduino library" />
  <row Id="1499" PostHistoryTypeId="10" PostId="548" RevisionGUID="3859112e-126e-49b7-9b4f-86fd664e0fc1" CreationDate="2014-03-02T03:34:13.757" UserId="11" Comment="103" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="1500" PostHistoryTypeId="5" PostId="548" RevisionGUID="4c2e4657-9e60-4089-ab79-98b097729f8b" CreationDate="2014-03-02T03:46:57.353" UserId="390" Comment="added 674 characters in body" Text="I have been through http://arduino.cc/en/Hacking/LibraryTutorial but i can't do it. It doesn't work and its not specific enough so can someone tell me how to create a library for arduino or send me a video tutorial for how to create one i cant found any tutorial anywhere but that one above but it doesn't make any sense my code is here &#xD;&#xA;&#xD;&#xA;int sensorpin = 5;&#xD;&#xA;int target = 0;          &#xD;&#xA;int targeta = 0;&#xD;&#xA;int pin = 1;&#xD;&#xA;boolean motionfound = false ;&#xD;&#xA;&#xD;&#xA;void setup() {&#xD;&#xA;  pinMode(sensorpin, OUTPUT);&#xD;&#xA;delay(1000); &#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void loop(){&#xD;&#xA;  motion();&#xD;&#xA;  motiontrue();&#xD;&#xA;  delay(10);&#xD;&#xA;  }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;void motion(){&#xD;&#xA; target = analogRead(sensorpin);             &#xD;&#xA;delay(75);&#xD;&#xA;   targeta = analogRead(sensorpin);            &#xD;&#xA;  if(targeta &lt; target) {              &#xD;&#xA;   boolean motionfound = true;&#xD;&#xA;}&#xD;&#xA;  if(targeta &gt; target) {   &#xD;&#xA;  boolean motionfound = true;&#xD;&#xA;}&#xD;&#xA;if(targeta == target) {   &#xD;&#xA; boolean motionfound = false;&#xD;&#xA;}&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;void motiontrue(){&#xD;&#xA;if(motionfound == true){&#xD;&#xA; pinMode(pin, OUTPUT);&#xD;&#xA;}&#xD;&#xA;}" />
  <row Id="1501" PostHistoryTypeId="5" PostId="548" RevisionGUID="5ab7d55b-e63c-4e2b-9aec-10b5e87d76a2" CreationDate="2014-03-02T03:51:21.447" UserId="11" Comment="formatted code." Text="I have been through http://arduino.cc/en/Hacking/LibraryTutorial but i can't do it. It doesn't work and its not specific enough so can someone tell me how to create a library for arduino or send me a video tutorial for how to create one i cant found any tutorial anywhere but that one above but it doesn't make any sense my code is here &#xD;&#xA;&#xD;&#xA;    int sensorpin = 5;&#xD;&#xA;    int target = 0;          &#xD;&#xA;    int targeta = 0;&#xD;&#xA;    int pin = 1;&#xD;&#xA;    boolean motionfound = false ;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;        pinMode(sensorpin, OUTPUT);&#xD;&#xA;        delay(1000); &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        motion();&#xD;&#xA;        motiontrue();&#xD;&#xA;        delay(10);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void motion(){&#xD;&#xA;        target = analogRead(sensorpin);             &#xD;&#xA;        delay(75);&#xD;&#xA;        targeta = analogRead(sensorpin);            &#xD;&#xA;        if(targeta &lt; target) {&#xD;&#xA;            boolean motionfound = true;&#xD;&#xA;        }&#xD;&#xA;        if(targeta &gt; target) {   &#xD;&#xA;            boolean motionfound = true;&#xD;&#xA;        }&#xD;&#xA;        if(targeta == target) {   &#xD;&#xA;            boolean motionfound = false;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void motiontrue(){&#xD;&#xA;        if(motionfound == true){&#xD;&#xA;            pinMode(pin, OUTPUT);&#xD;&#xA;        }&#xD;&#xA;    }" />
  <row Id="1502" PostHistoryTypeId="5" PostId="548" RevisionGUID="624af6cd-79f4-4015-a151-b83543c92200" CreationDate="2014-03-02T04:05:55.103" UserId="390" Comment="added 151 characters in body" Text="I have been through http://arduino.cc/en/Hacking/LibraryTutorial but i can't do it. It doesn't work and its not specific enough so can someone tell me how to create a library for arduino or send me a video tutorial for how to create one i cant found any tutorial anywhere but that one above but it doesn't make any sense my code is here &#xD;&#xA;&#xD;&#xA;    int sensorpin = 5;&#xD;&#xA;    int target = 0;          &#xD;&#xA;    int targeta = 0;&#xD;&#xA;    int pin = 1;&#xD;&#xA;    boolean motionfound = false ;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;        pinMode(sensorpin, OUTPUT);&#xD;&#xA;        delay(1000); &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        motion();&#xD;&#xA;        motiontrue();&#xD;&#xA;        delay(10);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void motion(){&#xD;&#xA;        target = analogRead(sensorpin);             &#xD;&#xA;        delay(75);&#xD;&#xA;        targeta = analogRead(sensorpin);            &#xD;&#xA;        if(targeta &lt; target) {&#xD;&#xA;            boolean motionfound = true;&#xD;&#xA;        }&#xD;&#xA;        if(targeta &gt; target) {   &#xD;&#xA;            boolean motionfound = true;&#xD;&#xA;        }&#xD;&#xA;        if(targeta == target) {   &#xD;&#xA;            boolean motionfound = false;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void motiontrue(){&#xD;&#xA;        if(motionfound == true){&#xD;&#xA;            pinMode(pin, OUTPUT);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;	&#xD;&#xA;so how am i meant to convert it to a library if i cant follow that tutorial i cant find any other ones and now no one can tell me how to do it" />
  <row Id="1503" PostHistoryTypeId="11" PostId="548" RevisionGUID="4c63365f-cd1a-46ec-a905-b6882442cd16" CreationDate="2014-03-02T04:06:15.990" UserId="11" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="1504" PostHistoryTypeId="5" PostId="548" RevisionGUID="1a7a78cb-6198-4407-bae8-6163beb7624a" CreationDate="2014-03-02T04:10:46.970" UserId="65" Comment="Rewrote the question to include only the relevant part" Text="I have been through http://arduino.cc/en/Hacking/LibraryTutorial but i can't do it. Whenever I create a new sketch and try to save it as `.cpp` or `.h` from the &lt;kbd&gt;Save As&lt;/kbd&gt; button in the Arduino IDE, it gets saved as `_cpp` and `_h`. I am not able to create a library this way. How do I create a new library? What am I missing here?" />
  <row Id="1505" PostHistoryTypeId="24" PostId="548" RevisionGUID="1a7a78cb-6198-4407-bae8-6163beb7624a" CreationDate="2014-03-02T04:10:46.970" Comment="Proposed by 65 approved by 11 edit id of 189" />
  <row Id="1506" PostHistoryTypeId="2" PostId="549" RevisionGUID="02754fb6-3185-46c4-895f-742d8ef1c6c7" CreationDate="2014-03-02T04:20:02.597" UserId="65" Text="When you save a file using the &lt;kbd&gt;Save As&lt;/kbd&gt; button from the Arduino IDE, it saves the current file as a sketch i.e. as an `.ino` file.&#xD;&#xA;&#xD;&#xA;To create a `.cpp` and `.h` files for working on a new library, you need to create the files alongside a sketch. For this, you can use the &lt;kbd&gt;Tab&lt;/kbd&gt; button on the top right (circled in red).&#xD;&#xA;&#xD;&#xA;&gt;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;Click on it, and select &lt;kbd&gt;New Tab&lt;/kbd&gt;. You will get a bar at the bottom of the screen asking for a file name. Enter the name with extension (`test.cpp`) and press &lt;kbd&gt;Enter&lt;/kbd&gt;.&#xD;&#xA;&#xD;&#xA;&gt;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;Your file has now been added to the current directory.&#xD;&#xA;&#xD;&#xA;&gt;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;Similarly, follow the same steps for creating the `.h` file.&#xD;&#xA;&#xD;&#xA;Once your library is complete and ready to ship, you can move the `.cpp` and `.h` files to a separate directory and then add it under libraries.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/lya7P.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/5cIWe.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/1Cp0V.png" />
  <row Id="1507" PostHistoryTypeId="5" PostId="548" RevisionGUID="5ecdf0de-53ec-414a-82c1-3f0974ffaeae" CreationDate="2014-03-02T05:26:09.770" UserId="390" Comment="added 118 characters in body" Text="I have been through http://arduino.cc/en/Hacking/LibraryTutorial but i can't do it. Whenever I create a new sketch and try to save it as `.cpp` or `.h` from the &lt;kbd&gt;Save As&lt;/kbd&gt; button in the Arduino IDE, it gets saved as `_cpp` and `_h`. I am not able to create a library this way. How do I create a new library? What am I missing here?&#xD;&#xA;&#xD;&#xA;and i am also unable to follow the tutorial above can someone give me a easier tutorial on how to create a library" />
  <row Id="1512" PostHistoryTypeId="5" PostId="543" RevisionGUID="536cab21-68c8-4b6a-9e80-2ee44d28af52" CreationDate="2014-03-02T10:26:27.067" UserId="379" Comment="added 2 characters in body" Text="The truth is always in the datasheets, the schematics and the code:&#xD;&#xA;&#xD;&#xA;The Arduino UNO actually uses the `/DTR` line to trigger a reset, as you can see on the following datasheet:&#xD;&#xA;&#xD;&#xA;![reset schematic](http://www.m0g.net/stuff/arduino-uno-schematic-reset.png)&#xD;&#xA;&#xD;&#xA;So basically, when the firmware of the Atmega8u2 (on the left) is [pulling the pin 13 low](https://github.com/arduino/Arduino/blob/master/hardware/arduino/firmwares/atmegaxxu2/arduino-usbserial/Arduino-usbserial.c#L234), a reset is triggered for the Atmega328 on the right.&#xD;&#xA;&#xD;&#xA;[Another design](http://arduino.cc/en/uploads/Main/arduino-duemilanove-schematic.pdf) was achieving the same thing using the `DTR` and `RTS` lines of the FTDI component (left) to trigger a reset on the Atmega328 (left).&#xD;&#xA;&#xD;&#xA;To avoid this behavior, a 10μF capacitor between Reset and Ground is enough, but you can also cut the RESET-EN trace to prevent the auto reset permanently.&#xD;&#xA;&#xD;&#xA;On the software side, as @sachleen says in his answer, you can control the reset behavior using whether you trigger or not the DTR line.&#xD;&#xA;&#xD;&#xA;That thing does *not* happen with the Arduino [leonardo](http://arduino.cc/en/uploads/Main/arduino-leonardo-schematic_3b.pdf) and [Micro](http://arduino.cc/en/uploads/Main/arduino-micro-schematic.pdf), with the bootloader [Caterina](https://github.com/arduino/Arduino/blob/master/hardware/arduino/bootloaders/caterina/Caterina.h) does act on the `DTR` line, but on whether you open a connection at 1200bps. That's because both arduinos have an AVR microcontroller that can directly &quot;talk&quot; on USB. There's actually a topic about [how to trigger a reset](http://arduino.cc/en/Guide/ArduinoLeonardoMicro?from=Guide.ArduinoLeonardo#toc4)." />
  <row Id="1513" PostHistoryTypeId="2" PostId="551" RevisionGUID="6e2871a9-dc72-4852-8f20-81dd61d73f2b" CreationDate="2014-03-02T11:52:16.930" UserId="-1" Text="" />
  <row Id="1514" PostHistoryTypeId="2" PostId="552" RevisionGUID="dd267e74-abb0-415a-9374-edb55616ac96" CreationDate="2014-03-02T11:52:16.930" UserId="-1" Text="" />
  <row Id="1515" PostHistoryTypeId="2" PostId="553" RevisionGUID="7405d7e2-3efc-45f5-b9c7-b23e8b14b669" CreationDate="2014-03-02T11:53:49.047" UserId="-1" Text="" />
  <row Id="1516" PostHistoryTypeId="2" PostId="554" RevisionGUID="559b31c8-6802-4bbd-b17e-54d153e5826f" CreationDate="2014-03-02T11:53:49.047" UserId="-1" Text="" />
  <row Id="1517" PostHistoryTypeId="2" PostId="555" RevisionGUID="539bae70-0c8a-4a99-906e-bd39c85f9611" CreationDate="2014-03-02T11:56:17.977" UserId="-1" Text="" />
  <row Id="1518" PostHistoryTypeId="2" PostId="556" RevisionGUID="179333df-b6ff-4c93-8870-414aecf0f493" CreationDate="2014-03-02T11:56:17.977" UserId="-1" Text="" />
  <row Id="1519" PostHistoryTypeId="2" PostId="557" RevisionGUID="0fb86d46-6364-4718-93b8-5ae26bd40fa7" CreationDate="2014-03-02T11:57:28.750" UserId="-1" Text="" />
  <row Id="1520" PostHistoryTypeId="2" PostId="558" RevisionGUID="f6f84ab0-36b6-4c7b-aef1-b4eba417b2be" CreationDate="2014-03-02T11:57:28.750" UserId="-1" Text="" />
  <row Id="1521" PostHistoryTypeId="2" PostId="559" RevisionGUID="2fe637be-5d03-41fa-a8e1-cc57ba57feb8" CreationDate="2014-03-02T11:59:13.443" UserId="-1" Text="" />
  <row Id="1522" PostHistoryTypeId="2" PostId="560" RevisionGUID="1a741195-d662-4736-91ae-35bbd650e8ed" CreationDate="2014-03-02T11:59:13.443" UserId="-1" Text="" />
  <row Id="1523" PostHistoryTypeId="2" PostId="561" RevisionGUID="ed8fac62-92d8-40d1-a524-081ae6f7bb2c" CreationDate="2014-03-02T13:05:58.760" UserId="379" Text="&gt;    What is making the upload process pause?&#xD;&#xA;&#xD;&#xA;Well, given all the comments made under your question, this is definitely a tricky one. You might want to try to add a decoupling capacitor as suggested by @jfpoilpret, though your schematics look alright to me… (maybe ask a review of it on [EE SE](http://electronics.stackexchange.com)).&#xD;&#xA;&#xD;&#xA;I'd also advice you to copy the `avrdude` command from Arduino IDE output (you'll find it at the top), and run it in the command shell with lower bitrate:&#xD;&#xA;&#xD;&#xA;    avrdude -v -v -v -v -C &quot;C:\arduino-1.0.3\hardware/tools/avr/etc/avrdude.conf&quot; -P COM1 -patmega328 -U… -B3 -b115200&#xD;&#xA;&#xD;&#xA;the higher the `-B` value is the lower your bitrate is. and `-b` to the correct baudrate for your bootloader (are you *sure* this is 115200? it's more common to see 57600).&#xD;&#xA;&#xD;&#xA;Did you also set fuses correctly? You might as well want to check the values of the fuses to see if the clocks are correctly set up:&#xD;&#xA;&#xD;&#xA;    avrdude -U lfuse:r:-:i -U hfuse:r:-:i -U efuse:r:-:i&#xD;&#xA;&#xD;&#xA;which will output the values of the fuses. Then to make the values readable, put the values at the bottom of the form on the [fuse calculator site](http://www.engbedded.com/fusecalc/), after choosing the `Atmega328P` MCU from the dropdown list.&#xD;&#xA;&#xD;&#xA;Double check that:&#xD;&#xA;&#xD;&#xA; * you have enough size for the bootloader (usually the more you give it the better it is) ;&#xD;&#xA; * you have correctly set up the cristals configuration for your design (which may not be compatible with default Uno settings as setup by the Arduino IDE), checking if you correctly set up the external crystal at 16MHz…&#xD;&#xA;&#xD;&#xA;&gt;    Why is the buzzer beeping when the process pauses?&#xD;&#xA;&#xD;&#xA;It's because when the processor does not have the output set up, the values within the registers are in an undefined and unpredictable state. Which means that usually it keeps the last value it had before a reset, or changed state because of some electrostatic weirdness, or is giving some weird PWM output because of the influence of a clock nearby.&#xD;&#xA;&#xD;&#xA;So basically, there's something wrong happening when you're uploading your code and that wrong thing has an indirect effect on the audio. I wouldn't worry much about that stuff, but more about the cause of the pausing.&#xD;&#xA;&#xD;&#xA;Sadly, I don't have a direct answer for you, but at best a few paths you should investigate more. HTH" />
  <row Id="1524" PostHistoryTypeId="2" PostId="562" RevisionGUID="736e4daa-fbf9-4563-9750-01c90853cfdd" CreationDate="2014-03-02T13:26:25.627" UserId="65" Text="The Arduino IDE by default is oriented towards C++. The linker for example requires `.cpp` files and not `.c` files, otherwise it leads to errors during the linking process. See [name mangling][1] if you want to know more.&#xD;&#xA;&#xD;&#xA;So, what are the tools that I need to setup a C environment? Can this be done from the Arduino IDE itself?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Name_mangling" />
  <row Id="1525" PostHistoryTypeId="1" PostId="562" RevisionGUID="736e4daa-fbf9-4563-9750-01c90853cfdd" CreationDate="2014-03-02T13:26:25.627" UserId="65" Text="What are the tools that I need to program the Arduino in C?" />
  <row Id="1526" PostHistoryTypeId="3" PostId="562" RevisionGUID="736e4daa-fbf9-4563-9750-01c90853cfdd" CreationDate="2014-03-02T13:26:25.627" UserId="65" Text="&lt;programming&gt;&lt;c&gt;" />
  <row Id="1527" PostHistoryTypeId="5" PostId="548" RevisionGUID="a5789aa6-2567-443d-ab54-6e128845d8c3" CreationDate="2014-03-02T13:57:29.260" UserId="65" Comment="Removed fluff; edited title" Text="I have been through http://arduino.cc/en/Hacking/LibraryTutorial but I can't do it. Whenever I create a new sketch and try to save it as `.cpp` or `.h` from the &lt;kbd&gt;Save As&lt;/kbd&gt; button in the Arduino IDE, it gets saved as `_cpp` and `_h`. I am not able to create a library this way. How do I create a new library? What am I missing here?" />
  <row Id="1528" PostHistoryTypeId="4" PostId="548" RevisionGUID="a5789aa6-2567-443d-ab54-6e128845d8c3" CreationDate="2014-03-02T13:57:29.260" UserId="65" Comment="Removed fluff; edited title" Text="Why are the files not being created correctly?" />
  <row Id="1529" PostHistoryTypeId="24" PostId="548" RevisionGUID="a5789aa6-2567-443d-ab54-6e128845d8c3" CreationDate="2014-03-02T13:57:29.260" Comment="Proposed by 65 approved by 220 edit id of 197" />
  <row Id="1531" PostHistoryTypeId="6" PostId="460" RevisionGUID="22d6e41c-2303-4bd7-b1ac-dfef51378f98" CreationDate="2014-03-02T14:07:16.013" UserId="65" Comment="Unnecessary tag; " Text="&lt;arduino-uno&gt;&lt;safety&gt;&lt;memory&gt;" />
  <row Id="1532" PostHistoryTypeId="24" PostId="460" RevisionGUID="22d6e41c-2303-4bd7-b1ac-dfef51378f98" CreationDate="2014-03-02T14:07:16.013" Comment="Proposed by 65 approved by -1 edit id of 196" />
  <row Id="1533" PostHistoryTypeId="4" PostId="460" RevisionGUID="c632f861-bc3a-4d7e-8827-e07701959b4b" CreationDate="2014-03-02T14:07:16.013" UserId="220" Comment="Unnecessary tag" Text="How do I erase the memory of the Arduino Uno?" />
  <row Id="1534" PostHistoryTypeId="5" PostId="554" RevisionGUID="32f283fa-30ae-492d-83c2-9a34a5a08a87" CreationDate="2014-03-02T14:07:29.140" UserId="65" Comment="added 136 characters in body" Text="Refers to the sum total of software, circuit diagrams, documentation, libraries, and hardware that make up an Arduino based application." />
  <row Id="1535" PostHistoryTypeId="24" PostId="554" RevisionGUID="32f283fa-30ae-492d-83c2-9a34a5a08a87" CreationDate="2014-03-02T14:07:29.140" Comment="Proposed by 65 approved by 220 edit id of 192" />
  <row Id="1536" PostHistoryTypeId="5" PostId="560" RevisionGUID="e3817346-4329-4386-aa15-db6064ffbc6f" CreationDate="2014-03-02T14:08:39.703" UserId="65" Comment="added 148 characters in body" Text="Version control refers to the management of changes made over time to a code base. Use this tag for questions about managing software and libraries." />
  <row Id="1537" PostHistoryTypeId="24" PostId="560" RevisionGUID="e3817346-4329-4386-aa15-db6064ffbc6f" CreationDate="2014-03-02T14:08:39.703" Comment="Proposed by 65 approved by 220 edit id of 195" />
  <row Id="1538" PostHistoryTypeId="5" PostId="558" RevisionGUID="00e11fa7-ea5a-44b9-a7da-e3d99339d7c3" CreationDate="2014-03-02T14:08:52.220" UserId="65" Comment="added 109 characters in body" Text="Use this tag for questions about connecting, controlling, and safely operating motors using an Arduino board." />
  <row Id="1539" PostHistoryTypeId="24" PostId="558" RevisionGUID="00e11fa7-ea5a-44b9-a7da-e3d99339d7c3" CreationDate="2014-03-02T14:08:52.220" Comment="Proposed by 65 approved by 220 edit id of 194" />
  <row Id="1540" PostHistoryTypeId="5" PostId="552" RevisionGUID="382b9179-80e3-4a3f-a467-69a7065d3b86" CreationDate="2014-03-02T14:09:01.257" UserId="65" Comment="added 247 characters in body" Text="Refers to the code burned on the Arduino flash memory that runs every time the board is powered up. It starts the execution of user-loaded programs. This tag should be used for questions about modifying, changing, uploading the default bootloader." />
  <row Id="1541" PostHistoryTypeId="24" PostId="552" RevisionGUID="382b9179-80e3-4a3f-a467-69a7065d3b86" CreationDate="2014-03-02T14:09:01.257" Comment="Proposed by 65 approved by 220 edit id of 191" />
  <row Id="1542" PostHistoryTypeId="5" PostId="556" RevisionGUID="72654ae4-7110-4bb8-95e3-e94001f68b34" CreationDate="2014-03-02T14:10:02.670" UserId="65" Comment="added 206 characters in body" Text="Flash memory is a type of memory available on the Arduino boards. It can be accessed from a program using PROGMEM directive to store data. For questions about using and accessing flash memory, use this tag." />
  <row Id="1543" PostHistoryTypeId="24" PostId="556" RevisionGUID="72654ae4-7110-4bb8-95e3-e94001f68b34" CreationDate="2014-03-02T14:10:02.670" Comment="Proposed by 65 approved by 220 edit id of 193" />
  <row Id="1544" PostHistoryTypeId="5" PostId="562" RevisionGUID="324e1c49-fe69-403e-828f-a6976002f167" CreationDate="2014-03-02T15:00:23.053" UserId="65" Comment="added 42 characters in body" Text="The Arduino IDE by default is oriented towards C++. The linker for example requires `.cpp` files and not `.c` files, otherwise it leads to errors during the linking process. See [name mangling][1] if you want to know more.&#xD;&#xA;&#xD;&#xA;So, what are the tools that I need to setup a C environment? Can this be done from the Arduino IDE itself?&#xD;&#xA;&#xD;&#xA;I work on a Linux system (Ubuntu 12.04).&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Name_mangling" />
  <row Id="1545" PostHistoryTypeId="5" PostId="546" RevisionGUID="abc1aa06-e4c3-4413-b41a-7ea368e1a4ed" CreationDate="2014-03-02T15:57:15.070" UserId="65" Comment="added 245 characters in body" Text="If safety is a major concern, then you should almost always load a stop* sketch onto the board before calling it a day. This would be a good idea, for example, when your board is semi-permanently a part of a larger system. You could do so by: &#xD;&#xA;&#xD;&#xA;- Upload the Bare Minimum sketch found in &lt;kbd&gt;File&lt;/kbd&gt; -&gt;  &lt;kbd&gt;Examples&lt;/kbd&gt; -&gt; &lt;kbd&gt;Basic&lt;/kbd&gt; in the [tag:Arduino-IDE]&#xD;&#xA;- Upload a sketch with a large delay in loop.&#xD;&#xA;&#xD;&#xA;&lt;!-- language: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;    #include &lt;limits.h&gt;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {}&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      delay(ULONG_MAX);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;- Upload a sketch with a [call to `exit()` from `setup()`](http://arduino.stackexchange.com/q/188/65) (*Thanks @Peter!*)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;!-- language: lang-cpp --&gt;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;       exit(0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;*Stop is simply figurative. The board doesnt really stop running.&lt;/sub&gt;&#xD;&#xA;" />
  <row Id="1546" PostHistoryTypeId="2" PostId="563" RevisionGUID="7761faba-6832-4b49-af2f-4cd3bc4bffd4" CreationDate="2014-03-02T16:27:27.340" UserId="65" Text="I am working on a UAV and we are currently exploring inertial measurement units or IMUs. The two options that we have come across are:&#xD;&#xA;&#xD;&#xA;- Using an Arduino Uno and a 9 DOF IMU like [this one][1]&#xD;&#xA;- Using an ArduIMU chip like [this one][2]&#xD;&#xA;&#xD;&#xA;Ignoring the cost aspect, what would be the pros and cons of either of these approaches?&#xD;&#xA;&#xD;&#xA;Keep in mind that performance is very important for a UAV controller as ESCs require 60 Hz or higher refresh rates for stable flight.&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sparkfun.com/products/10724&#xD;&#xA;  [2]: https://www.sparkfun.com/products/11055" />
  <row Id="1547" PostHistoryTypeId="1" PostId="563" RevisionGUID="7761faba-6832-4b49-af2f-4cd3bc4bffd4" CreationDate="2014-03-02T16:27:27.340" UserId="65" Text="Arduino + IMU vs ArduIMU" />
  <row Id="1548" PostHistoryTypeId="3" PostId="563" RevisionGUID="7761faba-6832-4b49-af2f-4cd3bc4bffd4" CreationDate="2014-03-02T16:27:27.340" UserId="65" Text="&lt;arduino-uno&gt;&lt;sensors&gt;&lt;robotics&gt;" />
  <row Id="1550" PostHistoryTypeId="2" PostId="564" RevisionGUID="c2b85a16-9291-469d-a571-09ebb5e34164" CreationDate="2014-03-02T20:18:51.180" UserId="381" Text="Anyone with kids knows they never help with the toilet paper. Anyone know how to track when it's low or out and sound an audible alarm? I just don't know what sensor to use that may help. &#xD;&#xA;&#xD;&#xA;Some that came to mind are: by weight, by reflection (the color of the paper) or some laser tripwire - all right on the spool. I don't mind building it, it's just I don't know which sensor. Anyone know which to use?&#xD;&#xA;&#xD;&#xA;Thanks" />
  <row Id="1551" PostHistoryTypeId="1" PostId="564" RevisionGUID="c2b85a16-9291-469d-a571-09ebb5e34164" CreationDate="2014-03-02T20:18:51.180" UserId="381" Text="Design question: how to alarm when toilet paper is low?" />
  <row Id="1552" PostHistoryTypeId="3" PostId="564" RevisionGUID="c2b85a16-9291-469d-a571-09ebb5e34164" CreationDate="2014-03-02T20:18:51.180" UserId="381" Text="&lt;sensors&gt;" />
  <row Id="1553" PostHistoryTypeId="2" PostId="565" RevisionGUID="4476d0c7-234e-42df-a934-257265897029" CreationDate="2014-03-02T20:40:39.523" UserId="84" Text="One idea that comes to mind would be something like that:&#xD;&#xA;&#xD;&#xA;- stick a small magnet on the paper roll (this has to be done every time you change it; though)&#xD;&#xA;- use a reed contact (electro-magnetic switch) at the tip of a stick mounted with a spring to be always in contact with the paper roll&#xD;&#xA;- one pin of the reed contact can be directly connected to an input logical pin (set it up as a pullup resistor input)&#xD;&#xA;- the other pin of the reed contact is to be connected to the ground&#xD;&#xA;&#xD;&#xA;The difficulty here will be to find the right sensitivity of the reed contact (or the force of the magnet) so that the reed contact gets closed when the distance between it and the magnet is small enough to avoid an alarm that would be activated too soon)." />
  <row Id="1554" PostHistoryTypeId="2" PostId="566" RevisionGUID="e01126f5-a98e-4321-8e90-9d156e069028" CreationDate="2014-03-02T20:43:43.507" UserId="220" Text="## You have a few options:&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Note: The links given are just the first ones that come up. Most of them are pricey compared to other sites. eBay buy it nows can be fairly cheap for most of these items. Check other places, too, including [Sparkfun](http://www.sparkfun.com).&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA; - [Ultrasonic Ping Sensor](http://www.robotmesh.com/parallax-ping-ultrasound-sensor?gclid=CJvLqNvY9LwCFewRMwod0SQAzw). This isn't ideal by any means, but they're easy to use. Just add one with an enclosure. It isn't ideal because it won't be accurate enough to tell when exactly it's empty. It might be a little over/under sensitive. Weight would be harder, though if it shifts at all.&#xD;&#xA; - [Color sensor](https://www.sparkfun.com/products/10904). You mentioned this. This probably would be the best idea. It'll give you analogue values for red, green, and blue. [Assuming that the higher the content of that color, the higher the voltage,] white should be pretty much all of those at 100% and brown I would image that most of them would be about 30-40%. That's kinda confusing, I'll rewrite this part later. Basically, you can then do an if statement with the input values to decide if it's the brown or the white color. If it's brown, sound the alarm.&#xD;&#xA;&#xD;&#xA;Note: these can be a little fidgety. I would recommend a LED instead so the whole house isn't woken up in the middle of the night just because of low toilet paper. If it wasn't in the bathroom, I would recommend a camera and have it take a shot every time it gets very low with a reed switch like @jfpolipret's answer... but... (no pun intended)" />
  <row Id="1555" PostHistoryTypeId="5" PostId="565" RevisionGUID="4e77b3ce-6a43-40a5-9187-a576f131ae1d" CreationDate="2014-03-02T20:47:07.780" UserId="84" Comment="more precision of why this slution shall work" Text="One idea that comes to mind would be something like that:&#xD;&#xA;&#xD;&#xA;- stick a small magnet inside the paper roll, i.e. inside the cardboard part (this has to be done every time you change it; though)&#xD;&#xA;- use a reed contact (electro-magnetic switch) at the tip of a stick mounted with a spring to be always in contact with the paper roll&#xD;&#xA;- one pin of the reed contact can be directly connected to an input logical pin (set it up as a pullup resistor input)&#xD;&#xA;- the other pin of the reed contact is to be connected to the ground&#xD;&#xA;&#xD;&#xA;Thus, as soon as the distance between the magnet and the reed contact is under some limit, the switch will close the circuit. That distance will decrease while the paper roll gets drawn.&#xD;&#xA;&#xD;&#xA;The difficulty here will be to find the right sensitivity of the reed contact (or the force of the magnet) so that the reed contact gets closed when the distance between it and the magnet is small enough to avoid an alarm that would be activated too soon)." />
  <row Id="1556" PostHistoryTypeId="2" PostId="567" RevisionGUID="461f98f1-b1d9-48a9-bdda-a0ea17a1818f" CreationDate="2014-03-02T20:49:38.497" UserId="42" Text="An short-range ultrasound distance sensor might be an effective (and fairly cheap) option. You can get an emitter+sensor combination mounted on a chip. Different sensors may work in different ways (always check the datasheet). A common output though uses the length of a pulse to indicate the distance sensed. You could process that in Arduino using the [`pulseIn()`][1] function.&#xD;&#xA;&#xD;&#xA;In terms of installation, you'd probably fit it directly behind the toilet paper, pointing at the centre of the spool. The readings are often quite erratic, so you want to take several measurements and average them (or use a simple moving average). With a bit of calibration, you could determine what distance represents an empty spool.&#xD;&#xA;&#xD;&#xA;When you detect that distance repeatedly for a significant period (e.g. a minute or more), you'd sound the alarm.&#xD;&#xA;&#xD;&#xA;A reflectance-based sensor might be another possibility, although I wonder if you might struggle to find one which will work properly on toilet paper (depending on how soft your preferred brand is!).&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/PulseIn" />
  <row Id="1557" PostHistoryTypeId="5" PostId="566" RevisionGUID="9b104ddc-2b53-43a7-88e3-8217ca0c4714" CreationDate="2014-03-02T21:06:49.540" UserId="220" Comment="added 1661 characters in body" Text="## You have a few options:&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Note: The links given are just the first ones that come up. Most of them are pricey compared to other sites. eBay buy it nows can be fairly cheap for most of these items. Check other places, too, including [Sparkfun](http://www.sparkfun.com).&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA; - [Ultrasonic Ping Sensor](http://www.robotmesh.com/parallax-ping-ultrasound-sensor?gclid=CJvLqNvY9LwCFewRMwod0SQAzw). This isn't ideal by any means, but they're easy to use. Just add one with an enclosure. It isn't ideal because it won't be accurate enough to tell when exactly it's empty. It might be a little over/under sensitive. Weight would be harder, though if it shifts at all.&#xD;&#xA; - [Color sensor  (preferable, but costs more)](https://www.sparkfun.com/products/10904). You mentioned this and this is probably the best idea. It'll give you analogue values (to read with Arduino) for red, green, and blue. [Assuming that the higher the content of that color, the higher the voltage,] white should be pretty much all of those at 100% and brown I would image that most of them would be about 30-40%. (More later, if you don't understand this, skip this part)&#xD;&#xA;&#xD;&#xA;***&#xD;&#xA;**I'm going to go into more detail on the color sensor:**&#xD;&#xA;&#xD;&#xA;Colors are read with three values here: red, green, and blue. There are three sensors on the board. One filters out everything except red, another blue, and the other green. The sensors on the board detect the amount of incoming light and then convert that to a voltage: between 5V (&quot;100% red/green/blue&quot;) or 0V (&quot;0% red/green/blue&quot;). This then can be converted into a number by the Arduino (0-1024 on an analogue pin).&#xD;&#xA;&#xD;&#xA;**A problem with lighting:**&#xD;&#xA;This sensor, from what I can tell, has a LED that's always on. You'll want to either desolder that or cover it up, unless you want an illuminated toilet paper holder. Now wait... your sensor will think that when it's dark, it's brown. No problem... here's something for you mind to think about.&#xD;&#xA;&#xD;&#xA;[Use a color picker like I'm using and select a brown](http://www.w3schools.com/tags/ref_colorpicker.asp). On the left of this one, you can control the &quot;simulated brightness.&quot; Besides that is the hexadecimal form of RGB. You'll want to convert that to standard [values with this calcuator](http://www.javascripter.net/faq/hextorgb.htm).&#xD;&#xA;&#xD;&#xA;In brown, the color blue is almost nonexistent. We should ignore that color, unless you want a way to double check that it's brown. I'd say it should always be under 40% for pretty much any shade of brown.&#xD;&#xA;&#xD;&#xA;From what I can tell with a sample shade of brown, the red is pretty much 2x the green. That ratio may vary, but you should verify that it is *somewhat* existent. For white/grey/black, all the colors are proportional 1:1:1. You can use this to detect if it's dark, or if it's brown.&#xD;&#xA;&#xD;&#xA;[Sample code coming... one minute here...]&#xD;&#xA;***&#xD;&#xA;Note: these can be a little fidgety. **I would recommend a LED instead** so the whole house isn't woken up in the middle of the night just because of low toilet paper. Also, if you obstruct the sensor at all... If it wasn't in the bathroom, I would recommend a camera and have it take a shot every time it gets very low with a reed switch like @jfpolipret's answer... but... (no pun intended) :)" />
  <row Id="1558" PostHistoryTypeId="2" PostId="568" RevisionGUID="88b0a813-4fa2-4c86-b311-92c78f6130b7" CreationDate="2014-03-02T21:11:46.487" UserId="313" Text="Bring up several rolls at a time and hang one for use. Put the other two on a short vertical pole within reach of the sitter. Sitter can take another roll when needed. &#xD;&#xA;&#xD;&#xA;Mechanically sense lack of weight on the shelf at the bottom of the pole. Alarm triggers when the last roll is removed. No one has to get caught short." />
  <row Id="1559" PostHistoryTypeId="5" PostId="565" RevisionGUID="95f7af14-ef74-406a-a69e-1797a79f1dd1" CreationDate="2014-03-02T21:17:19.300" UserId="84" Comment="added hall effect as an option instead of reed" Text="One idea that comes to mind would be something like that:&#xD;&#xA;&#xD;&#xA;- stick a small magnet inside the paper roll, i.e. inside the cardboard part (this has to be done every time you change it; though)&#xD;&#xA;- use a reed contact (electro-magnetic switch) at the tip of a stick mounted with a spring to be always in contact with the paper roll&#xD;&#xA;- one pin of the reed contact can be directly connected to an input logical pin (set it up as a pullup resistor input)&#xD;&#xA;- the other pin of the reed contact is to be connected to the ground&#xD;&#xA;&#xD;&#xA;Thus, as soon as the distance between the magnet and the reed contact is under some limit, the switch will close the circuit. That distance will decrease while the paper roll gets drawn.&#xD;&#xA;&#xD;&#xA;Note that, instead of a reed contact, you may also use a Hall Effect sensor, the principles remain the same, only technology and characteristics change.&#xD;&#xA;&#xD;&#xA;The difficulty here will be to find the right sensitivity of the reed contact (or the force of the magnet) so that the reed contact gets closed when the distance between it and the magnet is small enough to avoid an alarm that would be activated too soon)." />
  <row Id="1560" PostHistoryTypeId="33" PostId="348" RevisionGUID="0fef5d05-5ac3-4c34-978b-309e5da8963f" CreationDate="2014-03-02T21:31:19.413" UserId="84" Comment="3" />
  <row Id="1561" PostHistoryTypeId="5" PostId="566" RevisionGUID="a6099484-1998-4978-a162-f01d7e5234b7" CreationDate="2014-03-02T21:54:27.677" UserId="220" Comment="added 1991 characters in body" Text="## You have a few options:&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;Note: The links given are just the first ones that come up. Most of them are pricey compared to other sites. eBay buy it nows can be fairly cheap for most of these items. Check other places, too, including [Sparkfun](http://www.sparkfun.com).&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA; - [Ultrasonic Ping Sensor](http://www.robotmesh.com/parallax-ping-ultrasound-sensor?gclid=CJvLqNvY9LwCFewRMwod0SQAzw). This isn't ideal by any means, but they're easy to use. Just add one with an enclosure. It isn't ideal because it won't be accurate enough to tell when exactly it's empty. It might be a little over/under sensitive. Weight would be harder, though if it shifts at all.&#xD;&#xA; - [Color sensor  (preferable, but costs more)](https://www.sparkfun.com/products/10904). You mentioned this and this is probably the best idea. It'll give you analogue values (to read with Arduino) for red, green, and blue. [Assuming that the higher the content of that color, the higher the voltage,] white should be pretty much all of those at 100% and brown I would image that most of them would be about 30-40%. (More later, if you don't understand this, skip this part)&#xD;&#xA;&#xD;&#xA;***&#xD;&#xA;**I'm going to go into more detail on the color sensor:**&#xD;&#xA;&#xD;&#xA;Colors are read with three values here: red, green, and blue. There are three sensors on the board. One filters out everything except red, another blue, and the other green. The sensors on the board detect the amount of incoming light and then convert that to a voltage: between 5V (&quot;100% red/green/blue&quot;) or 0V (&quot;0% red/green/blue&quot;). This then can be converted into a number by the Arduino (0-1024 on an analogue pin).&#xD;&#xA;&#xD;&#xA;**A problem with lighting:**&#xD;&#xA;This sensor, from what I can tell, has a LED that's always on. You'll want to either desolder that or cover it up, unless you want an illuminated toilet paper holder. Now wait... your sensor will think that when it's dark, it's brown. No problem... here's something for you mind to think about.&#xD;&#xA;&#xD;&#xA;[Use a color picker like I'm using and select a brown](http://www.w3schools.com/tags/ref_colorpicker.asp). On the left of this one, you can control the &quot;simulated brightness.&quot; Besides that is the hexadecimal form of RGB. You'll want to convert that to standard [values with this calcuator](http://www.javascripter.net/faq/hextorgb.htm).&#xD;&#xA;&#xD;&#xA;In brown, the color blue is almost nonexistent. We should ignore that color, unless you want a way to double check that it's brown. I'd say it should always be under 40% for pretty much any shade of brown.&#xD;&#xA;&#xD;&#xA;From what I can tell with a sample shade of brown, the red is pretty much 2x the green. That ratio may vary, but you should verify that it is *somewhat* existent. For white/grey/black, all the colors are proportional 1:1:1. You can use this to detect if it's dark, or if it's brown.&#xD;&#xA;&#xD;&#xA;    int rPin = A0;      //Red Pin&#xD;&#xA;    int gPin = A1;      //Green Pin&#xD;&#xA;    int bPin = A2;      //Blue Pin&#xD;&#xA;    int ledPin = 13;    //I made this code with a LED, not a speaker&#xD;&#xA;    boolean testTwice = false;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      pinMode(ledPin, OUTPUT);  &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      int rValue = analogRead(rPin);&#xD;&#xA;      int gValue = analogRead(gPin);&#xD;&#xA;      int bValue = analogRead(bPin);&#xD;&#xA;      &#xD;&#xA;      if (bPin &lt; 256) { //If this is false, either something is in the way or it's white. Going to verify that something's not in the way...&#xD;&#xA;        int minRed = rPin * 0.4; //A little under a half for padding... this values may need to be adjusted. Adjust this one and the one below farther apart for less sensitive.&#xD;&#xA;        int maxRed = rPin * 0.6; //A little over a half for padding... this values may need to be adjusted.&#xD;&#xA;        if (gPin &lt; maxRed &amp;&amp; gPin &gt; minRed) { //Verifys that red between minRed and maxRed&#xD;&#xA;          digitalWrite(ledPin, HIGH);&#xD;&#xA;          delay(5000);&#xD;&#xA;          digitalWrite(ledPin, LOW);&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      delay(5000); // No need to waste power... you might want to add an actutal sleep function if on battery power&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;First, it verifies that the blue is less than 25%. Then, it verifies that the red and green are equal... give or take 20%. (i.e. red = 100 green = 80, red = 110 green = 90, etc.). If that is true, you can pretty much establish that it's brown. Then, a LED turn on for five seconds.&#xD;&#xA;&#xD;&#xA;You can modify the LED to be a buzzer if you want. You might have to adjust the if statement with verifying that the blue is less than 256/1024 (1024 = resolution of analog pin) if it isn't working in a lot of light or is working in dark light. Since the code later verifies that the red is about 2x the green, any shade of white shouldn't pass that if statement. You may also have to adjust the `minRed` and `maxRed` to be farther (if not detecting brown) or closer (if detecting brown when it's white). I can't really test this code with no color sensor.&#xD;&#xA;***&#xD;&#xA;Note: these can be a little fidgety. **I would recommend a LED instead** so the whole house isn't woken up in the middle of the night just because of low toilet paper. Also, if you obstruct the sensor at all... If it wasn't in the bathroom, I would recommend a camera and have it take a shot every time it gets very low with a reed switch like @jfpolipret's answer... but... (no pun intended) :)" />
  <row Id="1562" PostHistoryTypeId="2" PostId="569" RevisionGUID="328b6ad1-d0de-4d30-b550-6858fcc026b7" CreationDate="2014-03-02T22:11:52.803" UserId="313" Text="Both variables are static - they persist for the entire execution session. The global is visible to all function if it declares - not defines - the global, or if the follows the definition in the same compilation unit (file + includes).&#xD;&#xA;&#xD;&#xA;Moving the definition of `count` to inside of a function both limits its scope of visibility to the nearest enclosing set of `{}`es, and gives it function invocation lifetime (it is created and destroyed as the function is entered and exited). Declaring it `static` as well gives it execution session lifetime (it exists from the start to the end of the execution session, persisting across function invocations)." />
  <row Id="1563" PostHistoryTypeId="2" PostId="570" RevisionGUID="4b600cbc-6e71-489a-9fd2-c06e8cb11494" CreationDate="2014-03-02T22:16:08.053" UserId="397" Text="Sounds like a cool project, here are my 2 ct:&#xD;&#xA;&#xD;&#xA;Point a camera to take photos of the roll from sideways, that is probably the only way to really find out how much paper is left.&#xD;&#xA;&#xD;&#xA;For an estimate it might also be enough to count rotations of the roll, but you need to fiix the roll better so it doesn't slip. Or you can use magnets like you do on bicycles, but they need to be attached to the roll directly then." />
  <row Id="1564" PostHistoryTypeId="5" PostId="569" RevisionGUID="bdc2773e-2503-4e64-9ea6-ba3c4e462383" CreationDate="2014-03-02T22:16:53.880" UserId="313" Comment="added 467 characters in body" Text="Both variables are static - they persist for the entire execution session. The global is visible to any function if it declares - not defines - the global, or if the function follows the definition in the same compilation unit (file + includes).&#xD;&#xA;&#xD;&#xA;Moving the definition of `count` to inside of a function both limits its scope of visibility to the nearest enclosing set of `{}`es, and gives it function invocation lifetime (it is created and destroyed as the function is entered and exited). Declaring it `static` as well gives it execution session lifetime it exists from the start to the end of the execution session, persisting across function invocations.&#xD;&#xA;&#xD;&#xA;BTW: be cautious about using initialized statics within a function, as I have seen some versions of the gnu compiler get this wrong. An automatic variable with an initializer should be created and initialized on every function entry. A static with an initializer should only be initialized once, during the execution setup, before main() is given control (just as a global would be). I have had local statics get reinitialized on each function entry as though they were automatics, which is incorrect. Test your own compiler to be sure." />
  <row Id="1565" PostHistoryTypeId="2" PostId="571" RevisionGUID="db2837d3-6a79-41cf-bfd8-297ca7ebc8fe" CreationDate="2014-03-02T22:57:16.733" UserId="313" Text="If you can tolerate the data volume, debugging communicatons is **so** much easier when sending strings than when sending binary; sprintf()/sscanf() and their variants are your friends here. Enclose the communication in dedicated functions in their own module (.cpp file); if you need to optimize the channel later - **after** you have a working system - you can replace the string-based module with one coded for smaller messages.&#xD;&#xA;&#xD;&#xA;You'll make your life lots easier if you hold tight to protocol specs on transmission and interpret them more loosely on reception, regard to field widths, delimiters, line endings, insignificant zeros, presence of `+` signs, etc. &#xD;&#xA;" />
  <row Id="1566" PostHistoryTypeId="5" PostId="570" RevisionGUID="932ce5e7-0528-422b-9256-1c97d8d1b0ac" CreationDate="2014-03-02T23:00:40.160" UserId="397" Comment="answered question from comment" Text="Sounds like a cool project, here are my 2 ct:&#xD;&#xA;&#xD;&#xA;Point a camera to take photos of the roll from sideways, that is probably the only way to really find out how much paper is left. (edit: You could use a raspberry pi with the csi camera and create an output signal corresponding to the number of sheets and feed that signal to the arduino?!)&#xD;&#xA;&#xD;&#xA;For an estimate it might also be enough to count rotations of the roll, but you need to fiix the roll better so it doesn't slip. Or you can use magnets like you do on bicycles, but they need to be attached to the roll directly then.&#xD;&#xA;&#xD;&#xA;(edit: one more idea, mesure the thickness of the roll by measuring the angle of the lid)" />
  <row Id="1567" PostHistoryTypeId="2" PostId="572" RevisionGUID="f40b01f3-62b6-4f75-9bb1-305047b9b719" CreationDate="2014-03-02T23:19:02.123" UserId="313" Text="You could interrupt instead of polling if you can de-bounce the buttons in hardware. Otherwise you'll be take many more interrupts than there were button presses and still have to de-bounce them in software.&#xD;&#xA;&#xD;&#xA;But to the primary question, a collection of state machines can be very useful, at least for the ui, and give you most of the benefits of multi-tasking without needed a m/t kernel.  can be  in RAM limited devices, unfortunately, because &#xD;&#xA;&#xD;&#xA;The technique could be especially useful on these small devices but for the severe limits on RAM, making it something of a challenge to divide your state-machine data between flash and RAM, to fit." />
  <row Id="1568" PostHistoryTypeId="2" PostId="573" RevisionGUID="9db9ccfd-776f-4d2d-af59-9f1b6e2317b6" CreationDate="2014-03-03T02:45:31.253" UserId="401" Text="Use a radiation detector to detect the amount of paper left on the roll. Place some amount of radioactive material in the middle of the roll, and place the radiation detector somewhere else (you could mount it on the other side of the surface the roll holder is mounted to, if you want), and measure the radiation amounts to determine how much paper is left on the roll." />
  <row Id="1569" PostHistoryTypeId="5" PostId="573" RevisionGUID="bf50af89-069e-46a2-9ac4-fe0a410f33a2" CreationDate="2014-03-03T02:51:10.553" UserId="401" Comment="added 340 characters in body" Text="Use a radiation detector to detect the amount of paper left on the roll. Place some amount of radioactive material in the middle of the roll, and place the radiation detector somewhere else (you could mount it on the other side of the surface the roll holder is mounted to, if you want), and measure the radiation amounts to determine how much paper is left on the roll.&#xD;&#xA;&#xD;&#xA;Alternately, you could have an electronically controlled toilet paper dispenser (push button to dispense a preprogrammed length of toilet paper) and have the arduino just keep track of how much has been dispensed.&#xD;&#xA;&#xD;&#xA;Or, attach a rotary encoder to the side of the roll, and count the rotations of the roll to determine how much has been used." />
  <row Id="1570" PostHistoryTypeId="2" PostId="574" RevisionGUID="ab4eb453-35a4-43f8-a696-79bec93a6b9d" CreationDate="2014-03-03T05:07:38.563" UserId="405" Text="I am using the A0 port on my Arduino Uno to read the voltage output from an LM35 temperature sensor.  I observed that the reading fluctuates a lot if I leave the remaining analog input ports A1 to A5 floating. Would floating analog inputs affect the accuracy of readings on input ports connected to some signals." />
  <row Id="1571" PostHistoryTypeId="1" PostId="574" RevisionGUID="ab4eb453-35a4-43f8-a696-79bec93a6b9d" CreationDate="2014-03-03T05:07:38.563" UserId="405" Text="Should all unused analog input ports be tied to ground for accurate A2D measurements?" />
  <row Id="1572" PostHistoryTypeId="3" PostId="574" RevisionGUID="ab4eb453-35a4-43f8-a696-79bec93a6b9d" CreationDate="2014-03-03T05:07:38.563" UserId="405" Text="&lt;arduino-uno&gt;&lt;pins&gt;" />
  <row Id="1573" PostHistoryTypeId="2" PostId="575" RevisionGUID="c6a85e87-b734-4b57-abee-efc0bdb30bea" CreationDate="2014-03-03T05:37:08.900" UserId="407" Text="Any floating pin will act as an antenna, and may interfere with values around it, this is one of the major disadvantages of using analog.&#xD;&#xA;&#xD;&#xA;To get the most accurate readings with minimal amount of interference, you can pull all unused inputs to ground.&#xD;&#xA;&#xD;&#xA;The accuracy will not change, as the accuracy is determined by the sensor itself. However it will reduce the amount of noise / interference, which will give you more accurate readings.&#xD;&#xA;&#xD;&#xA;    pinMode(A1, OUTPUT);&#xD;&#xA;    digitalWrite(A1, LOW);" />
  <row Id="1574" PostHistoryTypeId="5" PostId="575" RevisionGUID="de20d811-4ed9-4d01-aead-34b87c41dddf" CreationDate="2014-03-03T05:42:31.690" UserId="407" Comment="added 125 characters in body" Text="Any floating pin will act as an antenna, and may interfere with values around it, this is one of the major disadvantages of using analog.&#xD;&#xA;&#xD;&#xA;To get the most accurate readings with minimal amount of interference, you can pull all unused inputs to ground.&#xD;&#xA;&#xD;&#xA;The accuracy will not change, as the accuracy is determined by the sensor itself. However it will reduce the amount of noise / interference, which will give you more accurate readings.&#xD;&#xA;&#xD;&#xA;These pull to grounds can be accomplished by configuring the unused analog pins as digital outputs, and setting them low.&#xD;&#xA;&#xD;&#xA;    pinMode(A1, OUTPUT);&#xD;&#xA;    digitalWrite(A1, LOW);" />
  <row Id="1575" PostHistoryTypeId="2" PostId="576" RevisionGUID="96e70262-77aa-444a-9ee0-968b43141cf4" CreationDate="2014-03-03T08:45:26.233" UserId="136" Text="I am currently using a ST7565 graphic LCD for display in a heat pump system.&#xD;&#xA;&#xD;&#xA;This LCD has the following characteristics:&#xD;&#xA;&#xD;&#xA; - 128x64 pixels&#xD;&#xA; - 2.5&quot;x1.5&quot;&#xD;&#xA; - monochrome, no greyscale&#xD;&#xA; - backlit&#xD;&#xA; - good viewing angles&#xD;&#xA; - serially connected (i.e. only uses a small number of pins)&#xD;&#xA; - high enough refresh rate to show animated icons&#xD;&#xA; - low cost (£20)&#xD;&#xA; - has a high-quality, maintained library&#xD;&#xA; - available from multiple sources for several years&#xD;&#xA;&#xD;&#xA;I am finding the resolution of the screen limiting for my application. Ideally I would like a display that is exactly the same but with a higher resolution. Something between&#xD;&#xA;&#xD;&#xA;I do not want:&#xD;&#xA;&#xD;&#xA; - colour (largely as the display is less visible, but also increased cost and code complexity), but red/green/blue on black would be OK.&#xD;&#xA; - a physically smaller display (all of the OLED displays are small - 2&quot; and below) as it needs to be visible from a distance&#xD;&#xA;&#xD;&#xA;Are there any displays that meet these requirements?&#xD;&#xA;&#xD;&#xA;I hope that the specific requirements here mean that this is not a simple &quot;[shopping question][1]&quot;.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://meta.arduino.stackexchange.com/questions/16/when-should-questions-be-considered-shopping-recommendations" />
  <row Id="1576" PostHistoryTypeId="1" PostId="576" RevisionGUID="96e70262-77aa-444a-9ee0-968b43141cf4" CreationDate="2014-03-03T08:45:26.233" UserId="136" Text="Are there any commonly available and supported backlit, monochrome graphic LCDs with more than 128x64 pixels?" />
  <row Id="1577" PostHistoryTypeId="3" PostId="576" RevisionGUID="96e70262-77aa-444a-9ee0-968b43141cf4" CreationDate="2014-03-03T08:45:26.233" UserId="136" Text="&lt;display&gt;" />
  <row Id="1578" PostHistoryTypeId="2" PostId="577" RevisionGUID="30fd3fb4-67d3-4ac3-80a7-504dbe4d88f5" CreationDate="2014-03-03T10:47:43.347" UserId="379" Text="Here you can find a bunch of displays at [new haven display](http://www.newhavendisplay.com/oled-graphic-oled-c-119_577.html?zenid=jpvgfaffukfrnbam6l9mnkbqg1), which are big and OLED and not too expensive:&#xD;&#xA;&#xD;&#xA; * [2.7&quot; 128x64 OLED](http://www.newhavendisplay.com/images/NHD-2.7-12864UCY3-front-NOBL.jpg)&#xD;&#xA; * [3.12&quot; 256x64 OLED](http://www.newhavendisplay.com/nhd31225664umy3-p-6092.html)&#xD;&#xA;&#xD;&#xA;You got also [LCD ones](http://www.newhavendisplay.com/lcd-graphic-c-21.html) over there:&#xD;&#xA;&#xD;&#xA; * [320x240 LCD with backlight](http://www.newhavendisplay.com/lcd-graphic-320-x-240-c-21_107.html) " />
  <row Id="1579" PostHistoryTypeId="5" PostId="577" RevisionGUID="dc749de1-a26a-4b22-a76c-a8f64f35a85e" CreationDate="2014-03-03T10:54:41.610" UserId="379" Comment="added 396 characters in body" Text="Here you can find a bunch of displays at [new haven display](http://www.newhavendisplay.com/oled-graphic-oled-c-119_577.html?zenid=jpvgfaffukfrnbam6l9mnkbqg1), which are big and OLED and not too expensive:&#xD;&#xA;&#xD;&#xA; * [2.7&quot; 128x64 OLED](http://www.newhavendisplay.com/images/NHD-2.7-12864UCY3-front-NOBL.jpg)&#xD;&#xA; * [3.12&quot; 256x64 OLED](http://www.newhavendisplay.com/nhd31225664umy3-p-6092.html)&#xD;&#xA;&#xD;&#xA;Those OLED Displays have a really excellent viewing angle and can be read from far (given you accept those sizes, which are &gt;2&quot;).&#xD;&#xA;&#xD;&#xA;Otherwise, the biggest I know about are [LCD ones from NHD](http://www.newhavendisplay.com/lcd-graphic-c-21.html) over there:&#xD;&#xA;&#xD;&#xA; * [320x240 LCD with backlight](http://www.newhavendisplay.com/lcd-graphic-320-x-240-c-21_107.html)&#xD;&#xA;&#xD;&#xA;What's good with them, it's that they can cope with production in case this is needed, their prices are decent and their product just work(cTMr). You can find the [u8g library](https://code.google.com/p/u8glib/) to run them." />
  <row Id="1582" PostHistoryTypeId="2" PostId="579" RevisionGUID="47fbf650-57e7-4804-b17d-e5ff1eb674a8" CreationDate="2014-03-03T11:57:39.827" UserId="379" Text="My way of organizing an arduino project is quite simple, all my project are git repositories so that there is at least the following:&#xD;&#xA;&#xD;&#xA; * project/&#xD;&#xA;   * project.ino&#xD;&#xA;   * [Makefile](https://github.com/guyzmo/Arduino-Tools/blob/master/Makefile)&#xD;&#xA;&#xD;&#xA;I have a preference using my [favorite editor](http://vim.org) and a [Makefile](https://github.com/guyzmo/Arduino-Tools/blob/master/Makefile) which I have crafted to work against most use cases (and I even improved on that one that I'm going to share soon).&#xD;&#xA;&#xD;&#xA;For the libraries, I prefer to keep them as their own repositories and use git submodule to include them to the project. As many libraries written by the community are shared as git repositories, that's a good generic solution. Then, within the Makefile, I just have to add the libraries path I want to include in the [LOCALLIBS](https://github.com/guyzmo/Arduino-Tools/blob/master/Makefile#L63) variable.&#xD;&#xA;&#xD;&#xA;Though, for some projects, it makes sense to encapsulate the libraries into a hardware abstraction layer library crafted for the project, then I prefer to use a path such as:&#xD;&#xA;&#xD;&#xA;  * `project`&#xD;&#xA;     * `project.ino`&#xD;&#xA;     * `Makefile`&#xD;&#xA;     * `project_hal_lib`&#xD;&#xA;        * `library1`&#xD;&#xA;        * `library2`&#xD;&#xA;        * `library3`&#xD;&#xA;        * …&#xD;&#xA;&#xD;&#xA;Though, with arduino 1.5.x a new [way to specify libraries](https://github.com/arduino/Arduino/wiki/Arduino-IDE-1.5:-Library-specification) is offered, that will offer a way to create and build arduino projects the same way we already do with pipy and virtualenv in python, i.e. you define the set of libraries you need and they get downloaded." />
  <row Id="1584" PostHistoryTypeId="2" PostId="580" RevisionGUID="329ab761-a66b-4a62-884b-278cc0ce8524" CreationDate="2014-03-03T12:13:37.963" UserId="379" Text="The simplest, yet best solution afaict, would be to use an optocoupler made of one IR LED and an opto-transistor. You make the LED lighten towards the roll, the LED being within the roll tied to the &quot;handle&quot;. Once you remove the cardboard roll, the opto-transistor gets the IR light from the LED and triggers a pin change interruption on the Arduino, which can then alert you through many ways (light, SMS, twitter, alarm…).&#xD;&#xA;&#xD;&#xA;That design is really cheap, easy and fast to build. Though there's still one thing you need to do: when there's no more toilet paper, you need to actually have the cardboard roll *removed* ;-)&#xD;&#xA;&#xD;&#xA;Otherwise, the same kind of solution for the spare rolls is even a better idea :-)" />
  <row Id="1585" PostHistoryTypeId="5" PostId="563" RevisionGUID="ca6ee7b2-5732-4312-86f2-4bdfca347e9b" CreationDate="2014-03-03T13:43:59.567" UserId="65" Comment="added 46 characters in body" Text="I am working on a UAV and we are currently exploring inertial measurement units or IMUs. The two options that we have come across are:&#xD;&#xA;&#xD;&#xA;- Using an Arduino Uno and a 9 DOF IMU like [this one][1]&#xD;&#xA;- Using an ArduIMU chip like [this one][2]&#xD;&#xA;&#xD;&#xA;Ignoring the cost aspect and assuming the same microprocessor on board, what would be the pros and cons of either of these approaches?&#xD;&#xA;&#xD;&#xA;Keep in mind that performance is very important for a UAV controller as ESCs require 60 Hz or higher refresh rates for stable flight.&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sparkfun.com/products/10724&#xD;&#xA;  [2]: https://www.sparkfun.com/products/11055" />
  <row Id="1586" PostHistoryTypeId="5" PostId="573" RevisionGUID="1eefd585-616e-4c00-83c3-7b5c22223849" CreationDate="2014-03-03T14:54:43.100" UserId="401" Comment="added 42 characters in body" Text="Use a radiation detector to detect the amount of paper left on the roll. Place some amount of radioactive material in the middle of the roll, and place the radiation detector somewhere else (you could mount it on the other side of the surface the roll holder is mounted to, if you want; radiation sensors are extremely flexible), and measure the radiation amounts to determine how much paper is left on the roll.&#xD;&#xA;&#xD;&#xA;Alternately, you could have an electronically controlled toilet paper dispenser (push button to dispense a preprogrammed length of toilet paper) and have the arduino just keep track of how much has been dispensed.&#xD;&#xA;&#xD;&#xA;Or, attach a rotary encoder to the side of the roll, and count the rotations of the roll to determine how much has been used." />
  <row Id="1587" PostHistoryTypeId="2" PostId="581" RevisionGUID="19bdb2fd-649a-4cd8-a115-75d57a5d77a1" CreationDate="2014-03-03T15:07:17.307" UserId="58" Text="Weight, marginal as the difference between one board (with everything on it) and two boards (Uno plus DOF) may be - for model airplanes every bit counts. &#xD;&#xA;&#xD;&#xA;Size, the traditional &quot;Uno&quot; is much larger than the ArduIMU integrated boards.&#xD;&#xA;&#xD;&#xA;Power, the integrated board PROBABLY will use less and thus get away with a smaller (lighter) battery." />
  <row Id="1588" PostHistoryTypeId="2" PostId="582" RevisionGUID="0773cf3a-a6f0-4ef5-9e31-74552d324e97" CreationDate="2014-03-03T15:13:39.260" UserId="425" Text="I think I saw this in series 1 episode 2 of James May's Manlab. &#xD;&#xA;&#xD;&#xA;Similar to jfpoilpret, use a wide reed on a spring that makes contact with the roll at all times. I say 'wide' so that when the roll is empty the reed touches with a contact on one of the roll holders on the side. When it touches it completes a circuit to your alarm." />
  <row Id="1589" PostHistoryTypeId="5" PostId="564" RevisionGUID="5d44c44f-7592-4105-99dc-61e4cee68756" CreationDate="2014-03-03T15:15:13.953" UserId="65" Comment="Edited title; added relevant tag" Text="Anyone with kids knows they never help with the toilet paper. Anyone know how to track when it's low or out and sound an audible alarm? I just don't know what sensor to use that may help. &#xD;&#xA;&#xD;&#xA;Some that came to mind are: by weight, by reflection (the color of the paper) or some laser tripwire - all right on the spool. I don't mind building it, it's just I don't know which sensor. Anyone know which to use?" />
  <row Id="1590" PostHistoryTypeId="4" PostId="564" RevisionGUID="5d44c44f-7592-4105-99dc-61e4cee68756" CreationDate="2014-03-03T15:15:13.953" UserId="65" Comment="Edited title; added relevant tag" Text="How to trigger an alarm when toilet paper is low?" />
  <row Id="1591" PostHistoryTypeId="6" PostId="564" RevisionGUID="5d44c44f-7592-4105-99dc-61e4cee68756" CreationDate="2014-03-03T15:15:13.953" UserId="65" Comment="Edited title; added relevant tag" Text="&lt;sensors&gt;&lt;system-design&gt;" />
  <row Id="1592" PostHistoryTypeId="24" PostId="564" RevisionGUID="5d44c44f-7592-4105-99dc-61e4cee68756" CreationDate="2014-03-03T15:15:13.953" Comment="Proposed by 65 approved by 42 edit id of 198" />
  <row Id="1593" PostHistoryTypeId="5" PostId="581" RevisionGUID="ca4cad65-5391-4827-8a46-b8fdd901ccc8" CreationDate="2014-03-03T15:42:39.937" UserId="8" Comment="formatting..." Text="**Weight:** marginal as the difference between one board (with everything on it) and two boards (Uno plus DOF) may be - for model airplanes every bit counts. &#xD;&#xA;&#xD;&#xA;**Size:** the traditional &quot;Uno&quot; is much larger than the ArduIMU integrated boards.&#xD;&#xA;&#xD;&#xA;**Power:** the integrated board PROBABLY will use less and thus get away with a smaller (lighter) battery." />
  <row Id="1594" PostHistoryTypeId="2" PostId="583" RevisionGUID="bb8e79e6-b41d-4d05-926e-de610b51aab3" CreationDate="2014-03-03T16:28:28.857" UserId="310" Text="Your best option is attaching a rotary encoder to the side of the roll, and count the rotations of the roll to determine how much has been used. Once you know the number of rotations per roll,you can set where you want your notification to fire. Attach it to a logging system of sorts and you'll have historical data of paper use as well as toilet use.&#xD;&#xA;" />
  <row Id="1595" PostHistoryTypeId="2" PostId="584" RevisionGUID="0a6fbd41-e79b-4167-95a6-aad0639d1d49" CreationDate="2014-03-03T16:43:42.907" UserId="379" Text="Well, if you want to do more advanced stuff with your AVRs, you should definitely leave the Arduino environment, and integrate your AVR development in your &quot;usual&quot; favorite development environment, whatever it is.&#xD;&#xA;&#xD;&#xA;Then you've got two choices, either do 100% pure C with AVR libraries, for which you only need a simple makefile that calls avr-gcc with avr-libc libraries as include path. You can also use Atmel Studio that helps you a lot on that stuff. But if you do so, you're loosing the advantages of the libraries built for/by the arduino community – which, sadly, is not a huge loss for a strong majority of those.&#xD;&#xA;&#xD;&#xA;Or you can work your code out as a 100% C external library, used from within the sketch, and included at linking time. Then you'll have all the advantages of working with any C++ library you'd like to have, but still doing the important code in pure C. Having only the `.ino` used to generate the main `.cpp` and any `.cpp` library you'd need. Though, for many basic features like writing on the serial port, you'll have to do it [the good old way][2] or by doing some weird encapsulation of `Serial.println()` call sent as a functor to the pure C parts.&#xD;&#xA;&#xD;&#xA;In the [makefile][1] I've written (debian offers another one with the non-gui install of arduino), every `.c` file from declared libraries are detected and compiled with avr-gcc, every `.cpp` file is compiled with `avr-g++` and both gets linked when doing the `.elf`/`.hex` file.&#xD;&#xA;&#xD;&#xA;[1]:https://github.com/guyzmo/Arduino-Tools/blob/master/Makefile" />
  <row Id="1596" PostHistoryTypeId="5" PostId="582" RevisionGUID="73cca354-efbb-40ec-b4af-ec90a4d78afe" CreationDate="2014-03-03T17:10:42.697" UserId="425" Comment="Adding image to help explain idea" Text="I think I saw this in series 1 episode 2 of James May's Manlab. &#xD;&#xA;&#xD;&#xA;Similar to jfpoilpret, use a wide reed on a spring that makes contact with the roll at all times. I say 'wide' so that when the roll is empty the reed touches with a contact on one of the roll holders on the side. When it touches it completes a circuit to your alarm.&#xD;&#xA;&#xD;&#xA;Here's a crude image describing what I mean.&#xD;&#xA;&#xD;&#xA;![Behold the image of my imagination][1]&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/uSWHr.jpg" />
  <row Id="1597" PostHistoryTypeId="2" PostId="585" RevisionGUID="b3f9200f-d827-4867-a7b3-dd9391ff1e1c" CreationDate="2014-03-03T17:32:34.200" UserId="427" Text="I believe the reed sensor concept put forth by jfpoilpret and jmathew is the easiest to accomplish. I have drawn a diagram of how I think it would look.&#xD;&#xA;&#xD;&#xA;You could adjust sensitivity by adjusting the height of the lower contact.&#xD;&#xA;&#xD;&#xA;This really only gets you to a &quot;low&quot; condition and not necessarily out. Unless you want to change rolls while there are still a few sheets left this doesn't seem to me to be a satisfactory solution. I'd rather have an &quot;out&quot; indicator and have an audible buzzer to prompt/shame the user into replacing the roll.&#xD;&#xA;&#xD;&#xA;This design could be accomplished using standalone electronics (no arduino needed). However it you wanted to gamify the changing of the roll you could use an arduino for that.&#xD;&#xA;&#xD;&#xA;Note also for color based optics sensors, while the vast majority of cardboard tubes used for this purpose are brown, I have seen white ones in use as well.&#xD;&#xA;&#xD;&#xA;![Reed Sensor Diagram](http://i.imgur.com/nnAFUih.png)&#xD;&#xA;" />
  <row Id="1598" PostHistoryTypeId="5" PostId="568" RevisionGUID="a1342a33-224d-46be-b1d3-0a933c9b6490" CreationDate="2014-03-03T18:39:09.873" UserId="225" Comment="added a hardware example and two more mechanical options" Text="Bring up several rolls at a time and hang one for use. Put the other two on a short vertical pole within reach of the sitter. Sitter can take another roll when needed. &#xD;&#xA;&#xD;&#xA;Mechanically sense lack of weight on the shelf at the bottom of the pole. Alarm triggers when the last roll is removed. No one has to get caught short.&#xD;&#xA;&#xD;&#xA;To sense the weight use a force sensitive resistor such as the [FSR 400][1] (see [datasheet][2]). Alternatively, you could use a lightweight coil spring to rest the toilet paper on with a micro switch that is released when both rolls are removed. Another option would be an IR beam break detector where the circuit is completed when the last roll is removed.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sparkfun.com/products/9673&#xD;&#xA;  [2]: http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/ForceFlex/2010-10-26-DataSheet-FSR400-Layout2.pdf" />
  <row Id="1599" PostHistoryTypeId="24" PostId="568" RevisionGUID="a1342a33-224d-46be-b1d3-0a933c9b6490" CreationDate="2014-03-03T18:39:09.873" Comment="Proposed by 225 approved by 11 edit id of 199" />
  <row Id="1600" PostHistoryTypeId="2" PostId="586" RevisionGUID="75c94d27-92ed-4527-824f-8bdb17dd6e00" CreationDate="2014-03-03T18:48:47.357" UserId="379" Text="Well, your best bet is to import the arduino libraries in your [Atmel Studio project][1]. Then you'll be able to use existing code to connect to the &quot;traditional&quot; Ethernet Shield using SPI.&#xD;&#xA;&#xD;&#xA;Though, the Sam 3X features an hardware ethernet [that is not wired][2], unlike the [MBed LPC1768][3]… Sadly that's the [ethernet PHY component][4] you saw, but won't be able to actually use…&#xD;&#xA;&#xD;&#xA;[1]:http://www.engblaze.com/tutorial-using-atmel-studio-6-with-arduino-projects/&#xD;&#xA;[2]:http://forum.arduino.cc/index.php?topic=197083.0&#xD;&#xA;[3]:http://mbed.org/platforms/mbed-LPC1768/&#xD;&#xA;[4]:http://asf.atmel.com/docs/3.11.0/sam3x/html/group__dm9161a__ethernet__phy__group.html" />
  <row Id="1601" PostHistoryTypeId="2" PostId="587" RevisionGUID="973a819f-8f9e-439d-893b-5527b9f8a9bc" CreationDate="2014-03-03T21:15:47.080" UserId="382" Text="I built a reflectance tachometer for an Arduino that'd probably solve your problem.&#xD;&#xA;The basic circuit is quite simple: &#xD;&#xA;&#xD;&#xA;![tachometer circuit][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I had a photoransistor laying around that responded well to red light, and [another from Radio Shack][2] that was quite sensitive to the IR output of old TV remote LED's.&#xD;&#xA;For your purposes, green wire would be hooked up to Analog Pin 0 of Arduino, and you just have to sample periodically, not set up an interupt driven sketch.&#xD;&#xA;The trick to getting a reflected signal difference between white paper and grey roll is knowing that light sensitivity of a photransistor increases w increasing resistance to GND, but the dark voltage also goes up. I came by the 5 and 3 megohm values empically, by checking the AtoD values off dark and light objects at a distance of a few inches from the detector. Same procedure should work for your detection of grey vs white. Although some things that look quite different visibly have the same reflectance in IR. Here's a pic of the finished red light tachometer: &#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;It should be simple to make the sensor board small enough to fit into the back of your paper dispenser. IR version is even smaller, but buried too deeply in a home-built centrifuge to get a pic of it today.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/IOohy.png&#xD;&#xA;  [2]: http://www.radioshack.com/product/index.jsp?productId=2049724&#xD;&#xA;  [3]: http://i.stack.imgur.com/TlJjj.png" />
  <row Id="1602" PostHistoryTypeId="5" PostId="582" RevisionGUID="6284e7a6-12cf-4a6a-a3df-7416ce4a58f9" CreationDate="2014-03-03T21:53:55.473" UserId="425" Comment="Reed is too specific a term" Text="I think I saw this in series 1 episode 2 of James May's Manlab. &#xD;&#xA;&#xD;&#xA;Similar to jfpoilpret, use a wide piece of material on a spring that makes contact with the roll at all times. I say 'wide' so that when the roll is empty the reed touches with a contact on one of the roll holders on the side. When it touches it completes a circuit to your alarm.&#xD;&#xA;&#xD;&#xA;Here's a crude image describing what I mean.&#xD;&#xA;&#xD;&#xA;![Behold the image of my imagination][1]&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/uSWHr.jpg" />
  <row Id="1604" PostHistoryTypeId="2" PostId="588" RevisionGUID="96f51c35-483f-46aa-b590-dd94db1abb87" CreationDate="2014-03-03T23:17:03.163" UserId="220" Text="## Ignore the stalker-like title.&#xD;&#xA;I am thinking about creating a project with Arduino that can sense you sleep habits, when you're asleep, and how much you sleep. It would be convenient to not have to turn it on/off at night; it should know how to do this.&#xD;&#xA;&#xD;&#xA;Some ideas that I have:&#xD;&#xA;&#xD;&#xA; - Motion sensor&#xD;&#xA; - Breathing patterns (if an Arduino microphone could even pick that out... I would be surprised if it could)&#xD;&#xA; - A RTC clock could assist in deciding *It's midnight. Usual, Steve isn't asleep at this time on Fridays. He's probably not sleeping now.* It won't always be there to help you, but you might be able to try to get more accurate results this way&#xD;&#xA;&#xD;&#xA;**How can I accomplish this?** (Extra points for some sort of algorithm that can tell dozing off from a deep sleep.)" />
  <row Id="1605" PostHistoryTypeId="1" PostId="588" RevisionGUID="96f51c35-483f-46aa-b590-dd94db1abb87" CreationDate="2014-03-03T23:17:03.163" UserId="220" Text="How can I sense when someone is sleeping with my Arduino?" />
  <row Id="1606" PostHistoryTypeId="3" PostId="588" RevisionGUID="96f51c35-483f-46aa-b590-dd94db1abb87" CreationDate="2014-03-03T23:17:03.163" UserId="220" Text="&lt;sensors&gt;&lt;arduino-uno-smd&gt;" />
  <row Id="1607" PostHistoryTypeId="5" PostId="452" RevisionGUID="73dd0c8f-2cd0-4beb-a1f1-9b34e410cf62" CreationDate="2014-03-03T23:46:23.220" UserId="136" Comment="Add details" Text="I've traditionally used a text editor with avr-gcc and makefiles for working with Arduino boards. I'm now trying to develop projects for the wider Arduino user-base, so I am trying to use the Arduino libraries and common IDEs for ease of use.&#xD;&#xA;&#xD;&#xA;I started using Stino, but then found out that the Arduino IDE has some toolchain &quot;quirks&quot; that mean I will need to test everything in Arduino IDE expressly.&#xD;&#xA;&#xD;&#xA;Since starting to use it more, I have found it frequently hangs or crashes. The triggers for this are:&#xD;&#xA;&#xD;&#xA; - Creating a new sketch takes about 15s, and shows me the OS X beach&#xD;&#xA;   ball. &#xD;&#xA; - Saving a sketch takes about 15s. &#xD;&#xA; - Going to File-&gt;Examples frequently crashes the IDE - I need to force quit.&#xD;&#xA; - Going to&#xD;&#xA;   File-&gt;Sketchbook always crashes the IDE. &#xD;&#xA; - It sometimes randomly hangs.&#xD;&#xA;&#xD;&#xA;I don't have any other stability issues and other Java based IDEs like Pycharm work flawlessly.&#xD;&#xA;&#xD;&#xA;I have installed numerous libraries, including the entire Teensyduino suite (which is a lot of libraries!). Outside of that, no changes have been made.&#xD;&#xA;&#xD;&#xA;Is this a common issue? Is there any logging or anyway I can try and work out what is causing this issue?&#xD;&#xA;&#xD;&#xA;This is happening with:&#xD;&#xA; - Arduino 1.05&#xD;&#xA; - Arduino 1.55&#xD;&#xA;&#xD;&#xA;I have tried uninstalling and reinstalling." />
  <row Id="1611" PostHistoryTypeId="2" PostId="590" RevisionGUID="51c28ad7-db88-4bee-94c4-d3eb7aa8dba6" CreationDate="2014-03-03T23:50:11.703" UserId="11" Text="I actually did something like this, using a [PIR Motion sensor][1].&#xD;&#xA;&#xD;&#xA;The motion sensor is good enough to detect a person turning in their sleep, and my simple algorithm just counts movements per minute and when its over a threshold (found by trial and error), it sounds the alarm to wake you up.&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;The image above represents my body movements during a night. The spikes represent a high movements/minute.&#xD;&#xA;&#xD;&#xA;&gt; Here we see after about 30 minutes body motion was minimal. This suggests I was in a deeper stage of sleep during that time.&#xD;&#xA;&gt; &#xD;&#xA;&gt; The spike at 250 minutes (around 4:30AM) is when I woke up only to&#xD;&#xA;&gt; realize I could sleep for couple of hours longer. I recall the time&#xD;&#xA;&gt; being 4:38 when I looked at my clock and I was already facing it. This&#xD;&#xA;&gt; means I turned around to face the clock but actually &quot;woke up&quot; 8&#xD;&#xA;&gt; minutes later to see the time, and then turned back around (indicated&#xD;&#xA;&gt; by the shorter spike at 265).&#xD;&#xA;&gt; &#xD;&#xA;&gt; The data suggests I was not able to sleep very well (compared to the&#xD;&#xA;&gt; time period between 30 and 240 minutes) after waking up once and&#xD;&#xA;&gt; finally got up at 400 minutes (7:00AM), when I shut everything down.&#xD;&#xA;&#xD;&#xA;Here are a couple of posts from my blog that have a lot more information.&#xD;&#xA;&#xD;&#xA;* [Body Movement During Sleep][3]&#xD;&#xA;* [Intelligent Alarm Clock Hardware][4]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sparkfun.com/products/8630&#xD;&#xA;  [2]: http://i.stack.imgur.com/pYBe3.png&#xD;&#xA;  [3]: http://blog.sachleen.com/posts/1353217318/body-movement-during-sleep/&#xD;&#xA;  [4]: http://blog.sachleen.com/posts/1353217790/alarm-clock-hardware/" />
  <row Id="1613" PostHistoryTypeId="2" PostId="591" RevisionGUID="eab464c0-4347-48bc-9ad8-279bbe064508" CreationDate="2014-03-04T00:59:03.920" UserId="358" Text="I think another decent and cheap option to use is a proximity sensor like the ones on the phone or a fixed field infrared sensor. These sensor are pretty accurate and can easily be used to &quot;look&quot; at the back of the toilet roll by mounting the sensor to the holder or the wall where the toilet roll is placed.&#xD;&#xA;All the other ideas I saw on the post were either fairly inaccurate or felt intrusive towards the toilet roll which in the long run I feel may provide contamination.&#xD;&#xA;A proximity sensor is not only fairly cheap and easy to use, if calibrated well, they can allow a very good amount of accuracy and reliability. This model is already in wide usage in men urinals to auto-flush.&#xD;&#xA;For example on your phone: Your phone will accurately provide a distance of 2.0 inches or infinity when your hand or your face is near the screen." />
  <row Id="1614" PostHistoryTypeId="2" PostId="592" RevisionGUID="b4c8585e-6eb9-4ea3-acdf-5c1d204703f7" CreationDate="2014-03-04T01:11:20.083" UserId="358" Text="I am planning to build a remote for my Camera i.e Sony NEX 5R. I derived inspiration from a friend who did the same for his camera, but is far more experienced than me. I plan to use an Arduino Uno R3 with other components such as an ATmega328, IR LED, npn BJT for amplification to the LED, Schmidt Trigger for rectification of the output from a push button along with a 9volt battery.&#xD;&#xA;I have several issues as of now:&#xD;&#xA;&#xD;&#xA; 1. I am new to Arduino and would like to learn more about how I can use it to serve my project purposes. I have used the PIC24 Micro controller before.&#xD;&#xA; 2. What standard should I be using for the infrared control and is there some basic model code I can work upon.&#xD;&#xA; 3. A 9volt battery for a remote seems to big and I would like the miniaturize the design using a button cell but I am unsure of how to power the LED in such a case along with the micro controller.&#xD;&#xA; 4. I would like to use a smaller micro controller as the ATmega 328 is a 40pin IC. I have an ATtiny2313 as well but I am not sure how to use this." />
  <row Id="1615" PostHistoryTypeId="1" PostId="592" RevisionGUID="b4c8585e-6eb9-4ea3-acdf-5c1d204703f7" CreationDate="2014-03-04T01:11:20.083" UserId="358" Text="Build Infrared Camera Remote" />
  <row Id="1616" PostHistoryTypeId="3" PostId="592" RevisionGUID="b4c8585e-6eb9-4ea3-acdf-5c1d204703f7" CreationDate="2014-03-04T01:11:20.083" UserId="358" Text="&lt;arduino-uno&gt;&lt;programming&gt;" />
  <row Id="1617" PostHistoryTypeId="2" PostId="593" RevisionGUID="961d97dd-c51f-4c76-b1fe-d0464947b410" CreationDate="2014-03-04T01:43:31.853" UserId="-1" Text="" />
  <row Id="1618" PostHistoryTypeId="2" PostId="594" RevisionGUID="9fd32b71-1121-43b5-aacc-5661a5e69fa9" CreationDate="2014-03-04T01:43:31.853" UserId="-1" Text="" />
  <row Id="1619" PostHistoryTypeId="5" PostId="594" RevisionGUID="4cd31d20-41a0-4cad-bcdf-ea685636d2f0" CreationDate="2014-03-04T01:50:14.033" UserId="65" Comment="added 172 characters in body" Text="This tag should be used for questions regarding the selection of components, deciding functionality, and other issues that may come up during the early stages of a project." />
  <row Id="1620" PostHistoryTypeId="24" PostId="594" RevisionGUID="4cd31d20-41a0-4cad-bcdf-ea685636d2f0" CreationDate="2014-03-04T01:50:14.033" Comment="Proposed by 65 approved by 11 edit id of 201" />
  <row Id="1621" PostHistoryTypeId="2" PostId="595" RevisionGUID="97d39b3f-86e2-43d7-9ed3-93063aef3dbb" CreationDate="2014-03-04T01:57:56.513" UserId="11" Text="1. Using the Arduino shouldn't be any different than any other microcontroller.&#xD;&#xA;2. The [IRremote library][1] is my go-to library for any IR related stuff.&#xD;&#xA;3. Power shouldn't be an issue, look at the [Moteino from LowPowerLab][2] and check out his [coin cell battery tests][3]. It's definitely possible. Not with a full blown Uno, but with a bare chip, yes.&#xD;&#xA;4. You want to burn the bootloader on the IC first, before you can start writing Arduino code. Check out this tutorial: [From Arduino to a Microcontroller on a Breadboard][4]. It's the same process for an ATTiny, you just have to look at the datasheet to see where to plug things into. Specifically, MOSI, MISO, SCK, and Reset pins. The [Tiny AVR Programmer][5] is also a good choice. It's meant for the 8 pin micros but it has an ISP header so you can use it for almost any chip.&#xD;&#xA;&#xD;&#xA;This may be useful for more information about decoding IR signals:&#xD;&#xA;&#xD;&#xA;* [EEVblog #505 - IR Learning Remote Control Hack][6]&#xD;&#xA;* [EEVblog #506 - IR Remote Control Arduino Protocol Tutorial][7]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/shirriff/Arduino-IRremote&#xD;&#xA;  [2]: http://lowpowerlab.com/moteino/&#xD;&#xA;  [3]: http://lowpowerlab.com/blog/2012/12/24/moteino-coin-cell-battery-tests/&#xD;&#xA;  [4]: http://arduino.cc/en/Tutorial/ArduinoToBreadboard&#xD;&#xA;  [5]: https://www.sparkfun.com/products/11801&#xD;&#xA;  [6]: https://www.youtube.com/watch?v=vOzaDQmAW0g&#xD;&#xA;  [7]: https://www.youtube.com/watch?v=BUvFGTxZBG8&amp;feature=youtu.be" />
  <row Id="1622" PostHistoryTypeId="2" PostId="596" RevisionGUID="516d8afe-594e-41a4-a217-850828ac53b6" CreationDate="2014-03-04T02:18:58.167" UserId="220" Text=" 1.) I'm not exactly sure what you mean by this. What I'd recommend is a [ATMega328](https://www.sparkfun.com/products/9061) for the heart of the chip. It's what is in the Uno, so with a exception of uploading code, for this project this will cut down on the size of your project. However, an Uno will work pretty much identical. If you do want to use a chip like this, [this design](http://fritzing.org/projects/barebones-arduino) looks pretty complete. You'll probably want to move to a PCB for your final product, but since you have a little electronic experience, I assume you can solder and know about this. [Here is another tutorial for barebones](http://playground.arduino.cc/Learning/AtmegaStandalone).&#xD;&#xA; 2.) Again, what do you mean by &quot;standard?&quot; Like protocol? If so, there's no real protocol to use. [This may be easy for a begginer](http://www.robotmesh.com/ir-kit-for-arduino?gclid=CM650djc97wCFexcMgodK0kAjQ). It's the remote and the receiver. If you want to go all geek you can also [hack an existing TV remote to do the same task](http://www.righto.com/2009/08/multi-protocol-infrared-remote-library.html). That library should take care of everything you need (see code later).&#xD;&#xA;&#xD;&#xA;****&#xD;&#xA;**A bit of code/wiring:**&#xD;&#xA;&#xD;&#xA;The circuit will depend on what receiver you choose. Most IR receivers have one pin for 5v, one for GND, and the last one is connected to a digital pin. Again, look at the information on the specific receiver you choose.&#xD;&#xA;&#xD;&#xA;Some sample code with the library I listed:&#xD;&#xA;&#xD;&#xA;    #include &lt;IRremote.h&gt;&#xD;&#xA;    &#xD;&#xA;    int RECV_PIN = 11;        //Using pin 11 for the signal pin&#xD;&#xA;    IRrecv irrecv(RECV_PIN);  //Creates a variable that will be used later to inference between library and code&#xD;&#xA;    decode_results results;   //Use it to store the value of the keycode&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      irrecv.enableIRIn(); // Start the receiver&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      if (irrecv.decode(&amp;results)) {&#xD;&#xA;        Serial.println(results.value, HEX);&#xD;&#xA;        irrecv.resume(); // Receive the next value&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You'll have to run this sketch to determine the value of the button you'll use on the remote. It should print on the serial window some sort of hexadecimal value IIRC that you'll have to convert into decimal if you want to use it inside the code to compare that to the button you want to use on the remote. The post I mentioned is a great resource: go and look at it.&#xD;&#xA;****&#xD;&#xA; 3.) I don't recommend building a remote. Like I said, you can use existing TV remotes or buy one for this purpose. Start small, figure out how IR remotes work, and then build one later if you desire. A v2 is often required on Arduino.&#xD;&#xA;&#xD;&#xA; 4.) Don't bother for the receiver. It *can* be bigger. If you don't know how to to program it, [this guide is a good reference](http://highlowtech.org/?p=1695). It has some files that you download to add it in the IDE to trick the IDE to think the chip is a board. Note: You'll have to program it with an Uno or similar to upload and to burn the firmware. (I would explain it more in case the site goes down, but you need the files there so it'll be pointless anyway.)&#xD;&#xA;&#xD;&#xA;Also a quick tip: don't be afraid to ask your friend for some help. You don't need to rely on him, but if you get stuck ask him.&#xD;&#xA;&#xD;&#xA;I don't know how to connect the Arduino to the camera, but you seem to know how to do that." />
  <row Id="1623" PostHistoryTypeId="2" PostId="597" RevisionGUID="a4a76ec1-0356-4921-aae3-2750b446cc47" CreationDate="2014-03-04T02:38:20.473" UserId="220" Text="## Just [report it to Arduino](https://github.com/arduino/Arduino/issues).&#xD;&#xA;You don't really have any other option. I've been waiting to answer this question until I was sure that no one here knew the answer. You don't really have any other option.&#xD;&#xA;&#xD;&#xA;This seems like a bug. **We're not Arduino developers or a bug tracking site.** We can only do so much here. Even if it was confirmed a bug and we fixed it, there's only so much that can be done without submitting a report.&#xD;&#xA;****&#xD;&#xA;**BEFORE YOU SUBMIT A REPORT:**&#xD;&#xA;&#xD;&#xA; - I'd try copying out the libraries from Arduino. So many libraries&#xD;&#xA;   might make Arduino IDE somewhat heavier. I don't know if it'll really&#xD;&#xA;   affect the sluggishness but it's worth a shot.&#xD;&#xA; - The only other thing that I can think of, besides RAM (which you&#xD;&#xA;   already said wasn't an issue) and the libraries, is some sort of&#xD;&#xA;   cache/temporary file. Try reinstalling Arduino, even if you haven't,&#xD;&#xA;   and also I'd try using the [beta 1.5.6-r2&#xD;&#xA;   version](http://arduino.cc/en/main/software). It has to be pretty&#xD;&#xA;   stable for it to be the only version that supports the YUN and DUE.&#xD;&#xA;   Both have been out for a considerable amount of time with this&#xD;&#xA;   software, so I'd imagine that it's pretty stable minus a few issues.&#xD;&#xA;&#xD;&#xA;&gt; Many things are said to have been improved compared to the previous 1.0.5-r2 version.&#xD;&#xA;&#xD;&#xA;It'd be stupid not to try the newer version.&#xD;&#xA;&#xD;&#xA;![GitHub Screenshot][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/G7N4P.png" />
  <row Id="1624" PostHistoryTypeId="2" PostId="598" RevisionGUID="0a0cf160-c02c-4883-a6fb-72356428f27d" CreationDate="2014-03-04T02:50:55.353" UserId="220" Text="Stepper motors are often pricey for a large motor. However, with a powerful, standard DC motor and a rotary encoder, you can &quot;simulate&quot; a stepper motor. **How accurate are rotary encoders with Arduino just with a basic loop and not much other code?** Is it going to &quot;miss a pulse&quot; and not record enough rotation often? How can I handle this with much more code? Is there a better way to do this? Would interrupts help? Is there some sort of circuit that would help with this problem?&#xD;&#xA;&#xD;&#xA;Note: It will probably not exceed 4 rotations a second... *(That may be a lot but if you're doing a lead screw type mechanism that would only be 24 inches a minute if there is 10 rotations per inch of linear motion.)*" />
  <row Id="1625" PostHistoryTypeId="1" PostId="598" RevisionGUID="0a0cf160-c02c-4883-a6fb-72356428f27d" CreationDate="2014-03-04T02:50:55.353" UserId="220" Text="How precise can I get Arduino using rotary encoders?" />
  <row Id="1626" PostHistoryTypeId="3" PostId="598" RevisionGUID="0a0cf160-c02c-4883-a6fb-72356428f27d" CreationDate="2014-03-04T02:50:55.353" UserId="220" Text="&lt;interrupt&gt;&lt;rotary-encoder&gt;&lt;accuracy&gt;" />
  <row Id="1627" PostHistoryTypeId="2" PostId="599" RevisionGUID="8a14a03b-737a-410a-9519-6a2b14941949" CreationDate="2014-03-04T03:26:23.890" UserId="407" Text="Interrupts are what you would use in this situation.&#xD;&#xA;&#xD;&#xA;The rates that you have mentioned are slow enough where you *probably* would be able to count it inside of a loop, however this is not recommended, as a typical loop will take many clock cycles to complete, and depending on the number of instuctiuons per loop, you may miss some counts.&#xD;&#xA;&#xD;&#xA;Interrupts are made for this purpose, as they can be triggered at any time, regardless of the state of the loop.&#xD;&#xA;&#xD;&#xA;There is a function named `attachInterrupt()` which will take three arguments.&#xD;&#xA;&#xD;&#xA; 1. Interrupt Pin&#xD;&#xA; 2. Interrupt Service Routine&#xD;&#xA; 3. Mode&#xD;&#xA;&#xD;&#xA;Below is an example for counting an interrupt&#xD;&#xA;&#xD;&#xA;    volatile int myCounter = 0;&#xD;&#xA;&#xD;&#xA;    void setup(){&#xD;&#xA;        attachInterrupt(0, count, RISING);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void count(){&#xD;&#xA;        myCounter++;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The Modes are as follows:&#xD;&#xA;&#xD;&#xA;&gt;LOW, CHANGE, RISING, FALLING&#xD;&#xA;&#xD;&#xA;More information about using interrupts can be found [here][1].&#xD;&#xA;&#xD;&#xA;Depending on the encoder you use, you will need to tailor the code your needs, and do some more calculations to determine your position, but this should be a good starting point.&#xD;&#xA;&#xD;&#xA;**Edit**&#xD;&#xA;[Here][2] is some example code from Arduino Sandbox for using a rotary encoder.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/attachInterrupt#.UxVGrvldXvM&#xD;&#xA;  [2]: http://playground.arduino.cc/Main/RotaryEncoders#.UxVIwvldU4J" />
  <row Id="1629" PostHistoryTypeId="5" PostId="592" RevisionGUID="ca7f4b3a-2fe8-4643-a108-55f2d715c170" CreationDate="2014-03-04T05:38:36.570" UserId="358" Comment="Reworded question and clarified that a reciever is IN the camera." Text="I wish to build a remote for my Camera i.e Sony NEX 5R. It has a built in IR receiver and has several Sony as well as aftermarket remotes provided for it. Due to my interest in Micro controller design I wish to build one myself rather than use an aftermarket one.&#xD;&#xA;&#xD;&#xA;A friend who did the same for his NEX 5 series camera posted a video of the same on Facebook, which inspired me to build my own. I plan to use an Arduino Uno R3 with the following additional components:&#xD;&#xA;&#xD;&#xA; - IR LED&#xD;&#xA;&#xD;&#xA; - NPN Transistor(for amplification)&#xD;&#xA; - Schmidt Triggers(for rectification)&#xD;&#xA; - 9 Volt Battery&#xD;&#xA;&#xD;&#xA;Ultimately I would like to swap out the Arduino for a standalone ATmega328 or ATtiny2313 but currently I have some issues as of now:&#xD;&#xA;&#xD;&#xA; 1. I currently do not have a schematic or a sample code which I can use. I have been trying to search the internet for the same but to no avail.&#xD;&#xA; 2. I am unsure of the protocol used by my camera. I have found it difficult to find documentation on the same.&#xD;&#xA; 3. How can I replace the 9-Volt battery for something smaller?&#xD;&#xA; 4. I would like to use a smaller micro controller but what differences will I encounter when trying to change my code for the smaller micro controller?&#xD;&#xA; 5. For such a project, will I need additional hardware?" />
  <row Id="1630" PostHistoryTypeId="5" PostId="596" RevisionGUID="ff2382ec-03ef-4bfe-b596-6a29e6bc4d90" CreationDate="2014-03-04T07:07:06.070" UserId="11" Comment="deleted 4 characters in body" Text="1. I'm not exactly sure what you mean by this. What I'd recommend is a [ATMega328](https://www.sparkfun.com/products/9061) for the heart of the chip. It's what is in the Uno, so with a exception of uploading code, for this project this will cut down on the size of your project. However, an Uno will work pretty much identical. If you do want to use a chip like this, [this design](http://fritzing.org/projects/barebones-arduino) looks pretty complete. You'll probably want to move to a PCB for your final product, but since you have a little electronic experience, I assume you can solder and know about this. [Here is another tutorial for barebones](http://playground.arduino.cc/Learning/AtmegaStandalone).&#xD;&#xA;2. Again, what do you mean by &quot;standard?&quot; Like protocol? If so, there's no real protocol to use. [This may be easy for a begginer](http://www.robotmesh.com/ir-kit-for-arduino?gclid=CM650djc97wCFexcMgodK0kAjQ). It's the remote and the receiver. If you want to go all geek you can also [hack an existing TV remote to do the same task](http://www.righto.com/2009/08/multi-protocol-infrared-remote-library.html). That library should take care of everything you need (see code later).&#xD;&#xA;&#xD;&#xA;****&#xD;&#xA;**A bit of code/wiring:**&#xD;&#xA;&#xD;&#xA;The circuit will depend on what receiver you choose. Most IR receivers have one pin for 5v, one for GND, and the last one is connected to a digital pin. Again, look at the information on the specific receiver you choose.&#xD;&#xA;&#xD;&#xA;Some sample code with the library I listed:&#xD;&#xA;&#xD;&#xA;    #include &lt;IRremote.h&gt;&#xD;&#xA;    &#xD;&#xA;    int RECV_PIN = 11;        //Using pin 11 for the signal pin&#xD;&#xA;    IRrecv irrecv(RECV_PIN);  //Creates a variable that will be used later to inference between library and code&#xD;&#xA;    decode_results results;   //Use it to store the value of the keycode&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      irrecv.enableIRIn(); // Start the receiver&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      if (irrecv.decode(&amp;results)) {&#xD;&#xA;        Serial.println(results.value, HEX);&#xD;&#xA;        irrecv.resume(); // Receive the next value&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You'll have to run this sketch to determine the value of the button you'll use on the remote. It should print on the serial window some sort of hexadecimal value IIRC that you'll have to convert into decimal if you want to use it inside the code to compare that to the button you want to use on the remote. The post I mentioned is a great resource: go and look at it.&#xD;&#xA;****&#xD;&#xA; 3.) I don't recommend building a remote. Like I said, you can use existing TV remotes or buy one for this purpose. Start small, figure out how IR remotes work, and then build one later if you desire. A v2 is often required on Arduino.&#xD;&#xA;&#xD;&#xA; 4.) Don't bother for the receiver. It *can* be bigger. If you don't know how to to program it, [this guide is a good reference](http://highlowtech.org/?p=1695). It has some files that you download to add it in the IDE to trick the IDE to think the chip is a board. Note: You'll have to program it with an Uno or similar to upload and to burn the firmware. (I would explain it more in case the site goes down, but you need the files there so it'll be pointless anyway.)&#xD;&#xA;&#xD;&#xA;Also a quick tip: don't be afraid to ask your friend for some help. You don't need to rely on him, but if you get stuck ask him.&#xD;&#xA;&#xD;&#xA;I don't know how to connect the Arduino to the camera, but you seem to know how to do that." />
  <row Id="1631" PostHistoryTypeId="2" PostId="600" RevisionGUID="1bb4c51b-f76c-402c-98ea-e7f310388b9b" CreationDate="2014-03-04T10:26:29.627" UserId="379" Text="Well, for your project you can simply buy/rebuild a TV-B-Gone [made by Mitch](https://cornfieldelectronics.com/tvbgone/buy.tvbgkit.php?PHPSESSID=3phhip32unp1ku0di8qe9e6od0), which he uses as a basic project to teach soldering all over the world.&#xD;&#xA;&#xD;&#xA;You can &quot;hack&quot; the TV-B-Gone by adding a [TSOP4838](http://www.vishay.com/docs/82459/tsop48.pdf) that can work as an IR receiver (or use another device as a code recorder).&#xD;&#xA;&#xD;&#xA;![TV-B-Gone](http://www.dl8ma.de/jugendarbeit/tv-b-gone/tvbgone3sch.png)&#xD;&#xA;&#xD;&#xA;And as you can see here the TV B Gone features an ATTiny85. A really small and nice beast.&#xD;&#xA;&#xD;&#xA;Here you'll find the [source code](https://github.com/adafruit/TV-B-Gone-kit/tree/master/firmware) for the TV B Gone. I'm not sure what format they use for their code database though.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1632" PostHistoryTypeId="5" PostId="179" RevisionGUID="2dc9f22a-e9df-493d-a821-d9a36d72a693" CreationDate="2014-03-04T12:31:52.697" UserId="37" Comment="deleted 2 characters in body; edited title" Text="I made a sketch, but then I lost it. However, I uploaded it to the Arduino before losing it. Is there any way I can get it back?" />
  <row Id="1633" PostHistoryTypeId="4" PostId="179" RevisionGUID="2dc9f22a-e9df-493d-a821-d9a36d72a693" CreationDate="2014-03-04T12:31:52.697" UserId="37" Comment="deleted 2 characters in body; edited title" Text="Is there any way to download a sketch from an Arduino?" />
  <row Id="1634" PostHistoryTypeId="2" PostId="601" RevisionGUID="9d18b078-031f-454c-b332-700b76492f6b" CreationDate="2014-03-04T12:59:01.943" UserId="94" Text="There exists a large variety of sensors in the [Grove System][1]. Usually these are accessed via a special shield (Grove base shield). &#xD;&#xA;&#xD;&#xA;Can I access these sensor directly without a shield. In particular I am interested in using them with an Arduino Pro Mini. My guess is that one definitely needs the 5V version of the Mini, but other than this? How fiddly is it to use these sensors directly? &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.seeedstudio.com/wiki/GROVE_System" />
  <row Id="1635" PostHistoryTypeId="1" PostId="601" RevisionGUID="9d18b078-031f-454c-b332-700b76492f6b" CreationDate="2014-03-04T12:59:01.943" UserId="94" Text="Grove sensors without a Grove shield" />
  <row Id="1636" PostHistoryTypeId="3" PostId="601" RevisionGUID="9d18b078-031f-454c-b332-700b76492f6b" CreationDate="2014-03-04T12:59:01.943" UserId="94" Text="&lt;sensors&gt;" />
  <row Id="1637" PostHistoryTypeId="2" PostId="602" RevisionGUID="e6edd3ef-f695-463b-9b12-dff297918c2e" CreationDate="2014-03-04T13:26:36.847" UserId="453" Text="I have got a problem with my Arduino, I can't upload any program to it (it tells me that there was a verification error), but the LEDS are still blinking, so do you think that the whole Arduino is dead or is it just the chip ?" />
  <row Id="1638" PostHistoryTypeId="1" PostId="602" RevisionGUID="e6edd3ef-f695-463b-9b12-dff297918c2e" CreationDate="2014-03-04T13:26:36.847" UserId="453" Text="Is my Arduino dead or is this just it's processor?" />
  <row Id="1639" PostHistoryTypeId="3" PostId="602" RevisionGUID="e6edd3ef-f695-463b-9b12-dff297918c2e" CreationDate="2014-03-04T13:26:36.847" UserId="453" Text="&lt;arduino-uno&gt;" />
  <row Id="1641" PostHistoryTypeId="5" PostId="601" RevisionGUID="d4c46833-6571-46c3-ab59-a10a80fc14c0" CreationDate="2014-03-04T13:42:51.337" UserId="94" Comment="extended answer" Text="There exists a large variety of sensors in the [Grove System][1]. Usually these are accessed via a special shield (Grove base shield). &#xD;&#xA;&#xD;&#xA;Can I access these sensor directly without a shield. In particular I am interested in using them with an Arduino Pro Mini. My guess is that one definitely needs the 5V version of the Mini, but other than this? How fiddly is it to use these sensors directly? &#xD;&#xA;&#xD;&#xA;I am interested in using the [Grove dust sensor][2], but I am also would like to operate a [Grove 4 digit display][3].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.seeedstudio.com/wiki/GROVE_System&#xD;&#xA;  [2]: http://www.seeedstudio.com/wiki/Grove_-_Dust_Sensor&#xD;&#xA;  [3]: http://www.seeedstudio.com/wiki/Grove_-_4-Digit_Display" />
  <row Id="1642" PostHistoryTypeId="5" PostId="602" RevisionGUID="1d3e9671-417e-490a-b7f5-ff2903831156" CreationDate="2014-03-04T14:01:49.043" UserId="37" Comment="fixed grammar, edited tags, added info from comment" Text="I have a problem with my Arduino. I can't upload any sketches to it (it gives me the error `avrdude: verification error; content mismatch`), but the LEDS are still blinking. Do you think that the whole Arduino is dead or is it just the chip?" />
  <row Id="1643" PostHistoryTypeId="4" PostId="602" RevisionGUID="1d3e9671-417e-490a-b7f5-ff2903831156" CreationDate="2014-03-04T14:01:49.043" UserId="37" Comment="fixed grammar, edited tags, added info from comment" Text="Is my Arduino dead or is it just its processor?" />
  <row Id="1644" PostHistoryTypeId="6" PostId="602" RevisionGUID="1d3e9671-417e-490a-b7f5-ff2903831156" CreationDate="2014-03-04T14:01:49.043" UserId="37" Comment="fixed grammar, edited tags, added info from comment" Text="&lt;arduino-uno&gt;&lt;uploading&gt;&lt;atmega328&gt;" />
  <row Id="1645" PostHistoryTypeId="24" PostId="602" RevisionGUID="1d3e9671-417e-490a-b7f5-ff2903831156" CreationDate="2014-03-04T14:01:49.043" Comment="Proposed by 37 approved by 42 edit id of 204" />
  <row Id="1646" PostHistoryTypeId="2" PostId="604" RevisionGUID="6449dc53-c95e-4d71-a7dd-32838a5d0080" CreationDate="2014-03-04T14:05:45.620" UserId="454" Text="I have an Arduino motor shield like this one plugged into my Mega board.&#xD;&#xA;&#xD;&#xA;![Arduino motor shield][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I would like to know some more information about the orange and white pin blocks on the board. The [Arduino website][2] has the following information, but it doesn't give any explanation of what is best to use them for or which pins are mapped to the data pins etc.  &#xD;&#xA;&#xD;&#xA; - TinkerKit connectors for two Analog Inputs (in white), connected to A2 and A3.  &#xD;&#xA; - TinkerKit connectors for two Aanlog Outputs (in orange in the middle), connected to PWM outputs on pins D5 and D6.  &#xD;&#xA; - TinkerKit connectors for the TWI interface (in white with 4 pins), one for input and the other one for output.&#xD;&#xA;&#xD;&#xA;What I want to do is connect a servo up to the board and was hoping I could use one of the orange `OUT` blocks. I haven't been successful in finding any examples of this which leaves me in doubt as to whether it is possible or not. I would just plug it in, but I'm afraid of frying the shield/mega/servo. Probably an irrational fear, but I can't afford another one of any at the moment!&#xD;&#xA;&#xD;&#xA;I don't know which pins in the block are assigned to the data, vcc and out, so if anyone know I would be grateful for the answer.&#xD;&#xA;&#xD;&#xA;Also, just because it is annoying not to understand, what are the `TWI` connectors for?&#xD;&#xA;&#xD;&#xA;I hope this isn't too general a question as I could really use some answers!&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/cKBqi.jpg&#xD;&#xA;  [2]: http://arduino.cc/en/Main/ArduinoMotorShieldR3#.UxXT9vl_skI" />
  <row Id="1647" PostHistoryTypeId="1" PostId="604" RevisionGUID="6449dc53-c95e-4d71-a7dd-32838a5d0080" CreationDate="2014-03-04T14:05:45.620" UserId="454" Text="Arduino motor shield orange/white pin usage" />
  <row Id="1648" PostHistoryTypeId="3" PostId="604" RevisionGUID="6449dc53-c95e-4d71-a7dd-32838a5d0080" CreationDate="2014-03-04T14:05:45.620" UserId="454" Text="&lt;pins&gt;&lt;shields&gt;&lt;motor&gt;" />
  <row Id="1649" PostHistoryTypeId="2" PostId="605" RevisionGUID="fb54f982-ad9b-4ad5-8a8b-cc93ab3190ff" CreationDate="2014-03-04T14:31:35.913" UserId="316" Text="It's possible you have a non-fatal problem&#xD;&#xA;&#xD;&#xA; - check power&#xD;&#xA; - check connections&#xD;&#xA; - reflash the Arduino bootloader&#xD;&#xA;&#xD;&#xA;If your Arduino has a socketed microcontroller you can try swapping it out with one that has the bootloader preloaded." />
  <row Id="1650" PostHistoryTypeId="6" PostId="17" RevisionGUID="3226beee-0b88-492f-90f3-ad665e82d4a2" CreationDate="2014-03-04T14:46:23.010" UserId="37" Comment="edited tags" Text="&lt;uploading&gt;&lt;avrdude&gt;" />
  <row Id="1651" PostHistoryTypeId="2" PostId="606" RevisionGUID="dd7ca7ab-4e75-46eb-8828-8a0b35d23a45" CreationDate="2014-03-04T15:15:51.453" UserId="8" Text="Grove sensors use a special socket, a 4 pin JST with two power lines and two data. you would have to make your own board/terminal to get them to connect to a mini. &#xD;&#xA;&#xD;&#xA;What you could do is use a [Grove proto board](http://www.seeedstudio.com/wiki/Grove_-_Protoshield), which converts the JST terminals onto .1&quot; pins suitable for connecting to the Mini. There is also a litle proto area if you want it.&#xD;&#xA;&#xD;&#xA;You could also use an [adapter cable](http://www.seeedstudio.com/depot/grove-to-4-pin-254-female-jumper-wire5-pcs-pack-p-1020.html?cPath=178_179), which would not have a bulky protoboard along with it. The terminals could be soldered directly to the Mini." />
  <row Id="1652" PostHistoryTypeId="5" PostId="478" RevisionGUID="72f711da-f01f-4dfa-ac62-92ecdc5fa690" CreationDate="2014-03-04T15:42:05.450" UserId="37" Comment="fixed grammar; removed text that should be in a comment" Text="There's the stm32 nucleo and discovery boards. The nucleo is even hardware-compatible with Arduino shields." />
  <row Id="1653" PostHistoryTypeId="24" PostId="478" RevisionGUID="72f711da-f01f-4dfa-ac62-92ecdc5fa690" CreationDate="2014-03-04T15:42:05.450" Comment="Proposed by 37 approved by 48 edit id of 205" />
  <row Id="1654" PostHistoryTypeId="2" PostId="607" RevisionGUID="5158ce1c-b991-420d-846c-473ff3e85cd5" CreationDate="2014-03-04T15:54:17.963" UserId="65" Text="[Git submodules][1] are extremely powerful when it comes to organizing multiple nested repositories. Handling multiple libraries from different sources, and even handling parts of your own project which may be stored at different sources becomes easy with git submodules.&#xD;&#xA;&#xD;&#xA;##Directory Structure&#xD;&#xA;&#xD;&#xA;A way to organize your projects would be:&#xD;&#xA;&#xD;&#xA;- **projectA** - Parent Directory&#xD;&#xA;&#xD;&#xA; - **projectA** - Source code directory containing Arduino code&#xD;&#xA;      1. projectA.ino&#xD;&#xA;      2. header.h&#xD;&#xA;      3. implementation.cpp&#xD;&#xA;&#xD;&#xA; - **docs** - Your main documentation directory&#xD;&#xA;&#xD;&#xA; - **schematics** - these may be maintained separately on a separate Git repo or part of the same repo&#xD;&#xA;&#xD;&#xA; - **libs** - This will contain your third party libraries.&#xD;&#xA;     1. libA - These may be maintained as third party repositories&#xD;&#xA;     2. libC - ...&#xD;&#xA;&#xD;&#xA; - **license**&#xD;&#xA;&#xD;&#xA; - **README**&#xD;&#xA;&#xD;&#xA; - **Makefile** - Necessary to handle dependencies across directories&#xD;&#xA;&#xD;&#xA;##Workflow&#xD;&#xA;&#xD;&#xA;You would follow your normal cycle of make changes, add and commit as far as the main repository is concerned. Things get interesting with the sub-repositories.&#xD;&#xA;&#xD;&#xA;You have the option of adding a repository into the parent directory of your main repository. This means that any part of you directory structure, i.e. docs, schematics, etc. can be maintained as a separate repository and continuously updated from.&#xD;&#xA;&#xD;&#xA;You can do this using the `git submodule add &lt;repo.git&gt;` command. To keep it up to date, you can use `git submodule update &lt;path&gt;`.&#xD;&#xA;&#xD;&#xA;When it comes to maintaining multiple third party libraries within your repository such that each can be version controlled in itself or each can be kept up to date if need be, git submodule again saves your day!&#xD;&#xA;&#xD;&#xA;To add a third party repo to **libs**, use the command `git submodule add &lt;lib1.git&gt; libs/lib1`. Then, to maintain the library at a fixed point in the release cycle, checkout the library and make a commit. To keep the library up to date, use the command `git submodule update &lt;path&gt;`.&#xD;&#xA;&#xD;&#xA;Now, you can maintain multiple repositories within a main repository as well as multiple third party libraries in their independent stages of release. &#xD;&#xA;&#xD;&#xA;#Versus Single Directory Approach&#xD;&#xA;&#xD;&#xA;While the [single directory approach][2] is the simplest, it is not possible to version control parts of a directory without a lot of pain. Hence, the simple approach fails to accomodate different repositories with varying states in the project.&#xD;&#xA;&#xD;&#xA;This approach allows maintaining multiple repositories but brings in the need for a Makefile to handle the compilation and linking process. &#xD;&#xA;&#xD;&#xA;Depending on the complexity of your project, the optimal approach can be selected. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://git-scm.com/book/en/Git-Tools-Submodules&#xD;&#xA;  [2]: http://arduino.stackexchange.com/a/351/65" />
  <row Id="1655" PostHistoryTypeId="10" PostId="462" RevisionGUID="a289cfdc-97f6-4c58-8e62-a0bca1ca278b" CreationDate="2014-03-04T18:34:19.043" UserId="11" Comment="104" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;},{&quot;Id&quot;:37,&quot;DisplayName&quot;:&quot;The Guy with The Hat&quot;},{&quot;Id&quot;:65,&quot;DisplayName&quot;:&quot;AsheeshR&quot;},{&quot;Id&quot;:8,&quot;DisplayName&quot;:&quot;TheDoctor&quot;},{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="1656" PostHistoryTypeId="2" PostId="608" RevisionGUID="bb53609d-7b59-4054-a7d6-0dabe24580aa" CreationDate="2014-03-04T18:49:29.397" UserId="11" Text="&gt; I don't know which pins in the block are assigned to the data, vcc and&#xD;&#xA;&gt; out, so if anyone know I would be grateful for the answer.&#xD;&#xA;&#xD;&#xA;Following the example on [TinkerKit's Custom Distance Sensor][1] page, we see that:&#xD;&#xA;&#xD;&#xA;&gt; If you look on the edge of the sensor, you can see the three pins,&#xD;&#xA;&gt; that are power (5V), ground and signal. The same as your TinkerKit!&#xD;&#xA;&gt; modules, just in a different order.&#xD;&#xA;&gt; &#xD;&#xA;&gt; The only difference is that the signal and ground cable are inverted.&#xD;&#xA;&#xD;&#xA;So the order in the connector is Vcc Signal Ground.&#xD;&#xA;&#xD;&#xA;Another way, and what I would do to be 100% sure, is measure resistance with a multimeter. If your meter has a continuity test feature, that's even better because it'll beep.&#xD;&#xA;&#xD;&#xA;Anyway, put one end of the probe on pin 1 of the connector and the other end on GND and see if the resistance is very close to 0 ohms. If it's reading OL (Over-Limit) then that pin is not GND.&#xD;&#xA;&#xD;&#xA;Put the probe on Vcc instead and it should show 0 ohm or beep. So now you know that pin is Vcc.&#xD;&#xA;&#xD;&#xA;Do the same for the other pins and find out which one is ground. The third pin is your PWM output. It's connected to D5 or D6, check the continuity on those pins to see which one.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.tinkerkit.com/custom-distance-sensor/" />
  <row Id="1657" PostHistoryTypeId="2" PostId="609" RevisionGUID="7dcdb704-3456-4b24-8c95-39da4c3b13d1" CreationDate="2014-03-04T21:03:13.783" UserId="467" Text="I've faced this problem several times!&#xD;&#xA;If you are using arduino UNO, make sure to remove any serial connected device on the (Tx,RX) pins. Upload your sketch, then connect them back again.&#xD;&#xA;It's because the arduino UNO has on serial pins which is used for uploading the code, there will be a conflict if there was a device that is connected to the serial the same time you upload the code.&#xD;&#xA;" />
  <row Id="1658" PostHistoryTypeId="8" PostId="596" RevisionGUID="31bd0787-6c4e-478b-b41a-ab4544887519" CreationDate="2014-03-04T21:26:27.457" UserId="220" Comment="Rollback to [516d8afe-594e-41a4-a217-850828ac53b6]" Text=" 1.) I'm not exactly sure what you mean by this. What I'd recommend is a [ATMega328](https://www.sparkfun.com/products/9061) for the heart of the chip. It's what is in the Uno, so with a exception of uploading code, for this project this will cut down on the size of your project. However, an Uno will work pretty much identical. If you do want to use a chip like this, [this design](http://fritzing.org/projects/barebones-arduino) looks pretty complete. You'll probably want to move to a PCB for your final product, but since you have a little electronic experience, I assume you can solder and know about this. [Here is another tutorial for barebones](http://playground.arduino.cc/Learning/AtmegaStandalone).&#xD;&#xA; 2.) Again, what do you mean by &quot;standard?&quot; Like protocol? If so, there's no real protocol to use. [This may be easy for a begginer](http://www.robotmesh.com/ir-kit-for-arduino?gclid=CM650djc97wCFexcMgodK0kAjQ). It's the remote and the receiver. If you want to go all geek you can also [hack an existing TV remote to do the same task](http://www.righto.com/2009/08/multi-protocol-infrared-remote-library.html). That library should take care of everything you need (see code later).&#xD;&#xA;&#xD;&#xA;****&#xD;&#xA;**A bit of code/wiring:**&#xD;&#xA;&#xD;&#xA;The circuit will depend on what receiver you choose. Most IR receivers have one pin for 5v, one for GND, and the last one is connected to a digital pin. Again, look at the information on the specific receiver you choose.&#xD;&#xA;&#xD;&#xA;Some sample code with the library I listed:&#xD;&#xA;&#xD;&#xA;    #include &lt;IRremote.h&gt;&#xD;&#xA;    &#xD;&#xA;    int RECV_PIN = 11;        //Using pin 11 for the signal pin&#xD;&#xA;    IRrecv irrecv(RECV_PIN);  //Creates a variable that will be used later to inference between library and code&#xD;&#xA;    decode_results results;   //Use it to store the value of the keycode&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      irrecv.enableIRIn(); // Start the receiver&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      if (irrecv.decode(&amp;results)) {&#xD;&#xA;        Serial.println(results.value, HEX);&#xD;&#xA;        irrecv.resume(); // Receive the next value&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You'll have to run this sketch to determine the value of the button you'll use on the remote. It should print on the serial window some sort of hexadecimal value IIRC that you'll have to convert into decimal if you want to use it inside the code to compare that to the button you want to use on the remote. The post I mentioned is a great resource: go and look at it.&#xD;&#xA;****&#xD;&#xA; 3.) I don't recommend building a remote. Like I said, you can use existing TV remotes or buy one for this purpose. Start small, figure out how IR remotes work, and then build one later if you desire. A v2 is often required on Arduino.&#xD;&#xA;&#xD;&#xA; 4.) Don't bother for the receiver. It *can* be bigger. If you don't know how to to program it, [this guide is a good reference](http://highlowtech.org/?p=1695). It has some files that you download to add it in the IDE to trick the IDE to think the chip is a board. Note: You'll have to program it with an Uno or similar to upload and to burn the firmware. (I would explain it more in case the site goes down, but you need the files there so it'll be pointless anyway.)&#xD;&#xA;&#xD;&#xA;Also a quick tip: don't be afraid to ask your friend for some help. You don't need to rely on him, but if you get stuck ask him.&#xD;&#xA;&#xD;&#xA;I don't know how to connect the Arduino to the camera, but you seem to know how to do that." />
  <row Id="1660" PostHistoryTypeId="2" PostId="610" RevisionGUID="98e79563-b59b-4332-9469-da57209288b1" CreationDate="2014-03-04T22:26:04.753" UserId="470" Text="&gt;...which pins are mapped to the data pins etc. &#xD;&#xA;&#xD;&#xA;The shield page provides a [schematic](http://arduino.cc/en/uploads/Main/arduino_MotorShield_Rev3-schematic.pdf)&#xD;&#xA;&#xD;&#xA;&gt;I would like to know some more information about the orange and white pin blocks on the board  &#xD;&#xA;&#xD;&#xA;These have the reference printed on the board&#xD;&#xA;![enter image description here][1]  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#TWI IN and TWI OUT#&#xD;&#xA;They are the same and are both connected to the same I2C pins of Arduino (SCL, SDA). They are intended to help in case you want to connect more than one device.&#xD;&#xA;![enter image description here][4]&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;#OUT 5, OUT 6#&#xD;&#xA;Connected to Arduino pins 5 and 6 (PWM outputs)&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;#IN 2, IN 3#&#xD;&#xA;Connected to Analog in A2 and A3&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;The power outputs of [L298](http://www.st.com/st-web-ui/static/active/en/resource/technical/document/datasheet/CD00000240.pdf) intended to drive the motor are the blue screw connectors.&#xD;&#xA;&#xD;&#xA;![enter image description here][5]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/H7mnt.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/5YY7w.jpg&#xD;&#xA;  [3]: http://i.stack.imgur.com/AK2nq.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/bAIkc.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/9zRaY.jpg" />
  <row Id="1661" PostHistoryTypeId="2" PostId="611" RevisionGUID="47aca348-c444-41f3-a99e-7b034c2944ac" CreationDate="2014-03-04T22:35:36.890" UserId="136" Text="In this [code][1] for heating monitor, there appears to be macros called &quot;FLASH_ARRAY&quot; and &quot;FLASH_TABLE&quot;. I can't find any reference to them either in this code, Arduino, or on the Internet. What do they do?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://code.google.com/p/heating-monitor/source/browse/HeatingMonitor/consts.h" />
  <row Id="1662" PostHistoryTypeId="1" PostId="611" RevisionGUID="47aca348-c444-41f3-a99e-7b034c2944ac" CreationDate="2014-03-04T22:35:36.890" UserId="136" Text="What are the FLASH_ARRAY/FLASH_TABLE macros in this code?" />
  <row Id="1663" PostHistoryTypeId="3" PostId="611" RevisionGUID="47aca348-c444-41f3-a99e-7b034c2944ac" CreationDate="2014-03-04T22:35:36.890" UserId="136" Text="&lt;macro&gt;" />
  <row Id="1664" PostHistoryTypeId="2" PostId="612" RevisionGUID="4d082292-fb07-409a-8935-436ea448649f" CreationDate="2014-03-04T22:42:39.183" UserId="136" Text="After further digging, this appears to be from Mikal Hart's [Flash library][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduiniana.org/libraries/flash/" />
  <row Id="1665" PostHistoryTypeId="5" PostId="611" RevisionGUID="0b6cd339-621f-4caf-99d6-770ed09f7251" CreationDate="2014-03-04T22:55:08.280" UserId="11" Comment="added 610 characters in body" Text="In this [code][1] for heating monitor, there appears to be macros called `FLASH_ARRAY` and `FLASH_TABLE`. I can't find any reference to them either in this code, Arduino, or on the Internet. What do they do?&#xD;&#xA;&#xD;&#xA;    FLASH_ARRAY(byte, VARIABLE_DEVICE_TABLE,&#xD;&#xA;        DEVICE_LADDNING_RETUR,&#xD;&#xA;        DEVICE_LADDNING_UT,&#xD;&#xA;        DEVICE_TANK1,&#xD;&#xA;        DEVICE_TANK2,&#xD;&#xA;        ...&#xD;&#xA;        VARIABLE_ID_LOAD,&#xD;&#xA;        VARIABLE_ID_TIME_EMPTY);&#xD;&#xA;&#xD;&#xA;and&#xD;&#xA;&#xD;&#xA;    FLASH_TABLE(byte, NUMBER_TEMP_TABLE, 7,&#xD;&#xA;      {DEVICE_LADDNING_RETUR, 99,  5, 10,  7, MAIN_TYPE_TEXT_CELCIUS, 2},&#xD;&#xA;      {DEVICE_LADDNING_UT,    99, 43, 10,  7, MAIN_TYPE_TEXT_CELCIUS, 2},&#xD;&#xA;      ...&#xD;&#xA;      {DEVICE_UTE,             0, 55, 15,  7, MAIN_TYPE_TEXT_CELCIUS_WITH_NEGATIVE, 103},&#xD;&#xA;      {VARIABLE_ID_EFFECT,   114, 29, 10,  7, MAIN_TYPE_TEXT_VARIABLE, 2});&#xD;&#xA;&#xD;&#xA;  [1]: https://code.google.com/p/heating-monitor/source/browse/HeatingMonitor/consts.h" />
  <row Id="1669" PostHistoryTypeId="2" PostId="614" RevisionGUID="48fe56f9-76c3-4aa5-a5ee-7d89143e5e3e" CreationDate="2014-03-05T01:43:32.587" UserId="379" Text="The flash array is from Mikal Hart's [flash library](https://github.com/mikalhart/Flash/blob/master/Flash.h#L39) as you show, and what it does is that they declare an array or a matrix (table) object in the PROGMEM memory:&#xD;&#xA;&#xD;&#xA;    #define FLASH_ARRAY(type, name, values...) \&#xD;&#xA;    static const type name##_flash[] PROGMEM = { values }; \&#xD;&#xA;    _FLASH_ARRAY&lt;type&gt; name(name##_flash, sizeof(name##_flash) / sizeof(type));&#xD;&#xA;&#xD;&#xA;which is an instance of the `_FLASH_ARRAY` class defined in that same file, which is a facility to access PROGMEM/Flash memory.&#xD;&#xA;&#xD;&#xA;Basically, it's a lot of boilerplate for what already does the `PSTR()` macro amongst other from `pgmspace.h`. I personally would avoid using that and prefer to use the original macros along with my own index and pointers.&#xD;&#xA;&#xD;&#xA;BTW, except for some ardunio IDE magic, I don't think that could can compile, as the `Flash.h` is not included." />
  <row Id="1670" PostHistoryTypeId="2" PostId="615" RevisionGUID="33feea2a-02ba-473f-847b-41792ed3a9e9" CreationDate="2014-03-05T02:04:47.267" UserId="220" Text="I've seen many temperature sensors, but the most they go up to is 125 degrees C (257 degrees F). I want to reach *higher* temperatures than that. I'm thinning about rigging up a closed loop sensor for my soldering iron (for a convenient LCD display), but I can't find out how to sense the temperature of the tip when it's so hot with most sensors." />
  <row Id="1671" PostHistoryTypeId="1" PostId="615" RevisionGUID="33feea2a-02ba-473f-847b-41792ed3a9e9" CreationDate="2014-03-05T02:04:47.267" UserId="220" Text="How can I sense very high temperatures with Arduino?" />
  <row Id="1672" PostHistoryTypeId="3" PostId="615" RevisionGUID="33feea2a-02ba-473f-847b-41792ed3a9e9" CreationDate="2014-03-05T02:04:47.267" UserId="220" Text="&lt;sensors&gt;&lt;temperature-sensor&gt;" />
  <row Id="1673" PostHistoryTypeId="2" PostId="616" RevisionGUID="b86946c0-34bb-493f-91b4-ee7dc9054c78" CreationDate="2014-03-05T02:13:41.933" UserId="65" Text="One of the options to measure high temperatures would be to use [thermocouples][1]. This table provides a basic description of [the types][2] and the corresponding temperatures that they can sense.&#xD;&#xA;&#xD;&#xA;A simple search led me to these components.&#xD;&#xA;&#xD;&#xA;- [Thermocouple Type-K Glass Braid Insulated][3] - A mid range thermocouple&#xD;&#xA;- [Thermocouple Amplifier MAX31855 breakout board][4] - Board to interface the thermocouple with the Arduino. This is needed as the voltage changes in the thermocouple are extremely small, and the rise is non-linear. &#xD;&#xA;&#xD;&#xA;There is also a [tutorial on Adafruit][5] that deals with using and interfacing thermocouples.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Thermocouple&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Thermocouple#Thermocouple_comparison&#xD;&#xA;  [3]: https://www.adafruit.com/products/270&#xD;&#xA;  [4]: https://www.adafruit.com/products/269&#xD;&#xA;  [5]: http://learn.adafruit.com/thermocouple/" />
  <row Id="1674" PostHistoryTypeId="2" PostId="617" RevisionGUID="a09783e5-a3c4-4c1a-9d1f-d5537a2a24e2" CreationDate="2014-03-05T02:13:53.903" UserId="11" Text="You probably want to use a [thermocouple][1]. It'll give you the ability to measure much higher temps than regular temperature sensor. You'll also need a IC like the [MAX6675][2] to interface with it.&#xD;&#xA;&#xD;&#xA;&gt; The MAX6675 performs cold-junction compensation and digitizes the&#xD;&#xA;&gt; signal from a type-K thermocouple. The data is output in a 12-bit&#xD;&#xA;&gt; resolution, SPI™-compatible, read-only format.&#xD;&#xA;&gt; &#xD;&#xA;&gt; This converter resolves temperatures to 0.25°C, allows readings as&#xD;&#xA;&gt; high as +1024°C, and exhibits thermocouple accuracy of 8 LSBs for&#xD;&#xA;&gt; temperatures ranging from 0°C to +700°C.&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;[Page 6 of the datasheet][4] has the serial interface protocol information and. You can really just set the Chip Select line and it'll give you 16 bits of information, 12 of which will be the temperature.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Thermocouple&#xD;&#xA;  [2]: http://www.maximintegrated.com/datasheet/index.mvp/id/3149&#xD;&#xA;  [3]: http://i.stack.imgur.com/pyNbk.gif&#xD;&#xA;  [4]: http://datasheets.maximintegrated.com/en/ds/MAX6675.pdf" />
  <row Id="1675" PostHistoryTypeId="2" PostId="618" RevisionGUID="018d3952-926f-485a-a18c-d4e812903cc4" CreationDate="2014-03-05T02:43:12.093" UserId="220" Text="![Groove Schematic][1]&#xD;&#xA;*[From the wiki](http://www.seeedstudio.com/wiki/File:Stem-diagram-sign.jpg)*.&#xD;&#xA;&#xD;&#xA;Above is a schematic of a Groove shield. You can see that each of the connectors has two digital pins connected to it and then V (5V) and G (GND). The last two you can connect normally to an Arduino. The first two you connect to the pins that are used in your sketch.&#xD;&#xA;&#xD;&#xA;Say it says to connect the connector to the top left DIGITAL pin on the board (D6/D7). You'll 7want to connect the pins as followed: Black → GND, Red → 5V, White → D7, and Yellow → D6. &#xD;&#xA;****&#xD;&#xA;Notes:&#xD;&#xA;&#xD;&#xA; - The shield overlaps the pins (i.e. 3-4, 4-5), so that might make things confusing. I think that is a design flaw. If it needs two pins, *it should have two connectors*. In the current state, you can connect two things together. **I don't really know how to figure out if it uses all of the ports attached or not. If you don't have to, I would try not to overlap any two grooves.** You would do this by using two digital ports for every groove &quot;module.&quot;&#xD;&#xA; - **You'll also need to have a [adapter cable](http://www.seeedstudio.com/depot/grove-to-4-pin-254-female-jumper-wire5-pcs-pack-p-1020.html?cPath=178_179) (Link from *TheDoctor's* Answer.)**&#xD;&#xA; - For analog connections, it applies the same way as digital. G is ground, V is 5v, and A# is an analog pin.&#xD;&#xA;&#xD;&#xA;****&#xD;&#xA;## Inferencing it:&#xD;&#xA;There's no real cookie cutter way to connect to them. However, the [wiki](http://www.seeedstudio.com/wiki/GROVE_System) seems to be a decent resource once you figure out how to navigate it. The [dust sensor you mentioned](http://www.seeedstudio.com/wiki/Grove_-_Dust_Sensor) seems to ONLY use digital pin 8. It was connected to the D7/D8 connector on the Groove shield, so the yellow wire could be ignored since it was never used in the sketch.&#xD;&#xA;&#xD;&#xA;It's hard to do much with this system: it's poorly documented and not uniform at all. Plus, some boards could cause problems that could even lead to damaging components. I would say look at something else.&#xD;&#xA;&#xD;&#xA; - [This dust sensor](https://www.sparkfun.com/products/9689) seems pretty good, minus the documentation. On [this blog](https://www.sparkfun.com/products/9689), they say to do this:&#xD;&#xA;&#xD;&#xA;&gt; Sharp pin 1 (V-LED)   =&gt; 5V (connected to 150ohm resister) Sharp pin 2&#xD;&#xA;&#xD;&#xA;&gt; (LED-GND) =&gt; Arduino GND pin Sharp pin 3 (LED)     =&gt; Arduino pin 2&#xD;&#xA;&#xD;&#xA;&gt; Sharp pin 4 (S-GND)   =&gt; Arduino GND pin Sharp pin 5 (Vo)      =&gt;&#xD;&#xA;&#xD;&#xA;&gt; Arduino A0 pin Sharp pin 6 (Vcc)     =&gt; 5V&#xD;&#xA;&#xD;&#xA;I can't seem to find the cord for it, but I'm sure there are many others like this online. (It lists the cable needed: a 6-pin, 1.5mm pitch connector. That doesn't seem too hard to find).&#xD;&#xA;&#xD;&#xA; - Here is a [4x7 segment display](https://www.sparkfun.com/products/9483) for much cheaper. It does use a lot of pins and need resistors, but multiplexing and resistors aren't that hard to figure out. That's outside of the scope of this question. There might be some other board with a built in IC for controlling a display like that, but I can't seem to find one now.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/vxc2g.jpg" />
  <row Id="1676" PostHistoryTypeId="5" PostId="616" RevisionGUID="96a2be5e-67e1-45d9-8c20-83a9778d1d33" CreationDate="2014-03-05T02:53:47.743" UserId="65" Comment="Added images" Text="One of the options to measure high temperatures would be to use [thermocouples][1]. This table provides a basic description of [the types][2] and the corresponding temperatures that they can sense.&#xD;&#xA;&#xD;&#xA;A simple search led me to these components.&#xD;&#xA;&#xD;&#xA;- [Thermocouple Type-K Glass Braid Insulated][3] - A mid range thermocouple&#xD;&#xA;- [Thermocouple Amplifier MAX31855 breakout board][4] - Board to interface the thermocouple with the Arduino. This is needed as the voltage changes in the thermocouple are extremely small, and the rise is non-linear. &#xD;&#xA;&#xD;&#xA;&gt;This is how the board is connected to the thermocouple.&#xD;&#xA;&gt;![enter image description here][5]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;There is also a [tutorial on Adafruit][6] that deals with using and interfacing thermocouples. &#xD;&#xA;&#xD;&#xA;&gt; This is an image of the thermocouple interfaced with the Arduino.&#xD;&#xA;&gt;![enter image description here][7]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Thermocouple&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Thermocouple#Thermocouple_comparison&#xD;&#xA;  [3]: https://www.adafruit.com/products/270&#xD;&#xA;  [4]: https://www.adafruit.com/products/269&#xD;&#xA;  [5]: http://i.stack.imgur.com/oV37Y.jpg&#xD;&#xA;  [6]: http://learn.adafruit.com/thermocouple/&#xD;&#xA;  [7]: http://i.stack.imgur.com/tvzG0.jpg" />
  <row Id="1677" PostHistoryTypeId="2" PostId="619" RevisionGUID="8f6301c5-cd20-497f-9df5-3ddf76724fb2" CreationDate="2014-03-05T07:03:24.243" UserId="480" Text="I am integrate the MPU-6050 Accelerometer + Gyro sensor into a large project that contains 12 `arduino` boards and 6 `Raspberry Pis.` However, at some point, I will have to load the output of my MPu-6050 sensor into another application through command line. The process is to be all done with Python and Bash (on the Raspberry Pi side), and so what I need is a way to store the output of my `arduino` boards. What I am currently looking at is the python program`ino'. I have used the product for about a year now, and as far as I am aware of, the only way to exit out of `Serial Mode` in `ino` is by closing the command-line window!&#xD;&#xA;&#xD;&#xA;Is there a way I can achieve what I've discussed above? Essentially, all I want is a way to hold the output of my `Arduino` `Serial output` so I can use it later in other parts of my project" />
  <row Id="1678" PostHistoryTypeId="1" PostId="619" RevisionGUID="8f6301c5-cd20-497f-9df5-3ddf76724fb2" CreationDate="2014-03-05T07:03:24.243" UserId="480" Text="Redirecting Arduino Serial Output to a File" />
  <row Id="1679" PostHistoryTypeId="3" PostId="619" RevisionGUID="8f6301c5-cd20-497f-9df5-3ddf76724fb2" CreationDate="2014-03-05T07:03:24.243" UserId="480" Text="&lt;arduino-uno&gt;" />
  <row Id="1680" PostHistoryTypeId="5" PostId="619" RevisionGUID="799d2905-0db2-4eb2-8cec-483ca754d5fa" CreationDate="2014-03-05T07:10:00.587" UserId="480" Comment="edited body" Text="I am integrate the MPU-6050 Accelerometer + Gyro sensor into a large project that contains 12 `arduino` boards and 6 `Raspberry Pis.` However, at some point, I will have to load the output of my MPu-6050 sensor into another application through command line. The process is to be all done with Python and Bash (on the Raspberry Pi side), and so what I need is a way to store the output of my `arduino` boards. What I am currently looking at is the python program`ino`. I have used the product for about a year now, and as far as I am aware of, the only way to exit out of `Serial Mode` in `ino` is by closing the command-line window!&#xD;&#xA;&#xD;&#xA;Is there a way I can achieve what I've discussed above? Essentially, all I want is a way to hold the output of my `Arduino` `Serial output` so I can use it later in other parts of my project" />
  <row Id="1681" PostHistoryTypeId="5" PostId="619" RevisionGUID="dbcbf49c-d1f1-459c-bff1-5abdfb11b2f2" CreationDate="2014-03-05T07:31:19.943" UserId="65" Comment="deleted 8 characters in body" Text="I am integrating the MPU-6050 Accelerometer + Gyro sensor into a large project that contains 12 Arduino boards and 6 Raspberry Pis. At some point, I will have to load the output of my MPU-6050 sensor into another application through command line. The process is to be all done with Python and Bash (on the Raspberry Pi side), and so what I need is a way to store the output of my Arduino boards. &#xD;&#xA;&#xD;&#xA;What I am currently looking at is the python program `ino`. I have used the product for about a year now, and as far as I am aware of, the only way to exit out of serial mode in `ino` is by closing the command-line window! &#xD;&#xA;&#xD;&#xA;Is there a way I can achieve what I've discussed above? Essentially, all I want is a way to hold the output of my Arduino serial output so I can use it later in other parts of my project." />
  <row Id="1682" PostHistoryTypeId="5" PostId="612" RevisionGUID="0056878d-d3ba-4fe0-a2dc-e27b3b54d6da" CreationDate="2014-03-05T09:03:48.357" UserId="136" Comment="Made answer stand alone." Text="After further digging, this appears to be from Mikal Hart's [Flash library][1].&#xD;&#xA;&#xD;&#xA;The reason this library was developed is:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&gt; Storing static program data in flash/PROGMEM is a tricky part of&#xD;&#xA;&gt; Arduino programming. To save precious RAM, a novice user already at&#xD;&#xA;&gt; odds with unfamiliar C++ syntax must digest such daunting concepts as&#xD;&#xA;&gt; prog_char, PSTR(), PROGMEM, pgm_read_word(), etc. Even seasoned users&#xD;&#xA;&gt; get tripped up by the indirection and typecasting that are required to&#xD;&#xA;&gt; retrieve valid PROGMEM data. Add to that a couple of apparent bugs in&#xD;&#xA;&gt; the implementation, and it’s clear that PROGMEM is a complicated mess.&#xD;&#xA;&#xD;&#xA;&gt; I have written a new library, Flash, which abstracts away most of this&#xD;&#xA;&gt; complexity. It provides new String, Array, Table, and String Array&#xD;&#xA;&gt; types that make ROM-based data collections as easy to use as “normal”&#xD;&#xA;&gt; types. Each overrides the C++ [] operator, so to extract individual&#xD;&#xA;&gt; elements one uses familiar array access syntax:&#xD;&#xA;&#xD;&#xA;Specifically, these are macros and a simple helper class to make it easier to create arrays and tables of values in program memory.&#xD;&#xA;&#xD;&#xA;The two macros are declared as so:&#xD;&#xA;&#xD;&#xA;    // Example: FLASH_ARRAY(float, temperatures, 98.1, 98.5, 99.1, 102.1);&#xD;&#xA;    #define FLASH_ARRAY(type, name, values...) \&#xD;&#xA;      static const type name##_flash[] PROGMEM = { values }; \&#xD;&#xA;      _FLASH_ARRAY&lt;type&gt; name(name##_flash, sizeof(name##_flash) / sizeof(type));&#xD;&#xA;    &#xD;&#xA;    // Example: FLASH_TABLE(uint8_t, fonts, 7, {ON, OFF, ON, ON, OFF, ON, OFF}, {OFF, ON, OFF, ON, OFF, ON, OFF});&#xD;&#xA;    #define FLASH_TABLE(type, name, cols, values...) \&#xD;&#xA;      static const type name##_flash[][cols] PROGMEM = { values }; \&#xD;&#xA;      _FLASH_TABLE&lt;type&gt; name((const PROGMEM type *)name##_flash, sizeof(name##_flash) / sizeof(name##_flash[0]), cols);&#xD;&#xA;&#xD;&#xA;The helper functions include size and override the operator [] so that they can easily be accessed like so&#xD;&#xA;&#xD;&#xA;    FLASH_ARRAY[0]&#xD;&#xA;&#xD;&#xA;I disagree with zmo - this is more than boilerplate. The area of PROGMEM causes a lot of questions from Arduino users, and it is very easy to do things wrong when creating arrays in PROGMEM.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduiniana.org/libraries/flash/" />
  <row Id="1683" PostHistoryTypeId="5" PostId="614" RevisionGUID="1a04b901-377f-459d-a9db-49e667167d83" CreationDate="2014-03-05T10:04:47.770" UserId="379" Comment="added 104 characters in body" Text="The flash array is from Mikal Hart's [flash library](https://github.com/mikalhart/Flash/blob/master/Flash.h#L39) as you show, and what it does is that they declare an array or a matrix (table) object in the PROGMEM memory:&#xD;&#xA;&#xD;&#xA;    #define FLASH_ARRAY(type, name, values...) \&#xD;&#xA;    static const type name##_flash[] PROGMEM = { values }; \&#xD;&#xA;    _FLASH_ARRAY&lt;type&gt; name(name##_flash, sizeof(name##_flash) / sizeof(type));&#xD;&#xA;&#xD;&#xA;which is an instance of the `_FLASH_ARRAY` class defined in that same file, which is a facility to access PROGMEM/Flash memory.&#xD;&#xA;&#xD;&#xA;Basically, it's a lot of boilerplate for what already does the `PSTR()` macro amongst other from `pgmspace.h`. I personally would avoid using that and prefer to use the original macros along with my own index and pointers.&#xD;&#xA;&#xD;&#xA;BTW, except for some ardunio IDE magic, I don't think that could can compile, as the `Flash.h` is not included.&#xD;&#xA;&#xD;&#xA;Oh and btw, most recent avr-gcc introduced the `__flash` pragma that does the same thing as PROGMEM " />
  <row Id="1684" PostHistoryTypeId="2" PostId="620" RevisionGUID="bc8f075e-49fd-41bd-a04a-49e1ea60bce7" CreationDate="2014-03-05T10:05:42.047" UserId="481" Text="I want the current to return back through the IO pin, similar to the function of ground.&#xD;&#xA;&#xD;&#xA;Which of this will achieve what i require?&#xD;&#xA;&#xD;&#xA;    pinMode(pinnumber,OUTPUT)&#xD;&#xA;    digitWrite(pinnumber,LOW)&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    pinMode(pinnumber,input)" />
  <row Id="1685" PostHistoryTypeId="1" PostId="620" RevisionGUID="bc8f075e-49fd-41bd-a04a-49e1ea60bce7" CreationDate="2014-03-05T10:05:42.047" UserId="481" Text="Digital IO pin as ground" />
  <row Id="1686" PostHistoryTypeId="3" PostId="620" RevisionGUID="bc8f075e-49fd-41bd-a04a-49e1ea60bce7" CreationDate="2014-03-05T10:05:42.047" UserId="481" Text="&lt;pins&gt;&lt;arduino-due&gt;&lt;current&gt;" />
  <row Id="1687" PostHistoryTypeId="2" PostId="621" RevisionGUID="add6bb6e-cbad-42cf-8ac1-accd4b0f4ccf" CreationDate="2014-03-05T10:21:00.027" UserId="379" Text="well I don't know about your `ino` program, but here's how I'd do it:&#xD;&#xA;&#xD;&#xA;get_serial.py&#xD;&#xA;&#xD;&#xA;    import serial, sys&#xD;&#xA;&#xD;&#xA;    with serial.Serial(port=sys.argv[1], baudrate=sys.argv[2]) as ser:&#xD;&#xA;        while ser.isOpen():&#xD;&#xA;            print(ser.readline())&#xD;&#xA;&#xD;&#xA;the idea, here, is to print on stdout the data coming on the serial line:&#xD;&#xA;&#xD;&#xA;    python get_serial.py /dev/ttyACM0 115200 &gt; output.log&#xD;&#xA;&#xD;&#xA;or you can do it this way:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;get_serial.py&#xD;&#xA;&#xD;&#xA;    import serial, sys&#xD;&#xA;&#xD;&#xA;    with open(sys.argv[3]) as f:&#xD;&#xA;        with serial.Serial(port=sys.argv[1], baudrate=sys.argv[2]) as ser:&#xD;&#xA;            while ser.isOpen():&#xD;&#xA;                f.write(ser.readline())&#xD;&#xA;&#xD;&#xA;which is ran:&#xD;&#xA;&#xD;&#xA;    python get_serial.py /dev/ttyACM0 115200 output.log&#xD;&#xA;&#xD;&#xA;HTH" />
  <row Id="1688" PostHistoryTypeId="2" PostId="622" RevisionGUID="9a15d534-e883-4f8e-872d-806c8e61da76" CreationDate="2014-03-05T10:26:07.987" UserId="291" Text="Your first snippet is the correct solution.&#xD;&#xA;&#xD;&#xA;    pinMode(pinnumber,OUTPUT)&#xD;&#xA;    digitalWrite(pinnumber,LOW)&#xD;&#xA;&#xD;&#xA;Be careful though, you can only sink up to 40mA per pin (as per the documentation, I never tried more). If you need more current, use a transistor ([this][1] looks like a good example, you just need to invert the output pin to `HIGH`).&#xD;&#xA;&#xD;&#xA;When the pin is configured as input it is supposed to be high impedance, not what you want.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://learn.adafruit.com/adafruit-arduino-lesson-13-dc-motors/transistors" />
  <row Id="1689" PostHistoryTypeId="5" PostId="622" RevisionGUID="7131121c-e392-47ba-91ac-5e5af3257deb" CreationDate="2014-03-05T11:12:10.207" UserId="291" Comment="Ooops, arduino due is a different chip than I thought, fixing current rating" Text="Your first snippet is the correct solution.&#xD;&#xA;&#xD;&#xA;    pinMode(pinnumber,OUTPUT)&#xD;&#xA;    digitalWrite(pinnumber,LOW)&#xD;&#xA;&#xD;&#xA;Be careful though, you can only sink up to 6mA or 9mA per pin (as per the [documentation][1] [&quot;Input and Output&quot; section], I never tried more). If you need more current, use a transistor ([this][2] looks like a good example, you just need to invert the output pin to `HIGH`).&#xD;&#xA;&#xD;&#xA;When the pin is configured as input it is supposed to be high impedance, not what you want.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardDue&#xD;&#xA;  [2]: http://learn.adafruit.com/adafruit-arduino-lesson-13-dc-motors/transistors" />
  <row Id="1690" PostHistoryTypeId="2" PostId="623" RevisionGUID="bbe3ae06-58a9-478f-8732-7f2c0000f82a" CreationDate="2014-03-05T11:52:44.643" UserId="136" Text="I'm currently changing some libraries to use flash instead of RAM for string storage so that I do not run out of SRAM on a project.&#xD;&#xA;&#xD;&#xA;Some strings in the library are declared in this manner:&#xD;&#xA;&#xD;&#xA;    const char *testStringA = &quot;ABC&quot;;&#xD;&#xA;&#xD;&#xA;This is different to how I normally see this done:&#xD;&#xA;&#xD;&#xA;    const char testStringB[] = &quot;DEF&quot;;&#xD;&#xA;&#xD;&#xA;However, I think that these two are equivalent when declared const and initialised in the declaration. Both work fine in code.&#xD;&#xA;&#xD;&#xA;I attempted to move these to flash:&#xD;&#xA;&#xD;&#xA;    const prog_char *testStringC PROGMEM = &quot;GHI&quot;;&#xD;&#xA;&#xD;&#xA;I then found that this didn't work. It was producing gobbledegook when printed.&#xD;&#xA;&#xD;&#xA;However, following the more usual pattern of:&#xD;&#xA;&#xD;&#xA;    const prog_char testStringD[] PROGMEM = &quot;JKL&quot;;&#xD;&#xA;&#xD;&#xA;works fine.&#xD;&#xA;&#xD;&#xA;I can see in the disassembly:&#xD;&#xA;&#xD;&#xA;    00000068 &lt;testStringC&gt;:&#xD;&#xA;      68:	04 01                                               ..&#xD;&#xA;    &#xD;&#xA;    0000006a &lt;_ZL11testStringD&gt;:&#xD;&#xA;      6a:	4a 4b 4c 00                                         JKL.&#xD;&#xA;&#xD;&#xA;So it is clear the pointer and PROGMEM results in the string/array not being initialised.&#xD;&#xA;&#xD;&#xA;Why is this?&#xD;&#xA;&#xD;&#xA;Example code:&#xD;&#xA;&#xD;&#xA;    #include &lt;avr/pgmspace.h&gt;&#xD;&#xA;        &#xD;&#xA;    const int BUFFER_LEN = 20;&#xD;&#xA;    &#xD;&#xA;    const char *testStringA = &quot;ABC&quot;;&#xD;&#xA;    const char testStringB[] = &quot;DEF&quot;;&#xD;&#xA;    const prog_char *testStringC PROGMEM = &quot;GHI&quot;;&#xD;&#xA;    const prog_char testStringD[] PROGMEM = &quot;JKL&quot;;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        char buffer[BUFFER_LEN];&#xD;&#xA;    &#xD;&#xA;        Serial.println(testStringA);&#xD;&#xA;        Serial.println(testStringB);&#xD;&#xA;    &#xD;&#xA;        strncpy_P(buffer, testStringC, BUFFER_LEN);&#xD;&#xA;        Serial.println(buffer);&#xD;&#xA;    &#xD;&#xA;        strncpy_P(buffer, testStringD, BUFFER_LEN);&#xD;&#xA;        Serial.println(buffer);&#xD;&#xA;    &#xD;&#xA;        delay(1000);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="1691" PostHistoryTypeId="1" PostId="623" RevisionGUID="bbe3ae06-58a9-478f-8732-7f2c0000f82a" CreationDate="2014-03-05T11:52:44.643" UserId="136" Text="Why can I not use pointers instead of array with PROGMEM?" />
  <row Id="1692" PostHistoryTypeId="3" PostId="623" RevisionGUID="bbe3ae06-58a9-478f-8732-7f2c0000f82a" CreationDate="2014-03-05T11:52:44.643" UserId="136" Text="&lt;progmem&gt;&lt;pointer&gt;" />
  <row Id="1693" PostHistoryTypeId="2" PostId="624" RevisionGUID="ca2bd28b-db82-4ed6-af14-bf965bf430a5" CreationDate="2014-03-05T13:07:26.727" UserId="368" Text="What this line:&#xD;&#xA;&#xD;&#xA;    const prog_char *testStringC PROGMEM = &quot;GHI&quot;;&#xD;&#xA;&#xD;&#xA;does is to write prologue code to copy the characters in the string to SRAM, and then initializes the *pointer* stored in flash to this SRAM location. You must load the pointer via normal means, and then dereference the pointer as usual.&#xD;&#xA;&#xD;&#xA;    const char *str = pgm_read_word(testStringC);&#xD;&#xA;    Serial.println(str);&#xD;&#xA;&#xD;&#xA;This line:&#xD;&#xA;&#xD;&#xA;    const prog_char testStringD[] PROGMEM = &quot;JKL&quot;;&#xD;&#xA;&#xD;&#xA;creates the *array of characters* in flash, allowing you to access it as expected." />
  <row Id="1694" PostHistoryTypeId="2" PostId="625" RevisionGUID="d6e8c6dd-5530-49ff-adde-8daa2e07c2cf" CreationDate="2014-03-05T13:10:11.627" UserId="379" Text="well, this question has been wisely answered on stackoverflow:&#xD;&#xA;&#xD;&#xA; * http://stackoverflow.com/a/1335836/1290438&#xD;&#xA;&#xD;&#xA;Basically, what you're declaring as PROGMEM with:&#xD;&#xA;&#xD;&#xA;    const prog_char testStringD[] PROGMEM = &quot;JKL&quot;;&#xD;&#xA;&#xD;&#xA;is both the array and the memory it points to, i.e. the elements of the array, both in current's scope stack. Whereas with:&#xD;&#xA;&#xD;&#xA;    const prog_char *testStringC PROGMEM = &quot;GHI&quot;;&#xD;&#xA;&#xD;&#xA;you declare a PROGMEM pointer to a constant String that may stay elsewhere in the memory, but not declared as a PROGMEM string.&#xD;&#xA;&#xD;&#xA;Though I did *not* test that, but you should try to declare:&#xD;&#xA;&#xD;&#xA;    const prog_char *testStringC PROGMEM = F(&quot;GHI&quot;);&#xD;&#xA;&#xD;&#xA;to actually allocate the pointed string within the PROGMEM space. I *guess* it should be working." />
  <row Id="1695" PostHistoryTypeId="5" PostId="625" RevisionGUID="2f0edc37-3fc6-4fdc-9cce-9940e1b8fb4d" CreationDate="2014-03-05T13:16:45.453" UserId="379" Comment="added 100 characters in body" Text="well, this question has been wisely answered on stackoverflow:&#xD;&#xA;&#xD;&#xA; * http://stackoverflow.com/a/1335836/1290438&#xD;&#xA;&#xD;&#xA;Basically, what you're declaring as PROGMEM with:&#xD;&#xA;&#xD;&#xA;    const prog_char testStringD[] PROGMEM = &quot;JKL&quot;;&#xD;&#xA;&#xD;&#xA;is both the array and the memory it points to, i.e. the elements of the array, both in current's scope stack. Whereas with:&#xD;&#xA;&#xD;&#xA;    const prog_char* testStringC PROGMEM = &quot;GHI&quot;;&#xD;&#xA;&#xD;&#xA;you declare a PROGMEM pointer to a constant String that may stay elsewhere in the memory, but not declared as a PROGMEM string.&#xD;&#xA;&#xD;&#xA;Though I did *not* test that, but you should try to declare:&#xD;&#xA;&#xD;&#xA;    const prog_char* testStringC PROGMEM = F(&quot;GHI&quot;);&#xD;&#xA;&#xD;&#xA;to actually allocate the pointed string within the PROGMEM space. I *guess* it should be working, using arduino's [`F()` macro](http://andybrown.me.uk/wk/wp-content/images//avr-gcc-4.7.0/WString.h), which adds a lot of boilerplate to actually have the same result as the array declaration.&#xD;&#xA;&#xD;&#xA;Simpler is better: use the array declaration, not the pointer one!" />
  <row Id="1696" PostHistoryTypeId="5" PostId="624" RevisionGUID="9ca51e2c-2e79-4793-94b0-b5f1eb30b3c9" CreationDate="2014-03-05T13:32:05.830" UserId="368" Comment="added 1 characters in body" Text="What this line:&#xD;&#xA;&#xD;&#xA;    const prog_char *testStringC PROGMEM = &quot;GHI&quot;;&#xD;&#xA;&#xD;&#xA;does is to write prologue code to copy the characters in the string to SRAM, and then initializes the *pointer* stored in flash to this SRAM location. You must load the pointer via normal means, and then dereference the pointer as usual.&#xD;&#xA;&#xD;&#xA;    const char *str = pgm_read_word(&amp;testStringC);&#xD;&#xA;    Serial.println(str);&#xD;&#xA;&#xD;&#xA;This line:&#xD;&#xA;&#xD;&#xA;    const prog_char testStringD[] PROGMEM = &quot;JKL&quot;;&#xD;&#xA;&#xD;&#xA;creates the *array of characters* in flash, allowing you to access it as expected." />
  <row Id="1697" PostHistoryTypeId="2" PostId="626" RevisionGUID="cac0eb61-fd65-4071-ace3-f134a4dd2f12" CreationDate="2014-03-05T13:48:35.653" UserId="33" Text="How can I run a webserver in a Arduino Uno? I want to use my Arduino to monitor things in my home such as temperature. I want to be able to access this data through the internet." />
  <row Id="1698" PostHistoryTypeId="1" PostId="626" RevisionGUID="cac0eb61-fd65-4071-ace3-f134a4dd2f12" CreationDate="2014-03-05T13:48:35.653" UserId="33" Text="Webserver on Arduino" />
  <row Id="1699" PostHistoryTypeId="3" PostId="626" RevisionGUID="cac0eb61-fd65-4071-ace3-f134a4dd2f12" CreationDate="2014-03-05T13:48:35.653" UserId="33" Text="&lt;arduino-uno&gt;&lt;ethernet&gt;&lt;networking&gt;" />
  <row Id="1701" PostHistoryTypeId="5" PostId="620" RevisionGUID="474a8d15-eb14-4c60-872c-b52985b4d022" CreationDate="2014-03-05T13:50:30.483" UserId="113" Comment="grammar and typos" Text="I want an IO pin to return current in a circuit, similarly to the function of ground.&#xD;&#xA;&#xD;&#xA;Which of these will achieve what I require?&#xD;&#xA;&#xD;&#xA;    pinMode(pinnumber,OUTPUT)&#xD;&#xA;    digitWrite(pinnumber,LOW)&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    pinMode(pinnumber,input)" />
  <row Id="1702" PostHistoryTypeId="24" PostId="620" RevisionGUID="474a8d15-eb14-4c60-872c-b52985b4d022" CreationDate="2014-03-05T13:50:30.483" Comment="Proposed by 113 approved by 65, 8 edit id of 207" />
  <row Id="1703" PostHistoryTypeId="5" PostId="624" RevisionGUID="7299e392-175b-4bd8-88bf-3a64aaadcea2" CreationDate="2014-03-05T13:52:06.723" UserId="8" Comment="deleted 3 characters in body" Text="What this line:&#xD;&#xA;&#xD;&#xA;    const prog_char *testStringC PROGMEM = &quot;GHI&quot;;&#xD;&#xA;&#xD;&#xA;does it write prologue code to copy the characters in the string to SRAM, and then initializes the *pointer* stored in flash to this SRAM location. You must load the pointer via normal means, and then dereference the pointer as usual.&#xD;&#xA;&#xD;&#xA;    const char *str = pgm_read_word(&amp;testStringC);&#xD;&#xA;    Serial.println(str);&#xD;&#xA;&#xD;&#xA;This line:&#xD;&#xA;&#xD;&#xA;    const prog_char testStringD[] PROGMEM = &quot;JKL&quot;;&#xD;&#xA;&#xD;&#xA;creates the *array of characters* in flash, allowing you to access it as expected." />
  <row Id="1704" PostHistoryTypeId="2" PostId="628" RevisionGUID="1840c4f8-bddd-4992-a8e4-b0b32bdc0eba" CreationDate="2014-03-05T13:55:57.310" UserId="486" Text="Another option, slightly complicated (but fun) to implement, but unintrusive and easy-to-install, is to build a cheap [color sensor][1] and mount it on the wall behind the roll. When you detect the color of the roll (or the absence of the color of TP), it's low.&#xD;&#xA;&#xD;&#xA;You can also just [buy one for $8][2].&#xD;&#xA;&#xD;&#xA;You can adjust the threshold by taking advantage of the thinness of TP and the fact that it starts to look a little darker when there's only a few sheets left.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.instructables.com/id/Introduction-29/&#xD;&#xA;  [2]: http://www.dfrobot.com/index.php?route=product/product&amp;product_id=540#.UxctDPldWSo" />
  <row Id="1706" PostHistoryTypeId="5" PostId="628" RevisionGUID="db025787-3d0e-41b2-9f96-ce11cd743768" CreationDate="2014-03-05T14:01:31.170" UserId="486" Comment="added 522 characters in body" Text="A lot of the options here seem overcomplicated and intrusive.&#xD;&#xA;&#xD;&#xA;&lt;h2&gt;Color Sensor&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;Another option, slightly complicated (but fun) to implement, but unintrusive and easy-to-install, is to build a cheap [color sensor][1] and mount it on the wall behind the roll. When you detect the color of the roll (or the absence of the color of TP), it's low.&#xD;&#xA;&#xD;&#xA;You can also just [buy one for $8][2].&#xD;&#xA;&#xD;&#xA;You can adjust the threshold by taking advantage of the thinness of TP and the fact that it starts to look a little darker when there's only a few sheets left.&#xD;&#xA;&#xD;&#xA;This is very easy to install and doesn't involve modification to the roll itself. You could stick the sensor to the wall with double-sided tape, or put it on a tiny shelf under the roll facing up (or on top facing down).&#xD;&#xA;&#xD;&#xA;&lt;h2&gt;IR beam break&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;Mount a small IR LED on one side of the dispenser, just above the spool. Mount an IR photo sensor on the other side of the dispenser. When the sensor sees the LED, the roll is low. Could be done with a cheap laser too (e.g. an off the shelf laser pointer on one side and a photosensor on the other; but don't hurt your eyes!)&#xD;&#xA;&#xD;&#xA;This is also easy to install (e.g. hot glue to dispenser) and doesn't involve modification to the roll, although the location of the sensors might make them easy to damage when you're replacing rolls.&#xD;&#xA;&#xD;&#xA;&lt;hr&gt;&#xD;&#xA;&#xD;&#xA;I also really like the reed sensor and range sensor (BTW: [$10 gets you a great short range distance sensor][3]) options here.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.instructables.com/id/Introduction-29/&#xD;&#xA;  [2]: http://www.dfrobot.com/index.php?route=product/product&amp;product_id=540#.UxctDPldWSo&#xD;&#xA;  [3]: http://www.adafruit.com/products/466" />
  <row Id="1707" PostHistoryTypeId="2" PostId="629" RevisionGUID="80854f12-c769-43a7-a4e6-8169fc0b4a66" CreationDate="2014-03-05T14:07:53.120" UserId="113" Text="You'll need something like the Ethernet Shield to connect your Arduino Uno to a LAN.&#xD;&#xA;&#xD;&#xA;As for webserver functionality, the Webserver Example sketch does the bulk of what you need.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;For the &quot;access this data through the internet&quot; part, assuming you want access beyond your LAN; you'll need to perform Port Forwarding on your local router (i.e. allow the &quot;Internet&quot; to see your Arduino).&#xD;&#xA;&#xD;&#xA;If you need wifi, then personally I prefer the [CC3300][2] to the Arduino Wifi shield.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/ju3X6.png&#xD;&#xA;  [2]: https://www.adafruit.com/products/1469" />
  <row Id="1708" PostHistoryTypeId="5" PostId="628" RevisionGUID="59cb9333-8b9b-41b0-b111-bc1b8a2955f1" CreationDate="2014-03-05T14:10:51.983" UserId="486" Comment="added 438 characters in body" Text="A lot of the options here seem overcomplicated and intrusive.&#xD;&#xA;&#xD;&#xA;&lt;h2&gt;Color Sensor&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;Another option, slightly complicated (but fun) to implement, but unintrusive and easy-to-install, is to build a cheap [color sensor][1] and mount it on the wall behind the roll. When you detect the color of the roll (or the absence of the color of TP), it's low.&#xD;&#xA;&#xD;&#xA;You can also just [buy one for $8][2].&#xD;&#xA;&#xD;&#xA;You can adjust the threshold by taking advantage of the thinness of TP and the fact that it starts to look a little darker when there's only a few sheets left.&#xD;&#xA;&#xD;&#xA;If necessary, calibration can be done by pressing a button after a new roll is installed with the bathroom lights on.&#xD;&#xA;&#xD;&#xA;You would have to make a few adjustments depending on the specifics of your bathroom. If you added some extra complexity and powered it off an AC outlet that was tied to the bathroom light switch, you could only have it powered on when the bathroom lights were on, which would filter out a lot of unreliable data.&#xD;&#xA;&#xD;&#xA;This is very easy to install and doesn't involve modification to the roll itself. You could stick the sensor to the wall with double-sided tape, or put it on a tiny shelf under the roll facing up (or on top facing down).&#xD;&#xA;&#xD;&#xA;&lt;h2&gt;IR beam break&lt;/h2&gt;&#xD;&#xA;&#xD;&#xA;Mount a small IR LED on one side of the dispenser, just above the spool. Mount an IR photo sensor on the other side of the dispenser. When the sensor sees the LED, the roll is low. Could be done with a cheap laser too (e.g. an off the shelf laser pointer on one side and a photosensor on the other; but don't hurt your eyes!)&#xD;&#xA;&#xD;&#xA;This is also easy to install (e.g. hot glue to dispenser) and doesn't involve modification to the roll, although the location of the sensors might make them easy to damage when you're replacing rolls.&#xD;&#xA;&#xD;&#xA;&lt;hr&gt;&#xD;&#xA;&#xD;&#xA;I also really like the reed sensor and range sensor (BTW: [$10 gets you a great short range distance sensor][3]) options here.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.instructables.com/id/Introduction-29/&#xD;&#xA;  [2]: http://www.dfrobot.com/index.php?route=product/product&amp;product_id=540#.UxctDPldWSo&#xD;&#xA;  [3]: http://www.adafruit.com/products/466" />
  <row Id="1709" PostHistoryTypeId="5" PostId="625" RevisionGUID="540bee09-22ec-4b63-9de1-76ff0b1e4511" CreationDate="2014-03-05T14:16:21.110" UserId="379" Comment="added 113 characters in body" Text="well, this question has been wisely answered on stackoverflow:&#xD;&#xA;&#xD;&#xA; * http://stackoverflow.com/a/1335836/1290438&#xD;&#xA;&#xD;&#xA;Basically, what you're declaring as PROGMEM with:&#xD;&#xA;&#xD;&#xA;    const prog_char testStringD[] PROGMEM = &quot;JKL&quot;;&#xD;&#xA;&#xD;&#xA;is both the array and the memory it points to, i.e. the elements of the array, both in current's scope stack. Whereas with:&#xD;&#xA;&#xD;&#xA;    const prog_char* testStringC PROGMEM = &quot;GHI&quot;;&#xD;&#xA;&#xD;&#xA;you declare a PROGMEM pointer to a constant String that may stay elsewhere in the memory, but not declared as a PROGMEM string.&#xD;&#xA;&#xD;&#xA;Though I did *not* test that, but you should try to declare:&#xD;&#xA;&#xD;&#xA;    const prog_char* testStringC PROGMEM = F(&quot;GHI&quot;);&#xD;&#xA;&#xD;&#xA;to actually allocate the pointed string within the PROGMEM space. I *guess* it should be working, using arduino's [`F()` macro](http://andybrown.me.uk/wk/wp-content/images//avr-gcc-4.7.0/WString.h), which adds a lot of boilerplate to actually have the same result as the array declaration.&#xD;&#xA;&#xD;&#xA;As said in comments, if not in a global context, the `PSTR()` macro could be used instead of the `F()` macro.&#xD;&#xA;&#xD;&#xA;Simpler is better: use the array declaration, not the pointer one!" />
  <row Id="1710" PostHistoryTypeId="5" PostId="629" RevisionGUID="ba70dd8b-04a3-4682-80aa-6e351f7d5ddb" CreationDate="2014-03-05T14:17:11.973" UserId="42" Comment="Added a link to the web-server example mentioned in the post" Text="You'll need something like the Ethernet Shield to connect your Arduino Uno to a LAN.&#xD;&#xA;&#xD;&#xA;As for webserver functionality, the [Webserver Example][1] sketch does the bulk of what you need.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;For the &quot;access this data through the internet&quot; part, assuming you want access beyond your LAN; you'll need to perform Port Forwarding on your local router (i.e. allow the &quot;Internet&quot; to see your Arduino).&#xD;&#xA;&#xD;&#xA;If you need wifi, then personally I prefer the [CC3300][3] to the Arduino Wifi shield.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Tutorial/WebServer&#xD;&#xA;  [2]: http://i.stack.imgur.com/ju3X6.png&#xD;&#xA;  [3]: https://www.adafruit.com/products/1469" />
  <row Id="1711" PostHistoryTypeId="5" PostId="621" RevisionGUID="5c1e97f5-7368-4686-b0c1-6637bf4f7402" CreationDate="2014-03-05T14:48:50.470" UserId="65" Comment="added 16 characters in body" Text="Well, I don't know about your `ino` program, but here's how I'd do it:&#xD;&#xA;&#xD;&#xA;get_serial.py&#xD;&#xA;&#xD;&#xA;    import serial, sys&#xD;&#xA;&#xD;&#xA;    with serial.Serial(port=sys.argv[1], baudrate=sys.argv[2]) as ser:&#xD;&#xA;        while ser.isOpen():&#xD;&#xA;            print(ser.readline())&#xD;&#xA;&#xD;&#xA;The idea, here, is to print on `stdout` the data coming on the serial line:&#xD;&#xA;&#xD;&#xA;    python get_serial.py /dev/ttyACM0 115200 &gt; output.log&#xD;&#xA;&#xD;&#xA;or you can do it this way:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;get_serial.py&#xD;&#xA;&#xD;&#xA;    import serial, sys&#xD;&#xA;&#xD;&#xA;    with open(sys.argv[3]) as f:&#xD;&#xA;        with serial.Serial(port=sys.argv[1], baudrate=sys.argv[2]) as ser:&#xD;&#xA;            while ser.isOpen():&#xD;&#xA;                f.write(ser.readline())&#xD;&#xA;&#xD;&#xA;which is ran:&#xD;&#xA;&#xD;&#xA;    python get_serial.py /dev/ttyACM0 115200 output.log&#xD;&#xA;&#xD;&#xA;Hope this helps!" />
  <row Id="1712" PostHistoryTypeId="2" PostId="630" RevisionGUID="f64b0fa9-4c68-495b-9a1b-9d0258b007ca" CreationDate="2014-03-05T16:23:32.863" UserId="492" Text="I just finished testing a haptic device at university, and when I took it home I got the joy of finding the device not working. Here's what I can trace the problem to: when multiple pins are set to output (pin 2~11), pin 3 writes constantly to high and there is nothing I can do to make it stop.&#xD;&#xA;&#xD;&#xA;Using a blinker program one pin at a time produces no problems, however when I run a blinker program that cycles through all pins, pin 3 is set to constant high. My actual code is similar in function but more complex. This program below though gets the same error.&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      for (int c =2; c&lt;12; c++){&#xD;&#xA;        pinMode(c, OUTPUT);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {  &#xD;&#xA;      for (int c =2; c&lt;12 ; c++){&#xD;&#xA;         digitalWrite(c, HIGH);&#xD;&#xA;         delay(100);&#xD;&#xA;         digitalWrite(c, LOW);&#xD;&#xA;         delay(100);&#xD;&#xA;      }  &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Is this a sign my arduino died? My device had been working for weeks on my prior code with no problem (and no updates). " />
  <row Id="1713" PostHistoryTypeId="1" PostId="630" RevisionGUID="f64b0fa9-4c68-495b-9a1b-9d0258b007ca" CreationDate="2014-03-05T16:23:32.863" UserId="492" Text="All voltage directed to pin 3 when multiple pins are set to out put" />
  <row Id="1714" PostHistoryTypeId="3" PostId="630" RevisionGUID="f64b0fa9-4c68-495b-9a1b-9d0258b007ca" CreationDate="2014-03-05T16:23:32.863" UserId="492" Text="&lt;pins&gt;" />
  <row Id="1716" PostHistoryTypeId="8" PostId="624" RevisionGUID="0b1d02bf-9f56-4ce7-806e-c6e71263d2b5" CreationDate="2014-03-05T16:32:40.537" UserId="42" Comment="Rollback to [9ca51e2c-2e79-4793-94b0-b5f1eb30b3c9]" Text="What this line:&#xD;&#xA;&#xD;&#xA;    const prog_char *testStringC PROGMEM = &quot;GHI&quot;;&#xD;&#xA;&#xD;&#xA;does is to write prologue code to copy the characters in the string to SRAM, and then initializes the *pointer* stored in flash to this SRAM location. You must load the pointer via normal means, and then dereference the pointer as usual.&#xD;&#xA;&#xD;&#xA;    const char *str = pgm_read_word(&amp;testStringC);&#xD;&#xA;    Serial.println(str);&#xD;&#xA;&#xD;&#xA;This line:&#xD;&#xA;&#xD;&#xA;    const prog_char testStringD[] PROGMEM = &quot;JKL&quot;;&#xD;&#xA;&#xD;&#xA;creates the *array of characters* in flash, allowing you to access it as expected." />
  <row Id="1717" PostHistoryTypeId="2" PostId="631" RevisionGUID="1f8b3048-9209-4fec-b0ad-854bd55b4737" CreationDate="2014-03-05T16:32:43.510" UserId="168" Text="Another way to do it, in case you just want to for the fun of it would be to put a metal rod inside the roll, and a metal plate on the outside, and measure the capacitance which should change with the TP remaining due to the dielectric constant of the paper.&#xD;&#xA;&#xD;&#xA;But that would be taking the &quot;scenic route&quot; for sure. Still, the Arduino can measure capacitance pretty easily and it might even be sensitive enough, and it would stay out of the way because it would just be a metal plate behind the roll and a metal rod in the roll. You might even be able to retrofit an existing holder without it being noticed.&#xD;&#xA;&#xD;&#xA;An easier way would be a stick attached to the shaft of a potentiometer held up by the top of the roll. Less TP, shaft goes lower and turns the pot. Might need a long shaft for leverage because you can't press too hard without impeding the function of pulling toilet paper.&#xD;&#xA;&#xD;&#xA;As AJMansfield suggested, Radioactivity actually is used to measure the thickness of things in industrial settings. If you really wanted to go crazy maybe you could use an extremely low energy radioactive source like a can of that weird tasting salt substitute which is a tiny bit above background levels and average over extremely long times(toilet paper shouldn't change much from hour to hour), so this could actually be a reasonable if expensive way to do things.&#xD;&#xA;&#xD;&#xA;Infrared beam break sensors are also good, and if you position it right you could get it to block more light the fuller the roll was instead of just giving you and on or off signal.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1718" PostHistoryTypeId="5" PostId="573" RevisionGUID="8d2e7466-0557-456b-9a55-3f1145d03c6a" CreationDate="2014-03-05T17:00:52.267" UserId="401" Comment="added 715 characters in body" Text="Use a radiation detector to detect the amount of paper left on the roll. Place some amount of radioactive material in the middle of the spool rod, and place the radiation detector somewhere else (you could mount it on the other side of the surface the roll holder is mounted to, if you want; radiation sensors are extremely flexible), and measure the radiation amounts to determine how much paper is left on the roll.&#xD;&#xA;&#xD;&#xA;Alternately, you could have an electronically controlled toilet paper dispenser (push button to dispense a preprogrammed length of toilet paper) and have the arduino just keep track of how much has been dispensed.&#xD;&#xA;&#xD;&#xA;Or, attach a rotary encoder to the side of the spool rod (make sure it fits without slipping inside the roll), and count the rotations of the roll to determine how much has been used.&#xD;&#xA;&#xD;&#xA;Of course, with any of these methods, you will have to do tests and collect data  depending on the exact type/brand/material/etc of toilet paper.&#xD;&#xA;&#xD;&#xA;Especially for the second and third ideas, I would recommend taking data from the system regularly, to keep track of the typical length of a roll so you can adjust the program for any significant variation. Even within one type of toilet paper, I would imagine that there would be some variation in roll length.&#xD;&#xA;&#xD;&#xA;For even more fun, you could instrument the detector to collect time series data, so later you can upload it to a computer and make a &quot;toilet paper usage over time&quot; graph or something." />
  <row Id="1719" PostHistoryTypeId="5" PostId="582" RevisionGUID="61a38c93-6aa4-4043-bd43-d2477afe5dec" CreationDate="2014-03-05T18:09:22.900" UserId="425" Comment="added 367 characters in body" Text="I think I saw this in series 1 episode 2 of James May's Manlab. &#xD;&#xA;&#xD;&#xA;Similar to jfpoilpret, use a wide piece of material on a spring that makes contact with the roll at all times. I say 'wide' so that when the roll is empty the reed touches with a contact on one of the roll holders on the side. When it touches it completes a circuit to your alarm.&#xD;&#xA;&#xD;&#xA;Here's a crude image describing what I mean.&#xD;&#xA;&#xD;&#xA;In Arluin's response it was mentioned that this method would not show that the the roll was empty. Thats pretty much true. If the top contact is as thick as the TP cardboard roll and the bottom contact is positioned inside the inner part of the cardboard roll it should get close enough for practical purposes. One foot of TP roll is not enough after taco night. &#xD;&#xA;&#xD;&#xA;![Behold the image of my imagination][1]&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/uSWHr.jpg" />
  <row Id="1720" PostHistoryTypeId="5" PostId="614" RevisionGUID="4c585548-f236-4c9d-8812-eedffbb0d5b7" CreationDate="2014-03-05T19:41:38.463" UserId="379" Comment="added 869 characters in body" Text="The flash array is from Mikal Hart's [flash library](https://github.com/mikalhart/Flash/blob/master/Flash.h#L39) as you show, and what it does is that they declare an array or a matrix (table) object in the PROGMEM memory:&#xD;&#xA;&#xD;&#xA;    #define FLASH_ARRAY(type, name, values...) \&#xD;&#xA;    static const type name##_flash[] PROGMEM = { values }; \&#xD;&#xA;    _FLASH_ARRAY&lt;type&gt; name(name##_flash, sizeof(name##_flash) / sizeof(type));&#xD;&#xA;&#xD;&#xA;which is an instance of the `_FLASH_ARRAY` class defined in that same file, which is a facility to access PROGMEM/Flash memory.&#xD;&#xA;&#xD;&#xA;Basically, it's a lot of boilerplate for what already does the `PSTR()` macro amongst other from `pgmspace.h`. I personally would avoid using that and prefer to use the original macros along with my own index and pointers.&#xD;&#xA;&#xD;&#xA;BTW, except for some ardunio IDE magic, I don't think that can compile, as the `Flash.h` is not included.&#xD;&#xA;&#xD;&#xA;EDIT:&#xD;&#xA;&#xD;&#xA;To make another point against the `FLASH_TABLE`/`FLASH_ARRAY` boilerplate/overhead, since avc-gcc 4.8 has been introduced the [`__flash` qualifier](http://gcc.gnu.org/onlinedocs/gcc/Named-Address-Spaces.html) which is a replacement for the `PROGMEM` macro, simplifying the whole stuff:&#xD;&#xA;&#xD;&#xA;    // to use string literals without having to cast&#xD;&#xA;    #define FSTR(X) ((const __flash char[]) { X })&#xD;&#xA;&#xD;&#xA;    // create string pstr in the .progmem.data address space&#xD;&#xA;    const __flash char* pstr = FSTR (&quot;foo&quot;); &#xD;&#xA;&#xD;&#xA;and no more use of the `pgm_read_*()` functions, you can now access the content of the flash memory using `*pstr`, as shown is [this thread](http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;p=1129848). In case you want to keep a code compatible with older version of avr-gcc, [here's a post](http://codereview.stackexchange.com/questions/33883/embedded-conditional-code-compaction) that offers macros to deal with both systems.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1721" PostHistoryTypeId="2" PostId="632" RevisionGUID="294317ba-f1d3-47e1-9b2e-aec1648e0133" CreationDate="2014-03-05T19:41:55.710" UserId="27" Text="The [Arduino Yún][1] has been made with this use case in mind. The [Bridge library][2] allows your sketch to publish data such as sensor readings: this data is available through a REST api.&#xD;&#xA;&#xD;&#xA;Say you want to publish the temperature of your living room: you'll write something like&#xD;&#xA;&#xD;&#xA;`Bridge.put(&quot;living_room&quot;, String(19)); //celsius`&#xD;&#xA;&#xD;&#xA;You can then access the data via web with a URL like&#xD;&#xA;&#xD;&#xA;`http://arduino.local/data/get/living_room`&#xD;&#xA;&#xD;&#xA;You can get all sensor readings without specifying the key name, with&#xD;&#xA;&#xD;&#xA;`http://arduino.local/data/get`&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardYun&#xD;&#xA;  [2]: http://arduino.cc/en/Reference/YunBridgeLibrary" />
  <row Id="1722" PostHistoryTypeId="5" PostId="625" RevisionGUID="eb976a81-b8b8-4006-9cfc-f22a0a6b8317" CreationDate="2014-03-05T20:18:45.573" UserId="379" Comment="added 124 characters in body" Text="well, this question has been wisely answered on stackoverflow:&#xD;&#xA;&#xD;&#xA; * http://stackoverflow.com/a/1335836/1290438&#xD;&#xA;&#xD;&#xA;Basically, what you're declaring as PROGMEM with:&#xD;&#xA;&#xD;&#xA;    const prog_char testStringD[] PROGMEM = &quot;JKL&quot;;&#xD;&#xA;&#xD;&#xA;is both the array and the memory it points to, i.e. the elements of the array, both in current's scope stack. Whereas with:&#xD;&#xA;&#xD;&#xA;    const prog_char* testStringC PROGMEM = &quot;GHI&quot;;&#xD;&#xA;&#xD;&#xA;you declare a PROGMEM pointer to a constant String that may stay elsewhere in the memory, but not declared as a PROGMEM string.&#xD;&#xA;&#xD;&#xA;Though I did *not* test that, but you should try to declare:&#xD;&#xA;&#xD;&#xA;    const prog_char* testStringC PROGMEM = F(&quot;GHI&quot;);&#xD;&#xA;&#xD;&#xA;to actually allocate the pointed string within the PROGMEM space. I *guess* it should be working, using arduino's [`F()` macro](http://andybrown.me.uk/wk/wp-content/images//avr-gcc-4.7.0/WString.h), which adds a lot of boilerplate to actually have the same result as the array declaration.&#xD;&#xA;&#xD;&#xA;As said in comments, if not in a global context, the `PSTR()` macro could be used instead of the `F()` macro.&#xD;&#xA;&#xD;&#xA;Simpler is better: use the array declaration, not the pointer one!&#xD;&#xA;&#xD;&#xA;EDIT: cf [that other answer](http://arduino.stackexchange.com/a/614/379) the `__flash` qualifier is a third solution ;-)" />
  <row Id="1723" PostHistoryTypeId="2" PostId="633" RevisionGUID="c37288dd-6fcd-4171-bf85-e7890a5defe2" CreationDate="2014-03-06T00:46:02.330" UserId="220" Text="[The Arduino Uno Page](http://arduino.cc/en/Main/arduinoBoardUno) doesn't say the tempreatures that it can operate in. I'm thinking about placing it outdoors. How can I make sure my Arduino Uno is safe in weather that can reach -20 to 105 degrees fahrenheit? (-26 to 40 degrees celsius.)" />
  <row Id="1724" PostHistoryTypeId="1" PostId="633" RevisionGUID="c37288dd-6fcd-4171-bf85-e7890a5defe2" CreationDate="2014-03-06T00:46:02.330" UserId="220" Text="How cold or hot can my Arduino Uno get?" />
  <row Id="1725" PostHistoryTypeId="3" PostId="633" RevisionGUID="c37288dd-6fcd-4171-bf85-e7890a5defe2" CreationDate="2014-03-06T00:46:02.330" UserId="220" Text="&lt;safety&gt;&lt;arduino-uno-smd&gt;&lt;temperature&gt;" />
  <row Id="1726" PostHistoryTypeId="2" PostId="634" RevisionGUID="43ef0470-2877-4b4f-945f-38c1f774eb2f" CreationDate="2014-03-06T00:46:02.330" UserId="220" Text="**It's not that big of deal.** [The ATmega 328p datasheet](http://www.atmel.com/images/atmel-8271-8-bit-avr-microcontroller-atmega48a-48pa-88a-88pa-168a-168pa-328-328p_datasheet.pdf) states this:&#xD;&#xA;&#xD;&#xA;&gt; Temperature range: -40 to 85 degrees celsius.&#xD;&#xA;&#xD;&#xA;The same goes for the [USB chip on the Uno](http://www.atmel.com/images/atmel-8271-8-bit-avr-microcontroller-atmega48a-48pa-88a-88pa-168a-168pa-328-328p_datasheet.pdf).&#xD;&#xA;&#xD;&#xA;That's inside your limits. It probably could go a bit colder than mentioned, but it'll shorten the length of the board a little bit.&#xD;&#xA;&#xD;&#xA;However, there are some things that may go wrong:&#xD;&#xA;&#xD;&#xA; - EEPROM might not be stored as long in extreme temperatures. Keep this in mind if you're storing critical data.&#xD;&#xA; - The voltage regulator may not perform as well in hot conditions&#xD;&#xA; - The crystal oscilloscope may not produce exact values. However, I would imagine that a few MHz more or less wouldn't affect a 16 MHz processor.&#xD;&#xA; - Resistors/capacitors may not produce the *exact* values. I'd imagine though that it won't be more than 8%: most resistors are rated at 5% for normal temperatures. It does depend on the manufacturer. That won't make much of a difference in this case.&#xD;&#xA; - Extreme cooling/warming may cause minor expansion problems. (Note: it's fine once in a while, but not on an hourly basis of dropping 30 degrees.)&#xD;&#xA; - Other components (LCDs, etc.) should be kept in mind also when looking at the viability of keeping it outdoors.&#xD;&#xA;&#xD;&#xA;So as long as all the other components not on the board will happily run in the temperatures that you need, you should be fine. Also, as with all engineering, values often have added &quot;padding&quot; built in. (i.e. 5% tolerance is often 3-4%, maximum 12V it can run on 12.5V, etc.)" />
  <row Id="1728" PostHistoryTypeId="2" PostId="635" RevisionGUID="af63b230-093f-4b0e-9002-ca6facc1d4f1" CreationDate="2014-03-06T01:17:51.240" UserId="79" Text="For program control, I made something of a menu handlomg framework for one of my projects and [shared the source on Github][1]. *Note that this is for chipKIT but the menu handling code is generic.* After building my 3rd or 4th huge if-else-if and switch structure, I decided there had to be a better way.&#xD;&#xA;&#xD;&#xA;I just use the main loop to check the button.&#xD;&#xA;&#xD;&#xA;I'm wanting to say the first step is to get a TFT. If you try it, you'll never go back... I particularly love the Adafruit 1.8&quot; TFT with joystick. Arduinos are slow enough that I cannot recall caring to debounce user input. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/cacycleworks/chipKIT_ST7735/blob/master/Libraries/ST7735/examples/simpleMenu/simpleMenu.ino" />
  <row Id="1729" PostHistoryTypeId="2" PostId="636" RevisionGUID="3cf468c6-59cd-4f74-bbb0-276a9cdc3146" CreationDate="2014-03-06T01:41:25.377" UserId="79" Text="You need to know the response time of your system and the repeatability of your measurements to characterize your data (establish confidence). I suggest taking samples and average them before turning the heater back on.&#xD;&#xA;&#xD;&#xA;Imho, water will not happily stay within 0.5°C. Can you allow for coarse and fine modes? Use a higher PWM for great differences and then lower PWM for when close to target. &#xD;&#xA;&#xD;&#xA;Once homed in on your target, there are a few means you can try to improve temperature stability. While pre-built things like PID work for many, I normally implement functionality like this manually.&#xD;&#xA;" />
  <row Id="1731" PostHistoryTypeId="5" PostId="634" RevisionGUID="0806651a-0b6b-4295-88af-efbb687127d4" CreationDate="2014-03-06T05:50:34.353" UserId="84" Comment="put the right link for the USB chip datasheet (atmega16u2)" Text="**It's not that big of deal.** [The ATmega 328p datasheet](http://www.atmel.com/images/atmel-8271-8-bit-avr-microcontroller-atmega48a-48pa-88a-88pa-168a-168pa-328-328p_datasheet.pdf) states this:&#xD;&#xA;&#xD;&#xA;&gt; Temperature range: -40 to 85 degrees celsius.&#xD;&#xA;&#xD;&#xA;The same goes for the [USB chip on the Uno (ATmega 16u2 for UNO R3)](http://www.atmel.com/Images/7799S.pdf).&#xD;&#xA;&#xD;&#xA;That's inside your limits. It probably could go a bit colder than mentioned, but it'll shorten the length of the board a little bit.&#xD;&#xA;&#xD;&#xA;However, there are some things that may go wrong:&#xD;&#xA;&#xD;&#xA; - EEPROM might not be stored as long in extreme temperatures. Keep this in mind if you're storing critical data.&#xD;&#xA; - The voltage regulator may not perform as well in hot conditions&#xD;&#xA; - The crystal oscilloscope may not produce exact values. However, I would imagine that a few MHz more or less wouldn't affect a 16 MHz processor.&#xD;&#xA; - Resistors/capacitors may not produce the *exact* values. I'd imagine though that it won't be more than 8%: most resistors are rated at 5% for normal temperatures. It does depend on the manufacturer. That won't make much of a difference in this case.&#xD;&#xA; - Extreme cooling/warming may cause minor expansion problems. (Note: it's fine once in a while, but not on an hourly basis of dropping 30 degrees.)&#xD;&#xA; - Other components (LCDs, etc.) should be kept in mind also when looking at the viability of keeping it outdoors.&#xD;&#xA;&#xD;&#xA;So as long as all the other components not on the board will happily run in the temperatures that you need, you should be fine. Also, as with all engineering, values often have added &quot;padding&quot; built in. (i.e. 5% tolerance is often 3-4%, maximum 12V it can run on 12.5V, etc.)" />
  <row Id="1732" PostHistoryTypeId="24" PostId="634" RevisionGUID="0806651a-0b6b-4295-88af-efbb687127d4" CreationDate="2014-03-06T05:50:34.353" Comment="Proposed by 84 approved by 65, 83 edit id of 208" />
  <row Id="1733" PostHistoryTypeId="2" PostId="637" RevisionGUID="815578a0-23a2-478d-924a-b1b975507812" CreationDate="2014-03-06T05:50:50.773" UserId="84" Text="For hot temperature, just follow the datasheet.&#xD;&#xA;&#xD;&#xA;For low temperature, I remember someone last year trying to [overclock a UNO with liquid nitrogen][1] so I guess you won't ever meet any problems with low temps :-)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://blog.arduino.cc/2013/08/29/overclocking-arduino-with-liquid-nitrogen/" />
  <row Id="1734" PostHistoryTypeId="5" PostId="634" RevisionGUID="e3c2450d-9825-4233-ab36-1a4826e93d1a" CreationDate="2014-03-06T05:52:09.067" UserId="83" Comment="deleted 2 characters in body" Text="**It's not that big of deal.** [The ATmega 328p datasheet](http://www.atmel.com/images/atmel-8271-8-bit-avr-microcontroller-atmega48a-48pa-88a-88pa-168a-168pa-328-328p_datasheet.pdf) states this:&#xD;&#xA;&#xD;&#xA;&gt; Temperature range: -40 to 85 degrees celsius.&#xD;&#xA;&#xD;&#xA;The same goes for the [USB chip on the Uno (ATmega 16u2 for UNO R3)](http://www.atmel.com/Images/7799S.pdf).&#xD;&#xA;&#xD;&#xA;That's inside your limits. It probably could go a bit colder than mentioned, but it'll shorten the length of the board a little bit.&#xD;&#xA;&#xD;&#xA;However, there are some things that may go wrong:&#xD;&#xA;&#xD;&#xA; - EEPROM might not be stored as long in extreme temperatures. Keep this in mind if you're storing critical data.&#xD;&#xA; - The voltage regulator may not perform as well in hot conditions&#xD;&#xA; - The crystal oscillator may not produce exact values. However, I would imagine that a few MHz more or less wouldn't affect a 16 MHz processor.&#xD;&#xA; - Resistors/capacitors may not produce the *exact* values. I'd imagine though that it won't be more than 8%: most resistors are rated at 5% for normal temperatures. It does depend on the manufacturer. That won't make much of a difference in this case.&#xD;&#xA; - Extreme cooling/warming may cause minor expansion problems. (Note: it's fine once in a while, but not on an hourly basis of dropping 30 degrees.)&#xD;&#xA; - Other components (LCDs, etc.) should be kept in mind also when looking at the viability of keeping it outdoors.&#xD;&#xA;&#xD;&#xA;So as long as all the other components not on the board will happily run in the temperatures that you need, you should be fine. Also, as with all engineering, values often have added &quot;padding&quot; built in. (i.e. 5% tolerance is often 3-4%, maximum 12V it can run on 12.5V, etc.)" />
  <row Id="1735" PostHistoryTypeId="2" PostId="638" RevisionGUID="82eb4626-3a92-45f9-8ff0-82d87e5e0e56" CreationDate="2014-03-06T08:57:06.017" UserId="213" Text="Presumably, one power an Arduino board with car batteries for long-term operation away from the power grid.&#xD;&#xA;&#xD;&#xA;Has anyone done this, and what are the most (1) economic, and (2) reliable ways to do this? Specifically, do any additional risks to short the board with an extraneous discharge exist?" />
  <row Id="1736" PostHistoryTypeId="1" PostId="638" RevisionGUID="82eb4626-3a92-45f9-8ff0-82d87e5e0e56" CreationDate="2014-03-06T08:57:06.017" UserId="213" Text="Powering Arduino with Car batteries" />
  <row Id="1737" PostHistoryTypeId="3" PostId="638" RevisionGUID="82eb4626-3a92-45f9-8ff0-82d87e5e0e56" CreationDate="2014-03-06T08:57:06.017" UserId="213" Text="&lt;power&gt;&lt;battery&gt;" />
  <row Id="1738" PostHistoryTypeId="2" PostId="639" RevisionGUID="25d095ec-de19-453b-92c7-4a2be74c2f24" CreationDate="2014-03-06T09:34:56.323" UserId="168" Text="I'm a big fan of USB car chargers for things like this, or USB buck converter boards that you get from ebay." />
  <row Id="1739" PostHistoryTypeId="5" PostId="635" RevisionGUID="02702608-2e1f-4721-a681-b73c33b05a20" CreationDate="2014-03-06T09:48:45.723" UserId="79" Comment="fixed spelling error and added credit for the menu structure source" Text="For program control, I made something of a menu handling framework for one of my projects and [shared the source on Github][1]. *Note that this is for chipKIT but the menu handling code is generic.* After building my 3rd or 4th huge if-else-if and switch structure, I decided there had to be a better way. *[Credit for the source of the static menu structures.][2]*&#xD;&#xA;&#xD;&#xA;I just use the main loop to check the button.&#xD;&#xA;&#xD;&#xA;I'm wanting to say the first step is to get a TFT. If you try it, you'll never go back... I particularly love the Adafruit 1.8&quot; TFT with joystick. Arduinos are slow enough that I cannot recall caring to debounce user input. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/cacycleworks/chipKIT_ST7735/blob/master/Libraries/ST7735/examples/simpleMenu/simpleMenu.ino&#xD;&#xA;  [2]: https://github.com/cacycleworks/chipKIT_ST7735/blob/master/Libraries/ST7735/examples/simpleMenu/menu_credit.txt" />
  <row Id="1740" PostHistoryTypeId="6" PostId="633" RevisionGUID="65c6b2be-c47e-493b-a290-859ce6e06757" CreationDate="2014-03-06T09:50:07.293" UserId="65" Comment="Too vague a tag; could be used for sensors measuring temp, the environment temp, the boards' own temp, etc.. More specific tag should be used, if needed." Text="&lt;safety&gt;&lt;arduino-uno-smd&gt;" />
  <row Id="1741" PostHistoryTypeId="2" PostId="640" RevisionGUID="06686aa9-c989-4c25-a359-0d4181c43f8d" CreationDate="2014-03-06T11:16:52.390" UserId="501" Text="So am I using an Arduino with a shield to gain some voltage values for an ECG. I am then plotting that data in Python. However whenever I &quot;observe&quot; the serial port, be that through the Arduino serial monitor or in attempting to plot the values of time (using millis()) against ECG (voltage) the values reset, so millis() resets the zero, which is fine, except that some of the older values still show up. Now this is especially a problem in Python because it means the plot is malfunctioning at the start of the script, because it is plotting some of the older values and then after a couple of seconds it resets and the plot looks normal again.&#xD;&#xA;&#xD;&#xA;To demonstrate this I have recorded it on video and put it on YouTube, here it is:&#xD;&#xA;&#xD;&#xA;https://www.youtube.com/watch?v=dNpUakcRPec&#xD;&#xA;&#xD;&#xA;Now initially I thought the problem was with Python or the Pyserial module so I labelled the video as such, but since it occurs in the serial monitor I realised the solution would be in the Arduino sketch. I have tried flushing, didn't work, I have tried even to not start the data till I send a start byte, but this didn't work on Python.&#xD;&#xA;&#xD;&#xA;Ideally I could start the Python plotting script and it would skip, or ignore those initial values from the serial port before beginning again.&#xD;&#xA;&#xD;&#xA;Here is the Arduino sketch I am using:&#xD;&#xA;&#xD;&#xA;    #include &lt;eHealth.h&gt;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    unsigned long time;&#xD;&#xA;    // The setup routine runs once when you press reset:&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600); &#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // The loop routine runs over and over again forever:&#xD;&#xA;    void loop() {&#xD;&#xA;    &#xD;&#xA;      float ECG = eHealth.getECG();&#xD;&#xA;      time = millis();&#xD;&#xA;      Serial.print(time);&#xD;&#xA;      Serial.print(&quot; &quot;);&#xD;&#xA;      Serial.print(ECG, 3); &#xD;&#xA;      Serial.println(&quot;&quot;); &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      delay(50);    // wait for 50 millisecond&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1742" PostHistoryTypeId="1" PostId="640" RevisionGUID="06686aa9-c989-4c25-a359-0d4181c43f8d" CreationDate="2014-03-06T11:16:52.390" UserId="501" Text="Arduino serial port reset in Serial monitor &amp; Python" />
  <row Id="1743" PostHistoryTypeId="3" PostId="640" RevisionGUID="06686aa9-c989-4c25-a359-0d4181c43f8d" CreationDate="2014-03-06T11:16:52.390" UserId="501" Text="&lt;arduino-uno&gt;&lt;serial&gt;&lt;python&gt;&lt;reset&gt;" />
  <row Id="1744" PostHistoryTypeId="2" PostId="641" RevisionGUID="caf3e1ef-92bd-444d-b929-f1a0255db73a" CreationDate="2014-03-06T12:20:35.623" UserId="113" Text="Take a look at [if(Serial)][1]&#xD;&#xA;&#xD;&#xA;That makes the Sketch wait for the serial port before continuing.&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;    //Initialize serial and wait for port to open:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      while (!Serial) {&#xD;&#xA;    ; // wait for serial port to connect.&#xD;&#xA;      }&#xD;&#xA;    } &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I have a sneaking suspicion that may only work on the Leonardo.&#xD;&#xA;&#xD;&#xA;If so you could try an alternative:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; 1. Have Python send something to Arduino after it connects.&#xD;&#xA;        &#xD;&#xA; 2. Wait until this is received in setup(): if (Serial.available() &gt; 0) {...}&#xD;&#xA;        &#xD;&#xA; 3. Execute the loop() normally&#xD;&#xA;&#xD;&#xA;e.g.&#xD;&#xA;&#xD;&#xA;    // send data only when you receive data:&#xD;&#xA;        if (Serial.available() &gt; 0) {&#xD;&#xA;                // read the incoming byte:&#xD;&#xA;                incomingByte = Serial.read();&#xD;&#xA;&#xD;&#xA;                // say what you got:&#xD;&#xA;                Serial.print(&quot;I received: &quot;);&#xD;&#xA;                Serial.println(incomingByte, DEC);&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Serial/IfSerial#.Uxhl8xARfxw" />
  <row Id="1745" PostHistoryTypeId="12" PostId="641" RevisionGUID="211dd0bc-3b25-47b4-a082-2efc15c6e7c0" CreationDate="2014-03-06T12:21:16.493" UserId="113" Comment="via Vote" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:113,&quot;DisplayName&quot;:&quot;akellyirl&quot;}]}" />
  <row Id="1746" PostHistoryTypeId="5" PostId="387" RevisionGUID="651e4df6-e5e7-4e96-a138-912afcc9389b" CreationDate="2014-03-06T12:25:54.893" UserId="65" Comment="Added short description and usage;" Text="This tag should be used when writing code for the Arduino specifically using the Arduino IDE.&#xD;&#xA;&#xD;&#xA;A sketch has the following structure:&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {}&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {}&#xD;&#xA;&#xD;&#xA;The `setup` function is run once when the sketch starts. The `loop` function then runs till the board is either shut down or restarted.&#xD;&#xA;&#xD;&#xA;A sketch is saved with the `ino` extension." />
  <row Id="1747" PostHistoryTypeId="24" PostId="387" RevisionGUID="651e4df6-e5e7-4e96-a138-912afcc9389b" CreationDate="2014-03-06T12:25:54.893" Comment="Proposed by 65 approved by 42 edit id of 209" />
  <row Id="1748" PostHistoryTypeId="5" PostId="374" RevisionGUID="d9f5bc15-d3e9-49fa-bab5-b610f8d6b405" CreationDate="2014-03-06T12:26:00.927" UserId="65" Comment="USB is not the only way to connect using serial" Text="Serial communication is the standard USB connection between the Arduino and a computer with a standard USB A to B cable or through the TX/RX pins using a USB to serial converter." />
  <row Id="1749" PostHistoryTypeId="24" PostId="374" RevisionGUID="d9f5bc15-d3e9-49fa-bab5-b610f8d6b405" CreationDate="2014-03-06T12:26:00.927" Comment="Proposed by 65 approved by 42 edit id of 210" />
  <row Id="1750" PostHistoryTypeId="2" PostId="642" RevisionGUID="baa4064a-db72-4cb3-976b-0297651f9fcb" CreationDate="2014-03-06T14:05:10.967" UserId="8" Text="The Arduino is designed to reset when a Serial monitor or script connects to it. The best way to mitigate this would be to send the Arduino some kind of &quot;start sending&quot; signal when you connect to the serial port. It would then send the data when your script was ready." />
  <row Id="1751" PostHistoryTypeId="13" PostId="641" RevisionGUID="d49a9c7c-70f6-4bd5-a2b1-0cd6d384b265" CreationDate="2014-03-06T15:50:39.197" UserId="113" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:113,&quot;DisplayName&quot;:&quot;akellyirl&quot;}]}" />
  <row Id="1752" PostHistoryTypeId="2" PostId="643" RevisionGUID="4ae0e6c5-e24e-4609-a2ec-d4f2fca61581" CreationDate="2014-03-06T17:18:02.817" UserId="470" Text="Use a switching regulator such as [LM2596](http://www.ti.com/product/lm2596), you can get ready board from ebay for about $1&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;Just set the output voltage to 5v and feed the Vcc input of Arduino, this bypasses the onboard regulator.&#xD;&#xA;&#xD;&#xA;The benefit of that is that unlike the linear onboard regulator, a switching regulator is very efficient which means less consumption and less generated heat on the regulator.  &#xD;&#xA;An additional benefit is that it can withstand a higher input voltage (about35v for the specified regulator), just in case the circuit is used in a vehicle that has 24v batteries.&#xD;&#xA;&#xD;&#xA;The regulator has already several protections like short circuit, overheat etc&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/HyLG8.jpg" />
  <row Id="1754" PostHistoryTypeId="2" PostId="645" RevisionGUID="2dd236b9-c774-46c6-8bc7-136978037d97" CreationDate="2014-03-06T17:48:01.883" UserId="196" Text="It is probably dead.  Try getting a new one and see if that fixes it." />
  <row Id="1755" PostHistoryTypeId="2" PostId="646" RevisionGUID="aff64e33-e275-427d-b28b-1a2ba2814496" CreationDate="2014-03-06T19:25:23.807" UserId="480" Text="This problem doesn't seen to be very commen around the `arduino` community.&#xD;&#xA;&#xD;&#xA;Basically, what's happening is that as soon as I click the `upload` button, the Arduino IDE tells me that my `Arduino` board is not connected. What's strange though is that the python application `ino` is able to upload my code just fine, so my only guess is that there is something wrong with the IDE itself.&#xD;&#xA;&#xD;&#xA;Here's a copy of the error message I am getting at upload&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 444 bytes (of a 32,256 byte&#xD;&#xA;&gt; maximum)processing.app.SerialException: Error opening serial port&#xD;&#xA;&gt; '/dev/ttyACM1'.at processing.app.Serial.&lt;init&gt;(Serial.java:178)at&#xD;&#xA;&gt; processing.app.Serial.&lt;init&gt;(Serial.java:77)at&#xD;&#xA;&gt; processing.app.debug.Uploader.flushSerialBuffer(Uploader.java:77)at&#xD;&#xA;&gt; processing.app.debug.AvrdudeUploader.uploadViaBootloader(AvrdudeUploader.java:174)at&#xD;&#xA;&gt; processing.app.debug.AvrdudeUploader.uploadUsingPreferences(AvrdudeUploader.java:67)at&#xD;&#xA;&gt; processing.app.Sketch.upload(Sketch.java:1671)at&#xD;&#xA;&gt; processing.app.Sketch.exportApplet(Sketch.java:1627)at&#xD;&#xA;&gt; processing.app.Sketch.exportApplet(Sketch.java:1599)at&#xD;&#xA;&gt; processing.app.Editor$DefaultExportHandler.run(Editor.java:2380)at&#xD;&#xA;&gt; java.lang.Thread.run(Thread.java:744)Caused by:&#xD;&#xA;&gt; gnu.io.UnsupportedCommOperationException: Invalid Parameterat&#xD;&#xA;&gt; gnu.io.RXTXPort.setSerialPortParams(RXTXPort.java:213)at&#xD;&#xA;&gt; processing.app.Serial.&lt;init&gt;(Serial.java:163)... 9&#xD;&#xA;&gt; moreprocessing.app.debug.RunnerException: Error opening serial port&#xD;&#xA;&gt; '/dev/ttyACM1'.at&#xD;&#xA;&gt; processing.app.debug.Uploader.flushSerialBuffer(Uploader.java:101)at&#xD;&#xA;&gt; processing.app.debug.AvrdudeUploader.uploadViaBootloader(AvrdudeUploader.java:174)at&#xD;&#xA;&gt; processing.app.debug.AvrdudeUploader.uploadUsingPreferences(AvrdudeUploader.java:67)at&#xD;&#xA;&gt; processing.app.Sketch.upload(Sketch.java:1671)at&#xD;&#xA;&gt; processing.app.Sketch.exportApplet(Sketch.java:1627)at&#xD;&#xA;&gt; processing.app.Sketch.exportApplet(Sketch.java:1599)at&#xD;&#xA;&gt; processing.app.Editor$DefaultExportHandler.run(Editor.java:2380)at&#xD;&#xA;&gt; java.lang.Thread.run(Thread.java:744)&#xD;&#xA;&#xD;&#xA;I am expecting to hear a few questions regarding this issue, so I'll go ahead and answer all the questions I can think of.&#xD;&#xA;&#xD;&#xA;Is this the first time I am trying to connect to the Arduino from this computer? &#xD;&#xA;&#xD;&#xA;&gt; No, in fact, I was able to upload the same source code just fine less&#xD;&#xA;&gt; than two hours ago.&#xD;&#xA;&#xD;&#xA;Did I try a different usb cord?&#xD;&#xA;&#xD;&#xA;&gt; Yes, I did.&#xD;&#xA;&#xD;&#xA;Can I upload the source code from a different computer?&#xD;&#xA;&#xD;&#xA;&gt; Yes, I can.&#xD;&#xA;&#xD;&#xA;Have I tried removing and re-installing the IDE?&#xD;&#xA;&#xD;&#xA;&gt; Yes, I have.&#xD;&#xA;&#xD;&#xA;Have I tried a different USB port?&#xD;&#xA;&gt; Yes, I have.&#xD;&#xA;&#xD;&#xA;What seems to be the problem here?" />
  <row Id="1756" PostHistoryTypeId="1" PostId="646" RevisionGUID="aff64e33-e275-427d-b28b-1a2ba2814496" CreationDate="2014-03-06T19:25:23.807" UserId="480" Text="Arduino disconnecting at upload" />
  <row Id="1757" PostHistoryTypeId="3" PostId="646" RevisionGUID="aff64e33-e275-427d-b28b-1a2ba2814496" CreationDate="2014-03-06T19:25:23.807" UserId="480" Text="&lt;arduino-uno&gt;&lt;connectivity&gt;" />
  <row Id="1758" PostHistoryTypeId="2" PostId="647" RevisionGUID="d105264c-0e92-431e-872c-dd5cf550c57f" CreationDate="2014-03-06T19:36:45.963" UserId="83" Text="Maybe another application is using the device. When working on Linux, you can verify this with the following commands:&#xD;&#xA;&#xD;&#xA;    $ lsof /dev/ttyUSB0&#xD;&#xA;    COMMAND  PID     USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME&#xD;&#xA;    avrdude 7356   jippie    3u   CHR  188,0      0t0 266450197 /dev/ttyUSB0&#xD;&#xA;&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    € fuser /dev/ttyUSB0&#xD;&#xA;    /dev/ttyUSB0:         7356&#xD;&#xA;&#xD;&#xA;In both results, the `7356` is the PID of the process that is locking the device. On Linux you can use:&#xD;&#xA;&#xD;&#xA;    $ ps -fp 7356&#xD;&#xA;    UID      PID  PPID  C STIME TTY          TIME CMD&#xD;&#xA;    jippie  7698 28116  1 20:34 pts/8    00:00:00 avrdude -patmega1280 -carduino -P/dev/ttyUSB002 -b57600 -D -Uflash:r:/tmp/flash:i&#xD;&#xA;&#xD;&#xA;or a more portable command:&#xD;&#xA;&#xD;&#xA;    $ ps -ef | grep 7356&#xD;&#xA;    jippie  7698 28116  1 20:34 pts/8    00:00:00 avrdude -patmega1280 -carduino -P/dev/ttyUSB002 -b57600 -D -Uflash:r:/tmp/flash:i" />
  <row Id="1759" PostHistoryTypeId="5" PostId="647" RevisionGUID="384e2fe0-bf7c-49af-bb86-6791675e359f" CreationDate="2014-03-06T19:42:25.040" UserId="83" Comment="added 90 characters in body" Text="Maybe another application is using the device. When working on Linux, you can verify this with the following commands:&#xD;&#xA;&#xD;&#xA;    $ lsof /dev/ttyUSB0&#xD;&#xA;    COMMAND  PID     USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME&#xD;&#xA;    avrdude 7356   jippie    3u   CHR  188,0      0t0 266450197 /dev/ttyUSB0&#xD;&#xA;&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    € fuser /dev/ttyUSB0&#xD;&#xA;    /dev/ttyUSB0:         7356&#xD;&#xA;&#xD;&#xA;In both results, the `7356` is the PID of the process that is locking the device. In my example I was reading flash from the command line, so the output will be different. On Linux you can use:&#xD;&#xA;&#xD;&#xA;    $ ps -fp 7356&#xD;&#xA;    UID      PID  PPID  C STIME TTY          TIME CMD&#xD;&#xA;    jippie  7698 28116  1 20:34 pts/8    00:00:00 avrdude -patmega1280 -carduino -P/dev/ttyUSB002 -b57600 -D -Uflash:r:/tmp/flash:i&#xD;&#xA;&#xD;&#xA;or a more portable command:&#xD;&#xA;&#xD;&#xA;    $ ps -ef | grep 7356&#xD;&#xA;    jippie  7698 28116  1 20:34 pts/8    00:00:00 avrdude -patmega1280 -carduino -P/dev/ttyUSB002 -b57600 -D -Uflash:r:/tmp/flash:i" />
  <row Id="1760" PostHistoryTypeId="6" PostId="646" RevisionGUID="52849fec-801b-4fd8-8825-c25ce964000e" CreationDate="2014-03-06T19:46:39.943" UserId="480" Comment="edited tags" Text="&lt;arduino-uno&gt;&lt;linux&gt;&lt;connectivity&gt;" />
  <row Id="1761" PostHistoryTypeId="5" PostId="647" RevisionGUID="0005354c-a723-4626-928d-345b5d74581a" CreationDate="2014-03-06T19:49:53.017" UserId="83" Comment="added 16 characters in body" Text="Maybe another application is using the device. When working on Linux, you can verify this with the following commands:&#xD;&#xA;&#xD;&#xA;    $ lsof /dev/ttyUSB0&#xD;&#xA;    COMMAND  PID     USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME&#xD;&#xA;    avrdude 7356   jippie    3u   CHR  188,0      0t0 266450197 /dev/ttyUSB0&#xD;&#xA;&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    € fuser /dev/ttyUSB0&#xD;&#xA;    /dev/ttyUSB0:         7356&#xD;&#xA;&#xD;&#xA;In both results, the `7356` is the PID of the process that is locking the device. In my example I was reading flash from the command line, so the output will be different. To identify the process, you can use:&#xD;&#xA;&#xD;&#xA;    $ ps -fp 7356&#xD;&#xA;    UID      PID  PPID  C STIME TTY          TIME CMD&#xD;&#xA;    jippie  7698 28116  1 20:34 pts/8    00:00:00 avrdude -patmega1280 -carduino -P/dev/ttyUSB002 -b57600 -D -Uflash:r:/tmp/flash:i&#xD;&#xA;&#xD;&#xA;or a more portable command:&#xD;&#xA;&#xD;&#xA;    $ ps -ef | grep 7356&#xD;&#xA;    jippie  7698 28116  1 20:34 pts/8    00:00:00 avrdude -patmega1280 -carduino -P/dev/ttyUSB002 -b57600 -D -Uflash:r:/tmp/flash:i" />
  <row Id="1762" PostHistoryTypeId="5" PostId="647" RevisionGUID="00aba87d-9516-425c-adb8-e9cfcce0e70b" CreationDate="2014-03-06T20:00:29.270" UserId="83" Comment="added 248 characters in body" Text="Maybe another application is using the device. When working on Linux, you can verify this with the following commands:&#xD;&#xA;&#xD;&#xA;    $ lsof /dev/ttyUSB0&#xD;&#xA;    COMMAND  PID     USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME&#xD;&#xA;    avrdude 7356   jippie    3u   CHR  188,0      0t0 266450197 /dev/ttyUSB0&#xD;&#xA;&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    € fuser /dev/ttyUSB0&#xD;&#xA;    /dev/ttyUSB0:         7356&#xD;&#xA;&#xD;&#xA;Where of course you have to replace `/dev/ttyUSB0` with the device file as mentioned in the error message. In case of this question `/dev/ttyACM1`, but do notice that the number can change when you unplug the board for a moment and then replug it.&#xD;&#xA;&#xD;&#xA;In both results, the `7356` is the PID of the process that is locking the device. In my example I was reading flash from the command line, so the output for your specific situation will be different. To identify the process, you can use:&#xD;&#xA;&#xD;&#xA;    $ ps -fp 7356&#xD;&#xA;    UID      PID  PPID  C STIME TTY          TIME CMD&#xD;&#xA;    jippie  7698 28116  1 20:34 pts/8    00:00:00 avrdude -patmega1280 -carduino -P/dev/ttyUSB002 -b57600 -D -Uflash:r:/tmp/flash:i&#xD;&#xA;&#xD;&#xA;or a more portable command:&#xD;&#xA;&#xD;&#xA;    $ ps -ef | grep 7356&#xD;&#xA;    jippie  7698 28116  1 20:34 pts/8    00:00:00 avrdude -patmega1280 -carduino -P/dev/ttyUSB002 -b57600 -D -Uflash:r:/tmp/flash:i" />
  <row Id="1763" PostHistoryTypeId="5" PostId="647" RevisionGUID="2990d190-73f9-42dc-9310-b737a6621d9f" CreationDate="2014-03-06T20:14:06.070" UserId="83" Comment="added 461 characters in body" Text="First of all, you must test if the device that you are trying to access, actually exists. The device file may change when you replug the Arduino. The easiest way to accomplish that is to find the device name in the error message, in this case `/dev/ttyACM1`. Then check two things:&#xD;&#xA;&#xD;&#xA;1. Does the device file exist in  the `/dev` tree? `ls -l /dev/ttyACM*`&#xD;&#xA;2. Is the Arduino IDE configured to use the correct device? Check under `Tools` =&gt; `Serial Port`.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Maybe another application is using the device. When working on Linux, you can verify this with the following commands:&#xD;&#xA;&#xD;&#xA;    $ lsof /dev/ttyUSB0&#xD;&#xA;    COMMAND  PID     USER   FD   TYPE DEVICE SIZE/OFF      NODE NAME&#xD;&#xA;    avrdude 7356   jippie    3u   CHR  188,0      0t0 266450197 /dev/ttyUSB0&#xD;&#xA;&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    € fuser /dev/ttyUSB0&#xD;&#xA;    /dev/ttyUSB0:         7356&#xD;&#xA;&#xD;&#xA;Where of course you have to replace `/dev/ttyUSB0` with the device file as mentioned in the error message. In case of this question `/dev/ttyACM1`, but do notice that the number can change when you unplug the board for a moment and then replug it.&#xD;&#xA;&#xD;&#xA;In both results, the `7356` is the PID of the process that is locking the device. In my example I was reading flash from the command line, so the output for your specific situation will be different. To identify the process, you can use:&#xD;&#xA;&#xD;&#xA;    $ ps -fp 7356&#xD;&#xA;    UID      PID  PPID  C STIME TTY          TIME CMD&#xD;&#xA;    jippie  7698 28116  1 20:34 pts/8    00:00:00 avrdude -patmega1280 -carduino -P/dev/ttyUSB002 -b57600 -D -Uflash:r:/tmp/flash:i&#xD;&#xA;&#xD;&#xA;or a more portable command:&#xD;&#xA;&#xD;&#xA;    $ ps -ef | grep 7356&#xD;&#xA;    jippie  7698 28116  1 20:34 pts/8    00:00:00 avrdude -patmega1280 -carduino -P/dev/ttyUSB002 -b57600 -D -Uflash:r:/tmp/flash:i" />
  <row Id="1764" PostHistoryTypeId="5" PostId="638" RevisionGUID="7375aaa5-7654-4a77-a314-fcbef08d6a28" CreationDate="2014-03-06T20:59:52.643" UserId="510" Comment="Copy edited." Text="Presumably, one powers an Arduino board with car batteries for long-term operation away from the power grid.&#xD;&#xA;&#xD;&#xA;How can this be done, and what are the most (1) economic, and (2) reliable ways to do this? Specifically, do any additional risks to short the board with an extraneous discharge exist?&#xD;&#xA;" />
  <row Id="1765" PostHistoryTypeId="4" PostId="638" RevisionGUID="7375aaa5-7654-4a77-a314-fcbef08d6a28" CreationDate="2014-03-06T20:59:52.643" UserId="510" Comment="Copy edited." Text="Powering Arduino with car batteries" />
  <row Id="1766" PostHistoryTypeId="24" PostId="638" RevisionGUID="7375aaa5-7654-4a77-a314-fcbef08d6a28" CreationDate="2014-03-06T20:59:52.643" Comment="Proposed by 510 approved by 83, 11 edit id of 212" />
  <row Id="1767" PostHistoryTypeId="5" PostId="643" RevisionGUID="00d6c70b-96c0-457b-bcc9-0fc6eee29006" CreationDate="2014-03-06T21:00:09.533" UserId="510" Comment="Copy edited." Text="Use a switching regulator such as the [LM2596][1]. You can get a ready board from [eBay][2] for about US$1.&#xD;&#xA;&#xD;&#xA;![Enter image description here][3]&#xD;&#xA;&#xD;&#xA;Just set the output voltage to 5&amp;nbsp;V and feed the V&lt;sub&gt;cc&lt;/sub&gt; input of Arduino; this bypasses the onboard regulator.&#xD;&#xA;&#xD;&#xA;The benefit is that unlike the linear onboard regulator, a switching regulator is very efficient which means less consumption and less generated heat on the regulator. An additional benefit is that it can withstand a higher input voltage (about 35&amp;nbsp;V for the specified regulator), just in case the circuit is used in a vehicle that has 24&amp;nbsp;V batteries.&#xD;&#xA;&#xD;&#xA;The regulator has already several protections like for [short circuiting][4], overheating, etc.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.ti.com/product/lm2596&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/EBay&#xD;&#xA;  [3]: http://i.stack.imgur.com/HyLG8.jpg&#xD;&#xA;  [4]: https://en.wikipedia.org/wiki/Short_circuit&#xD;&#xA;" />
  <row Id="1768" PostHistoryTypeId="24" PostId="643" RevisionGUID="00d6c70b-96c0-457b-bcc9-0fc6eee29006" CreationDate="2014-03-06T21:00:09.533" Comment="Proposed by 510 approved by 83, 11 edit id of 211" />
  <row Id="1769" PostHistoryTypeId="5" PostId="620" RevisionGUID="58e25d3d-f028-4a8f-85e1-cdb8fa622d20" CreationDate="2014-03-06T21:00:30.770" UserId="510" Comment="Copy edited (e.g. ref. &lt;http://en.wikipedia.org/wiki/Input/output&gt;)." Text="I want an I/O pin to return current in a circuit, similarly to the function of ground.&#xD;&#xA;&#xD;&#xA;Which of these will achieve what I require?&#xD;&#xA;&#xD;&#xA;    pinMode(pinnumber, OUTPUT)&#xD;&#xA;    digitWrite(pinnumber, LOW)&#xD;&#xA;&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    pinMode(pinnumber, input)&#xD;&#xA;" />
  <row Id="1770" PostHistoryTypeId="4" PostId="620" RevisionGUID="58e25d3d-f028-4a8f-85e1-cdb8fa622d20" CreationDate="2014-03-06T21:00:30.770" UserId="510" Comment="Copy edited (e.g. ref. &lt;http://en.wikipedia.org/wiki/Input/output&gt;)." Text="A digital I/O pin as ground" />
  <row Id="1771" PostHistoryTypeId="24" PostId="620" RevisionGUID="58e25d3d-f028-4a8f-85e1-cdb8fa622d20" CreationDate="2014-03-06T21:00:30.770" Comment="Proposed by 510 approved by 11 edit id of 213" />
  <row Id="1777" PostHistoryTypeId="5" PostId="645" RevisionGUID="7acc1fc2-6392-4a24-87bc-3f70292f5aed" CreationDate="2014-03-06T22:24:09.370" UserId="220" Comment="added 60 characters in body" Text="It is probably a dead chip. Try getting a new ATmega chip for the Arduino (easily found online for ~$5) and see if that fixes it." />
  <row Id="1779" PostHistoryTypeId="5" PostId="615" RevisionGUID="0b4cf7e1-8d29-4785-8b8b-d288093fb648" CreationDate="2014-03-07T01:12:39.413" UserId="225" Comment="corrected spelling, improved grammar" Text="I've seen many temperature sensors, but the highest temperature they go up to is 125 degrees C (257 degrees F). I want to reach *higher* temperatures than that. I'm thinking about rigging up a closed loop sensor for my soldering iron (for a convenient LCD display), but I can't find out how to sense the temperature of the tip due to the higher operating temperature than most sensors." />
  <row Id="1780" PostHistoryTypeId="24" PostId="615" RevisionGUID="0b4cf7e1-8d29-4785-8b8b-d288093fb648" CreationDate="2014-03-07T01:12:39.413" Comment="Proposed by 225 approved by 220 edit id of 214" />
  <row Id="1781" PostHistoryTypeId="2" PostId="649" RevisionGUID="d881bb5f-510e-4757-8ae0-5bea08484218" CreationDate="2014-03-07T01:35:18.833" UserId="514" Text="I'm trying to replicate a waveform exactly using external and timing interrupts. I've got an external that's setup as a 0ms reference, TIMER1 which is used to determine on time, and TIMER2, which sets the low period. Unfortunately, I can't get the pin low for 2ms. TIMER2 must have something wrong with it, but I can't find it. Instead of banging my head against the wall, I thought I'd ask you guys. Anyone know the answer?  &#xD;&#xA;&#xD;&#xA;     //3 is interrupt for Timing&#xD;&#xA;    //4 through 11 are Time dependent receivers&#xD;&#xA;    //3-11 Pins 12-19&#xD;&#xA;    &#xD;&#xA;    //Curent Serial Byte(Letter or Number)&#xD;&#xA;    char incomingByte = 0;&#xD;&#xA;    //Previous Byte in the Serial Chain&#xD;&#xA;    char previousByte = 0;&#xD;&#xA;    &#xD;&#xA;    //Iterator for Interrupt Values&#xD;&#xA;    volatile unsigned int maincount = 0;&#xD;&#xA;    &#xD;&#xA;    //Time of High Period or Timer Duration&#xD;&#xA;    volatile unsigned int timerhigh;&#xD;&#xA;    &#xD;&#xA;    //Output Pin for Timer Waveform&#xD;&#xA;    volatile unsigned int waveout;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    //Time for Timer Delay in milliseconds, default tim&#xD;&#xA;    volatile unsigned int groundtime = 0;&#xD;&#xA;    &#xD;&#xA;    //Receiver Pins in an Array, except for 3, which serves as 0 source reference&#xD;&#xA;    int pins[9] =&#xD;&#xA;    {&#xD;&#xA;      3,4,5,6,7,8,9,10,11&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    void rising()&#xD;&#xA;    {   &#xD;&#xA;      // set up Timer 1&#xD;&#xA;      TCCR1A = 0;  // normal mode&#xD;&#xA;      TCCR1B = bit(WGM12) | bit(CS11);  // CTC, scale to clock / 8&#xD;&#xA;      OCR1A = timerhigh;          // time before timer fires&#xD;&#xA;      TIMSK1 = bit (OCIE1A);            // interrupt on Compare A Match&#xD;&#xA;    &#xD;&#xA;     }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    //Sets Pin Low, then sets up another timer interrupt for the jump back to high&#xD;&#xA;    ISR(TIMER1_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;    //Brings Pin Low for Keypress&#xD;&#xA;    //Serial.println(&quot;We're in Timer 1&quot;);&#xD;&#xA;    pinMode(waveout,OUTPUT);&#xD;&#xA;    digitalWrite(waveout, LOW);&#xD;&#xA;    &#xD;&#xA;    //Stop Timer 1&#xD;&#xA;     TCCR1B = 0;                      // stop timer&#xD;&#xA;     TIMSK1 = 0;                      // cancel timer interrupt&#xD;&#xA;     &#xD;&#xA;     //Disables Interrupts Before Messing&#xD;&#xA;    cli();&#xD;&#xA;    // set up Timer 2&#xD;&#xA;    TCCR2A = 0;  // normal mode&#xD;&#xA;    TCCR2B = 0;&#xD;&#xA;    //  TCCR2A = bit(WGM21) | bit(CS21);  // CTC, scale to clock / 8&#xD;&#xA;    TCCR2A = (1 &lt;&lt; WGM21); //Enables CTC for timer &#xD;&#xA;    TCCR2B = (1 &lt;&lt; CS21); //Sets 8 bit prescaler&#xD;&#xA;    OCR2A = groundtime;          // time before timer fires&#xD;&#xA;    TIMSK2 = (1 &lt;&lt; OCIE2A);&#xD;&#xA;      &#xD;&#xA;    //Cancel Rising Interrupt on D3&#xD;&#xA;    EIFR = bit (INTF1); &#xD;&#xA;    //Reinables interrupts&#xD;&#xA;    sei();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    //Timer Interrupt for Low Period&#xD;&#xA;    ISR(TIMER2_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;    //Serial.println(&quot;WE'RE IN TIMER2&quot;);&#xD;&#xA;    //Brings Output pin high&#xD;&#xA;    digitalWrite(waveout, HIGH);&#xD;&#xA;      &#xD;&#xA;    //Stop Timer 2&#xD;&#xA;    TCCR2B = 0;                      // stop timer&#xD;&#xA;    TIMSK2 = 0;                      // cancel timer interrupt  &#xD;&#xA;    &#xD;&#xA;    //Cancel Rising Interrupt on D3&#xD;&#xA;     EIFR = bit (INTF1);   &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      // put your setup code here, to run once:&#xD;&#xA;    &#xD;&#xA;    //Sets all the pins for output use&#xD;&#xA;    for(int i=0;i&lt;8;i++)&#xD;&#xA;    {&#xD;&#xA;      pinMode(pins[i], INPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    //Sets Reference Pin as Input&#xD;&#xA;    pinMode(3,INPUT);&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    //Begins Serial&#xD;&#xA;    Serial.begin(115200);&#xD;&#xA;    &#xD;&#xA;    //Cancels Timer 1&#xD;&#xA;    TCCR1A = 0;  // normal mode&#xD;&#xA;    TCCR1B = 0;  // stop timer&#xD;&#xA;    TIMSK1 = 0;   // cancel timer interrupt&#xD;&#xA;    &#xD;&#xA;    //Cancels Timer 2&#xD;&#xA;     TCCR2A = 0;&#xD;&#xA;     TCCR2B = 0;                      // stop timer&#xD;&#xA;     TIMSK2 = 0;                      // cancel timer interrupt  &#xD;&#xA;    detachInterrupt(1);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;    &#xD;&#xA;      //Time of Ground Drop(2 mS), Universal for all letters and offsets&#xD;&#xA;      groundtime = 40000;     // spark time (4000 * 500 nS) = 2 mS&#xD;&#xA;       &#xD;&#xA;      // because of prescaler of 8, each unit is 500 nS (0.5 µS)&#xD;&#xA;      &#xD;&#xA;         if(Serial.available()&gt; 0);&#xD;&#xA;        {&#xD;&#xA;       //Reads Serial Value and assigns to incomingByte&#xD;&#xA;       incomingByte = Serial.read();&#xD;&#xA;       attachInterrupt(1,rising,RISING);&#xD;&#xA;        }&#xD;&#xA;      //  noInterrupts ();  // atomic change of the time amount&#xD;&#xA;    &#xD;&#xA;       //In this area, we'll set the output pin to be used by the timing interrupt, &#xD;&#xA;       //and the time delay off the default waveform present on pin 4&#xD;&#xA;       &#xD;&#xA;       //We can use switch case arrangement, don't know if that's the optimal setup though    &#xD;&#xA;     switch(incomingByte)&#xD;&#xA;     {&#xD;&#xA;       default:&#xD;&#xA;       //Do Nothing&#xD;&#xA;       break;&#xD;&#xA;    &#xD;&#xA;       //Cases FOR ALL THE LETTERS&#xD;&#xA;       case 'a':&#xD;&#xA;       break;&#xD;&#xA;       case 'b':&#xD;&#xA;       break;&#xD;&#xA;       case 'c':&#xD;&#xA;       break;&#xD;&#xA;       case 'd':&#xD;&#xA;       break;&#xD;&#xA;       case 'e':&#xD;&#xA;       break;&#xD;&#xA;       case 'f':&#xD;&#xA;       break;&#xD;&#xA;       case 'g':&#xD;&#xA;       break;&#xD;&#xA;       case 'h':&#xD;&#xA;       break;&#xD;&#xA;       case 'i':&#xD;&#xA;       break;&#xD;&#xA;       case 'j':&#xD;&#xA;       break;&#xD;&#xA;       case 'k':&#xD;&#xA;       break;&#xD;&#xA;       case 'l':&#xD;&#xA;       break;&#xD;&#xA;       case 'm':&#xD;&#xA;       break;&#xD;&#xA;       case 'n':&#xD;&#xA;       break;&#xD;&#xA;       case 'o':&#xD;&#xA;       break;&#xD;&#xA;       case 'p':&#xD;&#xA;       break;&#xD;&#xA;       case 'q':&#xD;&#xA;       break;&#xD;&#xA;       case 'r':&#xD;&#xA;       //Output pin 17 Frequency Pin 10&#xD;&#xA;       //microseconds&#xD;&#xA;       timerhigh=8000;&#xD;&#xA;       waveout=9;&#xD;&#xA;       break;&#xD;&#xA;       case 's':&#xD;&#xA;       break;&#xD;&#xA;       case 't':&#xD;&#xA;       break;&#xD;&#xA;       case 'u':&#xD;&#xA;       break;&#xD;&#xA;       case 'v':&#xD;&#xA;       break;&#xD;&#xA;       case 'w':&#xD;&#xA;       break;&#xD;&#xA;       case 'x':&#xD;&#xA;       break;&#xD;&#xA;       case 'y':&#xD;&#xA;       break;&#xD;&#xA;       case 'z':&#xD;&#xA;       break;&#xD;&#xA;       &#xD;&#xA;       //Cases FOR ALL THE NUMBERS&#xD;&#xA;       case '0':&#xD;&#xA;       break;&#xD;&#xA;       case '1':&#xD;&#xA;       break;&#xD;&#xA;       case '2':&#xD;&#xA;       break;&#xD;&#xA;       case '3':&#xD;&#xA;       break;&#xD;&#xA;       case '4':&#xD;&#xA;       break;&#xD;&#xA;       case '5':&#xD;&#xA;       break;&#xD;&#xA;       case '6':&#xD;&#xA;       break;&#xD;&#xA;       case '7':&#xD;&#xA;       break;&#xD;&#xA;       case '8':&#xD;&#xA;       break;&#xD;&#xA;       case '9':&#xD;&#xA;       break;&#xD;&#xA;       &#xD;&#xA;       //Cases FOR ALL THE PUNCUATION&#xD;&#xA;       case '.':&#xD;&#xA;       break;&#xD;&#xA;       case ',':&#xD;&#xA;       break;&#xD;&#xA;       case '!':&#xD;&#xA;       break;&#xD;&#xA;       case '&quot;':&#xD;&#xA;       break;&#xD;&#xA;       case '#':&#xD;&#xA;       break;&#xD;&#xA;       case '$':&#xD;&#xA;       break;&#xD;&#xA;       case '%':&#xD;&#xA;       break;&#xD;&#xA;       &#xD;&#xA;     }&#xD;&#xA;        &#xD;&#xA;        &#xD;&#xA;        &#xD;&#xA;    //Enables Rising Interrupt for 0ms detection&#xD;&#xA;    //attachInterrupt(1,rising,RISING);&#xD;&#xA;        &#xD;&#xA;    //Reenables interrupts after offset time change&#xD;&#xA;    //interrupts ();&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1782" PostHistoryTypeId="1" PostId="649" RevisionGUID="d881bb5f-510e-4757-8ae0-5bea08484218" CreationDate="2014-03-07T01:35:18.833" UserId="514" Text="Two Timer Interrupts, One Incorrect?" />
  <row Id="1783" PostHistoryTypeId="3" PostId="649" RevisionGUID="d881bb5f-510e-4757-8ae0-5bea08484218" CreationDate="2014-03-07T01:35:18.833" UserId="514" Text="&lt;interrupt&gt;&lt;timers&gt;" />
  <row Id="1784" PostHistoryTypeId="5" PostId="646" RevisionGUID="5282e0d1-c945-48e6-a76c-7b42e85ea648" CreationDate="2014-03-07T01:50:52.227" UserId="37" Comment="corrected spelling; improved formatting; edited tags" Text="This problem doesn't seen to be very common around the Arduino community.&#xD;&#xA;&#xD;&#xA;Basically, what's happening is that as soon as I click the upload button, the Arduino IDE tells me that my Arduino board is not connected. What's strange though is that the python application ino is able to upload my code just fine, so my only guess is that there is something wrong with the IDE itself.&#xD;&#xA;&#xD;&#xA;Here's a copy of the error message I am getting at upload&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 444 bytes (of a 32,256 byte&#xD;&#xA;&gt; maximum)processing.app.SerialException: Error opening serial port&#xD;&#xA;&gt; '/dev/ttyACM1'.at processing.app.Serial.&lt;init&gt;(Serial.java:178)at&#xD;&#xA;&gt; processing.app.Serial.&lt;init&gt;(Serial.java:77)at&#xD;&#xA;&gt; processing.app.debug.Uploader.flushSerialBuffer(Uploader.java:77)at&#xD;&#xA;&gt; processing.app.debug.AvrdudeUploader.uploadViaBootloader(AvrdudeUploader.java:174)at&#xD;&#xA;&gt; processing.app.debug.AvrdudeUploader.uploadUsingPreferences(AvrdudeUploader.java:67)at&#xD;&#xA;&gt; processing.app.Sketch.upload(Sketch.java:1671)at&#xD;&#xA;&gt; processing.app.Sketch.exportApplet(Sketch.java:1627)at&#xD;&#xA;&gt; processing.app.Sketch.exportApplet(Sketch.java:1599)at&#xD;&#xA;&gt; processing.app.Editor$DefaultExportHandler.run(Editor.java:2380)at&#xD;&#xA;&gt; java.lang.Thread.run(Thread.java:744)Caused by:&#xD;&#xA;&gt; gnu.io.UnsupportedCommOperationException: Invalid Parameterat&#xD;&#xA;&gt; gnu.io.RXTXPort.setSerialPortParams(RXTXPort.java:213)at&#xD;&#xA;&gt; processing.app.Serial.&lt;init&gt;(Serial.java:163)... 9&#xD;&#xA;&gt; moreprocessing.app.debug.RunnerException: Error opening serial port&#xD;&#xA;&gt; '/dev/ttyACM1'.at&#xD;&#xA;&gt; processing.app.debug.Uploader.flushSerialBuffer(Uploader.java:101)at&#xD;&#xA;&gt; processing.app.debug.AvrdudeUploader.uploadViaBootloader(AvrdudeUploader.java:174)at&#xD;&#xA;&gt; processing.app.debug.AvrdudeUploader.uploadUsingPreferences(AvrdudeUploader.java:67)at&#xD;&#xA;&gt; processing.app.Sketch.upload(Sketch.java:1671)at&#xD;&#xA;&gt; processing.app.Sketch.exportApplet(Sketch.java:1627)at&#xD;&#xA;&gt; processing.app.Sketch.exportApplet(Sketch.java:1599)at&#xD;&#xA;&gt; processing.app.Editor$DefaultExportHandler.run(Editor.java:2380)at&#xD;&#xA;&gt; java.lang.Thread.run(Thread.java:744)&#xD;&#xA;&#xD;&#xA;I am expecting to hear a few questions regarding this issue, so I'll go ahead and answer all the questions I can think of.&#xD;&#xA;&#xD;&#xA;&gt; Is this the first time I am trying to connect to the Arduino from this computer? &#xD;&#xA;&#xD;&#xA;No, in fact, I was able to upload the same source code just fine less than two hours ago.&#xD;&#xA;&#xD;&#xA;&gt; Did I try a different usb cord?&#xD;&#xA;&#xD;&#xA;Yes, I did.&#xD;&#xA;&#xD;&#xA;&gt; Can I upload the source code from a different computer?&#xD;&#xA;&#xD;&#xA;Yes, I can.&#xD;&#xA;&#xD;&#xA;&gt; Have I tried removing and re-installing the IDE?&#xD;&#xA;&#xD;&#xA;Yes, I have.&#xD;&#xA;&#xD;&#xA;&gt; Have I tried a different USB port?&#xD;&#xA;&#xD;&#xA;Yes, I have.&#xD;&#xA;&#xD;&#xA;What seems to be the problem here?" />
  <row Id="1785" PostHistoryTypeId="6" PostId="646" RevisionGUID="5282e0d1-c945-48e6-a76c-7b42e85ea648" CreationDate="2014-03-07T01:50:52.227" UserId="37" Comment="corrected spelling; improved formatting; edited tags" Text="&lt;arduino-uno&gt;&lt;uploading&gt;&lt;linux&gt;" />
  <row Id="1786" PostHistoryTypeId="24" PostId="646" RevisionGUID="5282e0d1-c945-48e6-a76c-7b42e85ea648" CreationDate="2014-03-07T01:50:52.227" Comment="Proposed by 37 approved by -1 edit id of 216" />
  <row Id="1787" PostHistoryTypeId="5" PostId="646" RevisionGUID="2b0e068d-727f-4f8a-81a0-13eaa20fb50e" CreationDate="2014-03-07T01:50:52.227" UserId="220" Comment="corrected spelling; improved formatting; edited tags" Text="This problem doesn't seen to be very common around the Arduino community.&#xD;&#xA;&#xD;&#xA;Basically, what's happening is that as soon as I click the upload button, the Arduino IDE tells me that my Arduino board is not connected. What's strange though is that the python application ino is able to upload my code just fine, so my only guess is that there is something wrong with the IDE itself.&#xD;&#xA;&#xD;&#xA;Here's a copy of the error message I am getting at the time of uploading the sketch:&#xD;&#xA;&#xD;&#xA;&gt; Binary sketch size: 444 bytes (of a 32,256 byte&#xD;&#xA;&gt; maximum)processing.app.SerialException: Error opening serial port&#xD;&#xA;&gt; '/dev/ttyACM1'.at processing.app.Serial.&lt;init&gt;(Serial.java:178)at&#xD;&#xA;&gt; processing.app.Serial.&lt;init&gt;(Serial.java:77)at&#xD;&#xA;&gt; processing.app.debug.Uploader.flushSerialBuffer(Uploader.java:77)at&#xD;&#xA;&gt; processing.app.debug.AvrdudeUploader.uploadViaBootloader(AvrdudeUploader.java:174)at&#xD;&#xA;&gt; processing.app.debug.AvrdudeUploader.uploadUsingPreferences(AvrdudeUploader.java:67)at&#xD;&#xA;&gt; processing.app.Sketch.upload(Sketch.java:1671)at&#xD;&#xA;&gt; processing.app.Sketch.exportApplet(Sketch.java:1627)at&#xD;&#xA;&gt; processing.app.Sketch.exportApplet(Sketch.java:1599)at&#xD;&#xA;&gt; processing.app.Editor$DefaultExportHandler.run(Editor.java:2380)at&#xD;&#xA;&gt; java.lang.Thread.run(Thread.java:744)Caused by:&#xD;&#xA;&gt; gnu.io.UnsupportedCommOperationException: Invalid Parameterat&#xD;&#xA;&gt; gnu.io.RXTXPort.setSerialPortParams(RXTXPort.java:213)at&#xD;&#xA;&gt; processing.app.Serial.&lt;init&gt;(Serial.java:163)... 9&#xD;&#xA;&gt; moreprocessing.app.debug.RunnerException: Error opening serial port&#xD;&#xA;&gt; '/dev/ttyACM1'.at&#xD;&#xA;&gt; processing.app.debug.Uploader.flushSerialBuffer(Uploader.java:101)at&#xD;&#xA;&gt; processing.app.debug.AvrdudeUploader.uploadViaBootloader(AvrdudeUploader.java:174)at&#xD;&#xA;&gt; processing.app.debug.AvrdudeUploader.uploadUsingPreferences(AvrdudeUploader.java:67)at&#xD;&#xA;&gt; processing.app.Sketch.upload(Sketch.java:1671)at&#xD;&#xA;&gt; processing.app.Sketch.exportApplet(Sketch.java:1627)at&#xD;&#xA;&gt; processing.app.Sketch.exportApplet(Sketch.java:1599)at&#xD;&#xA;&gt; processing.app.Editor$DefaultExportHandler.run(Editor.java:2380)at&#xD;&#xA;&gt; java.lang.Thread.run(Thread.java:744)&#xD;&#xA;&#xD;&#xA;I am expecting to hear a few questions regarding this issue, so I'll go ahead and answer all the questions I can think of.&#xD;&#xA;&#xD;&#xA;&gt; *Is this the first time you trying to connect to the Arduino from this computer?*&#xD;&#xA;&#xD;&#xA;No. In fact, I was able to upload the same source code just fine less than two hours ago.&#xD;&#xA;&#xD;&#xA;&gt; *Did you try a different USB cord?*&#xD;&#xA;&#xD;&#xA;Yes, I did.&#xD;&#xA;&#xD;&#xA;&gt; *Can you upload the source code from a different computer?*&#xD;&#xA;&#xD;&#xA;Yes, I can.&#xD;&#xA;&#xD;&#xA;&gt; *Have you tried removing and reinstalling the IDE?*&#xD;&#xA;&#xD;&#xA;Yes, I have.&#xD;&#xA;&#xD;&#xA;&gt; *Have you tried a different USB port?*&#xD;&#xA;&#xD;&#xA;Yes, I have.&#xD;&#xA;&#xD;&#xA;What seems to be the problem here?" />
  <row Id="1788" PostHistoryTypeId="5" PostId="649" RevisionGUID="194c2306-046b-4438-b355-ed182d8eac31" CreationDate="2014-03-07T06:14:54.590" UserId="514" Comment="added 670 characters in body" Text="I'm trying to replicate a waveform exactly using external and timing interrupts. I've got an external that's setup as a 0ms reference, TIMER1 which is used to determine on time, and TIMER2, which sets the low period. Unfortunately, I can't get the pin low for 2ms. TIMER2 must have something wrong with it, but I can't find it. Instead of banging my head against the wall, I thought I'd ask you guys. Anyone know the answer?  &#xD;&#xA;&#xD;&#xA;     //3 is interrupt for Timing&#xD;&#xA;    //4 through 11 are Time dependent receivers&#xD;&#xA;    //3-11 Pins 12-19&#xD;&#xA;    &#xD;&#xA;    //Curent Serial Byte(Letter or Number)&#xD;&#xA;    char incomingByte = 0;&#xD;&#xA;    //Previous Byte in the Serial Chain&#xD;&#xA;    char previousByte = 0;&#xD;&#xA;    &#xD;&#xA;    //Iterator for Interrupt Values&#xD;&#xA;    volatile unsigned int maincount = 0;&#xD;&#xA;    &#xD;&#xA;    //Time of High Period or Timer Duration&#xD;&#xA;    volatile unsigned int timerhigh;&#xD;&#xA;    &#xD;&#xA;    //Output Pin for Timer Waveform&#xD;&#xA;    volatile unsigned int waveout;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    //Time for Timer Delay in milliseconds, default tim&#xD;&#xA;    volatile unsigned int groundtime = 0;&#xD;&#xA;    &#xD;&#xA;    //Receiver Pins in an Array, except for 3, which serves as 0 source reference&#xD;&#xA;    int pins[9] =&#xD;&#xA;    {&#xD;&#xA;      3,4,5,6,7,8,9,10,11&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    void rising()&#xD;&#xA;    {   &#xD;&#xA;      // set up Timer 1&#xD;&#xA;      TCCR1A = 0;  // normal mode&#xD;&#xA;      TCCR1B = bit(WGM12) | bit(CS11);  // CTC, scale to clock / 8&#xD;&#xA;      OCR1A = timerhigh;          // time before timer fires&#xD;&#xA;      TIMSK1 = bit (OCIE1A);            // interrupt on Compare A Match&#xD;&#xA;    &#xD;&#xA;     }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    //Sets Pin Low, then sets up another timer interrupt for the jump back to high&#xD;&#xA;    ISR(TIMER1_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;    //Brings Pin Low for Keypress&#xD;&#xA;    //Serial.println(&quot;We're in Timer 1&quot;);&#xD;&#xA;    pinMode(waveout,OUTPUT);&#xD;&#xA;    digitalWrite(waveout, LOW);&#xD;&#xA;    &#xD;&#xA;    //Stop Timer 1&#xD;&#xA;     TCCR1B = 0;                      // stop timer&#xD;&#xA;     TIMSK1 = 0;                      // cancel timer interrupt&#xD;&#xA;     &#xD;&#xA;     //Disables Interrupts Before Messing&#xD;&#xA;    cli();&#xD;&#xA;    // set up Timer 2&#xD;&#xA;    TCCR2A = 0;  // normal mode&#xD;&#xA;    TCCR2B = 0;&#xD;&#xA;    //  TCCR2A = bit(WGM21) | bit(CS21);  // CTC, scale to clock / 8&#xD;&#xA;    TCCR2A = (1 &lt;&lt; WGM21); //Enables CTC for timer &#xD;&#xA;    TCCR2B = (1 &lt;&lt; CS21); //Sets 8 bit prescaler&#xD;&#xA;    OCR2A = groundtime;          // time before timer fires&#xD;&#xA;    TIMSK2 = (1 &lt;&lt; OCIE2A);&#xD;&#xA;      &#xD;&#xA;    //Cancel Rising Interrupt on D3&#xD;&#xA;    EIFR = bit (INTF1); &#xD;&#xA;    //Reinables interrupts&#xD;&#xA;    sei();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    //Timer Interrupt for Low Period&#xD;&#xA;    ISR(TIMER2_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;    //Serial.println(&quot;WE'RE IN TIMER2&quot;);&#xD;&#xA;    //Brings Output pin high&#xD;&#xA;    digitalWrite(waveout, HIGH);&#xD;&#xA;      &#xD;&#xA;    //Stop Timer 2&#xD;&#xA;    TCCR2B = 0;                      // stop timer&#xD;&#xA;    TIMSK2 = 0;                      // cancel timer interrupt  &#xD;&#xA;    &#xD;&#xA;    //Cancel Rising Interrupt on D3&#xD;&#xA;     EIFR = bit (INTF1);   &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      // put your setup code here, to run once:&#xD;&#xA;    &#xD;&#xA;    //Sets all the pins for output use&#xD;&#xA;    for(int i=0;i&lt;8;i++)&#xD;&#xA;    {&#xD;&#xA;      pinMode(pins[i], INPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    //Sets Reference Pin as Input&#xD;&#xA;    pinMode(3,INPUT);&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    //Begins Serial&#xD;&#xA;    Serial.begin(115200);&#xD;&#xA;    &#xD;&#xA;    //Cancels Timer 1&#xD;&#xA;    TCCR1A = 0;  // normal mode&#xD;&#xA;    TCCR1B = 0;  // stop timer&#xD;&#xA;    TIMSK1 = 0;   // cancel timer interrupt&#xD;&#xA;    &#xD;&#xA;    //Cancels Timer 2&#xD;&#xA;     TCCR2A = 0;&#xD;&#xA;     TCCR2B = 0;                      // stop timer&#xD;&#xA;     TIMSK2 = 0;                      // cancel timer interrupt  &#xD;&#xA;    detachInterrupt(1);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;    &#xD;&#xA;      //Time of Ground Drop(2 mS), Universal for all letters and offsets&#xD;&#xA;      groundtime = 40000;     // spark time (4000 * 500 nS) = 2 mS&#xD;&#xA;       &#xD;&#xA;      // because of prescaler of 8, each unit is 500 nS (0.5 µS)&#xD;&#xA;      &#xD;&#xA;         if(Serial.available()&gt; 0);&#xD;&#xA;        {&#xD;&#xA;       //Reads Serial Value and assigns to incomingByte&#xD;&#xA;       incomingByte = Serial.read();&#xD;&#xA;       attachInterrupt(1,rising,RISING);&#xD;&#xA;        }&#xD;&#xA;      //  noInterrupts ();  // atomic change of the time amount&#xD;&#xA;    &#xD;&#xA;       //In this area, we'll set the output pin to be used by the timing interrupt, &#xD;&#xA;       //and the time delay off the default waveform present on pin 4&#xD;&#xA;       &#xD;&#xA;       //We can use switch case arrangement, don't know if that's the optimal setup though    &#xD;&#xA;     switch(incomingByte)&#xD;&#xA;     {&#xD;&#xA;       default:&#xD;&#xA;       //Do Nothing&#xD;&#xA;       break;&#xD;&#xA;    &#xD;&#xA;       //Cases FOR ALL THE LETTERS&#xD;&#xA;       case 'a':&#xD;&#xA;       break;&#xD;&#xA;       case 'b':&#xD;&#xA;       break;&#xD;&#xA;       case 'c':&#xD;&#xA;       break;&#xD;&#xA;       case 'd':&#xD;&#xA;       break;&#xD;&#xA;       case 'e':&#xD;&#xA;       break;&#xD;&#xA;       case 'f':&#xD;&#xA;       break;&#xD;&#xA;       case 'g':&#xD;&#xA;       break;&#xD;&#xA;       case 'h':&#xD;&#xA;       break;&#xD;&#xA;       case 'i':&#xD;&#xA;       break;&#xD;&#xA;       case 'j':&#xD;&#xA;       break;&#xD;&#xA;       case 'k':&#xD;&#xA;       break;&#xD;&#xA;       case 'l':&#xD;&#xA;       break;&#xD;&#xA;       case 'm':&#xD;&#xA;       break;&#xD;&#xA;       case 'n':&#xD;&#xA;       break;&#xD;&#xA;       case 'o':&#xD;&#xA;       break;&#xD;&#xA;       case 'p':&#xD;&#xA;       break;&#xD;&#xA;       case 'q':&#xD;&#xA;       break;&#xD;&#xA;       case 'r':&#xD;&#xA;       //Output pin 17 Frequency Pin 10&#xD;&#xA;       //microseconds&#xD;&#xA;       timerhigh=8000;&#xD;&#xA;       waveout=9;&#xD;&#xA;       break;&#xD;&#xA;       case 's':&#xD;&#xA;       break;&#xD;&#xA;       case 't':&#xD;&#xA;       break;&#xD;&#xA;       case 'u':&#xD;&#xA;       break;&#xD;&#xA;       case 'v':&#xD;&#xA;       break;&#xD;&#xA;       case 'w':&#xD;&#xA;       break;&#xD;&#xA;       case 'x':&#xD;&#xA;       break;&#xD;&#xA;       case 'y':&#xD;&#xA;       break;&#xD;&#xA;       case 'z':&#xD;&#xA;       break;&#xD;&#xA;       &#xD;&#xA;       //Cases FOR ALL THE NUMBERS&#xD;&#xA;       case '0':&#xD;&#xA;       break;&#xD;&#xA;       case '1':&#xD;&#xA;       break;&#xD;&#xA;       case '2':&#xD;&#xA;       break;&#xD;&#xA;       case '3':&#xD;&#xA;       break;&#xD;&#xA;       case '4':&#xD;&#xA;       break;&#xD;&#xA;       case '5':&#xD;&#xA;       break;&#xD;&#xA;       case '6':&#xD;&#xA;       break;&#xD;&#xA;       case '7':&#xD;&#xA;       break;&#xD;&#xA;       case '8':&#xD;&#xA;       break;&#xD;&#xA;       case '9':&#xD;&#xA;       break;&#xD;&#xA;       &#xD;&#xA;       //Cases FOR ALL THE PUNCUATION&#xD;&#xA;       case '.':&#xD;&#xA;       break;&#xD;&#xA;       case ',':&#xD;&#xA;       break;&#xD;&#xA;       case '!':&#xD;&#xA;       break;&#xD;&#xA;       case '&quot;':&#xD;&#xA;       break;&#xD;&#xA;       case '#':&#xD;&#xA;       break;&#xD;&#xA;       case '$':&#xD;&#xA;       break;&#xD;&#xA;       case '%':&#xD;&#xA;       break;&#xD;&#xA;       &#xD;&#xA;     }&#xD;&#xA;        &#xD;&#xA;        &#xD;&#xA;        &#xD;&#xA;    //Enables Rising Interrupt for 0ms detection&#xD;&#xA;    //attachInterrupt(1,rising,RISING);&#xD;&#xA;        &#xD;&#xA;    //Reenables interrupts after offset time change&#xD;&#xA;    //interrupts ();&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Answer:&#xD;&#xA;Turns out the problem was that timer 0 and 2 on the arduino uno are 8 bit. Set a different prescaler and I'm golden&#xD;&#xA;&#xD;&#xA;    // set up Timer 2&#xD;&#xA;        TCCR2A = 0;  // normal mode&#xD;&#xA;        TCCR2B = 0;&#xD;&#xA;        //  TCCR2A = bit(WGM21) | bit(CS21);  // CTC, scale to clock / 8&#xD;&#xA;        TCCR2A = (1 &lt;&lt; WGM21); //Enables CTC for timer &#xD;&#xA;        &#xD;&#xA;        TCCR2B |= (1 &lt;&lt; CS21); &#xD;&#xA;        TCCR2B |= (1 &lt;&lt; CS22); //Sets 256 bit prescaler&#xD;&#xA;        TCCR2B |= (0 &lt;&lt; CS20); &#xD;&#xA;        OCR2A = groundtime;    // time before rising edge&#xD;&#xA;        TIMSK2 = (1 &lt;&lt; OCIE2A);&#xD;&#xA;        //Cancel Rising Interrupt on D3&#xD;&#xA;        EIFR = bit (INTF1); &#xD;&#xA;        //Reinables interrupts&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1789" PostHistoryTypeId="2" PostId="650" RevisionGUID="65315cb4-8d12-4ae0-b6b3-37b4771cc07d" CreationDate="2014-03-07T06:34:12.020" UserId="517" Text="I'm playing around with a SparkFun Redboard (essentially, an Arduino UNO).&#xD;&#xA;&#xD;&#xA;I have a simple 5V sensor that I'd been trying to get to work with A2 and analogRead(). Nothing seemed to work. It's supposed to be cycling from 0 to 5V, which should give me values from 0 to 1023, and instead I get constant values of around 260.&#xD;&#xA;&#xD;&#xA;In desperation, I tried using other ports. On A0, A1, and A3 I get the signals I expect. On A2, still nada.&#xD;&#xA;&#xD;&#xA;So, the question. Is there something I could have done in configuring things that would have made A2 and only A2 stop reading correctly? If so, how can I reset it?&#xD;&#xA;&#xD;&#xA;Or is there some other function that I might be using that could interfere with A2? Currently, I'm only using Serial over USB - could that interfere with A2?&#xD;&#xA;&#xD;&#xA;Or could I simply have fried the port?" />
  <row Id="1790" PostHistoryTypeId="1" PostId="650" RevisionGUID="65315cb4-8d12-4ae0-b6b3-37b4771cc07d" CreationDate="2014-03-07T06:34:12.020" UserId="517" Text="Have I fried my A2 port?" />
  <row Id="1791" PostHistoryTypeId="3" PostId="650" RevisionGUID="65315cb4-8d12-4ae0-b6b3-37b4771cc07d" CreationDate="2014-03-07T06:34:12.020" UserId="517" Text="&lt;arduino-uno&gt;" />
  <row Id="1792" PostHistoryTypeId="6" PostId="650" RevisionGUID="0991ff03-9f3e-4503-b303-05095db0a8a0" CreationDate="2014-03-07T06:53:49.837" UserId="65" Comment="edited tags" Text="&lt;arduino-uno&gt;&lt;pins&gt;" />
  <row Id="1793" PostHistoryTypeId="5" PostId="620" RevisionGUID="ae07d11b-c561-486c-981d-aa98397f6a87" CreationDate="2014-03-07T06:59:42.000" UserId="481" Comment="Wrong function call " Text="I want an I/O pin to return current in a circuit, similarly to the function of ground.&#xD;&#xA;&#xD;&#xA;Which of these will achieve what I require?&#xD;&#xA;&#xD;&#xA;    pinMode(pinnumber, OUTPUT)&#xD;&#xA;    digitalWrite(pinnumber, LOW)&#xD;&#xA;&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    pinMode(pinnumber, input)&#xD;&#xA;" />
  <row Id="1794" PostHistoryTypeId="2" PostId="651" RevisionGUID="22d93d11-6939-4ae3-868b-4627452f1951" CreationDate="2014-03-07T07:26:43.180" UserId="65" Text="When running the board at room temperature (20 C) without any extra cooling mechanisms added, how much can the Arduino Uno be overclocked?&#xD;&#xA;&#xD;&#xA;Also, what would I need to change/update to overclock the board?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1795" PostHistoryTypeId="1" PostId="651" RevisionGUID="22d93d11-6939-4ae3-868b-4627452f1951" CreationDate="2014-03-07T07:26:43.180" UserId="65" Text="How much can an Uno be overclocked?" />
  <row Id="1796" PostHistoryTypeId="3" PostId="651" RevisionGUID="22d93d11-6939-4ae3-868b-4627452f1951" CreationDate="2014-03-07T07:26:43.180" UserId="65" Text="&lt;arduino-uno&gt;&lt;performance&gt;" />
  <row Id="1797" PostHistoryTypeId="2" PostId="652" RevisionGUID="0b736572-0edc-494a-8ff6-87a6fc79bc90" CreationDate="2014-03-07T07:46:39.640" UserId="518" Text="I have sourced an LPG consumption meter from China with pulse output. I am looking to hook the output up to an arduino to get the consumption metrics. Unfortunately there is not too much documentation available on the unit that I can find. The suppliers inform me that:&#xD;&#xA;&#xD;&#xA;1. Black wire(signal 1)&#xD;&#xA;2. Black wire(signal 2)&#xD;&#xA;3. Red wire(earth wire)&#xD;&#xA;&#xD;&#xA;So that's a start, I know the unit pulses a signal for every cubic meter of gas consumed. &#xD;&#xA;What I'm wanting to know is:&#xD;&#xA;&#xD;&#xA;1. What are the input [likely] voltages for the unit (or how could I establish this)?&#xD;&#xA;2. How do I wire the unit to an arduino?&#xD;&#xA;3. I can cook up a sketch to do the reading but what is the signal I am looking for?&#xD;&#xA;&#xD;&#xA;The mechanical meter itself has a metallic strip on the 0 digit of the wheel (how it achieves the pulsing itself no doubt) so another approach would be something like this &lt;http://phk.freebsd.dk/Gasdims/&gt; which is a more accurate option. For this option any suggestions on what photoreflectors are available for the Arduino which could do the job.&#xD;&#xA;&#xD;&#xA;![meter][1]&#xD;&#xA;![output wiring - one red two black][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/sHmUd.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/WTD8F.jpg" />
  <row Id="1798" PostHistoryTypeId="1" PostId="652" RevisionGUID="0b736572-0edc-494a-8ff6-87a6fc79bc90" CreationDate="2014-03-07T07:46:39.640" UserId="518" Text="How to interface to LPG consumption meter" />
  <row Id="1799" PostHistoryTypeId="3" PostId="652" RevisionGUID="0b736572-0edc-494a-8ff6-87a6fc79bc90" CreationDate="2014-03-07T07:46:39.640" UserId="518" Text="&lt;arduino-uno&gt;" />
  <row Id="1800" PostHistoryTypeId="2" PostId="653" RevisionGUID="5d374ccc-a46c-4551-baed-1456da8cd922" CreationDate="2014-03-07T08:32:43.647" UserId="136" Text="Currently I am developing a graphic LCD system to display temperatures, flows, voltages, power and energy in a heat pump system. The use of a graphic LCD means that half of my SRAM and ~75% of my flash have been used up by a screen buffer and strings.&#xD;&#xA;&#xD;&#xA;I am currently displaying min/max/average figures for energy At midnight when the daily figure resets, the system checks if the consumption for the day is above or below the previous minimum or maximum, and stores the value. The average is calculated by dividing the cumulative energy consumption by the number of days.&#xD;&#xA;&#xD;&#xA;I would like to display the daily average over the last week and month (4 weeks for simplicity) i.e. a rolling average. Currently this involves maintaining an array of values for the last 28 days and calculating an average over the whole array for monthly and last 7 days for weekly.&#xD;&#xA;&#xD;&#xA;Initially I was doing this using an array of floats (as the energy is in the form &quot;12.12kWh&quot;), but this was using 28 * 4 bytes = 112 bytes (5.4% of SRAM). I don't mind having only a single decimal point of resolution, so I changed to using uint16_t and multiplying the figure by 100. This means that 12.12 is represented as 1212, and I divide by 100 for display purposes.&#xD;&#xA;&#xD;&#xA;The size of the array is now down to 56 bytes (much better!).&#xD;&#xA;&#xD;&#xA;There is no trivial way to reduce the figure down to a uint8_t that I can see. I could tolerate the loss of a decimal place (&quot;12.1kWh&quot; instead of &quot;12.12kWh&quot;), but consumption is frequently higher than 25.5kWh (255 being the highest value represented by a 8-bit unsigned integer). Consumption has never been below 10.0kWh or above 35.0kWh, so conceivably I could subtract 10 from the stored figures, but I know that one day we will exceed these limits.&#xD;&#xA;&#xD;&#xA;I then tested code to pack 9-bit values into an array. This gives a range of 0-51.2kWh and uses 32 bytes in total. However, accessing an array like this is pretty slow, especially when you have to iterate over all values to calculate an average.&#xD;&#xA;&#xD;&#xA;So my question is - is there a more efficient way of calculating a moving average in terms of SRAM? Can I avoid storing all values?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1801" PostHistoryTypeId="1" PostId="653" RevisionGUID="5d374ccc-a46c-4551-baed-1456da8cd922" CreationDate="2014-03-07T08:32:43.647" UserId="136" Text="Efficient algorithm/data structure to calculate moving averages" />
  <row Id="1802" PostHistoryTypeId="3" PostId="653" RevisionGUID="5d374ccc-a46c-4551-baed-1456da8cd922" CreationDate="2014-03-07T08:32:43.647" UserId="136" Text="&lt;memory-usage&gt;&lt;algorithm&gt;" />
  <row Id="1803" PostHistoryTypeId="2" PostId="654" RevisionGUID="574bcc51-f45d-4a08-9ec7-1be599f89647" CreationDate="2014-03-07T08:43:35.867" UserId="136" Text="With no active cooling, most ATmega328P will run at 30MHz but you will need to up the supply voltage to ~6V. I have never done this on an Arduino board, just an ATmega328P.&#xD;&#xA;&#xD;&#xA;I provided an external clock from a signal generator.&#xD;&#xA;&#xD;&#xA;The only way to achieve a speed faster than 16MHz is to change the crystal/oscillator/clock input for one faster than 16MHz. &#xD;&#xA;&#xD;&#xA;As this was just an experiment, I didn't alter f_cpu in boards.txt, so all timers etc. would be incorrect. Baud rates would also be incorrect - the only way to upload code was to change back to 16MHz." />
  <row Id="1804" PostHistoryTypeId="2" PostId="655" RevisionGUID="5ef514f8-86aa-4e87-9890-9119e2922bc9" CreationDate="2014-03-07T09:15:21.353" UserId="359" Text="you can use a different method, you keep the current average and then do &#xD;&#xA;&#xD;&#xA;    average = (weight1*average+weight2*new_value)/(weight1+weight2);&#xD;&#xA;&#xD;&#xA;it's not a true rolling average and has different semantics, but it may fit your needs nonetheless " />
  <row Id="1805" PostHistoryTypeId="2" PostId="656" RevisionGUID="59a34920-c1e0-483f-b939-3bc4306a713b" CreationDate="2014-03-07T09:37:34.870" UserId="65" Text="If your data has low standard deviation, then one method would be to sum values over the window, and then keep subtracting the mean from the sum, while adding the new value.&#xD;&#xA;&#xD;&#xA;This would work well if there are *no outliers*, thereby leading to the aggregate error tending to zero over time.&#xD;&#xA;&#xD;&#xA;    //Pseudocode&#xD;&#xA;&#xD;&#xA;    count=0&#xD;&#xA;    while new_reading and count&lt;7:&#xD;&#xA;        sum += new_reading        //Calculate the sum of first 7 values&#xD;&#xA;        count++&#xD;&#xA;&#xD;&#xA;    while new_reading:            //Loop till new readings available&#xD;&#xA;        avg = sum / 7             //Calculate average&#xD;&#xA;        sum -= avg                //Subtract average from sum&#xD;&#xA;        sum += new_reading        //Add next reading to sum&#xD;&#xA;        print avg&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1806" PostHistoryTypeId="5" PostId="655" RevisionGUID="54691e06-0162-4fb6-8771-80a1895cd0ff" CreationDate="2014-03-07T09:47:10.917" UserId="359" Comment="added 991 characters in body" Text="you can use a different method, you keep the current average and then do &#xD;&#xA;&#xD;&#xA;    average = (weight1*average+weight2*new_value)/(weight1+weight2);&#xD;&#xA;&#xD;&#xA;it's not a true rolling average and has different semantics, but it may fit your needs nonetheless &#xD;&#xA;&#xD;&#xA;for a more efficient storage method for your 9 bits per value solution you could keep the 8 highest bits of the values in an array and separate out the least significant bits:&#xD;&#xA;&#xD;&#xA;    uint8_t[28] highbits;&#xD;&#xA;    uint32_t lowbits;&#xD;&#xA;&#xD;&#xA;to set a value you need to split it out&#xD;&#xA;&#xD;&#xA;    void getvalue(uint8_t index, uint16_t value){&#xD;&#xA;        highbits[index] = value&gt;&gt;1;&#xD;&#xA;        uint32_t flag = (value &amp; 1)&lt;&lt;index;&#xD;&#xA;        highbits|=flag;&#xD;&#xA;        highbits&amp;=~flag;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;resulting in 2 shifts an AND and an OR and a not&#xD;&#xA;&#xD;&#xA;to calculate the average you can use various bit tricks to speed it up:&#xD;&#xA;&#xD;&#xA;    uint16_t getAverage(){&#xD;&#xA;        uint16_t sum=0;&#xD;&#xA;        for(uint8_t i=0;i&lt;28;i++){&#xD;&#xA;            sum+=highbits[i];&#xD;&#xA;        }&#xD;&#xA;        sum&lt;&lt;=1;&#xD;&#xA;        sum+=bitcount(lowbits);&#xD;&#xA;        return sum/28;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;you can use an [efficient parallel bitcount][1] for the `bitcount()`&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/3815165/how-to-implement-bitcount-using-only-bitwise-operators" />
  <row Id="1807" PostHistoryTypeId="5" PostId="655" RevisionGUID="9d68dbd3-2f96-433b-8618-f313fb65352f" CreationDate="2014-03-07T09:55:04.760" UserId="359" Comment="added 34 characters in body" Text="you can use a different method, you keep the current average and then do &#xD;&#xA;&#xD;&#xA;    average = (weight1*average+weight2*new_value)/(weight1+weight2);&#xD;&#xA;&#xD;&#xA;it's not a true rolling average and has different semantics, but it may fit your needs nonetheless &#xD;&#xA;&#xD;&#xA;for a more efficient calculation method for your 9 bits per value solution you could keep the 8 highest bits of the values in an array and separate out the least significant bits:&#xD;&#xA;&#xD;&#xA;    uint8_t[28] highbits;&#xD;&#xA;    uint32_t lowbits;&#xD;&#xA;&#xD;&#xA;to set a value you need to split it out&#xD;&#xA;&#xD;&#xA;    void getvalue(uint8_t index, uint16_t value){&#xD;&#xA;        highbits[index] = value&gt;&gt;1;&#xD;&#xA;        uint32_t flag = (value &amp; 1)&lt;&lt;index;&#xD;&#xA;        highbits|=flag;&#xD;&#xA;        highbits&amp;=~flag;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;resulting in 2 shifts an AND and an OR and a not&#xD;&#xA;&#xD;&#xA;to calculate the average you can use various bit tricks to speed it up:&#xD;&#xA;&#xD;&#xA;    uint16_t getAverage(){&#xD;&#xA;        uint16_t sum=0;&#xD;&#xA;        for(uint8_t i=0;i&lt;28;i++){&#xD;&#xA;            sum+=highbits[i];&#xD;&#xA;        }&#xD;&#xA;        sum&lt;&lt;=1;//multiply by 2 after the loop&#xD;&#xA;        sum+=bitcount(lowbits);&#xD;&#xA;        return sum/28;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;you can use an [efficient parallel bitcount][1] for the `bitcount()`&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/3815165/how-to-implement-bitcount-using-only-bitwise-operators" />
  <row Id="1809" PostHistoryTypeId="2" PostId="658" RevisionGUID="850250a9-58c7-4de8-b7fa-7af6a2eb3919" CreationDate="2014-03-07T12:29:32.300" UserId="136" Text="C on embedded systems has traditionally use structs to hold structured data.&#xD;&#xA;&#xD;&#xA;Arduino brings C++ to the table, so we can use objects instead.&#xD;&#xA;&#xD;&#xA;Lets say we have two different data structures which could be considered very similar:&#xD;&#xA;&#xD;&#xA;    typedef struct &#xD;&#xA;    {&#xD;&#xA;    	int valueOne,&#xD;&#xA;    	int valueTwo,&#xD;&#xA;    	int valueThree&#xD;&#xA;    } value_t;&#xD;&#xA;&#xD;&#xA;and:&#xD;&#xA;&#xD;&#xA;    class Value&#xD;&#xA;    {&#xD;&#xA;    	public:&#xD;&#xA;    		int valueOne;&#xD;&#xA;    		int valueTwo;&#xD;&#xA;    		int valueThree;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;In terms of memory, what difference will this make? &#xD;&#xA;&#xD;&#xA;I still see the struct technique being used heavily - why is this?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1810" PostHistoryTypeId="1" PostId="658" RevisionGUID="850250a9-58c7-4de8-b7fa-7af6a2eb3919" CreationDate="2014-03-07T12:29:32.300" UserId="136" Text="What overheads and other considerations are there when using a struct vs an object?" />
  <row Id="1811" PostHistoryTypeId="3" PostId="658" RevisionGUID="850250a9-58c7-4de8-b7fa-7af6a2eb3919" CreationDate="2014-03-07T12:29:32.300" UserId="136" Text="&lt;programming&gt;&lt;struct&gt;&lt;class&gt;" />
  <row Id="1812" PostHistoryTypeId="5" PostId="658" RevisionGUID="d0327dce-c951-4468-b0dc-d13015dcdbb7" CreationDate="2014-03-07T12:47:53.620" UserId="136" Comment="Incorrect syntax" Text="C on embedded systems has traditionally use structs to hold structured data.&#xD;&#xA;&#xD;&#xA;Arduino brings C++ to the table, so we can use objects instead.&#xD;&#xA;&#xD;&#xA;Lets say we have two different data structures which could be considered very similar:&#xD;&#xA;&#xD;&#xA;    typedef struct &#xD;&#xA;    {&#xD;&#xA;    	int valueOne;&#xD;&#xA;    	int valueTwo;&#xD;&#xA;    	int valueThree;&#xD;&#xA;    } value_t;&#xD;&#xA;&#xD;&#xA;and:&#xD;&#xA;&#xD;&#xA;    class Value&#xD;&#xA;    {&#xD;&#xA;    	public:&#xD;&#xA;    		int valueOne;&#xD;&#xA;    		int valueTwo;&#xD;&#xA;    		int valueThree;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;In terms of memory, what difference will this make? &#xD;&#xA;&#xD;&#xA;I still see the struct technique being used heavily - why is this?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1813" PostHistoryTypeId="2" PostId="659" RevisionGUID="68588594-8018-420d-8804-9de2f3b29ba8" CreationDate="2014-03-07T14:14:23.803" UserId="65" Text="[Microsmooth][1] is a lighweight signal smoothing library currently being developed by me.&#xD;&#xA;&#xD;&#xA;It is still being worked on and the aim is to make it lightweight in terms of memory and fast. The library provides multiple filters for smoothing:&#xD;&#xA;&#xD;&#xA;- Simple Moving Average&#xD;&#xA;- Exponential Moving Average&#xD;&#xA;- Cumulative Moving Average&#xD;&#xA;- Savitzky Golay Filter&#xD;&#xA;- Ramer Douglas Pecker Algorithm&#xD;&#xA;- Kalmogorov Zurbenko Filter&#xD;&#xA;&#xD;&#xA;To use the library, download and add it to the source directory. Also, add the following line to your source file:&#xD;&#xA;&#xD;&#xA;    #include &quot;microsmooth.h&quot;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/AsheeshR/Microsmooth" />
  <row Id="1814" PostHistoryTypeId="2" PostId="660" RevisionGUID="9fa6f3b1-4c6f-4874-a44b-e383c0c71678" CreationDate="2014-03-07T14:16:18.497" UserId="517" Text="I wrote a simple program that used all six analog pins as digital outputs, and wired up an LED. All of the pins except A2 would blink the LED. So yes, it is fried.  Thanks." />
  <row Id="1815" PostHistoryTypeId="2" PostId="661" RevisionGUID="3c314fc1-6a87-4e0f-96b3-37d77359512a" CreationDate="2014-03-07T14:21:28.740" UserId="213" Text="There is also the higher-end Akafugu breadboard power supply - takes in put from 7V all the way to 35V, but costs 11$ apiece in the bargain.&#xD;&#xA;&#xD;&#xA;[Akafugu][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://store.akafugu.jp/products/30" />
  <row Id="1816" PostHistoryTypeId="2" PostId="662" RevisionGUID="48e79fc6-da69-4dae-b7c6-2cd1d7f6f5c4" CreationDate="2014-03-07T14:41:46.277" UserId="359" Text="as taken from the accepted answer from [When should you use a class vs a struct in C++?][1]&#xD;&#xA;&#xD;&#xA;&gt; The only difference between a class and a struct in C++ is that&#xD;&#xA;&gt; structs have default public members and bases and classes have default&#xD;&#xA;&gt; private members and bases. Both classes and structs can have a mixture&#xD;&#xA;&gt; of public and private members, can use inheritance, and can have&#xD;&#xA;&gt; member functions.&#xD;&#xA;&gt; &#xD;&#xA;&gt; I would recommend using structs as plain-old-data structures without&#xD;&#xA;&gt; any class-like features, and using classes as aggregate data&#xD;&#xA;&gt; structures with private data and member functions.&#xD;&#xA;&#xD;&#xA;memory wise the access modifier makes no difference&#xD;&#xA;&#xD;&#xA;given the memory constraints of the arduino people are less likely to classes with complex hierarchies and prefer the POD structs&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/a/54596/731620" />
  <row Id="1817" PostHistoryTypeId="2" PostId="663" RevisionGUID="8df89a07-71b8-4f07-ae19-34ab96d07c2e" CreationDate="2014-03-07T14:53:45.960" UserId="42" Text="Unlike C, an instance of a `struct` in C++ is an object in exactly the same way as an instance of a `class`. From the point-of-view of the compiled code, they are identical. Memory usage, alignment, access times etc. are exactly the same.&#xD;&#xA;&#xD;&#xA;From the programmer's point-of-view, there is a very minor difference. Members of a `struct` have public visibility by default, whereas members of a `class` have private visibility by default. Otherwise, all language features work the same on both, such as constructors/destructors, inheritance, polymorphism, templates, and operator overloading. You can even derive a `struct` from a `class`, and vice versa.&#xD;&#xA;&#xD;&#xA;Despite the similarity, it's quite common to see people deliberately using a `struct` in C++ for very simple structures, e.g. where it only consists of a few data members, but no functions. A `class` would be used for anything more complex. This is purely a matter of convention or personal preference though, and can be used as a subtle indication of the structure's intended complexity." />
  <row Id="1819" PostHistoryTypeId="5" PostId="663" RevisionGUID="90cc41b7-c5cc-412b-a292-86719b4cb595" CreationDate="2014-03-07T15:26:19.540" UserId="42" Comment="added 30 characters in body" Text="Unlike C, an instance of a `struct` in C++ is an object in exactly the same way as an instance of a `class`. From the point-of-view of the compiled code, they are identical. Memory usage, alignment, access times etc. are exactly the same (i.e. there are no overheads).&#xD;&#xA;&#xD;&#xA;From the programmer's point-of-view, there is a very minor difference. Members of a `struct` have public visibility by default, whereas members of a `class` have private visibility by default. Otherwise, all language features work the same on both, such as constructors/destructors, inheritance, polymorphism, templates, and operator overloading. You can even derive a `struct` from a `class`, and vice versa.&#xD;&#xA;&#xD;&#xA;Despite the similarity, it's quite common to see people deliberately using a `struct` in C++ for very simple structures, e.g. where it only consists of a few data members, but no functions. A `class` would be used for anything more complex. This is purely a matter of convention or personal preference though, and can be used as a subtle indication of the structure's intended complexity." />
  <row Id="1820" PostHistoryTypeId="2" PostId="664" RevisionGUID="22ba8a12-3adc-4a7b-bb89-083ec34b7024" CreationDate="2014-03-07T15:29:42.223" UserId="353" Text="As other answers have pointed out, your particular `struct` and `class` are indistinguishable performance wise (There are slight differences in the scopes of the type names, due to the way you defined your struct). The delineation in C++ is not between `struct` and `class`, but between types that are *POD (plain old data)* and types that are not, as explained in [this discussion](http://stackoverflow.com/questions/146452/what-are-pod-types-in-c)." />
  <row Id="1821" PostHistoryTypeId="5" PostId="661" RevisionGUID="0dab81db-6e67-45e9-b331-5c3c62a67394" CreationDate="2014-03-07T16:05:30.093" UserId="213" Comment="spelling mistake" Text="There is also the higher-end Akafugu breadboard power supply - takes input from 7V all the way to 35V, but costs 11$ apiece in the bargain.&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;[Akafugu][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/IB0rt.jpg&#xD;&#xA;  [2]: http://store.akafugu.jp/products/30" />
  <row Id="1822" PostHistoryTypeId="6" PostId="658" RevisionGUID="abc029f7-421f-4da9-9ea7-2ba60bb61710" CreationDate="2014-03-07T16:13:26.357" UserId="525" Comment="add C++ tag" Text="&lt;programming&gt;&lt;c++&gt;&lt;struct&gt;&lt;class&gt;" />
  <row Id="1823" PostHistoryTypeId="24" PostId="658" RevisionGUID="abc029f7-421f-4da9-9ea7-2ba60bb61710" CreationDate="2014-03-07T16:13:26.357" Comment="Proposed by 525 approved by 65, 136 edit id of 217" />
  <row Id="1824" PostHistoryTypeId="2" PostId="665" RevisionGUID="8a4048f7-d1f5-4267-a39f-0422c7f3f7ff" CreationDate="2014-03-07T16:13:28.637" UserId="213" Text="Clearly, an Arduino can be powered with solar panels.  But what is the most optimal configuration? Can you recharge and discharge at the same time?  Is LiPO the best battery cache technology, or is there something more durable out there, for fielded deployment?  What are the most economic, and reliable ways to do this? &#xD;&#xA;" />
  <row Id="1825" PostHistoryTypeId="1" PostId="665" RevisionGUID="8a4048f7-d1f5-4267-a39f-0422c7f3f7ff" CreationDate="2014-03-07T16:13:28.637" UserId="213" Text="Powering Arduino with Solar Panels" />
  <row Id="1826" PostHistoryTypeId="3" PostId="665" RevisionGUID="8a4048f7-d1f5-4267-a39f-0422c7f3f7ff" CreationDate="2014-03-07T16:13:28.637" UserId="213" Text="&lt;power&gt;" />
  <row Id="1827" PostHistoryTypeId="5" PostId="665" RevisionGUID="ed344e4a-eb3c-4e25-9b98-82cd881d222b" CreationDate="2014-03-07T16:16:32.170" UserId="65" Comment="added 10 characters in body" Text="Clearly, an Arduino can be powered with solar panels. &#xD;&#xA;&#xD;&#xA;- What is the most optimal configuration? &#xD;&#xA;- Can you recharge and discharge at the same time?&#xD;&#xA;- Is LiPO the best battery cache technology, or is there something more durable out there, for fielded deployment? &#xD;&#xA;- What are the most economic, and reliable ways to do this? &#xD;&#xA;" />
  <row Id="1828" PostHistoryTypeId="2" PostId="666" RevisionGUID="2add09ff-45a4-49e6-887f-54b1f87d407b" CreationDate="2014-03-07T18:00:57.130" UserId="83" Text="How about only storing the difference from the previous value? In electronics there is a similar concept called Delta Sigma converter, which is used for DA/AD converters. It relies on the fact that the previous measurement is reasonably near the current one." />
  <row Id="1831" PostHistoryTypeId="2" PostId="667" RevisionGUID="d975c520-8082-4a32-a311-1511e1061d58" CreationDate="2014-03-07T22:13:32.720" UserId="220" Text="**First of all you want to buy some solar panels or cells.** Although they can be found on eBay for very cheap, but they not be as efficient as they say. I would say try to buy from a reputable dealer to see reviews on the product or trust that they work efficiently. Sparkfun datasheets are generally accurate and can be trusted.&#xD;&#xA;&#xD;&#xA; - Most optimal configuration: **Do not use a regulator and some sort of step-up booster.** Try the TPS61200 or TPS61202 chips. They will not *regulate* the voltage, they *boost* the voltage dynamically. This is much more efficient and therefore generates less heat. They work like a reverse voltage regulator, taking .3V to 5.5V and turning it into anywhere from 1.8V to 5V (xxx0) or 5V exactly (xxx2). Hack a USB B end and just connect the power lines to the Arduino.&#xD;&#xA; - Discharge/charge simultaneously: Yes, however I'm not sure how to. I believe that if you hook up a charger IC and a load, the voltage won't go through the battery, it will go through the path of least resistance. However, your battery wouldn't get charged then. This is outside the scope of the question, so I would recommend EE on how exactly to do this.&#xD;&#xA; - Is LiPO the best: **Try a Lithium-Ion Battery.** (A.K.A. Li-ion) According to [this site](http://www.androidauthority.com/lithium-ion-vs-lithium-polymer-whats-the-difference-27608/):&#xD;&#xA;&gt; Although the lithium-polymer battery is sleeker and thinner, lithium-ion batteries have a higher energy density and cost less to manufacture.&#xD;&#xA;&#xD;&#xA; Therefore, it seems like Li-ion is the best choice for you. **Note: Since you are dealing with very dense batteries that [if overvolted can go up into flames [Note: please mute your speakers!]](https://www.youtube.com/watch?v=SMy2_qNO2Y0&amp;feature=youtu.be&amp;t=2m), make *sure* to go with Sparkfun/Adafruit/etc...**&#xD;&#xA;&#xD;&#xA; - Economic way: If you don't mind a big &quot;homemade&quot; solar panel, go this way. Buy through eBay or a similar site solar *cells*. They are small plates that are connected to create a solar panel. Try looking for &quot;grade B&quot; or similar solar cells that work fine, they just may have minor imperfections. It won't be as pretty, but you'll save some cash.&#xD;&#xA;&#xD;&#xA;See [this EE.SE post for more information](http://electronics.stackexchange.com/questions/85757/how-do-i-go-about-building-a-charger-circuit). One cool thing that I saw was:&#xD;&#xA;&gt; This is really cool. You can connect the Li-Ion voltage through an op-amp to generate a pulse wave, which can be picked up by your MPU to tell your bot to go charge –  Raaj Oct 18 '13 at 18:44&#xD;&#xA;&#xD;&#xA;I'm not exactly sure how to do this, but it might be useful. I couldn't find anything online about it." />
  <row Id="1832" PostHistoryTypeId="34" PostId="451" RevisionGUID="8465d4e0-7ca0-49bb-a887-2c2eca0ada45" CreationDate="2014-03-08T00:03:29.247" UserId="-1" Comment="2" />
  <row Id="1833" PostHistoryTypeId="15" PostId="451" RevisionGUID="f3936edd-7709-4479-99b4-904bd416bcb7" CreationDate="2014-03-08T00:03:29.247" UserId="-1" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:-1,&quot;DisplayName&quot;:&quot;Community&quot;}]}" />
  <row Id="1834" PostHistoryTypeId="2" PostId="668" RevisionGUID="0cf226bc-c5bc-4260-91d9-ecfaefae8627" CreationDate="2014-03-08T01:31:24.920" UserId="530" Text="![Arduino Robotics : Circuit Example][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/5TXBA.png&#xD;&#xA;&#xD;&#xA;I'm new to Arduino and consequently, to circuits. I've been reading Arduino Robotics by Warren and this was a circuit present in the book.&#xD;&#xA;&#xD;&#xA;From what Warren has said, electricity in the circuit travels from the negative pole to the positive, BUT to imagine it as going the other way for simplicity. So, looking at this circuit... it seems useless to have the resistor placed after the LED, based on the + --&gt; - model. Wouldn't the LED turn on before going through the resistor, rendering the resistor useless?&#xD;&#xA;&#xD;&#xA;Sorry if this seems like a basic concept, I'm entirely new to this." />
  <row Id="1835" PostHistoryTypeId="1" PostId="668" RevisionGUID="0cf226bc-c5bc-4260-91d9-ecfaefae8627" CreationDate="2014-03-08T01:31:24.920" UserId="530" Text="Circuit diagram interpretation and electrical flow" />
  <row Id="1836" PostHistoryTypeId="3" PostId="668" RevisionGUID="0cf226bc-c5bc-4260-91d9-ecfaefae8627" CreationDate="2014-03-08T01:31:24.920" UserId="530" Text="&lt;arduino-uno&gt;&lt;performance&gt;&lt;build&gt;&lt;system-design&gt;" />
  <row Id="1837" PostHistoryTypeId="2" PostId="669" RevisionGUID="83e451b2-846a-4775-82b6-09dc25666944" CreationDate="2014-03-08T01:33:29.813" UserId="358" Text="Why couldn't you just add the values together as soon as you obtain them. So what I mean is you get the value for day 1, you divide it by 1 and store it and the 1 somewhere. Then you multiply the 1 by the value and add it to the next value and divide them both by 2.&#xD;&#xA;&#xD;&#xA;Doing this method would create a rolling average with two or three variable as I can think of. I would write some code but I am new to stackexchange so please bear with me." />
  <row Id="1838" PostHistoryTypeId="2" PostId="670" RevisionGUID="0107e300-5117-4fc7-b9ae-27695cba6636" CreationDate="2014-03-08T01:54:18.197" UserId="225" Text="**Should the Resistor be Placed Before or After the LED?**&#xD;&#xA;&#xD;&#xA;The important thing to remember is that the direct current electricity must flow *through* the circuit to be useful. Since the resistor is part of the circuit (meaning that there isn't another path for the current to take) it resists the overall flow, thereby helping to protect the LED. Whether before or after the LED, it would still be in the circuit, and would therefore still reduce current flow.&#xD;&#xA;&#xD;&#xA;**Visualizing the Flow of Water**&#xD;&#xA;&#xD;&#xA;Think of it like a water hose, where the LED is a flow meter and the resistor is your foot. If you step on the hose before the flow meter it will cause the overall flow to slow down. Stepping on the hose after the flow meter but before the nozzle will have the same result, as the water must pass through the entire length of the hose before being released." />
  <row Id="1839" PostHistoryTypeId="2" PostId="671" RevisionGUID="abd1f6a3-1c54-404e-af24-a2e37422e092" CreationDate="2014-03-08T02:13:19.160" UserId="42" Text="As you've probably seen in the book already, the resistor is there to limit the current flowing in the circuit. Without it, the LED will happily try to draw too much current, and it could end up burning itself out.&#xD;&#xA;&#xD;&#xA;The important thing to remember with electrical flow is that you have to look at the circuit as a whole. The electricity doesn't flow at maximum possible current into the LED and then just drop down when it hits the resistor. That would be impossible, because the electricity always has to go somewhere.&#xD;&#xA;&#xD;&#xA;For a simple series circuit like this (where it doesn't branch off anywhere), the same current flows through all components throughout the entire circuit. The level of current is determined by the supply voltage and the total resistance, according to Ohm's law (I = V/R)." />
  <row Id="1840" PostHistoryTypeId="2" PostId="672" RevisionGUID="5f907ad2-b7bd-4e75-9176-f82e7bb529a2" CreationDate="2014-03-08T04:04:14.447" UserId="533" Text="Duplicate of [this question](http://electronics.stackexchange.com/q/102224/38392)&#xD;&#xA;&#xD;&#xA;I'm trying to drive an 8x8 LED matrix with an arduino nano, but I can't get the LEDs to display what I tell it to.&#xD;&#xA;&#xD;&#xA;I'm using [this](http://www.aliexpress.com/store/product/Free-shipping-10-pcs-8-8-3-75MM-Red-16P-dot-matrix-module-Dimensions-38-38/605870_879542981.html) LED Matrix&#xD;&#xA;&#xD;&#xA;Here's my code:&#xD;&#xA;&#xD;&#xA;&lt;!-- language-all: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;    int row1 = 2;&#xD;&#xA;    int row2 = 3;&#xD;&#xA;    int row3 = 4;&#xD;&#xA;    int row4 = 5;&#xD;&#xA;    int row5 = 6;&#xD;&#xA;    int row6 = 7;&#xD;&#xA;    int row7 = 8;&#xD;&#xA;    int row8 = 9;&#xD;&#xA;    &#xD;&#xA;    int col1 = 10;&#xD;&#xA;    int col2 = 11;&#xD;&#xA;    int col3 = 12;&#xD;&#xA;    int col4 = 18;&#xD;&#xA;    int col5 = 14;&#xD;&#xA;    int col6 = 15;&#xD;&#xA;    int col7 = 16;&#xD;&#xA;    int col8 = 17;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      int i;&#xD;&#xA;      for(i = 2; i &lt;= 18; i++) {&#xD;&#xA;        pinMode(i,OUTPUT);&#xD;&#xA;      }&#xD;&#xA;      for(i = 2; i &lt;= 9; i++) {&#xD;&#xA;        digitalWrite(i, HIGH);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;&#xD;&#xA;      int display [8][8] = {&#xD;&#xA;      {1,0,0,0,0,0,0,0},&#xD;&#xA;      {0,1,0,0,0,0,0,0},&#xD;&#xA;      {0,0,1,0,0,0,0,0},&#xD;&#xA;      {0,0,0,1,0,0,0,0},&#xD;&#xA;      {0,0,0,0,1,0,0,0},&#xD;&#xA;      {0,0,0,0,0,1,0,0},&#xD;&#xA;      {0,0,0,0,0,0,1,0},&#xD;&#xA;      {0,0,0,0,0,0,0,1}&#xD;&#xA;      };&#xD;&#xA;      &#xD;&#xA;      updateScreen(display);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void updateScreen(int screen[8][8]) {&#xD;&#xA;      &#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      int i;&#xD;&#xA;      for (i = row1; i &lt;= row8; i++) {&#xD;&#xA;        Serial.println(i-1); &#xD;&#xA;        digitalWrite(i, LOW);&#xD;&#xA;          digitalWrite(col8, screen[i-2][0]);&#xD;&#xA;          Serial.print(screen[i-2][0]); Serial.print(&quot;|&quot;); &#xD;&#xA;          digitalWrite(col7, screen[i-2][1]);&#xD;&#xA;          Serial.print(screen[i-2][1]); Serial.print(&quot;|&quot;); &#xD;&#xA;          digitalWrite(col6, screen[i-2][2]);&#xD;&#xA;          Serial.print(screen[i-2][2]); Serial.print(&quot;|&quot;); &#xD;&#xA;          digitalWrite(col5, screen[i-2][3]);&#xD;&#xA;          Serial.print(screen[i-2][3]); Serial.print(&quot;|&quot;); &#xD;&#xA;          digitalWrite(col4, screen[i-2][4]);&#xD;&#xA;          Serial.print(screen[i-2][4]); Serial.print(&quot;|&quot;); &#xD;&#xA;          digitalWrite(col3, screen[i-2][5]);&#xD;&#xA;          Serial.print(screen[i-2][5]); Serial.print(&quot;|&quot;); &#xD;&#xA;          digitalWrite(col2, screen[i-2][6]);&#xD;&#xA;          Serial.print(screen[i-2][6]); Serial.print(&quot;|&quot;); &#xD;&#xA;          digitalWrite(col1, screen[i-2][7]);&#xD;&#xA;          Serial.println(screen[i-2][7]);&#xD;&#xA;          delay(1);&#xD;&#xA;          blank();&#xD;&#xA;        digitalWrite(i, HIGH);&#xD;&#xA;      }&#xD;&#xA;        &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void blank() {&#xD;&#xA;      digitalWrite(col1, LOW);&#xD;&#xA;      digitalWrite(col2, LOW);&#xD;&#xA;      digitalWrite(col3, LOW);&#xD;&#xA;      digitalWrite(col4, LOW);&#xD;&#xA;      digitalWrite(col5, LOW);&#xD;&#xA;      digitalWrite(col6, LOW);&#xD;&#xA;      digitalWrite(col7, LOW);&#xD;&#xA;      digitalWrite(col8, LOW);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;And here is the output:&#xD;&#xA;&#xD;&#xA;    1 &#xD;&#xA;    1|0|0|0|0|0|0|0 &#xD;&#xA;    2 &#xD;&#xA;    0|1|0|0|0|0|0|0 &#xD;&#xA;    3 &#xD;&#xA;    0|0|1|0|0|0|0|0 &#xD;&#xA;    4 &#xD;&#xA;    0|0|0|1|0|0|0|0 &#xD;&#xA;    5 &#xD;&#xA;    0|0|0|0|1|0|0¾j &#xD;&#xA;    6 &#xD;&#xA;    0|0|0|0|0|1|0|0 &#xD;&#xA;    7 &#xD;&#xA;    0|0|0|0|0|0|1|0 &#xD;&#xA;    8 &#xD;&#xA;    0|0|0|0|0|0|0|1&#xD;&#xA;&#xD;&#xA;So I can tell that the error (probably) isn't my wiring, because those array values are clearly wrong, I have no idea where the `¾j` is coming from." />
  <row Id="1841" PostHistoryTypeId="1" PostId="672" RevisionGUID="5f907ad2-b7bd-4e75-9176-f82e7bb529a2" CreationDate="2014-03-08T04:04:14.447" UserId="533" Text="Arduino LED matrix and 2D array, data seems to be corrupting" />
  <row Id="1842" PostHistoryTypeId="3" PostId="672" RevisionGUID="5f907ad2-b7bd-4e75-9176-f82e7bb529a2" CreationDate="2014-03-08T04:04:14.447" UserId="533" Text="&lt;led&gt;" />
  <row Id="1843" PostHistoryTypeId="5" PostId="665" RevisionGUID="5641cf1f-e5ee-4080-80e0-c9ee041cb687" CreationDate="2014-03-08T04:20:50.233" UserId="387" Comment="Formatting" Text="Clearly, an Arduino can be powered with solar panels. &#xD;&#xA;&#xD;&#xA; 1. What is the most optimal configuration? &#xD;&#xA; 2. Can you recharge and discharge at the same time?&#xD;&#xA; 3. Is LiPO the best battery cache technology, or is there something more durable out there, for fielded deployment?&#xD;&#xA; 4. What are the most economic, and reliable ways to do this? &#xD;&#xA;" />
  <row Id="1844" PostHistoryTypeId="24" PostId="665" RevisionGUID="5641cf1f-e5ee-4080-80e0-c9ee041cb687" CreationDate="2014-03-08T04:20:50.233" Comment="Proposed by 387 approved by 11 edit id of 218" />
  <row Id="1845" PostHistoryTypeId="6" PostId="672" RevisionGUID="1bffc4f8-ed4d-47cb-9ab1-28c99e28941d" CreationDate="2014-03-08T04:25:18.767" UserId="65" Comment="edited tags" Text="&lt;programming&gt;&lt;led&gt;&lt;arduino-nano&gt;" />
  <row Id="1846" PostHistoryTypeId="2" PostId="673" RevisionGUID="e23087b9-c8fa-4ea5-b902-d0741f2cd6b8" CreationDate="2014-03-08T04:39:56.710" UserId="65" Text="Your initial problem can be sorted out by using a longer `delay`. &#xD;&#xA;&#xD;&#xA;    void updateScreen(int screen[8][8]) {&#xD;&#xA;    &#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      int i;&#xD;&#xA;      ........&#xD;&#xA;          delay(100); //Longer time duration&#xD;&#xA;          blank();&#xD;&#xA;        digitalWrite(i, HIGH);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;As far as the chess pattern is concerned, it displays correctly for me.&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;    &#xD;&#xA;      int display [8][8] = {&#xD;&#xA;      {1,0,1,0,1,0,1,0},&#xD;&#xA;      {0,1,0,1,0,1,0,1},&#xD;&#xA;      {1,0,1,0,1,0,1,0},&#xD;&#xA;      {0,1,0,1,0,1,0,1},&#xD;&#xA;      {1,0,1,0,1,0,1,0},&#xD;&#xA;      {0,1,0,1,0,1,0,1},&#xD;&#xA;      {1,0,1,0,1,0,1,0},&#xD;&#xA;      {0,1,0,1,0,1,0,1}&#xD;&#xA;      };&#xD;&#xA;    &#xD;&#xA;      updateScreen(display);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Check your array declarations for errors." />
  <row Id="1847" PostHistoryTypeId="5" PostId="653" RevisionGUID="674d36fc-16fa-4ac4-bafd-af94a0e9919c" CreationDate="2014-03-08T06:41:13.103" UserId="136" Comment="clarified question as a few answers missed the window." Text="Currently I am developing a graphic LCD system to display temperatures, flows, voltages, power and energy in a heat pump system. The use of a graphic LCD means that half of my SRAM and ~75% of my flash have been used up by a screen buffer and strings.&#xD;&#xA;&#xD;&#xA;I am currently displaying min/max/average figures for energy At midnight when the daily figure resets, the system checks if the consumption for the day is above or below the previous minimum or maximum, and stores the value. The average is calculated by dividing the cumulative energy consumption by the number of days.&#xD;&#xA;&#xD;&#xA;I would like to display the daily average over the last week and month (4 weeks for simplicity) i.e. a rolling average. Currently this involves maintaining an array of values for the last 28 days and calculating an average over the whole array for monthly and last 7 days for weekly.&#xD;&#xA;&#xD;&#xA;Initially I was doing this using an array of floats (as the energy is in the form &quot;12.12kWh&quot;), but this was using 28 * 4 bytes = 112 bytes (5.4% of SRAM). I don't mind having only a single decimal point of resolution, so I changed to using uint16_t and multiplying the figure by 100. This means that 12.12 is represented as 1212, and I divide by 100 for display purposes.&#xD;&#xA;&#xD;&#xA;The size of the array is now down to 56 bytes (much better!).&#xD;&#xA;&#xD;&#xA;There is no trivial way to reduce the figure down to a uint8_t that I can see. I could tolerate the loss of a decimal place (&quot;12.1kWh&quot; instead of &quot;12.12kWh&quot;), but consumption is frequently higher than 25.5kWh (255 being the highest value represented by a 8-bit unsigned integer). Consumption has never been below 10.0kWh or above 35.0kWh, so conceivably I could subtract 10 from the stored figures, but I know that one day we will exceed these limits.&#xD;&#xA;&#xD;&#xA;I then tested code to pack 9-bit values into an array. This gives a range of 0-51.2kWh and uses 32 bytes in total. However, accessing an array like this is pretty slow, especially when you have to iterate over all values to calculate an average.&#xD;&#xA;&#xD;&#xA;So my question is - is there a more efficient way of calculating a moving average with three windows - lifetime, 28 days and 7 days? Efficiency means smaller in terms of SRAM usage, but without the penalty of huge code. Can I avoid storing all values?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1848" PostHistoryTypeId="6" PostId="488" RevisionGUID="1489b04d-dfc4-4d78-84ca-0ef2089337f0" CreationDate="2014-03-08T07:25:51.390" UserId="65" Comment="edited tags" Text="&lt;sensors&gt;&lt;system-design&gt;" />
  <row Id="1849" PostHistoryTypeId="6" PostId="668" RevisionGUID="cf0babb6-939c-4f1e-b1a1-e67c362e833e" CreationDate="2014-03-08T08:57:08.193" UserId="84" Comment="Better tags for this question (not actually related to uno, build...)" Text="&lt;electricity&gt;&lt;current-flow&gt;" />
  <row Id="1850" PostHistoryTypeId="24" PostId="668" RevisionGUID="cf0babb6-939c-4f1e-b1a1-e67c362e833e" CreationDate="2014-03-08T08:57:08.193" Comment="Proposed by 84 approved by 65, 136 edit id of 219" />
  <row Id="1851" PostHistoryTypeId="5" PostId="246" RevisionGUID="169518f0-6e6c-4d68-85b4-0a08d47e8aef" CreationDate="2014-03-08T11:54:29.480" UserId="65" Comment="Removed second graph; Seems unnecessary" Text="I am working on a mobile robot controlled via a wireless 2.4 GHz link.The receiver is connected to the Arduino Uno which serves onboard as the main controller. The most critical (and main) input channel coming from the receiver produces a very noisy signal, which leads to lots of minor changes in the output of the actuators, even though these are not needed.&#xD;&#xA;&#xD;&#xA;*&lt;pre&gt;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;                    Plot of the input of the Arduino in a 30 second interval.&lt;/pre&gt;*&#xD;&#xA;&#xD;&#xA;I am looking for libraries that can perform efficient smoothing. Are there any signal smoothing libraries available for the Arduino (Uno)?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/Z1yB0.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/6tnNC.png" />
  <row Id="1852" PostHistoryTypeId="2" PostId="674" RevisionGUID="8edfc1ef-fd60-4679-b372-7f4abaa8a2a6" CreationDate="2014-03-08T13:16:43.187" UserId="65" Text="&gt;[The Space Replay][1]&#xD;&#xA;&#xD;&#xA;&gt; A hovering object that explores and manipulates transitional public&#xD;&#xA;&gt; spaces with particular acoustic properties. By constantly recording&#xD;&#xA;&gt; and replaying these ambient sounds, the levitating sphere produces a&#xD;&#xA;&gt; delayed echo of human activity.&#xD;&#xA;&#xD;&#xA;&gt; ![](http://blog.arduino.cc/wp-content/uploads/2014/03/replay.jpg)&#xD;&#xA;&#xD;&#xA;In this project, the Arduino board and an [Adafruit Wave Shield][2] is used. The Wave shield is not designed to record audio, but is for playback. However, here, they say that they use the board for both *recording* and playback. &#xD;&#xA;&#xD;&#xA;Is this possible? (rhetorical) How would this be done?&#xD;&#xA;&#xD;&#xA;Would there be a better way to design this?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://ied.rca.ac.uk/de-computation/space-replay&#xD;&#xA;  [2]: https://www.adafruit.com/products/94" />
  <row Id="1853" PostHistoryTypeId="1" PostId="674" RevisionGUID="8edfc1ef-fd60-4679-b372-7f4abaa8a2a6" CreationDate="2014-03-08T13:16:43.187" UserId="65" Text="How does the Space Replay record audio?" />
  <row Id="1854" PostHistoryTypeId="3" PostId="674" RevisionGUID="8edfc1ef-fd60-4679-b372-7f4abaa8a2a6" CreationDate="2014-03-08T13:16:43.187" UserId="65" Text="&lt;sensors&gt;&lt;shields&gt;&lt;system-design&gt;&lt;project-critique&gt;" />
  <row Id="1855" PostHistoryTypeId="2" PostId="675" RevisionGUID="d8b4d1d3-57e7-484c-a96c-542f461338a2" CreationDate="2014-03-08T15:02:20.803" UserId="37" Text="Because of my psychic abilities*, I am able to tell that you actually used `.` in a few places you should have used `,` in your array initialization. Replacing the `,`s with `.`s should fix the problem.&#xD;&#xA;&#xD;&#xA;&lt;sup&gt;&lt;sup&gt;*[Okay, okay, not really.][1]&lt;/sup&gt;&lt;/sup&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/questions/672/arduino-led-matrix-and-2d-array-data-seems-to-be-corrupting#comment1193_672" />
  <row Id="1856" PostHistoryTypeId="2" PostId="676" RevisionGUID="6fa6c552-1f28-43fd-9742-5b167a482e98" CreationDate="2014-03-08T15:36:21.713" UserId="8" Text="As jippie said, you can use the Arduinos ADC to record audio, and presumably save that to the Arduino's RAM (the SD card is probably too slow for directly saving it). Then it writes the buffer to the SD card." />
  <row Id="1857" PostHistoryTypeId="2" PostId="677" RevisionGUID="e74cc0df-a747-4209-b74c-57d2d92cd2fa" CreationDate="2014-03-08T17:59:14.100" UserId="514" Text="Turns out the problem was that timer 0 and 2 on the arduino uno are 8 bit. Set a different prescaler and I'm golden&#xD;&#xA;&#xD;&#xA;    // set up Timer 2&#xD;&#xA;        TCCR2A = 0;  // normal mode&#xD;&#xA;        TCCR2B = 0;&#xD;&#xA;        //  TCCR2A = bit(WGM21) | bit(CS21);  // CTC, scale to clock / 8&#xD;&#xA;        TCCR2A = (1 &lt;&lt; WGM21); //Enables CTC for timer &#xD;&#xA;        &#xD;&#xA;        TCCR2B |= (1 &lt;&lt; CS21); &#xD;&#xA;        TCCR2B |= (1 &lt;&lt; CS22); //Sets 256 bit prescaler&#xD;&#xA;        TCCR2B |= (0 &lt;&lt; CS20); &#xD;&#xA;        OCR2A = groundtime;    // time before rising edge&#xD;&#xA;        TIMSK2 = (1 &lt;&lt; OCIE2A);&#xD;&#xA;        //Cancel Rising Interrupt on D3&#xD;&#xA;        EIFR = bit (INTF1); &#xD;&#xA;        //Reinables interrupts" />
  <row Id="1858" PostHistoryTypeId="36" PostId="678" RevisionGUID="448bddda-cbbe-48da-9b77-d722a2f03d12" CreationDate="2014-03-08T18:28:04.423" UserId="-1" Comment="from http://stackoverflow.com/questions/22128011/connecting-something-big-to-an-arduino-sending-more-than-5v" />
  <row Id="1859" PostHistoryTypeId="2" PostId="679" RevisionGUID="2a478431-d68a-4113-a266-fcab1d8bd8cd" CreationDate="2014-03-02T15:21:59.200" UserDisplayName="Steve Barnes" Text="Use a transistor, amplifier, opto-isolator or if you can drive a 5V relay use that relay to drive a higher voltage/current item item." />
  <row Id="1860" PostHistoryTypeId="2" PostId="678" RevisionGUID="e6c0bffd-c0f0-4b45-9ef3-22a86b80164b" CreationDate="2014-03-02T13:13:16.097" UserId="539" UserDisplayName="user3343579" Text="So I am turning a relay on and off with my Arduino. I am using python to control it but wrote the simple basic code in the Arduino IDE. I am able to send 5 or 0 volts to the pin. My question is, how can I turn something on and off that requires more than 5 volts to turn on?&#xD;&#xA;&#xD;&#xA;Thank you. " />
  <row Id="1861" PostHistoryTypeId="1" PostId="678" RevisionGUID="e6c0bffd-c0f0-4b45-9ef3-22a86b80164b" CreationDate="2014-03-02T13:13:16.097" UserId="539" UserDisplayName="user3343579" Text="Connecting Something Big to an Arduino - Sending more than 5V" />
  <row Id="1862" PostHistoryTypeId="3" PostId="678" RevisionGUID="e6c0bffd-c0f0-4b45-9ef3-22a86b80164b" CreationDate="2014-03-02T13:13:16.097" UserId="539" UserDisplayName="user3343579" Text="&lt;python&gt;" />
  <row Id="1863" PostHistoryTypeId="36" PostId="679" RevisionGUID="71dfdf73-2e83-482d-a84c-a1958790af52" CreationDate="2014-03-08T18:28:04.423" UserId="-1" Comment="from http://stackoverflow.com/questions/22128011/connecting-something-big-to-an-arduino-sending-more-than-5v/22129442#22129442" />
  <row Id="1867" PostHistoryTypeId="10" PostId="678" RevisionGUID="80ef5a0a-a6b7-48e9-8e14-29e50a029bfb" CreationDate="2014-03-09T05:28:26.683" UserId="11" Comment="101" Text="{&quot;OriginalQuestionIds&quot;:[403],&quot;Voters&quot;:[{&quot;Id&quot;:37,&quot;DisplayName&quot;:&quot;The Guy with The Hat&quot;},{&quot;Id&quot;:46,&quot;DisplayName&quot;:&quot;Ricardo&quot;},{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="1868" PostHistoryTypeId="6" PostId="678" RevisionGUID="273b2798-113e-4819-968c-ae719b054802" CreationDate="2014-03-09T05:30:15.857" UserId="11" Comment="edited tags" Text="&lt;relay&gt;&lt;transistor&gt;" />
  <row Id="1870" PostHistoryTypeId="2" PostId="681" RevisionGUID="06f03bac-75d3-436d-bcec-96e853fa20ef" CreationDate="2014-03-09T05:38:12.913" UserId="11" Text="It seems to be possible to record with the shield using a library called [waverp][1]&#xD;&#xA;&#xD;&#xA;&gt; WaveRP is an Arduino library for recording and playing Wave files with&#xD;&#xA;&gt; the Adafruit Wave Shield. It records 8-bit mono files at 4,000 to&#xD;&#xA;&gt; 44,100 samples per second.&#xD;&#xA;&#xD;&#xA;Some details [adafruit blog][2]:&#xD;&#xA;&#xD;&#xA;&gt; It records 8-bit mono files at 4,000 to 44,100 samples per second.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://code.google.com/p/waverp/&#xD;&#xA;  [2]: https://www.adafruit.com/products/94" />
  <row Id="1871" PostHistoryTypeId="2" PostId="682" RevisionGUID="9f2b6030-4b1e-4bbf-b288-f7c2ab22ff68" CreationDate="2014-03-09T09:00:25.003" UserId="136" Text="The use of malloc() and free() seems pretty rare in the Arduino world. It is used in pure AVR C much more often, but still with caution.&#xD;&#xA;&#xD;&#xA;Is it a really bad idea to use malloc() and free() with Arduino?" />
  <row Id="1872" PostHistoryTypeId="1" PostId="682" RevisionGUID="9f2b6030-4b1e-4bbf-b288-f7c2ab22ff68" CreationDate="2014-03-09T09:00:25.003" UserId="136" Text="Is using malloc() and free() a really bad idea on Arduino?" />
  <row Id="1873" PostHistoryTypeId="3" PostId="682" RevisionGUID="9f2b6030-4b1e-4bbf-b288-f7c2ab22ff68" CreationDate="2014-03-09T09:00:25.003" UserId="136" Text="&lt;programming&gt;&lt;memory&gt;" />
  <row Id="1875" PostHistoryTypeId="2" PostId="683" RevisionGUID="7d687098-2828-4506-b7f5-bf88c009058d" CreationDate="2014-03-09T12:42:12.190" UserId="546" Text="Start with earthing the red (!?) wire to the ground of the arduino.&#xD;&#xA;Apply 5 volts via a 10k resistor to one of the black wires and also connect the black wire to the arduino as well.&#xD;&#xA;Basically :&#xD;&#xA;&#xD;&#xA;    5V ----(10K resistor)---+---Black wire----( Gas Meter)-----ground&#xD;&#xA;                            |                              &#xD;&#xA;                            |                             &#xD;&#xA;                            +--- arduino digital input&#xD;&#xA;&#xD;&#xA;You should either get a high or a low signal. Try the other black wire, it might be inverted (as in high and then pulse low, vs low and then pulse high).&#xD;&#xA;&#xD;&#xA;Failing that, pop the top off that cover and have a poke around. Might give you a clue as to what's what.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1876" PostHistoryTypeId="5" PostId="28" RevisionGUID="d852bd09-5c46-483a-aaa1-3745b2924096" CreationDate="2014-03-09T12:43:25.033" UserId="65" Comment="deleted 10 characters in body" Text="I have been able to connect MATLAB to my Uno with this line of code: `a = arduino('COM4');` through this package: [Matlab support package for Arduino][1].&#xD;&#xA;&#xD;&#xA;Right now, MATLAB is my main script that will synchronize all the components [like the Arduino].&#xD;&#xA;&#xD;&#xA;I am able to send pulses to my stepper-motor just by using:&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;        digitalWrite(2, HIGH);&#xD;&#xA;        delay(1);&#xD;&#xA;        digitalWrite(2, LOW);&#xD;&#xA;        delay(1);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This works fine, and will make the motor move about once every 2 milliseconds. My problem is that I cannot find a way to produce this same delay through MATLAB's interface. I do know that MATLAB has a `pause()` function, but when I set up a loop in MATLAB like this:&#xD;&#xA;&#xD;&#xA;    a = arduino('COM4');&#xD;&#xA;    for m = 1:400&#xD;&#xA;        a.digitalWrite(2, 1);&#xD;&#xA;        pause(0.001);&#xD;&#xA;        a.digitalWrite(2, 0);&#xD;&#xA;        pause(0.001);&#xD;&#xA;    end&#xD;&#xA;&#xD;&#xA;Each step takes WAY longer - about 200 milliseconds each.&#xD;&#xA;&#xD;&#xA;What are other options for creating the pause between digital High / Low being sent to the Arduino? It would be nice if I could control the outcome from Matlab, through Arduino.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.mathworks.com/matlabcentral/fileexchange/32374-matlab-support-package-for-arduino-aka-arduinoio-package" />
  <row Id="1877" PostHistoryTypeId="5" PostId="56" RevisionGUID="f3d4a694-5100-4390-bc9e-730adb4cc5c2" CreationDate="2014-03-09T12:48:53.587" UserId="65" Comment="Not specific to Uno." Text="I want to unit test my Arduino code. Ideally, I want to execute and test my code without uploading it to the board. What tools or libraries can help me with this?&#xD;&#xA;&#xD;&#xA;There is an [Arduino emulator][1] in development which could be useful, but it doesn't yet seem to be ready for use.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://radpartbrainmat.blogspot.in/search/label/arduemu" />
  <row Id="1878" PostHistoryTypeId="4" PostId="56" RevisionGUID="f3d4a694-5100-4390-bc9e-730adb4cc5c2" CreationDate="2014-03-09T12:48:53.587" UserId="65" Comment="Not specific to Uno." Text="What is the best way to unit test my code without controller?" />
  <row Id="1879" PostHistoryTypeId="6" PostId="56" RevisionGUID="f3d4a694-5100-4390-bc9e-730adb4cc5c2" CreationDate="2014-03-09T12:48:53.587" UserId="65" Comment="Not specific to Uno." Text="&lt;programming&gt;&lt;testing&gt;" />
  <row Id="1880" PostHistoryTypeId="6" PostId="168" RevisionGUID="10ccbf36-592e-44e7-8947-5701398fa25b" CreationDate="2014-03-09T12:56:54.733" UserId="65" Comment="Vague tag; Also, meta;" Text="&lt;programming&gt;&lt;arduino-ide&gt;&lt;compile&gt;" />
  <row Id="1881" PostHistoryTypeId="2" PostId="684" RevisionGUID="0f984b50-ecae-4b5f-b4e5-6440fe322fed" CreationDate="2014-03-09T13:20:04.687" UserId="-1" Text="" />
  <row Id="1882" PostHistoryTypeId="2" PostId="685" RevisionGUID="66da6a26-27ca-4d13-adba-cd54ab7ae44a" CreationDate="2014-03-09T13:20:04.687" UserId="-1" Text="" />
  <row Id="1883" PostHistoryTypeId="5" PostId="685" RevisionGUID="82d1684d-346c-4e26-85b0-980e61efc740" CreationDate="2014-03-09T13:43:31.363" UserId="65" Comment="added 221 characters in body" Text="Use this tag when you are looking for feedback, suggestions, improvements or alternatives to a specific aspect of your working project. This tag should not be used for early design questions; also see [tag:system-design]." />
  <row Id="1884" PostHistoryTypeId="24" PostId="685" RevisionGUID="82d1684d-346c-4e26-85b0-980e61efc740" CreationDate="2014-03-09T13:43:31.363" Comment="Proposed by 65 approved by 220 edit id of 220" />
  <row Id="1885" PostHistoryTypeId="5" PostId="674" RevisionGUID="eaa736e9-b2ec-41d4-96dd-ecc826cc97b3" CreationDate="2014-03-09T14:56:48.103" UserId="65" Comment="added 260 characters in body; edited tags" Text="&gt;[The Space Replay][1]&#xD;&#xA;&#xD;&#xA;&gt; A hovering object that explores and manipulates transitional public&#xD;&#xA;&gt; spaces with particular acoustic properties. By constantly recording&#xD;&#xA;&gt; and replaying these ambient sounds, the levitating sphere produces a&#xD;&#xA;&gt; delayed echo of human activity.&#xD;&#xA;&#xD;&#xA;&gt; ![](http://blog.arduino.cc/wp-content/uploads/2014/03/replay.jpg)&#xD;&#xA;&#xD;&#xA;In this project, the Arduino board and an [Adafruit Wave Shield][2] is used. The Wave shield is not designed to record audio however, they say that they use the board for both *recording* and playback. &#xD;&#xA;&#xD;&#xA;&gt; The sphere responds sonically to people and its surroundings by means of a battery-powered Arduino, an Adafruit Wave Shield hacked to record and playback audio on-the-fly and a small speaker.&#xD;&#xA;&#xD;&#xA;This generates a few questions.&#xD;&#xA;&#xD;&#xA;- How would this be done?&#xD;&#xA;- Where would the microphone be placed inside the balloon for decent audio capture?&#xD;&#xA;- Would there be a better way to design this?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://ied.rca.ac.uk/de-computation/space-replay&#xD;&#xA;  [2]: https://www.adafruit.com/products/94" />
  <row Id="1886" PostHistoryTypeId="6" PostId="674" RevisionGUID="eaa736e9-b2ec-41d4-96dd-ecc826cc97b3" CreationDate="2014-03-09T14:56:48.103" UserId="65" Comment="added 260 characters in body; edited tags" Text="&lt;sensors&gt;&lt;shields&gt;&lt;project-critique&gt;" />
  <row Id="1887" PostHistoryTypeId="2" PostId="686" RevisionGUID="74b5a26e-ba47-475a-896a-54d301f1f6c8" CreationDate="2014-03-09T16:02:25.323" UserId="550" Text="if possible, what do I need to build an arduino shield capable of receiving 1080p video from usb camera, timestamp each frame and send the frame to memory card?" />
  <row Id="1888" PostHistoryTypeId="1" PostId="686" RevisionGUID="74b5a26e-ba47-475a-896a-54d301f1f6c8" CreationDate="2014-03-09T16:02:25.323" UserId="550" Text="webcam 1080p OSD arduino shield, possible?" />
  <row Id="1889" PostHistoryTypeId="3" PostId="686" RevisionGUID="74b5a26e-ba47-475a-896a-54d301f1f6c8" CreationDate="2014-03-09T16:02:25.323" UserId="550" Text="&lt;shields&gt;" />
  <row Id="1890" PostHistoryTypeId="5" PostId="686" RevisionGUID="9469b4c7-7437-45f7-b17b-78d007eef4f9" CreationDate="2014-03-09T16:22:56.430" UserId="65" Comment="deleted 22 characters in body; edited title" Text="What do I need to build a shield capable of receiving 1080p video from USB camera, timestamp each frame and send the frame to memory card?" />
  <row Id="1891" PostHistoryTypeId="4" PostId="686" RevisionGUID="9469b4c7-7437-45f7-b17b-78d007eef4f9" CreationDate="2014-03-09T16:22:56.430" UserId="65" Comment="deleted 22 characters in body; edited title" Text="Is it possible to build a 1080p OSD webcam shield?" />
  <row Id="1892" PostHistoryTypeId="34" PostId="348" RevisionGUID="b0b8f6cd-e681-4593-87e7-3ff86a06961e" CreationDate="2014-03-09T16:46:12.520" UserId="84" Comment="3" />
  <row Id="1893" PostHistoryTypeId="2" PostId="687" RevisionGUID="3a54e57d-6813-4e54-ad79-9f4fa4ae963d" CreationDate="2014-03-09T17:07:19.480" UserId="84" Text="Typically, when writing Arduino sketches, you will avoid dynamic allocation (be it with `malloc` or `new` for C++ instances), people rather use global -or `static`- variables, or local (stack) variables.&#xD;&#xA;&#xD;&#xA;Using dynamic allocation can lead to several problems:&#xD;&#xA;&#xD;&#xA;- memory leaks (if you lose a pointer to a memory you previously allocated, or more likely if you forget to free the allocated memory when you don't need it anymore)&#xD;&#xA;- heap fragmentation (after several `malloc`/`free` calls) where the heap grows bigger thant the actual amount of memory allocated currently&#xD;&#xA;&#xD;&#xA;In most situations I have faced, dynamic allocation was either not necessary, or could be avoided with macros as in thhe following code sample:&#xD;&#xA;&#xD;&#xA;**MySketch.ino**&#xD;&#xA;&#xD;&#xA;    #define BUFFER_SIZE 32&#xD;&#xA;    #include &quot;Dummy.h&quot;&#xD;&#xA;&#xD;&#xA;**Dummy.h**&#xD;&#xA;&#xD;&#xA;    class Dummy&#xD;&#xA;    {&#xD;&#xA;        byte buffer[BUFFER_SIZE];&#xD;&#xA;        ...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Without `#define BUFFER_SIZE`, if we wanted `Dummy` class to have a non-fixed `buffer` size, we would ave to use dynamic allocation as follows:&#xD;&#xA;&#xD;&#xA;    class Dummy&#xD;&#xA;    {&#xD;&#xA;        const byte* buffer;&#xD;&#xA;&#xD;&#xA;        public:&#xD;&#xA;        Dummy(int size):buffer(new byte[size])&#xD;&#xA;        {&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        ~Dummy()&#xD;&#xA;        {&#xD;&#xA;            delete [] bufer;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;In this case, we have more options than in the first sample (e.g. use different `Dummy` objects with different `buffer` size for each), but we may have heap fragmentation issues.&#xD;&#xA;&#xD;&#xA;Note the use of a destructor to ensure dynamically allocated memory for `buffer` will be freed when a `Dummy` instance is deleted." />
  <row Id="1894" PostHistoryTypeId="2" PostId="688" RevisionGUID="063e8673-e09f-45c1-9470-b7483067d164" CreationDate="2014-03-09T18:32:03.697" UserId="42" Text="Using dynamic allocation (via `malloc`/`free` or `new`/`delete`) isn't inherently bad as such. In fact, for something like string processing (e.g. via the `String` object), it's often quite helpful. That's because many sketches use several small fragments of strings, which eventually get combined into a larger one. Using dynamic allocation lets you use only as much memory as you need for each one. In contrast, using a fixed-size static buffer for each one could end up wasting a lot of space (causing it to run out of memory much faster), although it depends entirely on the context.&#xD;&#xA;&#xD;&#xA;With all of that being said, it's very important to make sure memory usage is predictable. Allowing the sketch to use arbitrary amounts of memory depending on run-time circumstances (e.g. input) can easily cause a problem sooner or later. In some cases, it might be perfectly safe, e.g. if you *know* the usage will never add up to much. Sketches can change during the programming process though. An assumption made early-on could be forgotten when something is changed later, resulting in an unforeseen problem.&#xD;&#xA;&#xD;&#xA;For robustness, it's usually better to work with fixed-size buffers where possible, and design the sketch to work explicitly with those limits from the outset. That means any future changes to the sketch, or any unexpected run-time circumstances, should hopefully not cause any memory problems." />
  <row Id="1895" PostHistoryTypeId="2" PostId="689" RevisionGUID="efd135a6-5a81-4217-ae0c-12973a6287fc" CreationDate="2014-03-09T18:53:20.203" UserId="555" Text="i am using the arduino ide to program the attiny85. i want to take an incoming analog reading, then based on that reading, output a specific pwm value. here's my circuit:&#xD;&#xA;&#xD;&#xA;![my circuit][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/q83mB.jpg&#xD;&#xA;&#xD;&#xA;and here's my code:&#xD;&#xA;&#xD;&#xA;    // to run on attiny85&#xD;&#xA;    &#xD;&#xA;    const byte pwmPin = 0;&#xD;&#xA;    const byte analogInPin = A2;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      pinMode(pwmPin, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      int analogIn = analogRead(analogInPin);&#xD;&#xA;      analogWrite(pwmPin, analogIn);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;should be very simple- i have no problems uploading code to the attiny85, and no problems with simple tests like outputting a specific pwm value (not based on the analog read). but when i try to combine the two- read, then write that value, i can't seem to get things to work. in this circuit for example- i get a reading of 1023 (5v) on the arduino micro- instead of a reading of ~ 790 (3.85v) which is what i should expect. i've used a multimeter to verify the voltages in this circuit- so i think i must either be doing something wrong with my expectations of how to wire up or program the attiny85." />
  <row Id="1896" PostHistoryTypeId="1" PostId="689" RevisionGUID="efd135a6-5a81-4217-ae0c-12973a6287fc" CreationDate="2014-03-09T18:53:20.203" UserId="555" Text="attiny85 and arduino - analogRead + pwmOut" />
  <row Id="1897" PostHistoryTypeId="3" PostId="689" RevisionGUID="efd135a6-5a81-4217-ae0c-12973a6287fc" CreationDate="2014-03-09T18:53:20.203" UserId="555" Text="&lt;programming&gt;" />
  <row Id="1898" PostHistoryTypeId="5" PostId="687" RevisionGUID="e4061de5-4cdd-417d-a553-131fb2c3002e" CreationDate="2014-03-09T18:53:37.703" UserId="84" Comment="fixed a few typos" Text="Typically, when writing Arduino sketches, you will avoid dynamic allocation (be it with `malloc` or `new` for C++ instances), people rather use global -or `static`- variables, or local (stack) variables.&#xD;&#xA;&#xD;&#xA;Using dynamic allocation can lead to several problems:&#xD;&#xA;&#xD;&#xA;- memory leaks (if you lose a pointer to a memory you previously allocated, or more likely if you forget to free the allocated memory when you don't need it anymore)&#xD;&#xA;- heap fragmentation (after several `malloc`/`free` calls) where the heap grows bigger thant the actual amount of memory allocated currently&#xD;&#xA;&#xD;&#xA;In most situations I have faced, dynamic allocation was either not necessary, or could be avoided with macros as in the following code sample:&#xD;&#xA;&#xD;&#xA;**MySketch.ino**&#xD;&#xA;&#xD;&#xA;    #define BUFFER_SIZE 32&#xD;&#xA;    #include &quot;Dummy.h&quot;&#xD;&#xA;&#xD;&#xA;**Dummy.h**&#xD;&#xA;&#xD;&#xA;    class Dummy&#xD;&#xA;    {&#xD;&#xA;        byte buffer[BUFFER_SIZE];&#xD;&#xA;        ...&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;Without `#define BUFFER_SIZE`, if we wanted `Dummy` class to have a non-fixed `buffer` size, we would have to use dynamic allocation as follows:&#xD;&#xA;&#xD;&#xA;    class Dummy&#xD;&#xA;    {&#xD;&#xA;        const byte* buffer;&#xD;&#xA;&#xD;&#xA;        public:&#xD;&#xA;        Dummy(int size):buffer(new byte[size])&#xD;&#xA;        {&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        ~Dummy()&#xD;&#xA;        {&#xD;&#xA;            delete [] bufer;&#xD;&#xA;        }&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;In this case, we have more options than in the first sample (e.g. use different `Dummy` objects with different `buffer` size for each), but we may have heap fragmentation issues.&#xD;&#xA;&#xD;&#xA;Note the use of a destructor to ensure dynamically allocated memory for `buffer` will be freed when a `Dummy` instance is deleted." />
  <row Id="1900" PostHistoryTypeId="2" PostId="691" RevisionGUID="96339bd8-e182-4c05-9344-62b5d6b76e64" CreationDate="2014-03-09T22:35:33.980" UserId="558" Text="I think 'Arluin' and 'jmathew' have the right idea.&#xD;&#xA;Use a lever resting on the top of the roll.&#xD;&#xA;&#xD;&#xA;I would do it slightly different however.&#xD;&#xA;Rather than rely on contacts shutting you can use a potentiometer.&#xD;&#xA;With this system you can measure the amount left instead of simply being notified when it gets low.&#xD;&#xA;&#xD;&#xA;With a contact such as those suggested already, you might get paper stuck in the contact as it closes and then low paper would not be detected.&#xD;&#xA;&#xD;&#xA;(You may need a weight, shown in blue on the diagram, to push the lever down as the roll is used)&#xD;&#xA;&#xD;&#xA;You would need to try and get the pot as close to the roll as possible for maximum swing of the pot and therefore maximum resolution of amount remaining.&#xD;&#xA;&#xD;&#xA;Another thing you might want is some kind of roller on the end of the lever so that the paper roll can move easily with little drag where the lever contacts the paper.&#xD;&#xA;&#xD;&#xA;![Proposed setup][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/3RoTx.png" />
  <row Id="1901" PostHistoryTypeId="2" PostId="692" RevisionGUID="7ae31d8e-4cc1-47c1-b39d-eacbe2ad9fbb" CreationDate="2014-03-09T23:28:49.490" UserId="501" Text="I have been using the Arduino to record some data. In my Arduino sketch I also used the millis() function so I can keep track of the time each value I am measuring is taken. However I noticed that the timing isn't correct. For example 30 seconds in real life only comes out as 10 seconds (made up example). &#xD;&#xA;&#xD;&#xA;Am I correct in saying that the Arduino delay function affects the time keeping using millis(). In other words suppose I have a delay of 50ms, does that mean, the millis() function stops for that duration as well and then continues and so on for the duration of the connection. I noticed this when I tried plotting some data and finding that the frequency of the peaks in my data was too frequent given the time which had passed by. So I want to know is that the reasoning for this mismatch of timing and if so, how do I fix this so that I can keep the time each sample occurs?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;To give some context here is my sketch: &#xD;&#xA;&#xD;&#xA;    #include &lt;eHealth.h&gt;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    unsigned long time;&#xD;&#xA;    // The setup routine runs once when you press reset:&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);  &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // The loop routine runs over and over again forever:&#xD;&#xA;    void loop() {&#xD;&#xA;    &#xD;&#xA;      float ECG = eHealth.getECG();&#xD;&#xA;      time = millis();&#xD;&#xA;      Serial.print(time);&#xD;&#xA;      Serial.print(&quot; &quot;);&#xD;&#xA;      Serial.print(ECG, 5); &#xD;&#xA;      Serial.println(&quot;&quot;); &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      delay(50);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1902" PostHistoryTypeId="1" PostId="692" RevisionGUID="7ae31d8e-4cc1-47c1-b39d-eacbe2ad9fbb" CreationDate="2014-03-09T23:28:49.490" UserId="501" Text="Arduino time keeping using millis() is not accurate or correct?" />
  <row Id="1903" PostHistoryTypeId="3" PostId="692" RevisionGUID="7ae31d8e-4cc1-47c1-b39d-eacbe2ad9fbb" CreationDate="2014-03-09T23:28:49.490" UserId="501" Text="&lt;arduino-uno&gt;&lt;time&gt;" />
  <row Id="1905" PostHistoryTypeId="5" PostId="689" RevisionGUID="2a5f24f4-8947-4de1-ac8c-b109afe00579" CreationDate="2014-03-10T04:15:10.320" UserId="65" Comment="grammar;" Text="I am using the Arduino IDE to program the attiny85. I want to take an incoming analog reading, then based on that reading, output a specific PWM value. Here's my circuit:&#xD;&#xA;&#xD;&#xA;![my circuit][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/q83mB.jpg&#xD;&#xA;&#xD;&#xA;and here's my code:&#xD;&#xA;&#xD;&#xA;    // to run on attiny85&#xD;&#xA;    &#xD;&#xA;    const byte pwmPin = 0;&#xD;&#xA;    const byte analogInPin = A2;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      pinMode(pwmPin, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      int analogIn = analogRead(analogInPin);&#xD;&#xA;      analogWrite(pwmPin, analogIn);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;should be very simple- I have no problems uploading code to the attiny85, and no problems with simple tests like outputting a specific PWM value (not based on the analog read). but when I try to combine the two- read, then write that value, I can't seem to get things to work. In this circuit for example- I get a reading of 1023 (5v) on the arduino micro- instead of a reading of ~ 790 (3.85v) which is what I should expect. I've used a multimeter to verify the voltages in this circuit- so I think I must either be doing something wrong with my expectations of how to wire up or program the attiny85." />
  <row Id="1906" PostHistoryTypeId="2" PostId="693" RevisionGUID="c8f8648e-b7ec-46e5-a16e-e8cbf5323655" CreationDate="2014-03-10T08:18:00.113" UserId="136" Text="Analog read is 10-bits (2^10 = 0-1023 range), analog write is 8-bits (2^8 = 0-255 range). Ditch the lower two bits of the result either by doing:&#xD;&#xA;&#xD;&#xA;    analogIn = analogIn &gt;&gt; 2;&#xD;&#xA;&#xD;&#xA;which can be shortened to:&#xD;&#xA;&#xD;&#xA;    analogIn &gt;&gt;= 2;&#xD;&#xA;&#xD;&#xA;Or you can use the rather complex map function:&#xD;&#xA;&#xD;&#xA;    analogIn = map(analogIn(0,1023,0,255)&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1907" PostHistoryTypeId="5" PostId="692" RevisionGUID="5559754d-4693-4f46-8b81-fa4ecc90fab2" CreationDate="2014-03-10T09:13:51.480" UserId="275" Comment="activated C++ syntax highlighting" Text="I have been using the Arduino to record some data. In my Arduino sketch I also used the `millis()` function so I can keep track of the time at which each value I am measuring is taken. However, I noticed that the timing isn't correct. For example 30 seconds in real life only comes out as 10 seconds (made up example). &#xD;&#xA;&#xD;&#xA;Am I correct in saying that the Arduino delay function affects the time keeping using `millis()`? In other words suppose I have a delay of 50ms, does that mean the `millis()` function stops for that duration as well and then continues and so on for the duration of the connection? I noticed this when I tried plotting some data and finding that the frequency of the peaks in my data was too frequent given the time which had passed by. So I want to know if that is the reasoning for this mismatch of timing and if so, how do I fix this so that I can keep the time each sample occurs?&#xD;&#xA;&#xD;&#xA;To give some context here is my sketch: &#xD;&#xA;&lt;!-- language: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;    #include &lt;eHealth.h&gt;    &#xD;&#xA;    &#xD;&#xA;    unsigned long time;&#xD;&#xA;    // The setup routine runs once when you press reset:&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);  &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // The loop routine runs over and over again forever:&#xD;&#xA;    void loop() {&#xD;&#xA;    &#xD;&#xA;      float ECG = eHealth.getECG();&#xD;&#xA;      time = millis();&#xD;&#xA;      Serial.print(time);&#xD;&#xA;      Serial.print(&quot; &quot;);&#xD;&#xA;      Serial.print(ECG, 5); &#xD;&#xA;      Serial.println(&quot;&quot;);    &#xD;&#xA;    &#xD;&#xA;      delay(50);&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="1908" PostHistoryTypeId="6" PostId="692" RevisionGUID="5559754d-4693-4f46-8b81-fa4ecc90fab2" CreationDate="2014-03-10T09:13:51.480" UserId="275" Comment="activated C++ syntax highlighting" Text="&lt;arduino-uno&gt;&lt;programming&gt;&lt;time&gt;" />
  <row Id="1909" PostHistoryTypeId="24" PostId="692" RevisionGUID="5559754d-4693-4f46-8b81-fa4ecc90fab2" CreationDate="2014-03-10T09:13:51.480" Comment="Proposed by 275 approved by 501 edit id of 221" />
  <row Id="1910" PostHistoryTypeId="2" PostId="694" RevisionGUID="c2c0d30b-c3c7-4c75-baa3-929130e3a8c0" CreationDate="2014-03-10T09:15:13.077" UserId="136" Text="`millis()` is interrupt driven so `delay()` won't impact it, at least not on an ATmega based board.&#xD;&#xA;&#xD;&#xA;That isn't to say that `millis()` is totally accurate either. Each tick of the timer is not exactly 1ms, but is 1.024ms. This error gradually accumulates until a correction is made. This can be seen in the implementation of the TIMER0_OVF (timer 0 overflow) interrupt handler.&#xD;&#xA;&#xD;&#xA;Another source of inaccuracy is the oscillator/crystal itself, which is not exactly 16MHz. It is pretty close though, and as long as temperature doesn't change too much, is relatively stable.&#xD;&#xA;&#xD;&#xA;The above means that you might be about 1ms out when using `millis()`. This doesn't sound like your problem.&#xD;&#xA;&#xD;&#xA;Another problem I have seen people have is when they change the clock speed but don't correctly change boards.txt. This means that the constants used in the `millis()` implementation are wrong and the times are wrong.&#xD;&#xA;&#xD;&#xA;We'd really need to see the timestamps you are getting. If you actually seeing 30s showing as 10s, then there is something else at work." />
  <row Id="1911" PostHistoryTypeId="5" PostId="694" RevisionGUID="6fccf160-ae78-4545-8f08-b492d3c5a84f" CreationDate="2014-03-10T09:28:59.460" UserId="136" Comment="Add detail on easier way to get constant timing." Text="`millis()` is interrupt driven so `delay()` won't impact it, at least not on an ATmega based board.&#xD;&#xA;&#xD;&#xA;That isn't to say that `millis()` is totally accurate either. Each tick of the timer is not exactly 1ms, but is 1.024ms. This error gradually accumulates until a correction is made. This can be seen in the implementation of the TIMER0_OVF (timer 0 overflow) interrupt handler.&#xD;&#xA;&#xD;&#xA;Another source of inaccuracy is the oscillator/crystal itself, which is not exactly 16MHz. It is pretty close though, and as long as temperature doesn't change too much, is relatively stable.&#xD;&#xA;&#xD;&#xA;The above means that you might be about 1ms out when using `millis()`. This doesn't sound like your problem.&#xD;&#xA;&#xD;&#xA;Another potential issue would be what `getECG()` is doing - it might be very slow.&#xD;&#xA;&#xD;&#xA;    float eHealthClass::getECG(void)&#xD;&#xA;    	{&#xD;&#xA;    		float analog0;&#xD;&#xA;    		// Read from analogic in. &#xD;&#xA;    		analog0=analogRead(0);&#xD;&#xA;    		// binary to voltage conversion&#xD;&#xA;    		return analog0 = (float)analog0 * 5 / 1023.0;   &#xD;&#xA;    	}&#xD;&#xA;&#xD;&#xA;`analogRead()` is slow, but not so slow as to impact a loop like this.&#xD;&#xA;&#xD;&#xA;Another problem I have seen people have is when they change the clock speed but don't correctly change boards.txt. This means that the constants used in the `millis()` implementation are wrong and the times are wrong.&#xD;&#xA;&#xD;&#xA;If you actually want to read values every 50ms, a much better way of implementing this is to do the following&#xD;&#xA;&#xD;&#xA;    static long lastUpdate;&#xD;&#xA;    &#xD;&#xA;    if (millis() - lastUpdate &gt; 50)&#xD;&#xA;    {&#xD;&#xA;        lastUpdate = millis();&#xD;&#xA;        //Do stuff&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;We'd really need to see the timestamps you are getting. If you actually seeing 30s showing as 10s, then there is something else at work." />
  <row Id="1912" PostHistoryTypeId="2" PostId="695" RevisionGUID="f83b0272-9e0f-4985-abb3-d04081f84a72" CreationDate="2014-03-10T10:42:31.183" UserId="562" Text="&quot;Practical Arduino book&quot; has a very interesting circuit for this purpose: http://www.practicalarduino.com/projects/vehicle-telemetry-platform&#xD;&#xA;&#xD;&#xA;Here is how I've recreated it:&#xD;&#xA;&#xD;&#xA;&lt;a href=&quot;http://arduino.bougakov.com/post/44802340184/ok-enough-with-preparations-lets-make-some-real&quot;&gt;&lt;img src=&quot;http://25.media.tumblr.com/8c2d23c56eb465d055e4d8c8406017c8/tumblr_mjb5327Gzh1s6jcaao1_1280.png&quot; /&gt;&lt;/a&gt;&#xD;&#xA;&#xD;&#xA;It uses LM2940CT and huge electrolytic cap - even if supply voltage drops, you'll have about a second to shut down your Arduino gracefully (close files on SD properly, and so on).&#xD;&#xA;&#xD;&#xA;&quot;Arduino Cookbook&quot; (2nd ed.) has a chapter with examples on how to reduce Arduino's power consumption to absolute minimum - have a look at it, too." />
  <row Id="1913" PostHistoryTypeId="2" PostId="696" RevisionGUID="aac72820-c0d4-4d69-8543-aeaeb6d9967b" CreationDate="2014-03-10T11:09:56.837" UserId="136" Text="None of the ATmega based boards have the hardware (in terms of acting as a USB host) or power (in terms of handling probably compressed 1080p video).&#xD;&#xA;&#xD;&#xA;Potentially one of the ARM boards could do this, but none of them are designed to be used as USB hosts and none of them will have drivers to connect to the camera.&#xD;&#xA;&#xD;&#xA;If a shield was developed to do this, it would have so much more power than the Arduino that the Arduino would probably better be viewed as a slave to the other device." />
  <row Id="1914" PostHistoryTypeId="5" PostId="631" RevisionGUID="84c004c1-fed9-4560-a1ad-298c62d98bbf" CreationDate="2014-03-10T13:11:53.087" UserId="168" Comment="added 426 characters in body" Text="Another way to do it, in case you just want to for the fun of it would be to put a metal rod inside the roll, and a metal plate on the outside, and measure the capacitance which should change with the TP remaining due to the dielectric constant of the paper.&#xD;&#xA;&#xD;&#xA;But that would be taking the &quot;scenic route&quot; for sure. Still, the Arduino can measure capacitance pretty easily and it might even be sensitive enough, and it would stay out of the way because it would just be a metal plate behind the roll and a metal rod in the roll. You might even be able to retrofit an existing holder without it being noticed.&#xD;&#xA;&#xD;&#xA;An easier way would be a stick attached to the shaft of a potentiometer held up by the top of the roll. Less TP, shaft goes lower and turns the pot. Might need a long shaft for leverage because you can't press too hard without impeding the function of pulling toilet paper.&#xD;&#xA;&#xD;&#xA;As AJMansfield suggested, Radioactivity actually is used to measure the thickness of things in industrial settings. If you really wanted to go crazy maybe you could use an extremely low energy radioactive source like a can of that weird tasting salt substitute which is a tiny bit above background levels and average over extremely long times(toilet paper shouldn't change much from hour to hour), so this could actually be a reasonable if expensive way to do things.&#xD;&#xA;&#xD;&#xA;Infrared beam break sensors are also good, and if you position it right you could get it to block more light the fuller the roll was instead of just giving you and on or off signal.&#xD;&#xA;&#xD;&#xA;EDIT:&#xD;&#xA;Working Proof of concept of the capacitative approach. Only needs an arduino and 2 stiff wires. Precise to about an 8th of an inch, with a lot of noise. Pretty sure you could reliably get at least 1inch accuracy. Measurement time is about a minute. It's really sensitive to it's surroundings. You'd have to make sure anything metal within a foot stayed where it was or use shielding.&#xD;&#xA;&#xD;&#xA;http://pastebin.com/2W5y81AB&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1916" PostHistoryTypeId="2" PostId="698" RevisionGUID="7102ea6a-92c3-4a79-b62e-c11c787018ed" CreationDate="2014-03-10T17:45:36.740" UserId="569" Text="You could just crack open one of those playing birthday cards and adapt the switch to the holder arm. Once you hear 'Happy Birthday&quot; chiming from the toilet you know you're in trouble! (and because they are very low-power these things chime on forever ;-) ) I've shown a LED setup here but you get the idea...&#xD;&#xA;&#xD;&#xA;![happy birthday][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/oQBrx.jpg" />
  <row Id="1917" PostHistoryTypeId="2" PostId="699" RevisionGUID="6b949a6d-446c-4c64-b67a-bb9561063d4f" CreationDate="2014-03-10T21:30:33.983" UserId="501" Text="I am beginning to get a bit confused about sampling rates and baudrates etc. I have this Arduino code: &#xD;&#xA;&#xD;&#xA;    #include &lt;eHealth.h&gt;&#xD;&#xA;    &#xD;&#xA;    extern volatile unsigned long timer0_overflow_count;&#xD;&#xA;    float fanalog0;&#xD;&#xA;    int analog0;&#xD;&#xA;    unsigned long time;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    byte serialByte;&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() { &#xD;&#xA;      while (Serial.available()&gt;0){  &#xD;&#xA;        serialByte=Serial.read();&#xD;&#xA;        if (serialByte=='S'){        &#xD;&#xA;          while(1){&#xD;&#xA;            fanalog0=eHealth.getECG();  &#xD;&#xA;            // Use the timer0 =&gt; 1 tick every 4 us&#xD;&#xA;            time=(timer0_overflow_count &lt;&lt; 8) + TCNT0;        &#xD;&#xA;            // Microseconds conversion.&#xD;&#xA;            time=(time*4);   &#xD;&#xA;            //Print in a file for simulation&#xD;&#xA;            //Serial.print(time);&#xD;&#xA;            //Serial.print(&quot; &quot;);&#xD;&#xA;            Serial.print(fanalog0,5);&#xD;&#xA;            Serial.print(&quot;\n&quot;);&#xD;&#xA;    &#xD;&#xA;            if (Serial.available()&gt;0){&#xD;&#xA;              serialByte=Serial.read();&#xD;&#xA;              if (serialByte=='F')  break;&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Since there is no delay interrupt, what is the sampling rate/frequency? Is it based on the Arduino ADC speed? When I increase the baudrate am I increasing the sampling frequency or just the rate at which I send data over the serial port. " />
  <row Id="1918" PostHistoryTypeId="1" PostId="699" RevisionGUID="6b949a6d-446c-4c64-b67a-bb9561063d4f" CreationDate="2014-03-10T21:30:33.983" UserId="501" Text="How do I know the sampling frequency?" />
  <row Id="1919" PostHistoryTypeId="3" PostId="699" RevisionGUID="6b949a6d-446c-4c64-b67a-bb9561063d4f" CreationDate="2014-03-10T21:30:33.983" UserId="501" Text="&lt;arduino-uno&gt;&lt;serial&gt;" />
  <row Id="1920" PostHistoryTypeId="5" PostId="699" RevisionGUID="1016dd23-be00-4f78-a5ea-59a58678297b" CreationDate="2014-03-10T21:37:52.027" UserId="275" Comment="added syntax highlighting" Text="I am beginning to get a bit confused about sampling rates and baudrates etc. I have this Arduino code: &#xD;&#xA;&lt;!-- language: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;    #include &lt;eHealth.h&gt;&#xD;&#xA;    &#xD;&#xA;    extern volatile unsigned long timer0_overflow_count;&#xD;&#xA;    float fanalog0;&#xD;&#xA;    int analog0;&#xD;&#xA;    unsigned long time;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    byte serialByte;&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() { &#xD;&#xA;      while (Serial.available()&gt;0){  &#xD;&#xA;        serialByte=Serial.read();&#xD;&#xA;        if (serialByte=='S'){        &#xD;&#xA;          while(1){&#xD;&#xA;            fanalog0=eHealth.getECG();  &#xD;&#xA;            // Use the timer0 =&gt; 1 tick every 4 us&#xD;&#xA;            time=(timer0_overflow_count &lt;&lt; 8) + TCNT0;        &#xD;&#xA;            // Microseconds conversion.&#xD;&#xA;            time=(time*4);   &#xD;&#xA;            //Print in a file for simulation&#xD;&#xA;            //Serial.print(time);&#xD;&#xA;            //Serial.print(&quot; &quot;);&#xD;&#xA;            Serial.print(fanalog0,5);&#xD;&#xA;            Serial.print(&quot;\n&quot;);&#xD;&#xA;    &#xD;&#xA;            if (Serial.available()&gt;0){&#xD;&#xA;              serialByte=Serial.read();&#xD;&#xA;              if (serialByte=='F')  break;&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Since there is no delay interrupt, what is the sampling rate/frequency? Is it based on the Arduino ADC speed? When I increase the baudrate am I increasing the sampling frequency or just the rate at which I send data over the serial port?" />
  <row Id="1921" PostHistoryTypeId="24" PostId="699" RevisionGUID="1016dd23-be00-4f78-a5ea-59a58678297b" CreationDate="2014-03-10T21:37:52.027" Comment="Proposed by 275 approved by 501 edit id of 222" />
  <row Id="1922" PostHistoryTypeId="5" PostId="699" RevisionGUID="854facd9-e79b-4d3c-8c17-632dcba1509e" CreationDate="2014-03-10T21:40:33.167" UserId="185" Comment="whitespace matters" Text="I am beginning to get a bit confused about sampling rates and baudrates etc. I have this Arduino code: &#xD;&#xA;&#xD;&#xA;&lt;!-- language: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;    #include &lt;eHealth.h&gt;&#xD;&#xA;    &#xD;&#xA;    extern volatile unsigned long timer0_overflow_count;&#xD;&#xA;    float fanalog0;&#xD;&#xA;    int analog0;&#xD;&#xA;    unsigned long time;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    byte serialByte;&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() { &#xD;&#xA;      while (Serial.available()&gt;0){  &#xD;&#xA;        serialByte=Serial.read();&#xD;&#xA;        if (serialByte=='S'){        &#xD;&#xA;          while(1){&#xD;&#xA;            fanalog0=eHealth.getECG();  &#xD;&#xA;            // Use the timer0 =&gt; 1 tick every 4 us&#xD;&#xA;            time=(timer0_overflow_count &lt;&lt; 8) + TCNT0;        &#xD;&#xA;            // Microseconds conversion.&#xD;&#xA;            time=(time*4);   &#xD;&#xA;            //Print in a file for simulation&#xD;&#xA;            //Serial.print(time);&#xD;&#xA;            //Serial.print(&quot; &quot;);&#xD;&#xA;            Serial.print(fanalog0,5);&#xD;&#xA;            Serial.print(&quot;\n&quot;);&#xD;&#xA;    &#xD;&#xA;            if (Serial.available()&gt;0){&#xD;&#xA;              serialByte=Serial.read();&#xD;&#xA;              if (serialByte=='F')  break;&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Since there is no delay interrupt, what is the sampling rate/frequency? Is it based on the Arduino ADC speed? When I increase the baudrate am I increasing the sampling frequency or just the rate at which I send data over the serial port?" />
  <row Id="1923" PostHistoryTypeId="2" PostId="700" RevisionGUID="5279522c-7301-425a-81b8-d64c0b6b2930" CreationDate="2014-03-10T22:14:32.777" UserId="136" Text="Each loop you are printing 8 characters over a 9600bps serial link. Each character takes 10 bits (1 start, 8 bits for the character, 1 stop). That means you can only go through this loop ~120 times/sec.&#xD;&#xA;&#xD;&#xA;The `analogRead()` function can sample at about 9600 times/sec in theory, realistically it is about 8600 times/sec. &#xD;&#xA;&#xD;&#xA;You are being bounded by the serial communication." />
  <row Id="1924" PostHistoryTypeId="2" PostId="701" RevisionGUID="dc6e6e6c-2beb-461f-b322-eab21b1ad55d" CreationDate="2014-03-10T22:23:02.007" UserId="470" Text="The Arduino ADC clock speed is set in ..arduino-1.5.5\hardware\arduino\avr\cores\arduino\wiring.c&#xD;&#xA;&#xD;&#xA;Here is the relevant part&#xD;&#xA;&#xD;&#xA;    #if defined(ADCSRA)&#xD;&#xA;    	// set a2d prescale factor to 128&#xD;&#xA;    	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.&#xD;&#xA;    	// XXX: this will not work properly for other clock speeds, and&#xD;&#xA;    	// this code should use F_CPU to determine the prescale factor.&#xD;&#xA;    	sbi(ADCSRA, ADPS2);&#xD;&#xA;    	sbi(ADCSRA, ADPS1);&#xD;&#xA;    	sbi(ADCSRA, ADPS0);&#xD;&#xA;    &#xD;&#xA;    	// enable a2d conversions&#xD;&#xA;    	sbi(ADCSRA, ADEN);&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;For a 16MHz Arduino the ADC clock is set to 16MHz/128 = 125 KHz  &#xD;&#xA;Each conversion in AVR takes 13 ADC clocks so 125KHz /13 = 9615 Hz&#xD;&#xA;&#xD;&#xA;That is the max possible sampling rate but the actual sampling rate in your application depends on the interval between successive conversions calls.  &#xD;&#xA;Since you read the result and send it through the serial port, you are getting a delay that increases as the baud rate decreases. The lower the baud rate the longer it will take to send the same length of data and the longer it will take to call the next ADC conversion.&#xD;&#xA;&#xD;&#xA;The actual sampling rate in your application can be determined with the use of a debugger or a simulator, but an easier solution is to toggle a digital pin every time you execute a conversion and measure the frequency that the digital pin toggles at." />
  <row Id="1925" PostHistoryTypeId="2" PostId="702" RevisionGUID="cf3f4517-67d5-4f97-8976-9842e2452dcc" CreationDate="2014-03-10T23:01:37.753" UserId="575" Text="I have a Pololu 5v AVR ISP (http://www.pololu.com/product/1300) which I have successfully used to program several arduinos (a Mega, an Uno and a Pro Mini 5v). I now have a new arduino compatible clone board which is basically a clone of the pro mini 3.3v.&#xD;&#xA;&#xD;&#xA;I am wondering if anyone else has used this programmer to program a 3.3v board without issues. I've seen a forum post on pololu's forum here http://forum.pololu.com/viewtopic.php?f=3&amp;t=7368 which discusses modifications required - but I don't really understand what is necessary.&#xD;&#xA;&#xD;&#xA;I've also found the software tool mentioned in the above forum post here http://www.pololu.com/docs/0J41 and I have downloaded it and built it.&#xD;&#xA;&#xD;&#xA;When I run the aforementioned tool I get these options:&#xD;&#xA;&#xD;&#xA;    PgmCmd: Configuration and status utility for the Pololu USB AVR Programmer.&#xD;&#xA;    Version: 1.0.1.0&#xD;&#xA;    Options:&#xD;&#xA;     -l, --list             list available devices&#xD;&#xA;     -d, --device SERIALNUM (optional) select device with given serial number&#xD;&#xA;     -s, --status           display complete device status&#xD;&#xA;         --freq NUM         sets the ISP frequency (in units of kHz)&#xD;&#xA;         --linea ID&#xD;&#xA;           or --lineb ID    set serial control signal associated with line A or B.&#xD;&#xA;                            Valid IDs are: none, cd, dsr, ri, dtr, rts.&#xD;&#xA;                            Warning: dtr and rts are outputs: -f option is required&#xD;&#xA;         --swminor HEXNUM   AVR ISP software version minor (in hex, e.g. A)&#xD;&#xA;         --swmajor HEXNUM   AVR ISP software version major (in hex)&#xD;&#xA;         --hw HEXNUM        AVR ISP software hardware version (in hex)&#xD;&#xA;         --vddmin NUM       set minimum allowed target vdd (units of mV)&#xD;&#xA;         --vddmaxrange NUM  set maximum allowed target vdd range (units of mV)&#xD;&#xA;         --restoredefaults  restore factory settings&#xD;&#xA;         --bootloader       put device in to bootloader (firmware upgrade) mode&#xD;&#xA;&#xD;&#xA;I then ran the --status option with the serial number of my programmer and got this:&#xD;&#xA;&#xD;&#xA;    Serial number:                  00048632&#xD;&#xA;    Firmware version:               1.07&#xD;&#xA;    Settings:&#xD;&#xA;      ISP Frequency:                200 kHz&#xD;&#xA;      Line A Identity:              None&#xD;&#xA;      Line B Identity:              None&#xD;&#xA;      AVR ISP hardware version:     F&#xD;&#xA;      AVR ISP software version:     2.A&#xD;&#xA;      Target VDD allowed minimum:   4384 mV&#xD;&#xA;      Target VDD allowed max range: 512 mV&#xD;&#xA;    Last programming:&#xD;&#xA;      Error: None&#xD;&#xA;      Measured Target VDD Minimum:  N/A&#xD;&#xA;      Measured Target VDD Range:    N/A&#xD;&#xA;    SLO-scope:&#xD;&#xA;      State:                        Off&#xD;&#xA;      Line A output:                Off&#xD;&#xA;      Line B output:                Off&#xD;&#xA;&#xD;&#xA;From this I deduced that my programmer is currently set at between about 4.38v and 4.89v which I presume corresponds to the 5v approximate voltage of the normal arduino chips.&#xD;&#xA;&#xD;&#xA;Given that the utility program allows me to set both the target minimum vdd and the target vdd max range should I therefore set it to something like a minimum of 2704 with a max range of 512 which should put the signal voltages at up to ~3.2v.&#xD;&#xA;&#xD;&#xA;Is that all I have to do to get this to work?" />
  <row Id="1926" PostHistoryTypeId="1" PostId="702" RevisionGUID="cf3f4517-67d5-4f97-8976-9842e2452dcc" CreationDate="2014-03-10T23:01:37.753" UserId="575" Text="How to use a Pololu 5v AVR ISP Programmer to program an AVR at 3.3v" />
  <row Id="1927" PostHistoryTypeId="3" PostId="702" RevisionGUID="cf3f4517-67d5-4f97-8976-9842e2452dcc" CreationDate="2014-03-10T23:01:37.753" UserId="575" Text="&lt;uploading&gt;&lt;voltage-level&gt;" />
  <row Id="1928" PostHistoryTypeId="6" PostId="702" RevisionGUID="891bef0a-3b6a-4671-a0c4-b5934174dae1" CreationDate="2014-03-11T00:39:47.773" UserId="11" Comment="added appropriate tag" Text="&lt;uploading&gt;&lt;voltage-level&gt;&lt;isp&gt;" />
  <row Id="1929" PostHistoryTypeId="2" PostId="703" RevisionGUID="4ffa8edb-dd0a-4022-a366-c1928d90600f" CreationDate="2014-03-11T00:42:38.050" UserId="11" Text="In-system programming (ISP) refers to the ability of chips to be programmed while installed in the system. This is usually accomplished by connecting to a 6 or 8 pin header on the board and a hardware programmer connected to the computer.&#xD;&#xA;&#xD;&#xA;More info on [Wiki][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/In-system_programming" />
  <row Id="1930" PostHistoryTypeId="2" PostId="704" RevisionGUID="1914dd11-49b5-448e-9261-10ebac9ede64" CreationDate="2014-03-11T00:42:38.050" UserId="11" Text="In-system programming (ISP) refers to the ability of chips to be programmed while installed in the system." />
  <row Id="1932" PostHistoryTypeId="2" PostId="705" RevisionGUID="f52963a8-9fd0-4c80-a140-a74961a4961b" CreationDate="2014-03-11T02:18:07.097" UserId="368" Text="Since AVR ISP is simply a modified form of SPI, the most universal way to handle this is to use a 3/1 level translator such as the &lt;a href=&quot;http://www.maximintegrated.com/datasheet/index.mvp/id/3253&quot;&gt;MAX3392E&lt;/a&gt;. Once you provide it with 5V on V&lt;sub&gt;CC&lt;/sub&gt; and 3V3 on V&lt;sub&gt;L&lt;/sub&gt; it will translate the MOSI, SCK, and nRESET signals to 3V3 and the MISO signal to 5V." />
  <row Id="1933" PostHistoryTypeId="2" PostId="706" RevisionGUID="0450d73b-fea3-458a-bb0a-60dafe4bc0f6" CreationDate="2014-03-11T03:41:35.897" UserId="186" Text="As jfpoilpret already said, a power MOSFET is great for turning ON and OFF the 12 VDC power to devices that pull up to 44 A. There are dozens of such power MOSFETs for under $1 each. More expensive MOSFETs are available that can handle much higher current and voltage.&#xD;&#xA;&#xD;&#xA;In principle it is possible to drive a stepper motor with a microcontroller and a handful of transistors and a few other little parts.&#xD;&#xA;However, many people prefer to use a &quot;stepper driver chip&quot;, so it is impossible for a software bug to accidentally turn on transistors in such a way as to short the power supply to ground (typically destroying at least 2 transistors).&#xD;&#xA;Many recent stepper driver chips also handle microstepping, current limiting, thermal overload protection, and other nice features.&#xD;&#xA;&#xD;&#xA;All the stepper driver chips that I've ever heard of, and a few off-the-shelf breakout boards using those chips, are listed at&#xD;&#xA;http://reprap.org/wiki/stepper_motor_driver .&#xD;&#xA;&#xD;&#xA;In particular, many of the RepRap 3D printers I've seen connect an Arduino to four [Pololu stepper drivers][1] (under $15 each) to drive five stepper motors.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.pololu.com/category/120/stepper-motor-drivers&#xD;&#xA;" />
  <row Id="1934" PostHistoryTypeId="2" PostId="707" RevisionGUID="51bd3c0b-ba1c-42d2-8b01-91875e384f37" CreationDate="2014-03-11T09:13:08.583" UserId="501" Text="I am using an Arduino Uno to send time and voltage information over the serial port to Python to plot. However the interval timings between successive time stamps appears to be increasing over time, affecting my plotting. This is especially true when the baud rate is set to 9600, where my initial time differences maybe 1320 and increases to 16400 after a relatively short period of time. When this rate is put to maximum of 115200 bps the change is slower and less noticeable, from around 1340 to 1500 even after a relatively long run of sending. All times are given in microseconds. &#xD;&#xA;I would like to know if I can reduce or elimnate this effect, and if not understand why it exists. I have read things about interrupts and delays causing this, but I do not fully appreciate the complexity of the electronics at hand and would like to know: &#xD;&#xA;&#xD;&#xA;1. Can I get greater precision in the timing?&#xD;&#xA;2. What causes this change in timing?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Here is what I currently have: &#xD;&#xA;&#xD;&#xA;    #include &lt;eHealth.h&gt;&#xD;&#xA;    &#xD;&#xA;    extern volatile unsigned long timer0_overflow_count;&#xD;&#xA;    float fanalog0;&#xD;&#xA;    int analog0;&#xD;&#xA;    unsigned long time;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    byte serialByte;&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() { &#xD;&#xA;      while (Serial.available()&gt;0){  &#xD;&#xA;        serialByte=Serial.read();&#xD;&#xA;        if (serialByte=='S'){        &#xD;&#xA;          while(1){&#xD;&#xA;            fanalog0=eHealth.getECG();  &#xD;&#xA;            // Use the timer0 =&gt; 1 tick every 4 us&#xD;&#xA;            time=(timer0_overflow_count &lt;&lt; 8) + TCNT0;        &#xD;&#xA;            // Microseconds conversion.&#xD;&#xA;            time=(time*4);   &#xD;&#xA;            //Print in a file for simulation&#xD;&#xA;            //Serial.print(time);&#xD;&#xA;            //Serial.print(&quot; &quot;);&#xD;&#xA;            Serial.print(fanalog0,5);&#xD;&#xA;            Serial.print(&quot;\n&quot;);&#xD;&#xA;    &#xD;&#xA;            if (Serial.available()&gt;0){&#xD;&#xA;              serialByte=Serial.read();&#xD;&#xA;              if (serialByte=='F')  break;&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1935" PostHistoryTypeId="1" PostId="707" RevisionGUID="51bd3c0b-ba1c-42d2-8b01-91875e384f37" CreationDate="2014-03-11T09:13:08.583" UserId="501" Text="High precision timing on Arduino for serial communication" />
  <row Id="1936" PostHistoryTypeId="3" PostId="707" RevisionGUID="51bd3c0b-ba1c-42d2-8b01-91875e384f37" CreationDate="2014-03-11T09:13:08.583" UserId="501" Text="&lt;arduino-uno&gt;&lt;serial&gt;" />
  <row Id="1937" PostHistoryTypeId="2" PostId="708" RevisionGUID="244a04aa-6966-4711-a0ea-87f17104061f" CreationDate="2014-03-11T10:25:06.483" UserId="578" Text="I need to communicate two arduinos each other via XBee.&#xD;&#xA;&#xD;&#xA;I am new to XBee and hardwares.&#xD;&#xA;&#xD;&#xA;So my doubt is which XBee shield and XBee module I need to purchase. I read about XBee series 2, XB24 etc.&#xD;&#xA;&#xD;&#xA;So please anyone give me an advise &#xD;&#xA;Thanks in advance" />
  <row Id="1938" PostHistoryTypeId="1" PostId="708" RevisionGUID="244a04aa-6966-4711-a0ea-87f17104061f" CreationDate="2014-03-11T10:25:06.483" UserId="578" Text="Arduino - XBee shield communication" />
  <row Id="1939" PostHistoryTypeId="3" PostId="708" RevisionGUID="244a04aa-6966-4711-a0ea-87f17104061f" CreationDate="2014-03-11T10:25:06.483" UserId="578" Text="&lt;arduino-uno&gt;&lt;shields&gt;&lt;wifi&gt;" />
  <row Id="1940" PostHistoryTypeId="5" PostId="707" RevisionGUID="2c0dabbf-fa95-4586-baa2-b6d9d530f174" CreationDate="2014-03-11T11:10:50.217" UserId="275" Comment="added syntax highlighting" Text="I am using an Arduino Uno to send time and voltage information over the serial port to Python to plot. However the interval timings between successive time stamps appears to be increasing over time, affecting my plotting. This is especially true when the baud rate is set to 9600, where my initial time differences maybe 1320 and increases to 16400 after a relatively short period of time. When this rate is put to maximum of 115200 bps the change is slower and less noticeable, from around 1340 to 1500 even after a relatively long run of sending. All times are given in microseconds.&#xD;&#xA; &#xD;&#xA;I would like to know if I can reduce or eliminate this effect, and if not understand why it exists. I have read things about interrupts and delays causing this, but I do not fully appreciate the complexity of the electronics at hand and would like to know: &#xD;&#xA;&#xD;&#xA;1. Can I get greater precision in the timing?&#xD;&#xA;2. What causes this change in timing?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Here is what I currently have: &#xD;&#xA;&#xD;&#xA;&lt;!-- language: lang-cpp --&gt;&#xD;&#xA;&#xD;&#xA;    #include &lt;eHealth.h&gt;&#xD;&#xA;    &#xD;&#xA;    extern volatile unsigned long timer0_overflow_count;&#xD;&#xA;    float fanalog0;&#xD;&#xA;    int analog0;&#xD;&#xA;    unsigned long time;    &#xD;&#xA;    &#xD;&#xA;    byte serialByte;&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() { &#xD;&#xA;      while (Serial.available()&gt;0){  &#xD;&#xA;        serialByte=Serial.read();&#xD;&#xA;        if (serialByte=='S'){        &#xD;&#xA;          while(1){&#xD;&#xA;            fanalog0=eHealth.getECG();  &#xD;&#xA;            // Use the timer0 =&gt; 1 tick every 4 us&#xD;&#xA;            time=(timer0_overflow_count &lt;&lt; 8) + TCNT0;        &#xD;&#xA;            // Microseconds conversion.&#xD;&#xA;            time=(time*4);   &#xD;&#xA;            //Print in a file for simulation&#xD;&#xA;            //Serial.print(time);&#xD;&#xA;            //Serial.print(&quot; &quot;);&#xD;&#xA;            Serial.print(fanalog0,5);&#xD;&#xA;            Serial.print(&quot;\n&quot;);&#xD;&#xA;    &#xD;&#xA;            if (Serial.available()&gt;0){&#xD;&#xA;              serialByte=Serial.read();&#xD;&#xA;              if (serialByte=='F')  break;&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1941" PostHistoryTypeId="24" PostId="707" RevisionGUID="2c0dabbf-fa95-4586-baa2-b6d9d530f174" CreationDate="2014-03-11T11:10:50.217" Comment="Proposed by 275 approved by 136, 501 edit id of 224" />
  <row Id="1942" PostHistoryTypeId="5" PostId="693" RevisionGUID="9552596e-ae33-4ae5-981b-f1383fb34080" CreationDate="2014-03-11T11:48:43.817" UserId="46" Comment="Fixed typo in the last line of code (parenthesis was missing)." Text="Analog read is 10-bits (2^10 = 0-1023 range), analog write is 8-bits (2^8 = 0-255 range). Ditch the lower two bits of the result either by doing: &#xD;&#xA;&#xD;&#xA;    analogIn = analogIn &gt;&gt; 2;&#xD;&#xA;&#xD;&#xA;which can be shortened to:&#xD;&#xA;&#xD;&#xA;    analogIn &gt;&gt;= 2;&#xD;&#xA;&#xD;&#xA;Or you can use the rather complex map function:&#xD;&#xA;&#xD;&#xA;    analogIn = map( analogIn(0, 1023, 0, 255) )&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1943" PostHistoryTypeId="24" PostId="693" RevisionGUID="9552596e-ae33-4ae5-981b-f1383fb34080" CreationDate="2014-03-11T11:48:43.817" Comment="Proposed by 46 approved by 136 edit id of 225" />
  <row Id="1944" PostHistoryTypeId="5" PostId="696" RevisionGUID="e9004fde-f66a-4f3a-9b38-4d1c3ed6a7bf" CreationDate="2014-03-11T11:49:52.457" UserId="136" Comment="Added Fake Name's clarification into answer." Text="None of the ATmega based boards have the hardware (in terms of acting as a USB host) or power (in terms of handling probably compressed 1080p video).&#xD;&#xA;&#xD;&#xA;Potentially one of the ARM boards could do this. The Arduino Due can act as a host, but it sounds fairly experimental, and none of them will have drivers to connect to the camera.&#xD;&#xA;&#xD;&#xA;If a shield was developed to do this, it would have so much more power than the Arduino that the Arduino would probably better be viewed as a slave to the other device." />
  <row Id="1946" PostHistoryTypeId="2" PostId="709" RevisionGUID="0d3ac730-2288-4132-93c4-b548e542d3f7" CreationDate="2014-03-11T13:09:06.670" UserId="58" Text="The &quot;XBee&quot; brand has two major types. Series 1 are the original ones, and are often NOT referred to by their series number. Series 2 are the newer mesh network brethren.&#xD;&#xA;&#xD;&#xA;Most XBee's and their clones are pin compatible (there is even a Bluetooth replacement 'Bee), thus any XBee shield or adapter can be used for either series.&#xD;&#xA;&#xD;&#xA;The difference is largely in their communication protocols. The Series 2 allow more robust mesh networking options. But for a beginner - the original (S1) provide simpler out-of-the-box networking.&#xD;&#xA;&#xD;&#xA;There are retail packages available that include a pair of S1 XBees, an Arduino compatible breakout board, and a USB adapter to program them. This allows you to get &quot;on the air&quot; and setup the XBees quickly. For communication between two arduinos, a pair of shields will make physical connectivity much easier." />
  <row Id="1947" PostHistoryTypeId="5" PostId="708" RevisionGUID="6cf6c54c-c875-4a2a-bcc1-44ebaa3f2bd6" CreationDate="2014-03-11T14:35:02.180" UserId="65" Comment="deleted 62 characters in body" Text="I need to communicate two arduinos each other via XBee. I am new to XBee and hardware.&#xD;&#xA;&#xD;&#xA;So my doubt is which XBee shield and XBee module I need to purchase. I read about XBee series 2, XB24 etc." />
  <row Id="1948" PostHistoryTypeId="6" PostId="707" RevisionGUID="ec67399f-7863-4b7b-b474-84f5d59faff9" CreationDate="2014-03-11T14:37:37.987" UserId="65" Comment="edited tags" Text="&lt;arduino-uno&gt;&lt;serial&gt;&lt;time&gt;" />
  <row Id="1949" PostHistoryTypeId="5" PostId="702" RevisionGUID="e6f17d84-63d0-4ae4-9e19-b5632abcaae7" CreationDate="2014-03-11T14:40:15.440" UserId="65" Comment="&quot;V&quot; is the unit for volts, not small v." Text="I have a [Pololu 5v AVR ISP](http://www.pololu.com/product/1300) which I have successfully used to program several Arduinos (a Mega, an Uno and a Pro Mini 5v). I now have a new Arduino compatible clone which is basically a clone of the pro mini 3.3V.&#xD;&#xA;&#xD;&#xA;I am wondering if anyone else has used this programmer to program a 3.3V board without issues. I've seen a forum post on [pololu's forum](http://forum.pololu.com/viewtopic.php?f=3&amp;t=7368) which discusses modifications required - but I don't really understand what is necessary.&#xD;&#xA;&#xD;&#xA;I've also found the software tool mentioned in the above forum post [here](http://www.pololu.com/docs/0J41) and I have downloaded it and built it.&#xD;&#xA;&#xD;&#xA;When I run the aforementioned tool I get these options:&#xD;&#xA;&#xD;&#xA;    PgmCmd: Configuration and status utility for the Pololu USB AVR Programmer.&#xD;&#xA;    Version: 1.0.1.0&#xD;&#xA;    Options:&#xD;&#xA;     -l, --list             list available devices&#xD;&#xA;     -d, --device SERIALNUM (optional) select device with given serial number&#xD;&#xA;     -s, --status           display complete device status&#xD;&#xA;         --freq NUM         sets the ISP frequency (in units of kHz)&#xD;&#xA;         --linea ID&#xD;&#xA;           or --lineb ID    set serial control signal associated with line A or B.&#xD;&#xA;                            Valid IDs are: none, cd, dsr, ri, dtr, rts.&#xD;&#xA;                            Warning: dtr and rts are outputs: -f option is required&#xD;&#xA;         --swminor HEXNUM   AVR ISP software version minor (in hex, e.g. A)&#xD;&#xA;         --swmajor HEXNUM   AVR ISP software version major (in hex)&#xD;&#xA;         --hw HEXNUM        AVR ISP software hardware version (in hex)&#xD;&#xA;         --vddmin NUM       set minimum allowed target vdd (units of mV)&#xD;&#xA;         --vddmaxrange NUM  set maximum allowed target vdd range (units of mV)&#xD;&#xA;         --restoredefaults  restore factory settings&#xD;&#xA;         --bootloader       put device in to bootloader (firmware upgrade) mode&#xD;&#xA;&#xD;&#xA;I then ran the --status option with the serial number of my programmer and got this:&#xD;&#xA;&#xD;&#xA;    Serial number:                  00048632&#xD;&#xA;    Firmware version:               1.07&#xD;&#xA;    Settings:&#xD;&#xA;      ISP Frequency:                200 kHz&#xD;&#xA;      Line A Identity:              None&#xD;&#xA;      Line B Identity:              None&#xD;&#xA;      AVR ISP hardware version:     F&#xD;&#xA;      AVR ISP software version:     2.A&#xD;&#xA;      Target VDD allowed minimum:   4384 mV&#xD;&#xA;      Target VDD allowed max range: 512 mV&#xD;&#xA;    Last programming:&#xD;&#xA;      Error: None&#xD;&#xA;      Measured Target VDD Minimum:  N/A&#xD;&#xA;      Measured Target VDD Range:    N/A&#xD;&#xA;    SLO-scope:&#xD;&#xA;      State:                        Off&#xD;&#xA;      Line A output:                Off&#xD;&#xA;      Line B output:                Off&#xD;&#xA;&#xD;&#xA;From this I deduced that my programmer is currently set at between about 4.38V and 4.89V which I presume corresponds to the 5V approximate voltage of the normal Arduino chips.&#xD;&#xA;&#xD;&#xA;Given that the utility program allows me to set both the target minimum V&lt;sub&gt;dd&lt;/sub&gt; and the target V&lt;sub&gt;dd&lt;/sub&gt; max range should I therefore set it to something like a minimum of 2704 with a max range of 512 which should put the signal voltages at up to ~3.2V.&#xD;&#xA;&#xD;&#xA;Is that all I have to do to get this to work?" />
  <row Id="1950" PostHistoryTypeId="2" PostId="710" RevisionGUID="b30971df-2098-492c-af02-ac938725662f" CreationDate="2014-03-11T15:28:40.127" UserId="379" Text="I can think of a few things that can impact the &quot;consistency&quot; of the serial write timings:&#xD;&#xA;&#xD;&#xA; * size of the data to be printout&#xD;&#xA;&#xD;&#xA;this may be the most obvious thing to think of, but indeed the more you print, the more it'll take to handle it.&#xD;&#xA;&#xD;&#xA;Solution: print format the string into a string of known length.&#xD;&#xA;&#xD;&#xA; * using buffered serial&#xD;&#xA;&#xD;&#xA;on unix you can access the serial port using a buffered or an unbuffered way. Using the buffered way for a long time may make it a bit slower as the buffer fills, usually it happens when data is incoming faster than you're reading it…&#xD;&#xA;&#xD;&#xA;Solution: use the unbuffered serial line (*e.g.*: on Darwin/OSX it's `/dev/cu.usbmodemXXX` instead of `/dev/tty.usbmodemXXX`)&#xD;&#xA;&#xD;&#xA; * priority of the timers&#xD;&#xA;&#xD;&#xA;it looks like your using a TC interrupt, and AVRs have priorities in the way interrupts are handled, I don't know the order of priority for the Atmega328, and it's not one of the most documented feature around, so I don't know how safe is TC0 versus the UART interrupt.&#xD;&#xA;&#xD;&#xA;Solution: look up further in the documentation/datasheet about interrupt priorities and change the timer if needed ; and/or do a test without having the other timer running.&#xD;&#xA;&#xD;&#xA; * the data you're reading from takes more time to read from over time&#xD;&#xA;&#xD;&#xA;some drivers need to average or do some operations over the previous values, so the more values you measure, the longer the buffer is, and the longer it takes to calculate the value, until you've reached the maximum size of the buffer.&#xD;&#xA;&#xD;&#xA;Solution: look at the source code of the library you're using, and either optimize it, remove the calcul if there's one or take that increasing processing time into account.&#xD;&#xA;&#xD;&#xA; * avoiding the arduino framework overhead&#xD;&#xA;&#xD;&#xA;but if you *really* want to optimize serial output from the arduino, you should avoid using the arduino overhead… But it's way less elegant and comfortable to use.&#xD;&#xA;&#xD;&#xA;I'm pretty sure there are other points I'm missing, but that's the first things that I'd check before digging further.&#xD;&#xA;&#xD;&#xA;HTH" />
  <row Id="1951" PostHistoryTypeId="2" PostId="711" RevisionGUID="f9c20909-ed96-48b5-805c-7c1f9b741f1a" CreationDate="2014-03-11T16:07:59.987" UserId="313" Text="If interrupts are turned off for any significant fraction `eHealth.getECG()` call duration, `millis()`'s count could fall behind. Otherwise, `millis()` should return much more accurate time than the 3x errors you described. &#xD;&#xA;&#xD;&#xA;You said your sampled signal appears higher in frequency than what you expected, which could happen if your sample rate is lower than you intended. Are you a assuming a 20Hz sample rate? Your loop could be taking a fair bit longer than 50ms, which you would see in the printed times, but those should still track the clock time. If you didn't account for that but assumed 50ms/sample, you'd see an apparent speed up of of the data.&#xD;&#xA;&#xD;&#xA;If this is not the issue, then the next step would be to toggle an output while you're in `loop()`, and measure the frequency of the resulting square wave with a frequency meter (some inexpensive DVMs can do this) or a 'scope. Do the same thing with an empty `loop()`. The first experiment will your real sampling rate or interval; the second will tell you whether `millis()` (ie., the timer0 frequency) is what you expected." />
  <row Id="1952" PostHistoryTypeId="2" PostId="712" RevisionGUID="df9f74eb-2329-47f8-a77f-a0cebbd5ed0d" CreationDate="2014-03-11T16:36:25.093" UserId="313" Text="My general rule for embedded systems is to only `malloc()` large buffers and only once, at the start of the program, e.g., in `setup()`. The trouble comes when you allocate and de-allocate memory. Over a long run session, memory becomes fragmented and eventually, an allocation fails due to lack of a sufficiently large free area, even if the total free memory is more than adequate for the request. &#xD;&#xA;&#xD;&#xA;(Historical perspective, skip if not interested): Depending on the loader implementation, the only advantage of run-time allocation vs. compile-time allocation (intialized globals) is the size of the hex file. When embedded systems were built with off the shelf computers having all volatile memory, the program was often uploaded to the embedded system from a network or an instrumentation computer and the upload time was sometimes an issue. Leaving out buffers full of zeros from the image could shorten the time considerably.)&#xD;&#xA;&#xD;&#xA;If I need dynamic memory allocation in an embedded system, I generally `malloc()` a pool of fixed-size buffers (or one pool each of small- and large buffers, respectively) and do my own allocation/de-allocation from that pool. That is, every request for any amount of memory up to the fixed buffer size is honored by returning one of those buffers - the calling function doesn't need to know that. Avoiding splitting and re-combining blocks solves fragmentation. Of course memory leaks can still occur if the program has allocate/de-allocate bugs." />
  <row Id="1953" PostHistoryTypeId="5" PostId="712" RevisionGUID="0ea5df3d-add7-4a3d-ad8d-b87e8a37f908" CreationDate="2014-03-11T16:43:49.160" UserId="313" Comment="added 32 characters in body" Text="My general rule for embedded systems is to only `malloc()` large buffers and only once, at the start of the program, e.g., in `setup()`. The trouble comes when you allocate and de-allocate memory. Over a long run session, memory becomes fragmented and eventually an allocation fails due to lack of a sufficiently large free area, even though the total free memory is more than adequate for the request. &#xD;&#xA;&#xD;&#xA;(Historical perspective, skip if not interested): Depending on the loader implementation, the only advantage of run-time allocation vs. compile-time allocation (intialized globals) is the size of the hex file. When embedded systems were built with off the shelf computers having all volatile memory, the program was often uploaded to the embedded system from a network or an instrumentation computer and the upload time was sometimes an issue. Leaving out buffers full of zeros from the image could shorten the time considerably.)&#xD;&#xA;&#xD;&#xA;If I need dynamic memory allocation in an embedded system, I generally `malloc()` a pool of fixed-size buffers (or one pool each of small- and large buffers, respectively) and do my own allocation/de-allocation from that pool. That is, every request for any amount of memory up to the fixed buffer size is honored with one of those buffers. The calling function doesn't need to know whether it's larger than requested and by avoiding splitting and re-combining blocks we solve fragmentation. Of course memory leaks can still occur if the program has allocate/de-allocate bugs." />
  <row Id="1954" PostHistoryTypeId="10" PostId="708" RevisionGUID="0becde52-2a8b-4a33-b905-845f749062aa" CreationDate="2014-03-11T17:00:34.250" UserId="11" Comment="103" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:65,&quot;DisplayName&quot;:&quot;AsheeshR&quot;},{&quot;Id&quot;:37,&quot;DisplayName&quot;:&quot;The Guy with The Hat&quot;},{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="1956" PostHistoryTypeId="2" PostId="713" RevisionGUID="043af5ab-1f90-499e-86be-7b09a68f0d1f" CreationDate="2014-03-11T17:16:42.697" UserId="83" Text="Use a timer and ISR (interrupt service routine) to make timing more accurate. &#xD;&#xA;&#xD;&#xA;Take a look at my [1ms timed interrupt Proof of Concept](http://blog.linformatronics.nl/213/electronics/timed-1-millisecond-interrupt-routine-for-arduino). The idea is to have a reasonably accurate 1ms 'heartbeat' in the system that can be used to trigger other events. In the PoC it is used to blink an LED at ½Hz, but having access to the new variables `millisecondCounter` and `secondCounter` enables you to trigger events in the main loop at arbitrary (but accurately timed) moments." />
  <row Id="1957" PostHistoryTypeId="2" PostId="714" RevisionGUID="ab5aebb7-813c-4774-8073-8fe0c46b9282" CreationDate="2014-03-11T17:54:18.690" UserId="555" Text="i needed to re-range the 10bit input to 8 bit for the pwm out.&#xD;&#xA;&#xD;&#xA;    // to run on attiny85&#xD;&#xA;    &#xD;&#xA;    const byte pwmPin = 0;&#xD;&#xA;    const byte analogInPin = A2;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      pinMode(pwmPin, OUTPUT);&#xD;&#xA;      int analogIn = analogRead(analogInPin);&#xD;&#xA;     analogIn = map(analogIn, 0, 1023, 0, 255);&#xD;&#xA;     analogWrite(pwmPin, analogIn);&#xD;&#xA;    }" />
  <row Id="1958" PostHistoryTypeId="5" PostId="234" RevisionGUID="56bd0f88-9a5e-42b2-8e6b-a29b779706a8" CreationDate="2014-03-11T18:37:31.400" UserId="194" Comment="added doc link" Text="There is one mechanism that can get MCU from erratic state and it's the **watchdog timer**. If you're implementing some code that will repeatedly run in a loop, that will not run anytime longer than some fixed time, you can set this time as watchdog period and enable the timer. &#xD;&#xA;&#xD;&#xA;Then, you have to repeatedly reset the timer in the loop. If your code freezes at some condition loop that will never end, then the watchdog will count to zero and eventually reset the MCU.&#xD;&#xA;&#xD;&#xA;This way you are losing data, but if you run the AVR WDT in interrupt mode, you can store some data before resetting the MCU.&#xD;&#xA;&#xD;&#xA;So the watchdog timer can guard your code from occasional unintended endles loops.&#xD;&#xA;&#xD;&#xA;Documentation: [AVR132: Using the Enhanced Watchdog Timer][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/Images/doc2551.pdf" />
  <row Id="1959" PostHistoryTypeId="5" PostId="631" RevisionGUID="6fdd11b9-be04-406f-afea-2db5b0d4eb29" CreationDate="2014-03-11T19:35:55.160" UserId="11" Comment="added 1211 characters in body" Text="Another way to do it, in case you just want to for the fun of it would be to put a metal rod inside the roll, and a metal plate on the outside, and measure the capacitance which should change with the TP remaining due to the dielectric constant of the paper.&#xD;&#xA;&#xD;&#xA;But that would be taking the &quot;scenic route&quot; for sure. Still, the Arduino can measure capacitance pretty easily and it might even be sensitive enough, and it would stay out of the way because it would just be a metal plate behind the roll and a metal rod in the roll. You might even be able to retrofit an existing holder without it being noticed.&#xD;&#xA;&#xD;&#xA;An easier way would be a stick attached to the shaft of a potentiometer held up by the top of the roll. Less TP, shaft goes lower and turns the pot. Might need a long shaft for leverage because you can't press too hard without impeding the function of pulling toilet paper.&#xD;&#xA;&#xD;&#xA;As AJMansfield suggested, Radioactivity actually is used to measure the thickness of things in industrial settings. If you really wanted to go crazy maybe you could use an extremely low energy radioactive source like a can of that weird tasting salt substitute which is a tiny bit above background levels and average over extremely long times(toilet paper shouldn't change much from hour to hour), so this could actually be a reasonable if expensive way to do things.&#xD;&#xA;&#xD;&#xA;Infrared beam break sensors are also good, and if you position it right you could get it to block more light the fuller the roll was instead of just giving you and on or off signal.&#xD;&#xA;&#xD;&#xA;EDIT:&#xD;&#xA;Working Proof of concept of the capacitative approach. Only needs an arduino and 2 stiff wires. Precise to about an 8th of an inch, with a lot of noise. Pretty sure you could reliably get at least 1inch accuracy. Measurement time is about a minute. It's really sensitive to it's surroundings. You'd have to make sure anything metal within a foot stayed where it was or use shielding.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    float difference;&#xD;&#xA;    unsigned long i;&#xD;&#xA;    unsigned long j;&#xD;&#xA;    unsigned int temp;&#xD;&#xA;    volatile unsigned char blah;&#xD;&#xA;     &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      pinMode(5,OUTPUT);&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;     &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;     difference =0;&#xD;&#xA;     Serial.print(&quot;Measuring: &quot;);&#xD;&#xA;     &#xD;&#xA;     for(i=0;i&lt;100;i++)&#xD;&#xA;       {&#xD;&#xA;         for(j=0;j&lt;5000;j++)&#xD;&#xA;         {&#xD;&#xA;           digitalWrite(5,LOW);&#xD;&#xA;           &#xD;&#xA;           temp=analogRead(A0);&#xD;&#xA;           &#xD;&#xA;           digitalWrite(5,HIGH);&#xD;&#xA;           &#xD;&#xA;           temp = analogRead(A0)-temp;&#xD;&#xA;           if(temp&lt;1024)&#xD;&#xA;           {&#xD;&#xA;             difference += temp;&#xD;&#xA;           }&#xD;&#xA;           &#xD;&#xA;         }&#xD;&#xA;         //Random delay every 5000 samples helps avoid problems with interference by staggering the samples to cancel aliasing.&#xD;&#xA;         delay(random(1,50));&#xD;&#xA;         Serial.print(&quot;|&quot;);&#xD;&#xA;         &#xD;&#xA;       }&#xD;&#xA;       Serial.print(&quot;\n&quot;);&#xD;&#xA;       Serial.print(&quot;Value: &quot;);&#xD;&#xA;       Serial.print(difference/500000);&#xD;&#xA;       Serial.print(&quot;\nMeasurement Complete. Press Enter to begin another test.\n&quot;);&#xD;&#xA;       &#xD;&#xA;       while(!Serial.available())&#xD;&#xA;       {&#xD;&#xA;         blah = 20;&#xD;&#xA;       }&#xD;&#xA;       Serial.read();&#xD;&#xA;     &#xD;&#xA;     &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;http://pastebin.com/2W5y81AB&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1960" PostHistoryTypeId="5" PostId="662" RevisionGUID="7e7dce26-761f-4e61-8a4e-18fb59312635" CreationDate="2014-03-11T19:56:14.977" UserId="275" Comment="language cleanup" Text="As taken from the accepted answer from [When should you use a class vs a struct in C++?][1]&#xD;&#xA;&#xD;&#xA;&gt; The only difference between a class and a struct in C++ is that&#xD;&#xA;&gt; structs have default public members and bases and classes have default&#xD;&#xA;&gt; private members and bases. Both classes and structs can have a mixture&#xD;&#xA;&gt; of public and private members, can use inheritance, and can have&#xD;&#xA;&gt; member functions.&#xD;&#xA;&gt; &#xD;&#xA;&gt; I would recommend using structs as plain-old-data structures without&#xD;&#xA;&gt; any class-like features, and using classes as aggregate data&#xD;&#xA;&gt; structures with private data and member functions.&#xD;&#xA;&#xD;&#xA;Memory wise the access modifier makes no difference and given the memory constraints of the Arduino, people are less likely to use classes with complex hierarchies, but prefer the POD structs anyway.&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/a/54596/731620" />
  <row Id="1961" PostHistoryTypeId="24" PostId="662" RevisionGUID="7e7dce26-761f-4e61-8a4e-18fb59312635" CreationDate="2014-03-11T19:56:14.977" Comment="Proposed by 275 approved by 359 edit id of 227" />
  <row Id="1962" PostHistoryTypeId="5" PostId="634" RevisionGUID="404dc727-59ca-491d-8344-1ca64ffc8650" CreationDate="2014-03-11T20:41:27.550" UserId="220" Comment="added 503 characters in body" Text="**It's not that big of deal.** [The ATmega 328p datasheet](http://www.atmel.com/images/atmel-8271-8-bit-avr-microcontroller-atmega48a-48pa-88a-88pa-168a-168pa-328-328p_datasheet.pdf) states this:&#xD;&#xA;&#xD;&#xA;&gt; Temperature range: -40 to 85 degrees celsius.&#xD;&#xA;&#xD;&#xA;The same goes for the [USB chip on the Uno (ATmega 16u2 for UNO R3)](http://www.atmel.com/Images/7799S.pdf).&#xD;&#xA;&#xD;&#xA;That's inside your limits. It probably could go a bit colder than mentioned, but it'll shorten the length of the board a little bit.&#xD;&#xA;&#xD;&#xA;However, there are some things that may go wrong:&#xD;&#xA;&#xD;&#xA; - EEPROM might not be stored as long in extreme temperatures. Keep this in mind if you're storing critical data.&#xD;&#xA; - The voltage regulator may not perform as well in hot conditions&#xD;&#xA; - The crystal oscillator may not produce exact values. &lt;strike&gt;However, I would imagine that a few hertz more or less wouldn't affect a 16 MHz processor.&lt;/strike&gt; The tolerance is actually a little less than 1%. You may have some issues with serial (baud rate not correct). I would look into any communications like I2C also. (I don't know exactly how the clock line works... it might be fine for I2C.)&#xD;&#xA; - Resistors/capacitors may not produce the *exact* values. I'd imagine that the tolerance won't be more than 8% on resistors: most resistors are rated at 5% for normal temperatures. It does depend on the manufacturer. Capacitors do have a bigger tolerance, but their main purpose is to &quot;smooth&quot; a signal.&#xD;&#xA; - Extreme cooling/warming may cause minor expansion problems. (Note: it's fine once in a while, but not on an hourly basis of dropping 30 degrees.)&#xD;&#xA; - Other components (LCDs, etc.) should be kept in mind also when looking at the viability of keeping it outdoors.&#xD;&#xA;&#xD;&#xA;So as long as all the other components not on the board will happily run in the temperatures that you need, you should be fine. Also, as with all engineering, values often have added &quot;padding&quot; built in. (i.e. 5% tolerance is often 3-4%, maximum 12V it can run on 12.5V, etc.)*&#xD;&#xA;&#xD;&#xA;*&lt;sub&gt;What I mean by that is your Arduino won't explode when it's -41 degrees C. It's not great for it, but most likely you should be fine as long is it isn't a regular occurrence.&lt;/sub&gt;" />
  <row Id="1963" PostHistoryTypeId="19" PostId="564" RevisionGUID="0fb7d8c3-1ec7-418c-9c86-022fafea54c4" CreationDate="2014-03-12T00:51:36.550" UserId="220" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:220,&quot;DisplayName&quot;:&quot;Annonomus Person&quot;}]}" />
  <row Id="1968" PostHistoryTypeId="36" PostId="716" RevisionGUID="f69da9f8-3dde-4af6-9917-1bae33a83017" CreationDate="2014-03-12T02:39:28.960" UserId="-1" Comment="from http://stackoverflow.com/questions/22314193/using-more-than-one-ping-ultrasonic-range-finder" />
  <row Id="1969" PostHistoryTypeId="2" PostId="716" RevisionGUID="6a5b08d5-71d5-4de8-a8fe-636f29f23c14" CreationDate="2014-03-11T00:36:49.290" UserDisplayName="alexmac" Text="I have done various applications with the Ultrasonic [example project](https://github.com/alexmac131/NodeXbeeTank) but it is always using one pinger. I'd like to make a scanner resting on a servo sweep but to reduce sweep time use more than one censor.&#xD;&#xA;&#xD;&#xA;the documentation is rather basic [ping sonic](http://www.parallax.com/sites/default/files/downloads/28015-PING-Sensor-Product-Guide-v2.0.pdf) that states the signal 40khz is used.&#xD;&#xA;&#xD;&#xA;Down to the question now. Is there a means to tell one pinger to use 40Khz and another say  45Khz. &#xD;&#xA;&#xD;&#xA;This would allow me to scan two areas (different directions) per cycle, reducing the time frame to complete area scan by half.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="1970" PostHistoryTypeId="1" PostId="716" RevisionGUID="6a5b08d5-71d5-4de8-a8fe-636f29f23c14" CreationDate="2014-03-11T00:36:49.290" UserDisplayName="alexmac" Text="Using more than one Ping Ultrasonic Range Finder" />
  <row Id="1971" PostHistoryTypeId="3" PostId="716" RevisionGUID="6a5b08d5-71d5-4de8-a8fe-636f29f23c14" CreationDate="2014-03-11T00:36:49.290" UserDisplayName="alexmac" Text="&lt;robotics&gt;" />
  <row Id="1973" PostHistoryTypeId="5" PostId="708" RevisionGUID="e8c7a655-cc23-4192-b18b-af6dc40db4e3" CreationDate="2014-03-12T04:12:31.140" UserId="578" Comment="added 269 characters in body" Text="I need to communicate two arduinos each other via XBee. I am new to XBee and hardware.&#xD;&#xA;&#xD;&#xA;So my doubt is which XBee shield and XBee module I need to purchase. I read about XBee series 2, XB24 etc.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Update**&#xD;&#xA;&#xD;&#xA;My exact requirement is there are two Arduino UNO's ( actually there are many in the circle ), when 2 UNO's with ZBee comes closer for eg. say 10 meter distance, then need to send a message ( number ) to each other and light an LED or play a sound. " />
  <row Id="1974" PostHistoryTypeId="2" PostId="717" RevisionGUID="9eb0470f-bdca-47e4-bc45-0ed948ff98b8" CreationDate="2014-03-12T05:26:14.837" UserId="213" Text="Two more options - battery pack with convenient pre-made screw holes for Arduino, Raspberry.PI, and Beagle Board:&#xD;&#xA;&#xD;&#xA;![Smart Power Base][1]&#xD;&#xA;&#xD;&#xA;[Smart Power Base][2]&#xD;&#xA;&#xD;&#xA;Kicking it up a notch - using a cordless drill's 18V battery.  The project is meant for R.PI, but it would work just as well on Arduino, as the power supply is USB&#xD;&#xA;&#xD;&#xA;![Portable PI Power][3]&#xD;&#xA;&#xD;&#xA;[Portable PI Power][4]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/T0aHD.jpg&#xD;&#xA;  [2]: http://www.makershed.com/product_p/mkmts01.htm&#xD;&#xA;  [3]: http://i.stack.imgur.com/I9ct9.jpg&#xD;&#xA;  [4]: http://makezine.com/projects/portable-pi-power-raspbery-pi-to-go/" />
  <row Id="1976" PostHistoryTypeId="6" PostId="708" RevisionGUID="37a91fca-423a-454a-b0c5-80808bccd2ed" CreationDate="2014-03-12T07:44:31.767" UserId="11" Comment="edited tags" Text="&lt;arduino-uno&gt;&lt;sensors&gt;&lt;shields&gt;&lt;proximity&gt;" />
  <row Id="1977" PostHistoryTypeId="11" PostId="708" RevisionGUID="cd9e01b9-c8af-4779-9085-8eeec7fe6a7b" CreationDate="2014-03-12T07:44:32.080" UserId="11" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:46,&quot;DisplayName&quot;:&quot;Ricardo&quot;},{&quot;Id&quot;:84,&quot;DisplayName&quot;:&quot;jfpoilpret&quot;},{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="1979" PostHistoryTypeId="2" PostId="718" RevisionGUID="03671d64-f153-4285-b608-297a7abe698b" CreationDate="2014-03-12T12:51:56.400" UserId="8" Text="I don't think it would be very easy to change the frequency unless Parallax decides to release the firmware for the Ping. It is possible to use two, as long as you use a different data pin for each, but the ultrasonic signals may interfere." />
  <row Id="1980" PostHistoryTypeId="5" PostId="708" RevisionGUID="cc448bbd-4de4-4094-81e0-ce7b5771d41c" CreationDate="2014-03-12T12:59:04.927" UserId="65" Comment="Rephrased" Text="I need to communicate between two Arduinos using XBee. I am new to XBee and hardware. The two Arduino Unos need to send a message (number) to each other and light an LED or play a sound, when they come close within a 10 meter distance.&#xD;&#xA;&#xD;&#xA;So my doubt is which XBee shield and XBee module I need to purchase. I read about XBee series 2, XB24 etc." />
  <row Id="1981" PostHistoryTypeId="2" PostId="719" RevisionGUID="01349c6d-4217-49e3-84ab-133058350f89" CreationDate="2014-03-12T13:04:22.340" UserId="8" Text="Adding to Ron's answer, the Series 1 is a lot easier to use, because you have to flash firmware onto them and do all kinds of setup. The S1s work out of the box.&#xD;&#xA;&#xD;&#xA;Another thing to keep in mind is that Xbees use 3.3v I/O pins, while the Arduino uses 5v. Most Xbee shields have a Logic Level Converter to handle this, but there are some that don't, and those could damage your Xbee." />
  <row Id="1982" PostHistoryTypeId="2" PostId="720" RevisionGUID="f1ca53d8-0bde-4aa7-928c-ac5e501b2104" CreationDate="2014-03-12T13:35:37.633" UserId="37" Text="There is no way to change the frequency, however there are other ways of doing what you want to accomplish. I think the best thing to do is stagger the timing of the pings so they don't happen at the same time.&#xD;&#xA;&#xD;&#xA;Example code, modified by me:&#xD;&#xA;&#xD;&#xA;&lt;!-- language: lang-c++ --&gt;&#xD;&#xA;&#xD;&#xA;    #include &lt;Servo.h&gt; &#xD;&#xA;    Servo servo; // create servo object to control a servo&#xD;&#xA;    &#xD;&#xA;    int pingPins[] = {7,8}; //The pins for the two sensors&#xD;&#xA;    char *pingString[] = {&quot;Ping1&quot;, &quot;Ping2&quot;};&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      servo.attach(10); // attaches a servo to pin 10&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      unsigned long ultrasoundValue;&#xD;&#xA;      for(int i = 0; i &lt; ultraSoundSignalPins.length; i++)&#xD;&#xA;      {&#xD;&#xA;        ultrasoundValue = ping(i);&#xD;&#xA;        Serial.print(pingString[i]);&#xD;&#xA;        Serial.print(&quot;: &quot;);&#xD;&#xA;        Serial.print(ultrasoundValue);&#xD;&#xA;        Serial.print(&quot;in, &quot;);    &#xD;&#xA;        delay(50);&#xD;&#xA;      }&#xD;&#xA;      Serial.println();&#xD;&#xA;      delay(50);&#xD;&#xA;     } &#xD;&#xA;    &#xD;&#xA;    //Ping function&#xD;&#xA;    unsigned long ping(int i)&#xD;&#xA;    {&#xD;&#xA;      unsigned long echo;&#xD;&#xA;      &#xD;&#xA;      pinMode(pingPins[i], OUTPUT);         // Switch signalpin to output&#xD;&#xA;      digitalWrite(pingPins[i], LOW);       // Send low pulse&#xD;&#xA;      delayMicroseconds(2);                 // Wait for 2 microseconds&#xD;&#xA;      digitalWrite(pingPins[i], HIGH);      // Send high pulse&#xD;&#xA;      delayMicroseconds(5);                 // Wait for 5 microseconds&#xD;&#xA;      digitalWrite(pingPins[i], LOW);       // Holdoff&#xD;&#xA;      pinMode(pingPins[i], INPUT);          // Switch signalpin to input&#xD;&#xA;      digitalWrite(pingPins[i], HIGH);      // Turn on pullup resistor&#xD;&#xA;      echo = pulseIn(pingPins[i], HIGH);    //Listen for echo&#xD;&#xA;      return (echo / 58.138) * .39;         //convert to CM then to inches&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&lt;sup&gt;&#xD;&#xA;Sources:&#xD;&#xA;&lt;/sup&gt;&#xD;&#xA;&#xD;&#xA; - &lt;sup&gt;http://stackoverflow.com/questions/20273971/arduino-multiple-ultrasonic-sensors-interference&lt;/sup&gt;&#xD;&#xA; - &lt;sup&gt;http://forum.arduino.cc/index.php?topic=17898.0&lt;/sup&gt;" />
  <row Id="1983" PostHistoryTypeId="6" PostId="716" RevisionGUID="bdb771a8-6ccf-4804-a3e2-f72e4854765b" CreationDate="2014-03-12T14:56:02.643" UserId="11" Comment="edited tags" Text="&lt;sensors&gt;&lt;robotics&gt;" />
  <row Id="1984" PostHistoryTypeId="2" PostId="721" RevisionGUID="43fa7ee9-4e9c-4771-be02-8cbf349e72a8" CreationDate="2014-03-12T15:13:33.620" UserId="591" Text="I might not be in the best place to ask this and feel free to tell me to move my question to another StachExchange, but I am trying to build a device that will allow me to control at least a couple hundred raising platform. The goal of this is to create a real time editor for board games (more precisely Dungeons and Dragons). Ideally all the platform would move simultaneously and the platforms would be transparent to allow us to place L.E.D.'s inside them to color the platform (this way we can make wood brown, water blue etc). On our current setup we would have used acrylic prism 1inch x 1inch x 6 inch (width, length, height). and we wanted to use a CNC motor to move around and move the platform, obviously this is NOT simultaneous raising at all and had (on paper) quite a long update time (calculated approximately 1 sec per platform), CNC is the only solution we found that had a reasonable cost/quality (a CNC motor per platform also raise the power consumption too high). Then we found this http://i.imgur.com/jBo02Zh.gif, Clearly WAY better then our idea but i have no idea how he did this, he seems to have thousands of platform and they all work simultaneously, His platforms are much smaller too which could be nice to have but 1 inch ^2 is fine for our use. So my question is. What would you guys recommend to raise simultaneously a thousand small platform ?" />
  <row Id="1985" PostHistoryTypeId="1" PostId="721" RevisionGUID="43fa7ee9-4e9c-4771-be02-8cbf349e72a8" CreationDate="2014-03-12T15:13:33.620" UserId="591" Text="How to ascent and descend a thousand platform" />
  <row Id="1986" PostHistoryTypeId="3" PostId="721" RevisionGUID="43fa7ee9-4e9c-4771-be02-8cbf349e72a8" CreationDate="2014-03-12T15:13:33.620" UserId="591" Text="&lt;motor&gt;" />
  <row Id="1987" PostHistoryTypeId="5" PostId="721" RevisionGUID="b6cd60ad-841e-419b-b0d1-4d203282da81" CreationDate="2014-03-12T15:19:17.227" UserId="591" Comment="added 121 characters in body" Text="I might not be in the best place to ask this and feel free to tell me to move my question to another StachExchange, but I am trying to build a device that will allow me to control at least a couple hundred raising platform. The goal of this is to create a real time editor for board games (more precisely Dungeons and Dragons). Ideally all the platform would move simultaneously and the platforms would be transparent to allow us to place L.E.D.'s inside them to color the platform (this way we can make wood brown, water blue etc). On our current setup we would have used acrylic prism 1inch x 1inch x 6 inch (width, length, height). and we wanted to use a CNC motor to move around and move the platform, obviously this is NOT simultaneous raising at all and had (on paper) quite a long update time (calculated approximately 1 sec per platform), CNC is the only solution we found that had a reasonable cost/quality (a CNC motor per platform also raise the power consumption too high). Then we found this http://i.imgur.com/jBo02Zh.gif, Clearly WAY better then our idea but i have no idea how he did this, he seems to have thousands of platform and they all work simultaneously, His platforms are much smaller too which could be nice to have but 1 inch ^2 is fine for our use. We also dont want the real time interractive thing. Loading from computer and staying static until we change it is good. So my question is. What would you guys recommend to raise simultaneously a thousand small platform ?" />
  <row Id="1988" PostHistoryTypeId="5" PostId="721" RevisionGUID="ac50dcc2-6f99-4a75-965a-f4231dfd289e" CreationDate="2014-03-12T15:27:52.360" UserId="65" Comment="grammar;" Text="I might not be in the best place to ask this and feel free to tell me to move my question to another Stack Exchange.&#xD;&#xA;&#xD;&#xA;I am trying to build a device that will allow me to control at least a couple hundred raising platforms. The goal of this is to create a real time editor for board games (more precisely Dungeons and Dragons). Ideally all the platforms would move simultaneously and the platforms would be transparent to allow us to place L.E.D.'s inside them to color the platform (this way we can make wood brown, water blue etc). &#xD;&#xA;&#xD;&#xA;On our current setup, we have used acrylic prism 1 inch x 1 inch x 6 inch (width, length, height) and we wanted to use a CNC motor to move around and move the platform. Obviously, this is NOT simultaneous raising at all and had (on paper) quite a long update time (calculated approximately 1 sec per platform).  CNC is the only solution we found that had a reasonable cost/quality (a CNC motor per platform also raised the power consumption very high). Then, we found  [this](http://i.imgur.com/jBo02Zh.gif).&#xD;&#xA;&#xD;&#xA;Clearly, WAY better then our idea but I have no idea how he did this. He seems to have thousands of platforms and they all work simultaneously; his platforms are much smaller too which could be nice to have but 1 inch ^2 is fine for our use. We also dont want the real time interactive thing. Loading from computer and staying static until we change it is good. So my question is. &#xD;&#xA;&#xD;&#xA;What would you guys recommend to raise simultaneously a thousand small platforms?" />
  <row Id="1989" PostHistoryTypeId="6" PostId="721" RevisionGUID="ac50dcc2-6f99-4a75-965a-f4231dfd289e" CreationDate="2014-03-12T15:27:52.360" UserId="65" Comment="grammar;" Text="&lt;system-design&gt;" />
  <row Id="1990" PostHistoryTypeId="4" PostId="721" RevisionGUID="ac50dcc2-6f99-4a75-965a-f4231dfd289e" CreationDate="2014-03-12T15:27:52.360" UserId="65" Comment="grammar;" Text="How do I manipulate a large number of moving platforms?" />
  <row Id="1991" PostHistoryTypeId="5" PostId="721" RevisionGUID="59ed11b2-b876-4dbe-a35c-5bc94a1530f2" CreationDate="2014-03-12T15:47:17.317" UserId="591" Comment="added 514 characters in body" Text="I might not be in the best place to ask this and feel free to tell me to move my question to another Stack Exchange.&#xD;&#xA;&#xD;&#xA;I am trying to build a device that will allow me to control at least a couple hundred raising platforms. The goal of this is to create a real time editor for board games (more precisely Dungeons and Dragons). Ideally all the platforms would move simultaneously and the platforms would be transparent to allow us to place L.E.D.'s inside them to color the platform (this way we can make wood brown, water blue etc). &#xD;&#xA;&#xD;&#xA;On our current setup, we have used acrylic prism 1 inch x 1 inch x 6 inch (width, length, height) and we wanted to use a CNC motor to move around and move the platform. Obviously, this is NOT simultaneous raising at all and had (on paper) quite a long update time (calculated approximately 1 sec per platform).  CNC is the only solution we found that had a reasonable cost/quality (a CNC motor per platform also raised the power consumption very high).After a few weeks of looking around, planning and throwing stupid ideas away, we found  [this](http://i.imgur.com/jBo02Zh.gif).&#xD;&#xA;&#xD;&#xA;Clearly, WAY better then our idea but I have no idea how he did this. They have 900 and they all work simultaneously; his platforms are much smaller too which could be nice to have but 1 inch ^2 is fine for our use. We also don't want the real time interactive thing. Loading from computer and staying static until we change it is good (though water movement would be really nice). So my question is. &#xD;&#xA;&#xD;&#xA;What would you guys recommend to raise simultaneously a thousand small platforms?&#xD;&#xA;&#xD;&#xA;Full video of the MIT product [video](http://www.youtube.com/watch?v=lvtfD_rJ2hE)&#xD;&#xA;&#xD;&#xA;Key difference between their implementation and our goal:&#xD;&#xA;&#xD;&#xA; - No real-time interraction with the table. Controlled by and arduino and or a computer is fine.&#xD;&#xA; - Size of the platforms will be closer to 1 inch^2&#xD;&#xA; - All sides of the platform should be light up, but I believe this is mostly a question of choosing the right material&#xD;&#xA;" />
  <row Id="1992" PostHistoryTypeId="5" PostId="721" RevisionGUID="0706b4c5-5e79-401f-acd8-cc009562f957" CreationDate="2014-03-12T16:19:50.087" UserId="591" Comment="added 259 characters in body" Text="I might not be in the best place to ask this and feel free to tell me to move my question to another Stack Exchange.&#xD;&#xA;&#xD;&#xA;I am trying to build a device that will allow me to control at least a couple hundred raising platforms. The goal of this is to create a real time editor for board games (more precisely Dungeons and Dragons). Ideally all the platforms would move simultaneously and the platforms would be transparent to allow us to place L.E.D.'s inside them to color the platform (this way we can make wood brown, water blue etc). &#xD;&#xA;&#xD;&#xA;On our current setup, we have used acrylic prism 1 inch x 1 inch x 6 inch (width, length, height) and we wanted to use a CNC motor to move around and move the platform. Obviously, this is NOT simultaneous raising at all and had (on paper) quite a long update time (calculated approximately 1 sec per platform).  CNC is the only solution we found that had a reasonable cost/quality (a CNC motor per platform also raised the power consumption very high).After a few weeks of looking around, planning and throwing stupid ideas away, we found  [this](http://www.youtube.com/watch?v=lvtfD_rJ2hE).&#xD;&#xA;&#xD;&#xA;Clearly, WAY better then our idea but I have no idea how he did this. They have 900 and they all work simultaneously; his platforms are much smaller too which could be nice to have but 1 inch ^2 is fine for our use. We also don't want the real time interactive thing. Loading from computer and staying static until we change it is good (though water movement would be really nice). So my question is. &#xD;&#xA;&#xD;&#xA;What would you guys recommend to raise simultaneously a thousand small platforms?&#xD;&#xA;&#xD;&#xA;Also this [document](http://tmg-trackr.media.mit.edu:8020/SuperContainer/RawData/Papers/527-inFORM%20Dynamic%20Physical%20Affordances/Published/PDF) that the devs made. Doing a bit more research I found that the device they used to move the platforms cost approx 30$, I don't think I need to say this, but I don't have 27000$ :(&#xD;&#xA;&#xD;&#xA;Key difference between their implementation and our goal:&#xD;&#xA;&#xD;&#xA; - No real-time interaction with the table. Controlled by and arduino and or a computer is fine.&#xD;&#xA; - Size of the platforms will be closer to 1 inch^2&#xD;&#xA; - All sides of the platform should be light up, but I believe this is mostly a question of choosing the right material&#xD;&#xA;" />
  <row Id="1997" PostHistoryTypeId="4" PostId="708" RevisionGUID="21af435f-1189-407e-97ab-d58bf4670824" CreationDate="2014-03-12T16:37:55.333" UserId="11" Comment="edited title" Text="XBee shield communication" />
  <row Id="1998" PostHistoryTypeId="2" PostId="723" RevisionGUID="0c78d0f7-ba91-4349-ac89-5e5fceaf1228" CreationDate="2014-03-12T16:47:08.177" UserId="11" Text="The only way I can think of accomplishing this without some sort of proximity sensor is to measure the signal strength of the XBees.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;From [page 41 of the datasheet][1]:&#xD;&#xA;&#xD;&#xA;&gt; **DB (Received Signal Strength) Command**&#xD;&#xA;&gt;&#xD;&#xA;&gt; **AT Command:** ATDB&#xD;&#xA;&gt;&#xD;&#xA;&gt; **Parameter Range [read-only]:**  0x17-0x5C (XBee), 0x24-0x64 (XBee-PRO)&#xD;&#xA;&gt; &#xD;&#xA;&gt; &lt;Diagnostics&gt; DB parameter is used to read the received signal&#xD;&#xA;&gt; strength (in dBm) of the last RF packet received. Reported values are&#xD;&#xA;&gt; accurate between -40 dBm and the RF module's receiver sensitivity.&#xD;&#xA;&gt; Absolute values are reported. For example: 0x58 = -88 dBm (decimal).&#xD;&#xA;&gt; If no packets have been received (since last reset, power cycle or&#xD;&#xA;&gt; sleep event), “0” will be reported.&#xD;&#xA;&#xD;&#xA;You can use this as a **rough** estimate of the distance between two sensors. You will have to correlate signal strength to actual distance and obstructions and other factors will cause the reported value to be off.&#xD;&#xA;&#xD;&#xA;[How to measure XBee signal strength?][2]&#xD;&#xA;&#xD;&#xA;This page has an example using Processing (on the computer): [XBee Signal Strength][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sparkfun.com/datasheets/Wireless/Zigbee/XBee-Datasheet.pdf&#xD;&#xA;  [2]: http://forum.arduino.cc/index.php?topic=151145.0&#xD;&#xA;  [3]: http://www.makingthingstalk.com/chapter8/22/" />
  <row Id="1999" PostHistoryTypeId="2" PostId="724" RevisionGUID="425c5a0d-bedf-411b-85a2-fb2faa77fbe2" CreationDate="2014-03-13T01:36:25.043" UserId="490" Text="I have a [Parallax 27800 2-Axis Joystick][1] wired up to a [AVR 14 Pin 20MHz 8K 12A/D - ATtiny84][2]. The joy stick sends out a x y analog signal. I have programmed the Attiny84 to read the signals and set one of the attiny84 pins (high or low) depending on the direction of the joystick. In this example, each pin is wired up to a LED. The problem I am having is there is about a 1 second delay for the LED to light. The Attiny84 has a built in 8MHz clock. Would connecting an external 20MHz crystal fix this issue?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.radioshack.com/product/index.jsp?productId=12345958&#xD;&#xA;  [2]: https://www.sparkfun.com/products/11232&#xD;&#xA;&#xD;&#xA;    int UD = 0;&#xD;&#xA;    int LR = 0;&#xD;&#xA;    &#xD;&#xA;    int DWN = 0;&#xD;&#xA;    int UP = 1;&#xD;&#xA;    int LEFT = 4;&#xD;&#xA;    int RT = 5;&#xD;&#xA;    &#xD;&#xA;    int LRMID = 0;&#xD;&#xA;    int UPMID = 0;&#xD;&#xA;    void setup(){&#xD;&#xA;      &#xD;&#xA;      pinMode(DWN, OUTPUT);&#xD;&#xA;      pinMode(UP, OUTPUT);  &#xD;&#xA;      pinMode(LEFT, OUTPUT); &#xD;&#xA;      pinMode(RT, OUTPUT);&#xD;&#xA;       &#xD;&#xA;      digitalWrite(DWN, LOW);&#xD;&#xA;      digitalWrite(UP, LOW);&#xD;&#xA;      digitalWrite(LEFT, LOW);&#xD;&#xA;      digitalWrite(RT, LOW);&#xD;&#xA;      &#xD;&#xA;      //calabrate center&#xD;&#xA;      LRMID = analogRead(3);&#xD;&#xA;      UPMID = analogRead(2);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop(){&#xD;&#xA;    &#xD;&#xA;      UD = analogRead(2);&#xD;&#xA;      LR = analogRead(3);&#xD;&#xA;      // UP-DOWN&#xD;&#xA;      if(UD &lt; UPMID - 5){&#xD;&#xA;       digitalWrite(DWN, HIGH);&#xD;&#xA;      }else{&#xD;&#xA;       digitalWrite(DWN, LOW);&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      if(UD &gt; UPMID + 5){&#xD;&#xA;       digitalWrite(UP, HIGH);&#xD;&#xA;      }else{&#xD;&#xA;       digitalWrite(UP, LOW);&#xD;&#xA;      }&#xD;&#xA;      // LEFT-RIGHT&#xD;&#xA;      if(LR &lt; LRMID-5){&#xD;&#xA;       digitalWrite(LEFT, HIGH);&#xD;&#xA;      }else{&#xD;&#xA;       digitalWrite(LEFT, LOW);&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      if(LR &gt; LRMID +5){&#xD;&#xA;       digitalWrite(RT, HIGH);&#xD;&#xA;      }else{&#xD;&#xA;       digitalWrite(RT, LOW);&#xD;&#xA;      }&#xD;&#xA;     &#xD;&#xA;      delay(100);&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    }" />
  <row Id="2000" PostHistoryTypeId="1" PostId="724" RevisionGUID="425c5a0d-bedf-411b-85a2-fb2faa77fbe2" CreationDate="2014-03-13T01:36:25.043" UserId="490" Text="Attiny84 and 2-Axis Joystick" />
  <row Id="2001" PostHistoryTypeId="3" PostId="724" RevisionGUID="425c5a0d-bedf-411b-85a2-fb2faa77fbe2" CreationDate="2014-03-13T01:36:25.043" UserId="490" Text="&lt;programming&gt;" />
  <row Id="2002" PostHistoryTypeId="2" PostId="725" RevisionGUID="9353127f-ab69-4cf0-8f9f-96dc668f66e5" CreationDate="2014-03-13T02:17:11.663" UserId="600" Text="I have a custom Arduino ATMega328 board that generally runs at 5V @ 8MHz (using the Arduino Pro 3.3V 8MHz profile and bootloader). The main reason I'm using this setup is so that I can put the board to sleep when main power is disconnected and it starts being run off of battery power (3V from a coin cell). The 5V and 3V sources are diode OR'ed together and the 5V input is tied to INT0. In code, when it detects that INT0 has fallen low, it initializes sleep mode and everything powers down with the exception of the watchdog timer that keeps a 1Hz cycle to keep an internal count and check it the chip should be woken back up. This works *beautifully* when 5V power is applied first, then the battery is inserted, *then* 5V is disconnected. It goes to sleep and when 5V is brought back it wakes up and I can see it hasn't lost count.&#xD;&#xA;&#xD;&#xA;However, the problem comes when 3V is applied *first*. I'm honestly not sure if it's even booting. But what it is supposed to do is boot, check if INT0 (Digital 2) is low and, if so, go right to sleep. By watching the current draw I see that it powers up to a few mA for a couple seconds, then drops to about 0.3mA (still higher than it should be in sleep mode). But when I re-apply 5V, *nothing*. The power draw goes back up but it is unresponsive (over FTDI serial).&#xD;&#xA;&#xD;&#xA;Is there maybe something I'm missing that it can't be booted on 3V... in theory it should run just fine. " />
  <row Id="2003" PostHistoryTypeId="1" PostId="725" RevisionGUID="9353127f-ab69-4cf0-8f9f-96dc668f66e5" CreationDate="2014-03-13T02:17:11.663" UserId="600" Text="Bootup on lower power not functioning" />
  <row Id="2004" PostHistoryTypeId="3" PostId="725" RevisionGUID="9353127f-ab69-4cf0-8f9f-96dc668f66e5" CreationDate="2014-03-13T02:17:11.663" UserId="600" Text="&lt;battery&gt;" />
  <row Id="2005" PostHistoryTypeId="5" PostId="725" RevisionGUID="3d0228d4-740d-4bed-9eef-f28f269c3051" CreationDate="2014-03-13T03:08:07.803" UserId="600" Comment="added 352 characters in body" Text="I have a custom Arduino ATMega328 board that generally runs at 5V @ 8MHz (using the Arduino Pro 3.3V 8MHz profile and bootloader). The main reason I'm using this setup is so that I can put the board to sleep when main power is disconnected and it starts being run off of battery power (3V from a coin cell). The 5V and 3V sources are diode OR'ed together and the 5V input is tied to INT0. In code, when it detects that INT0 has fallen low, it initializes sleep mode and everything powers down with the exception of the watchdog timer that keeps a 1Hz cycle to keep an internal count and check it the chip should be woken back up. This works *beautifully* when 5V power is applied first, then the battery is inserted, *then* 5V is disconnected. It goes to sleep and when 5V is brought back it wakes up and I can see it hasn't lost count.&#xD;&#xA;&#xD;&#xA;However, the problem comes when 3V is applied *first*. I'm honestly not sure if it's even booting. But what it is supposed to do is boot, check if INT0 (Digital 2) is low and, if so, go right to sleep. By watching the current draw I see that it powers up to a few mA for a couple seconds, then drops to about 0.3mA (still higher than it should be in sleep mode). But when I re-apply 5V, *nothing*. The power draw goes back up but it is unresponsive (over FTDI serial).&#xD;&#xA;&#xD;&#xA;Is there maybe something I'm missing that it can't be booted on 3V... in theory it should run just fine. &#xD;&#xA;&#xD;&#xA;**Update:** I dropped an LED onto D13 and tried the blink sketch. Works fine when starting from 3V or 5V. However, when I run my firmware and start it from 3V, the LED just starts flashing wildly. I have no idea what's causing it since I never even setup D13 as anything in my code. But it makes me thing it's something to do with the bootloader..." />
  <row Id="2006" PostHistoryTypeId="2" PostId="726" RevisionGUID="ce5fa795-1a37-4dcf-8fac-b3a1320a2014" CreationDate="2014-03-13T07:52:23.227" UserId="83" Text="- Are you absolutely sure your AVR is running at 8MHz, because default I believe it is scaling the 8MHz internal RC-oscillator down to 1MHz system clock. Change your F_CPU macro to 1MHz to see what happens.&#xD;&#xA;&#xD;&#xA;- If the 8MHz (or 1MHz for that matter) clock is really the issue (which I doubt), then you can first try to set the fuses to use the internal 16MHz clock. Cheaper solution than adding an external clock circuit.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2007" PostHistoryTypeId="5" PostId="726" RevisionGUID="03d41ad9-7e80-4bb5-8d27-5990ae4dd417" CreationDate="2014-03-13T10:36:23.797" UserId="83" Comment="added 11 characters in body" Text="- Are you absolutely sure your AVR is running at 8MHz, because default I believe it is scaling the 8MHz internal RC-oscillator down to 1MHz system clock. Change your F_CPU macro to 1MHz to see what happens.&#xD;&#xA;&#xD;&#xA;&lt;!--&#xD;&#xA;- If the 8MHz (or 1MHz for that matter) clock is really the issue (which I doubt), then you can first try to set the fuses to use the internal 16MHz clock. Cheaper solution than adding an external clock circuit.&#xD;&#xA;--&gt;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2008" PostHistoryTypeId="2" PostId="727" RevisionGUID="a6c6b06f-bab4-42b8-8bfc-7916c651db2c" CreationDate="2014-03-13T10:47:49.887" UserId="605" Text="I want to learn how to program microcontrollers using `Arduino` but I don't have an `Arduino` yet. Also I can't buy one at the moment but I would really like to start learning.&#xD;&#xA;&#xD;&#xA;Is there an `Arduino` emulator, with which you can simulate an `Arduino` board just like the `Android` or `IPhone` emulators?&#xD;&#xA;&#xD;&#xA;Thank you!" />
  <row Id="2009" PostHistoryTypeId="1" PostId="727" RevisionGUID="a6c6b06f-bab4-42b8-8bfc-7916c651db2c" CreationDate="2014-03-13T10:47:49.887" UserId="605" Text="Arduino Emulator" />
  <row Id="2010" PostHistoryTypeId="3" PostId="727" RevisionGUID="a6c6b06f-bab4-42b8-8bfc-7916c651db2c" CreationDate="2014-03-13T10:47:49.887" UserId="605" Text="&lt;arduino-uno&gt;&lt;emulation&gt;" />
  <row Id="2011" PostHistoryTypeId="5" PostId="727" RevisionGUID="d2ded503-23d1-4071-b2ad-0c18caba66ab" CreationDate="2014-03-13T11:02:53.220" UserId="65" Comment="backticks are for code." Text="I want to learn how to program microcontrollers using Arduino but I don't have an Arduino yet. Also I can't buy one at the moment but I would really like to start learning.&#xD;&#xA;&#xD;&#xA;Is there an Arduino emulator, with which you can simulate an Arduino board just like the Android or IPhone emulators?" />
  <row Id="2012" PostHistoryTypeId="10" PostId="727" RevisionGUID="87ae3d98-4f19-4992-b224-e7303d8a445e" CreationDate="2014-03-13T11:29:55.107" UserId="42" Comment="101" Text="{&quot;OriginalQuestionIds&quot;:[61],&quot;Voters&quot;:[{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;}]}" />
  <row Id="2013" PostHistoryTypeId="5" PostId="712" RevisionGUID="261d8dac-51e7-4446-823b-eeda20cff45c" CreationDate="2014-03-13T12:26:02.120" UserId="313" Comment="minor rewording for clarity" Text="My general rule for embedded systems is to only `malloc()` large buffers and only once, at the start of the program, e.g., in `setup()`. The trouble comes when you allocate and de-allocate memory. Over a long run session, memory becomes fragmented and eventually an allocation fails due to lack of a sufficiently large free area, even though the total free memory is more than adequate for the request. &#xD;&#xA;&#xD;&#xA;(Historical perspective, skip if not interested): Depending on the loader implementation, the only advantage of run-time allocation vs. compile-time allocation (intialized globals) is the size of the hex file. When embedded systems were built with off the shelf computers having all volatile memory, the program was often uploaded to the embedded system from a network or an instrumentation computer and the upload time was sometimes an issue. Leaving out buffers full of zeros from the image could shorten the time considerably.)&#xD;&#xA;&#xD;&#xA;If I need dynamic memory allocation in an embedded system, I generally `malloc()` a large pool and divide it into fixed-size buffers (or one pool each of small and large buffers, respectively) and do my own allocation/de-allocation from that pool. Then every request for any amount of memory up to the fixed buffer size is honored with one of those buffers. The calling function doesn't need to know whether it's larger than requested, and by avoiding splitting and re-combining blocks we solve fragmentation. Of course memory leaks can still occur if the program has allocate/de-allocate bugs." />
  <row Id="2014" PostHistoryTypeId="2" PostId="728" RevisionGUID="546100d7-f465-4c99-a6e3-9e55385a8a5e" CreationDate="2014-03-13T14:07:10.490" UserId="470" Text="Several AVR devices including ATtiny 84, have a clock prescaler that can be used to lower the core frequency.&#xD;&#xA;&#xD;&#xA;The divider can be controlled two ways.&#xD;&#xA;&#xD;&#xA;The first way is the **CKDIV8** fuse that controls the default loaded value to CLKPR (Clock prescale register) to either&#xD;&#xA;&#xD;&#xA;- **fuse disabled:**  Clock Division Factor 1 (clk/1)&#xD;&#xA;- **fuse enabled:** Clock Division Factor 8 (clk/8)&#xD;&#xA;&#xD;&#xA;The fuse is enabled by default and applies the clk/8 setting, it can be changed with a programmer.&#xD;&#xA;&#xD;&#xA;The second way is by changing the prescaler value during runtime. All you need to do is to include the following header&#xD;&#xA;&#xD;&#xA;    #include &lt;avr/power.h&gt;&#xD;&#xA;&#xD;&#xA;and call one of following functions with the appropriate value you want to use&#xD;&#xA;&#xD;&#xA;       clock_prescale_set(clock_div_1);    // Clock Division Factor 1&#xD;&#xA;       clock_prescale_set(clock_div_2);    // Clock Division Factor 2&#xD;&#xA;       clock_prescale_set(clock_div_4);    // Clock Division Factor 4&#xD;&#xA;       clock_prescale_set(clock_div_8);    // Clock Division Factor 8&#xD;&#xA;       clock_prescale_set(clock_div_16);   // Clock Division Factor 16&#xD;&#xA;       clock_prescale_set(clock_div_32);   // Clock Division Factor 32&#xD;&#xA;       clock_prescale_set(clock_div_64);   // Clock Division Factor 64&#xD;&#xA;       clock_prescale_set(lock_div_128);   // Clock Division Factor 128&#xD;&#xA;       clock_prescale_set(clock_div_256);  // Clock Division Factor 256&#xD;&#xA;&#xD;&#xA;[power.h manual](http://www.nongnu.org/avr-libc/user-manual/group__avr__power.html)&#xD;&#xA;&#xD;&#xA;Note that the above functions can be applied at any part of the program, for example you can lower the cpu frequency to reserve battery and then set it higher again for intensive tasks. Just be aware that all peripheral will work with the divided clock too so PWM, timers, SPI, UART etc will all be affected.&#xD;&#xA;&#xD;&#xA;If the problem you are facing is caused by the clock divider being in the /8 setting then you can change it at runtime.  &#xD;&#xA;&#xD;&#xA;Add the header at the start of the sketch&#xD;&#xA;&#xD;&#xA;    #include &lt;avr/power.h&gt;&#xD;&#xA;&#xD;&#xA;And then set the prescaler value to 1 at the start of setup()&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;                   clock_prescale_set(clock_div_1);  // set the clock prescaler to /1&#xD;&#xA;    }" />
  <row Id="2015" PostHistoryTypeId="2" PostId="729" RevisionGUID="9c573af3-1037-4d49-ad54-b039688911b0" CreationDate="2014-03-13T16:34:14.170" UserId="608" Text="My hardware is 4 potentiometers connected to Arduino Analog 0-3, the output is an RGB led driver connected to Digital outputs 9,10,11. The output channels provide access to PWM control of those pins. So idea is the color and intensity can be controlled by the Arduino. I wrote a simple Sketch that reads the potentiometers and then outputs PWM to the RGB driver circuitry. This works great! So the hardware is working! Now comes the Last potentiometer...&#xD;&#xA;&#xD;&#xA;I want to make the last potentiometer a &quot;mode select&quot; control. It would function like this....  If the last potentiometer(Pot4)is turned down all the way then all lights are off. If the level is turned up a little the Arduino then controls the RGB channels via Pots 1,2,3. If Pot4 is turned up to just past halfway the Sketch enters a &quot;strobe flash pattern&quot; pulsing all channels on and off. And if the mode control Pot4 is turned up all the Arduino turns on all RGB channels.&#xD;&#xA;&#xD;&#xA;How do implement such into software? Mode selection via a potentiometer....&#xD;&#xA;&#xD;&#xA;As you probably guessed, I know very little about programming..... " />
  <row Id="2016" PostHistoryTypeId="1" PostId="729" RevisionGUID="9c573af3-1037-4d49-ad54-b039688911b0" CreationDate="2014-03-13T16:34:14.170" UserId="608" Text="How to implement multiple modes in Sketch?" />
  <row Id="2017" PostHistoryTypeId="3" PostId="729" RevisionGUID="9c573af3-1037-4d49-ad54-b039688911b0" CreationDate="2014-03-13T16:34:14.170" UserId="608" Text="&lt;sketch&gt;&lt;analogwrite&gt;" />
  <row Id="2018" PostHistoryTypeId="2" PostId="730" RevisionGUID="1fa47934-732d-4a07-b381-d3fe209609e2" CreationDate="2014-03-13T16:41:37.180" UserId="554" Text="It would be relatively simple to do a threshold test on analogRead() to switch modes *(e.g. if the value is above 512 (analogRead() gives values between 0-1023)* then you switch modes (probably with a boolean variable that you can then use to decide whether to strobe the LEDs)." />
  <row Id="2019" PostHistoryTypeId="2" PostId="731" RevisionGUID="a6563179-be50-49ae-93ad-76a39c809fdc" CreationDate="2014-03-13T17:36:35.967" UserId="11" Text="Since you already know how to hook up a pot and read it's value, it's quite simple. You already have it hooked up in a voltage divider configuration and are getting a 10 bit (0-1023) value using [`analogRead()`][1], you just need to decide what to do with it.&#xD;&#xA;&#xD;&#xA;Assume `potVal` has the value of the pot.;&#xD;&#xA;&#xD;&#xA;    if (potVal &lt; 256) {&#xD;&#xA;        // Pot is one quarter turn or less&#xD;&#xA;    } else if (potVal &lt; 512) {&#xD;&#xA;        // Pot is between 256 and 512, so its more than quarter but less than half&#xD;&#xA;    } else if (potVal &lt; 768) {&#xD;&#xA;        // Pot is between half and 3/4ths of the way there&#xD;&#xA;    } else {&#xD;&#xA;        // Pot is greater than 3/4 of it's full range&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;So I have broken it down into four quadrants for you, but you can do it however you like.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/analogRead" />
  <row Id="2020" PostHistoryTypeId="5" PostId="729" RevisionGUID="6c6c9180-3c58-4176-a8db-c73b6aa92bfb" CreationDate="2014-03-13T18:15:19.450" UserId="275" Comment="language cleanup" Text="My hardware is 4 potentiometers connected to Arduino Analog 0-3, the output is an RGB led driver connected to Digital outputs 9,10,11. The output channels provide access to PWM control of those pins. So idea is the color and intensity can be controlled by the Arduino. I wrote a simple Sketch that reads the potentiometers and then outputs PWM to the RGB driver circuitry. This works great! So the hardware is working! Now comes the last potentiometer...&#xD;&#xA;&#xD;&#xA;I want to make the last potentiometer a &quot;mode select&quot; control. It would function like this: If the last potentiometer (Pot4) is turned down all the way, then all lights are off. If the level is turned up a little, the Arduino then controls the RGB channels via Pots 1, 2 &amp; 3. If Pot4 is turned up to just past halfway, the sketch enters a &quot;strobe flash pattern&quot; pulsing all channels on and off. And if the mode control Pot4 is turned up all the way, Arduino turns on all RGB channels.&#xD;&#xA;&#xD;&#xA;How do I implement? Mode selection via a potentiometer? " />
  <row Id="2021" PostHistoryTypeId="4" PostId="729" RevisionGUID="6c6c9180-3c58-4176-a8db-c73b6aa92bfb" CreationDate="2014-03-13T18:15:19.450" UserId="275" Comment="language cleanup" Text="How to implement multiple LED modes in a sketch with potentiometers?" />
  <row Id="2022" PostHistoryTypeId="6" PostId="729" RevisionGUID="6c6c9180-3c58-4176-a8db-c73b6aa92bfb" CreationDate="2014-03-13T18:15:19.450" UserId="275" Comment="language cleanup" Text="&lt;sketch&gt;&lt;analogwrite&gt;&lt;potentiometer&gt;" />
  <row Id="2023" PostHistoryTypeId="24" PostId="729" RevisionGUID="6c6c9180-3c58-4176-a8db-c73b6aa92bfb" CreationDate="2014-03-13T18:15:19.450" Comment="Proposed by 275 approved by 11 edit id of 228" />
  <row Id="2024" PostHistoryTypeId="2" PostId="732" RevisionGUID="7818aff1-bb46-4226-8eb1-48f8246c14a1" CreationDate="2014-03-13T18:33:24.297" UserId="353" Text="While @alexan_e’s suggestion fixed your practical problem, I would argue that it did not address your root cause, which is that whatever board setting you’re working from in boards.txt assumes a clock rate of 8MHz, while in reality your fuses are set to boot the microcontroller at 1MHz. This caused your delay(100) to take 800ms, and was the entire reason for the slowdown. &#xD;&#xA;&#xD;&#xA;Instead of fixing this at runtime, as aleman_e suggested, it seems more natural to me to bring your fuse settings into alignment with your compiler settings, using the “burn boot loader” Arduino command (which on Attinys generally does NOT burn a boot loader, but only sets the fuses to be in sync with the compiler settings).&#xD;&#xA;&#xD;&#xA;If your application is not going to become much more complex, running at 1MHz might be a more efficient choice than running at 8MHz. " />
  <row Id="2025" PostHistoryTypeId="2" PostId="733" RevisionGUID="14d3a8f2-d02b-47da-b6e9-4788f5a24f2b" CreationDate="2014-03-13T18:41:20.237" UserId="-1" Text="" />
  <row Id="2026" PostHistoryTypeId="2" PostId="734" RevisionGUID="968d6f3c-d735-43f4-9faf-b6961a0ff98e" CreationDate="2014-03-13T18:41:20.237" UserId="-1" Text="" />
  <row Id="2027" PostHistoryTypeId="5" PostId="734" RevisionGUID="8f84541a-e3ce-425b-929f-84d26f2174e1" CreationDate="2014-03-13T19:28:28.790" UserId="275" Comment="added 210 characters in body" Text="**Potentiometer** - short form **pot**. Electronic component forming a three-terminal resistor with a sliding contact that acts as a variable resistor / voltage divider and lets a variable current flow through." />
  <row Id="2028" PostHistoryTypeId="24" PostId="734" RevisionGUID="8f84541a-e3ce-425b-929f-84d26f2174e1" CreationDate="2014-03-13T19:28:28.790" Comment="Proposed by 275 approved by 11 edit id of 230" />
  <row Id="2029" PostHistoryTypeId="5" PostId="733" RevisionGUID="545c9b9a-88a0-4d6b-92a1-45e55da4021b" CreationDate="2014-03-13T19:28:37.273" UserId="275" Comment="added 547 characters in body" Text="**Potentiometer** - short form ***pot***. Electronic component forming a three-terminal resistor with a sliding contact that acts as a variable resistor / voltage divider and lets a variable current flow through.&#xD;&#xA;&#xD;&#xA;Potentiometers are commonly used to control electrical devices such as volume controls on audio equipment.&#xD;&#xA;&#xD;&#xA;*Wikipedia:* http://en.wikipedia.org/wiki/Potentiometer&#xD;&#xA;&#xD;&#xA;*Potentiometer Explanation:* http://www.electronics-tutorials.ws/io/io_2.html&#xD;&#xA;&#xD;&#xA;*Voltage Divider Tutorial:* https://learn.sparkfun.com/tutorials/voltage-dividers" />
  <row Id="2030" PostHistoryTypeId="24" PostId="733" RevisionGUID="545c9b9a-88a0-4d6b-92a1-45e55da4021b" CreationDate="2014-03-13T19:28:37.273" Comment="Proposed by 275 approved by 11 edit id of 229" />
  <row Id="2031" PostHistoryTypeId="2" PostId="735" RevisionGUID="6656bdb7-98fb-42c6-8ede-5246920289fa" CreationDate="2014-03-14T07:43:18.967" UserId="20" Text="I remember seeing [Primo](http://techcrunch.com/2013/11/24/primo/), this robot that is based on Arduino and serves to teach kids to program. My interest in the platform comes from there, but it is always nice to learn about other cool applications.&#xD;&#xA;&#xD;&#xA;What other applications for arduino in education are there?" />
  <row Id="2032" PostHistoryTypeId="1" PostId="735" RevisionGUID="6656bdb7-98fb-42c6-8ede-5246920289fa" CreationDate="2014-03-14T07:43:18.967" UserId="20" Text="Cool applications of arduino in education" />
  <row Id="2033" PostHistoryTypeId="3" PostId="735" RevisionGUID="6656bdb7-98fb-42c6-8ede-5246920289fa" CreationDate="2014-03-14T07:43:18.967" UserId="20" Text="&lt;project&gt;" />
  <row Id="2034" PostHistoryTypeId="2" PostId="736" RevisionGUID="2106e17b-4263-4fc5-99d7-3c9b8bd9e6f1" CreationDate="2014-03-14T10:41:10.037" UserId="617" Text="I've been trying to get colours fade into each other for a project I'm working on.&#xD;&#xA;I have achieved this with the rainbow effect that some from Adafruit's example code, however I want to be able to choose the colours (eg. dark blue into light blue).&#xD;&#xA;&#xD;&#xA;I've got the colours changing and fading, however the fade turns off all the LEDs and starts to increase the brightness of the new colour. I need the colours to blend rather than fade out and increase in brightness.&#xD;&#xA;&#xD;&#xA;Is anyone able to point me in the right direction?&#xD;&#xA;&#xD;&#xA;&lt;pre&gt;&#xD;&#xA;#include &quot;LPD8806.h&quot;&#xD;&#xA;#include &quot;SPI.h&quot;&#xD;&#xA;#define stripSize 64&#xD;&#xA;&#xD;&#xA;int nLEDs = 160;&#xD;&#xA;&#xD;&#xA;int dataPin  = 2;&#xD;&#xA;int clockPin = 3;&#xD;&#xA;&#xD;&#xA;// First parameter is the number of LEDs in the strand.  The LED strips&#xD;&#xA;// are 32 LEDs per meter but you can extend or cut the strip.  Next two&#xD;&#xA;// parameters are SPI data and clock pins:&#xD;&#xA;LPD8806 strip = LPD8806(64, dataPin, clockPin);&#xD;&#xA;&#xD;&#xA;// You can optionally use hardware SPI for faster writes, just leave out&#xD;&#xA;// the data and clock pin parameters.  But this does limit use to very&#xD;&#xA;// specific pins on the Arduino.  For &quot;classic&quot; Arduinos (Uno, Duemilanove,&#xD;&#xA;// etc.), data = pin 11, clock = pin 13.  For Arduino Mega, data = pin 51,&#xD;&#xA;// clock = pin 52.  For 32u4 Breakout Board+ and Teensy, data = pin B2,&#xD;&#xA;// clock = pin B1.  For Leonardo, this can ONLY be done on the ICSP pins.&#xD;&#xA;//LPD8806 strip = LPD8806(nLEDs);&#xD;&#xA;&#xD;&#xA;void setup() {&#xD;&#xA;  // Start up the LED strip&#xD;&#xA;  strip.begin();&#xD;&#xA;&#xD;&#xA;  // Update the strip, to start they are all 'off'&#xD;&#xA;  strip.show();&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void loop() {&#xD;&#xA;  //turnAllOn(strip.Color(30,30,30),4000);&#xD;&#xA;  fade(0, 127, 0, 100); //red, green, blue, delay - fade up all pixels one color&#xD;&#xA;  //turnAllOn(strip.Color(30,100,30),4000);&#xD;&#xA;  fade(50, 127, 02,100); //red, green, blue, delay - fade up all pixels one color&#xD;&#xA;  //turnAllOn(strip.Color(100,30,100),4000);&#xD;&#xA;  fade(50, 127, 50, 100); //red, green, blue, delay - fade up all pixels one color&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;void fade(uint32_t r, uint32_t g, uint32_t b, uint32_t wait) {&#xD;&#xA;  int i, j;&#xD;&#xA;  for (j=0; j &lt; 384; j++) {&#xD;&#xA;    for (i=0; i &lt; strip.numPixels(); i++) {&#xD;&#xA;      strip.setPixelColor(i, strip.Color((r*j)/1000,(g*j)/1000,(b*j)/1000));&#xD;&#xA;    }&#xD;&#xA;  strip.show();&#xD;&#xA;  }&#xD;&#xA;  delay(wait);&#xD;&#xA;}&#xD;&#xA;&lt;/pre&gt;&#xD;&#xA;void turnAllOn(uint32_t c, uint32_t wait) {&#xD;&#xA;  int i;  &#xD;&#xA;  for (i=0; i &lt; strip.numPixels(); i++) {&#xD;&#xA;    strip.setPixelColor(i, c);  // turn all pixels on&#xD;&#xA;  }&#xD;&#xA;  strip.show();   // write all the pixels out&#xD;&#xA;  delay(wait); &#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;uint32_t Wheel(uint16_t WheelPos)&#xD;&#xA;{&#xD;&#xA;  byte r, g, b;&#xD;&#xA;  switch(WheelPos / 128)&#xD;&#xA;  {&#xD;&#xA;    case 0:&#xD;&#xA;      r = 127 - WheelPos % 128;   //Red down&#xD;&#xA;      g = WheelPos % 128;      // Green up&#xD;&#xA;      b = 0;                  //blue off&#xD;&#xA;      break; &#xD;&#xA;    case 1:&#xD;&#xA;      g = 127 - WheelPos % 128;  //green down&#xD;&#xA;      b = WheelPos % 128;      //blue up&#xD;&#xA;      r = 0;                  //red off&#xD;&#xA;      break; &#xD;&#xA;    case 2:&#xD;&#xA;      b = 127 - WheelPos % 128;  //blue down &#xD;&#xA;      r = WheelPos % 128;      //red up&#xD;&#xA;      g = 0;                  //green off&#xD;&#xA;      break; &#xD;&#xA;  }&#xD;&#xA;  return(strip.Color(r,g,b));&#xD;&#xA;}&#xD;&#xA;&lt;/pre&gt;" />
  <row Id="2035" PostHistoryTypeId="1" PostId="736" RevisionGUID="2106e17b-4263-4fc5-99d7-3c9b8bd9e6f1" CreationDate="2014-03-14T10:41:10.037" UserId="617" Text="Digital RGB LED animation" />
  <row Id="2036" PostHistoryTypeId="3" PostId="736" RevisionGUID="2106e17b-4263-4fc5-99d7-3c9b8bd9e6f1" CreationDate="2014-03-14T10:41:10.037" UserId="617" Text="&lt;programming&gt;&lt;led&gt;&lt;c&gt;" />
  <row Id="2037" PostHistoryTypeId="5" PostId="736" RevisionGUID="d6de6a75-14ba-48cb-a777-d777c937d895" CreationDate="2014-03-14T10:53:22.070" UserId="42" Comment="Fixed code formatting. Removed unnecessary language tag." Text="I've been trying to get colours fade into each other for a project I'm working on.&#xD;&#xA;I have achieved this with the rainbow effect that some from Adafruit's example code, however I want to be able to choose the colours (eg. dark blue into light blue).&#xD;&#xA;&#xD;&#xA;I've got the colours changing and fading, however the fade turns off all the LEDs and starts to increase the brightness of the new colour. I need the colours to blend rather than fade out and increase in brightness.&#xD;&#xA;&#xD;&#xA;Is anyone able to point me in the right direction?&#xD;&#xA;&#xD;&#xA;    #include &quot;LPD8806.h&quot;&#xD;&#xA;    #include &quot;SPI.h&quot;&#xD;&#xA;    #define stripSize 64&#xD;&#xA;&#xD;&#xA;    int nLEDs = 160;&#xD;&#xA;&#xD;&#xA;    int dataPin  = 2;&#xD;&#xA;    int clockPin = 3;&#xD;&#xA;&#xD;&#xA;    // First parameter is the number of LEDs in the strand.  The LED strips&#xD;&#xA;    // are 32 LEDs per meter but you can extend or cut the strip.  Next two&#xD;&#xA;    // parameters are SPI data and clock pins:&#xD;&#xA;    LPD8806 strip = LPD8806(64, dataPin, clockPin);&#xD;&#xA;&#xD;&#xA;    // You can optionally use hardware SPI for faster writes, just leave out&#xD;&#xA;    // the data and clock pin parameters.  But this does limit use to very&#xD;&#xA;    // specific pins on the Arduino.  For &quot;classic&quot; Arduinos (Uno, Duemilanove,&#xD;&#xA;    // etc.), data = pin 11, clock = pin 13.  For Arduino Mega, data = pin 51,&#xD;&#xA;    // clock = pin 52.  For 32u4 Breakout Board+ and Teensy, data = pin B2,&#xD;&#xA;    // clock = pin B1.  For Leonardo, this can ONLY be done on the ICSP pins.&#xD;&#xA;    //LPD8806 strip = LPD8806(nLEDs);&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      // Start up the LED strip&#xD;&#xA;      strip.begin();&#xD;&#xA;&#xD;&#xA;      // Update the strip, to start they are all 'off'&#xD;&#xA;      strip.show();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      //turnAllOn(strip.Color(30,30,30),4000);&#xD;&#xA;      fade(0, 127, 0, 100); //red, green, blue, delay - fade up all pixels one color&#xD;&#xA;      //turnAllOn(strip.Color(30,100,30),4000);&#xD;&#xA;      fade(50, 127, 02,100); //red, green, blue, delay - fade up all pixels one color&#xD;&#xA;      //turnAllOn(strip.Color(100,30,100),4000);&#xD;&#xA;      fade(50, 127, 50, 100); //red, green, blue, delay - fade up all pixels one color&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void fade(uint32_t r, uint32_t g, uint32_t b, uint32_t wait) {&#xD;&#xA;      int i, j;&#xD;&#xA;      for (j=0; j &lt; 384; j++) {&#xD;&#xA;        for (i=0; i &lt; strip.numPixels(); i++) {&#xD;&#xA;          strip.setPixelColor(i, strip.Color((r*j)/1000,(g*j)/1000,(b*j)/1000));&#xD;&#xA;        }&#xD;&#xA;      strip.show();&#xD;&#xA;      }&#xD;&#xA;      delay(wait);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void turnAllOn(uint32_t c, uint32_t wait) {&#xD;&#xA;      int i;  &#xD;&#xA;      for (i=0; i &lt; strip.numPixels(); i++) {&#xD;&#xA;        strip.setPixelColor(i, c);  // turn all pixels on&#xD;&#xA;      }&#xD;&#xA;      strip.show();   // write all the pixels out&#xD;&#xA;      delay(wait); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    uint32_t Wheel(uint16_t WheelPos)&#xD;&#xA;    {&#xD;&#xA;      byte r, g, b;&#xD;&#xA;      switch(WheelPos / 128)&#xD;&#xA;      {&#xD;&#xA;        case 0:&#xD;&#xA;          r = 127 - WheelPos % 128;   //Red down&#xD;&#xA;          g = WheelPos % 128;      // Green up&#xD;&#xA;          b = 0;                  //blue off&#xD;&#xA;          break; &#xD;&#xA;        case 1:&#xD;&#xA;          g = 127 - WheelPos % 128;  //green down&#xD;&#xA;          b = WheelPos % 128;      //blue up&#xD;&#xA;          r = 0;                  //red off&#xD;&#xA;          break; &#xD;&#xA;        case 2:&#xD;&#xA;          b = 127 - WheelPos % 128;  //blue down &#xD;&#xA;          r = WheelPos % 128;      //red up&#xD;&#xA;          g = 0;                  //green off&#xD;&#xA;          break; &#xD;&#xA;      }&#xD;&#xA;      return(strip.Color(r,g,b));&#xD;&#xA;    }" />
  <row Id="2038" PostHistoryTypeId="6" PostId="736" RevisionGUID="d6de6a75-14ba-48cb-a777-d777c937d895" CreationDate="2014-03-14T10:53:22.070" UserId="42" Comment="Fixed code formatting. Removed unnecessary language tag." Text="&lt;programming&gt;&lt;led&gt;" />
  <row Id="2039" PostHistoryTypeId="2" PostId="737" RevisionGUID="b6548ff1-b6a4-4620-b35f-3a229a09d55f" CreationDate="2014-03-14T11:36:47.860" UserId="42" Text="Currently, your fade function is starting at 0 and effectively interpolating up to the desired colour. To fade between colours, you would need the sketch to remember the previous colour it used, and start fading from that instead of from 0.&#xD;&#xA;&#xD;&#xA;The approach I'd use is to start by calculating how much each component needs to change by on each step. For example, if you want to fade from 100 to 200 across 50 steps, then it needs to change by +2 on every step. If you wanted to do the same in reverse (200 to 100) then it would have to change by -2.&#xD;&#xA;&#xD;&#xA;One of the problems is that each component will probably be changing by a different amount (red might go from 0 to 200, but blue might only go from 50 to 70). If you're using integers all the time then it could result in some uneven transitions, so I'd recommend using floating point instead. It's technically slower (less efficient), but probably not enough to worry about.&#xD;&#xA;&#xD;&#xA;This is how I'd probably write it:&#xD;&#xA;&#xD;&#xA;    void fade(uint8_t oldR, uint8_t oldG, uint8_t oldB, uint8_t newR, uint8_t newG, uint8_t newB, uint32_t numSteps, uint32_t waitPerStep)&#xD;&#xA;    {&#xD;&#xA;        // Guard against division by zero&#xD;&#xA;        if (numSteps == 0) numSteps = 1;&#xD;&#xA;&#xD;&#xA;        // Calculate how how much each colour needs to change on each step&#xD;&#xA;        const float&#xD;&#xA;            stepR = (newR - oldR) / (float)numSteps,&#xD;&#xA;            stepG = (newG - oldG) / (float)numSteps,&#xD;&#xA;            stepB = (newB - oldB) / (float)numSteps;&#xD;&#xA;            &#xD;&#xA;        // These values will store our colours on the way along&#xD;&#xA;        float r = oldR, g = oldG, b = oldB;&#xD;&#xA;        uint8_t byteR = oldR, byteG = oldG, byteB = oldB;&#xD;&#xA;        &#xD;&#xA;        // Go through each fade step&#xD;&#xA;        const uint16_t numPixels = strip.numPixels();&#xD;&#xA;        for (uint32_t step = 0; step &lt; numSteps; ++step) {&#xD;&#xA;            // Move one step towards the target colour&#xD;&#xA;            r += stepR;&#xD;&#xA;            g += stepG;&#xD;&#xA;            b += stepB;&#xD;&#xA;            &#xD;&#xA;            // Round the colours to integers here so we don't have to do it repeatedly in the loop below&#xD;&#xA;            byteR = (uint8_t)(r + 0.5f);&#xD;&#xA;            byteG = (uint8_t)(g + 0.5f);&#xD;&#xA;            byteB = (uint8_t)(b + 0.5f);&#xD;&#xA;            &#xD;&#xA;            // Apply the colour to each pixel&#xD;&#xA;            for (uint16_t pixel = 0; pixel &lt; numPixels; ++pixel) {&#xD;&#xA;                strip.setPixelColor(pixel, byteR, byteG, byteB);&#xD;&#xA;            }&#xD;&#xA;            &#xD;&#xA;            strip.show();&#xD;&#xA;            delay(waitPerStep);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;As you can see, you pass it the old colour (which you're fading *from*) and the new colour (which you're fading *to*). As I mentioned above, this means your sketch has to remember which colour it previously used, as I don't think the library provides a way to read the current colour back.&#xD;&#xA;&#xD;&#xA;I've included some optimisations in there to make it run faster. There's more you could do to optimise it even further, if necessary.&#xD;&#xA;&#xD;&#xA;To use this, you'd do something like this:&#xD;&#xA;&#xD;&#xA;    // Fade from black to red and pause briefly&#xD;&#xA;    fade(0, 0, 0,  255, 0, 0,  100, 10);&#xD;&#xA;    delay(500);&#xD;&#xA;&#xD;&#xA;    // Fade from red to purple and pause briefly&#xD;&#xA;    fade(255, 0, 0,   255, 0, 255,  100, 10);&#xD;&#xA;    delay(500);&#xD;&#xA;&#xD;&#xA;    // Fade from purple to green and pause briefly&#xD;&#xA;    fade(255, 0, 255,  0, 255, 0,  100, 10);&#xD;&#xA;    delay(500);&#xD;&#xA;&#xD;&#xA;I've made a couple of other changes compared to your own fade function function. First of all, I've made it so that you can set the number of steps to fade over. This can be quite useful because bigger colour changes will need more steps to look smooth.&#xD;&#xA;&#xD;&#xA;I've also modified the `wait` parameter. In your code, you put the delay after the entire fade was complete, which seems like an odd approach. It makes more sense to allow a small delay between each step of the fade, so you can control how fast it goes.&#xD;&#xA;&#xD;&#xA;In my example above, you can see the `100, 10` parameters at the end of each call to `fade()`. That means it will divide the colour change into 100 steps, with a delay of 10ms between each step. The result is that each fade will take roughly 1 second (not counting the time taken to actually update the LED strip)." />
  <row Id="2040" PostHistoryTypeId="5" PostId="735" RevisionGUID="dad74965-fc07-45a1-a5ec-e1ccf8d28ea7" CreationDate="2014-03-14T14:48:05.777" UserId="20" Comment="added 5 characters in body" Text="I remember seeing [Primo](http://techcrunch.com/2013/11/24/primo/), this robot that is based on Arduino and serves to teach kids to program. My interest in the platform comes from there, but it is always nice to learn about other cool applications.&#xD;&#xA;&#xD;&#xA;What other applications for arduino in k-12 education are there?" />
  <row Id="2041" PostHistoryTypeId="2" PostId="738" RevisionGUID="7060b527-d670-47dd-86d4-8899ad46796f" CreationDate="2014-03-14T14:55:14.040" UserId="113" Text="I've used [Sparki][1] from Arcbotics as a robotics platform. It's uses Arduino Sketch to program and a modified Arduino IDE.&#xD;&#xA;&#xD;&#xA;Sensors for line following , edge detection, distance and light level sensing are built in. Also the creators are focused on education so the material and projects are teaching oriented.&#xD;&#xA;&#xD;&#xA;The Community seems pretty active and engaged too so the material should build over time.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arcbotics.com/products/sparki/start" />
  <row Id="2042" PostHistoryTypeId="5" PostId="735" RevisionGUID="47bbfbe4-b8c5-4d9f-9a5e-f947c276c52b" CreationDate="2014-03-14T16:36:08.273" UserId="65" Comment="added 10 characters in body; edited title" Text="I remember seeing [Primo](http://techcrunch.com/2013/11/24/primo/), this robot that is based on Arduino and serves to teach kids to program. My interest in the platform comes from there, but it is always nice to learn about other cool applications.&#xD;&#xA;&#xD;&#xA;What other applications are there that utilise Arduino for K-12 education?" />
  <row Id="2043" PostHistoryTypeId="4" PostId="735" RevisionGUID="47bbfbe4-b8c5-4d9f-9a5e-f947c276c52b" CreationDate="2014-03-14T16:36:08.273" UserId="65" Comment="added 10 characters in body; edited title" Text="How has Arduino been used in the classroom?" />
  <row Id="2044" PostHistoryTypeId="2" PostId="739" RevisionGUID="10ecbd3b-40d8-4a23-97ba-d73657e3ca9b" CreationDate="2014-03-14T16:47:37.697" UserId="618" Text="Uploading simple sketches seems to work when I run the arduino program as root(sudo). I would like to run it as a regular user, has anyone faced the same problem and fixed it?&#xD;&#xA;&#xD;&#xA;Here is what I obtained from lsusb&#xD;&#xA;&#xD;&#xA;    $ lsusb&#xD;&#xA;    Bus 002 Device 022: ID 2341:0043 Arduino SA Uno R3 (CDC ACM)&#xD;&#xA;&#xD;&#xA;And the Arduino program identifies it as `/dev/ttyACM0`. Here are its permissions &#xD;&#xA;&#xD;&#xA;    $ ls -l /dev/ttyACM0 &#xD;&#xA;    crw-rw---T 1 root dialout 166, 0 Mar 14 22:03 /dev/ttyACM0&#xD;&#xA;&#xD;&#xA;Any suggestions would be welcome." />
  <row Id="2045" PostHistoryTypeId="1" PostId="739" RevisionGUID="10ecbd3b-40d8-4a23-97ba-d73657e3ca9b" CreationDate="2014-03-14T16:47:37.697" UserId="618" Text="arduino program only works when run as root" />
  <row Id="2046" PostHistoryTypeId="3" PostId="739" RevisionGUID="10ecbd3b-40d8-4a23-97ba-d73657e3ca9b" CreationDate="2014-03-14T16:47:37.697" UserId="618" Text="&lt;arduino-uno&gt;" />
  <row Id="2050" PostHistoryTypeId="2" PostId="741" RevisionGUID="d8ecb878-e5ef-482a-907b-82bd4b0935ed" CreationDate="2014-03-14T17:32:03.900" UserId="168" Text="I would actually suggest LiFePo4 for anything DIY. Not only is it safer so one false move won't cause an inferno, but it will last two to four times as long at the CONST of a little extra size and weight.&#xD;&#xA;&#xD;&#xA;Since you are just running an arduino, I would use only 1 single cell, and avoid cell balance woes.&#xD;&#xA;&#xD;&#xA;I would use a boost regulator to step up the voltage from the cell to the required 5v.&#xD;&#xA;&#xD;&#xA;To actually charge the cell, I would probably use a cheap ebay CC-CV charger board, and set the voltage for about 0.15V below the max for your lifepo(you only lose 10% of the energy but You make the battery last much longer), and set the current as appropriate for your panel and battery.&#xD;&#xA;&#xD;&#xA;If your circuit is drawing power while the charger is charging, your circuit will take what it needs and any extra the charger puts out will go into the battery.&#xD;&#xA;&#xD;&#xA;You might need a diode, to make the battery not discharge back through the charger.&#xD;&#xA;&#xD;&#xA;Use a protection pcb like you can get from batteryspace, or better yet a protected lifepo with the pcb built it.&#xD;&#xA;&#xD;&#xA;Remember to size your solar panel so that there is enough energy to keep the circuit running. Even with the protected cells overdischarge kills.&#xD;&#xA;&#xD;&#xA;What I'd really like to do is design a lifepo4 charge control board that had all this in one unit since everyone seems to want it..." />
  <row Id="2051" PostHistoryTypeId="2" PostId="742" RevisionGUID="1521b08b-a906-4143-89eb-f6c8cf61b510" CreationDate="2014-03-14T17:48:43.850" UserId="83" Text="The easiest solution is to add yourself to the `dialout` group:&#xD;&#xA;&#xD;&#xA;First make a note of the output from `id`. Save it in file (not in `/tmp` as that gets cleaned out on a reboot).&#xD;&#xA;&#xD;&#xA;    sudo usermod -a -G dialout youUsername&#xD;&#xA;&#xD;&#xA;Don't forget the `-a` flag or you will have entirely different problems.&#xD;&#xA;&#xD;&#xA;Then log out and log in and it should work from that point.&#xD;&#xA;&#xD;&#xA;Optionally you can double check the output for `id` against the output you saved before." />
  <row Id="2052" PostHistoryTypeId="5" PostId="742" RevisionGUID="3d12d5bd-237d-49cf-b6d3-86da1250d368" CreationDate="2014-03-14T17:55:49.917" UserId="83" Comment="added 393 characters in body" Text="The easiest solution is to add yourself to the `dialout` group.&#xD;&#xA;&#xD;&#xA;First make a note of the output from `id`. Save it in file (not in `/tmp` as that gets cleaned out on a reboot). If you look at the output, you'll notice that your user is signed up for several groups and those groups represent extra privileges on the system. By default your Arduino is assigned to the group `dialout` because it registers as a serial interface and in the old days these were often used to ... dial out, using a modem.&#xD;&#xA;&#xD;&#xA;To add yourself to the `dialout` group issue the following command:&#xD;&#xA;&#xD;&#xA;    sudo usermod -a -G dialout youUsername&#xD;&#xA;&#xD;&#xA;Don't forget the `-a` flag (for appending groups rather than replacing) or you will have entirely different problems. This is the reason for making a copy of the `id` output to a file, so in case you do mess up at least you know what your user was configured like before.&#xD;&#xA;&#xD;&#xA;Then log out and log in and it should work from that point.&#xD;&#xA;&#xD;&#xA;Optionally you can double check the output for `id` against the output you saved before." />
  <row Id="2054" PostHistoryTypeId="6" PostId="739" RevisionGUID="0950f07d-fd09-40f6-b33e-c25926cd7489" CreationDate="2014-03-14T18:10:00.440" UserId="84" Comment="added relevant tags" Text="&lt;arduino-uno&gt;&lt;arduino-ide&gt;&lt;linux&gt;" />
  <row Id="2055" PostHistoryTypeId="24" PostId="739" RevisionGUID="0950f07d-fd09-40f6-b33e-c25926cd7489" CreationDate="2014-03-14T18:10:00.440" Comment="Proposed by 84 approved by 83, 11 edit id of 231" />
  <row Id="2056" PostHistoryTypeId="5" PostId="742" RevisionGUID="e348a3e5-d22c-458e-948c-8b751adaf89a" CreationDate="2014-03-14T20:59:49.107" UserId="83" Comment="added 1 characters in body" Text="The easiest solution is to add yourself to the `dialout` group.&#xD;&#xA;&#xD;&#xA;First make a note of the output from `id`. Save it in file (not in `/tmp` as that gets cleaned out on a reboot). If you look at the output, you'll notice that your user is signed up for several groups and those groups represent extra privileges on the system. By default your Arduino is assigned to the group `dialout` because it registers as a serial interface and in the old days these were often used to ... dial out, using a modem.&#xD;&#xA;&#xD;&#xA;To add yourself to the `dialout` group, issue the following command:&#xD;&#xA;&#xD;&#xA;    sudo usermod -a -G dialout yourUsername&#xD;&#xA;&#xD;&#xA;Don't forget the `-a` flag (for appending groups rather than replacing) or you will have entirely different problems. This is the reason for making a copy of the `id` output to a file, so in case you do mess up at least you know what your user was configured like before.&#xD;&#xA;&#xD;&#xA;Then log out and log in and it should work from that point.&#xD;&#xA;&#xD;&#xA;Optionally you can double check the output for `id` against the output you saved before." />
  <row Id="2057" PostHistoryTypeId="5" PostId="739" RevisionGUID="e3c2878f-f779-4dc7-99ff-e882744496be" CreationDate="2014-03-14T21:19:00.237" UserId="275" Comment="minor language improvements" Text="Uploading simple sketches seems to work when I run the Arduino program as root (`sudo`). I would like to run it as a regular user. Has anyone faced the same problem before and fixed it?&#xD;&#xA;&#xD;&#xA;Here is what I obtained from `lsusb`:&#xD;&#xA;&#xD;&#xA;    $ lsusb&#xD;&#xA;    Bus 002 Device 022: ID 2341:0043 Arduino SA Uno R3 (CDC ACM)&#xD;&#xA;&#xD;&#xA;And the Arduino program identifies it as `/dev/ttyACM0`. Here are its permissions: &#xD;&#xA;&#xD;&#xA;    $ ls -l /dev/ttyACM0 &#xD;&#xA;    crw-rw---T 1 root dialout 166, 0 Mar 14 22:03 /dev/ttyACM0&#xD;&#xA;&#xD;&#xA;Any suggestions would be welcome." />
  <row Id="2058" PostHistoryTypeId="4" PostId="739" RevisionGUID="e3c2878f-f779-4dc7-99ff-e882744496be" CreationDate="2014-03-14T21:19:00.237" UserId="275" Comment="minor language improvements" Text="Arduino program only works when run as root" />
  <row Id="2059" PostHistoryTypeId="24" PostId="739" RevisionGUID="e3c2878f-f779-4dc7-99ff-e882744496be" CreationDate="2014-03-14T21:19:00.237" Comment="Proposed by 275 approved by 83, 11 edit id of 232" />
  <row Id="2060" PostHistoryTypeId="5" PostId="649" RevisionGUID="8887d242-e0c9-4c96-9949-5a87da89d253" CreationDate="2014-03-14T21:36:17.583" UserId="261" Comment="Improved formatting. Removed part is already posted as answer." Text="I'm trying to replicate a waveform exactly using external and timing interrupts. I've got an external that's setup as a 0ms reference, TIMER1 which is used to determine on time, and TIMER2, which sets the low period. Unfortunately, I can't get the pin low for 2ms. TIMER2 must have something wrong with it, but I can't find it. Instead of banging my head against the wall, I thought I'd ask you guys. Anyone know the answer?  &#xD;&#xA;&#xD;&#xA;    //3 is interrupt for Timing&#xD;&#xA;    //4 through 11 are Time dependent receivers&#xD;&#xA;    //3-11 Pins 12-19&#xD;&#xA;    &#xD;&#xA;    //Current Serial Byte(Letter or Number)&#xD;&#xA;    char incomingByte = 0;&#xD;&#xA;    //Previous Byte in the Serial Chain&#xD;&#xA;    char previousByte = 0;&#xD;&#xA;    &#xD;&#xA;    //Iterator for Interrupt Values&#xD;&#xA;    volatile unsigned int maincount = 0;&#xD;&#xA;&#xD;&#xA;    //Time of High Period or Timer Duration&#xD;&#xA;    volatile unsigned int timerhigh;&#xD;&#xA;    &#xD;&#xA;    //Output Pin for Timer Waveform&#xD;&#xA;    volatile unsigned int waveout;&#xD;&#xA;&#xD;&#xA;    //Time for Timer Delay in milliseconds, default tim&#xD;&#xA;    volatile unsigned int groundtime = 0;&#xD;&#xA;    &#xD;&#xA;    //Receiver Pins in an Array, except for 3, which serves as 0 source reference&#xD;&#xA;    int pins[9] =&#xD;&#xA;    {&#xD;&#xA;      3,4,5,6,7,8,9,10,11&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    void rising()&#xD;&#xA;    {   &#xD;&#xA;      // set up Timer 1&#xD;&#xA;      TCCR1A = 0;  // normal mode&#xD;&#xA;      TCCR1B = bit(WGM12) | bit(CS11);  // CTC, scale to clock / 8&#xD;&#xA;      OCR1A = timerhigh;          // time before timer fires&#xD;&#xA;      TIMSK1 = bit (OCIE1A);            // interrupt on Compare A Match&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    //Sets Pin Low, then sets up another timer interrupt for the jump back to high&#xD;&#xA;    ISR(TIMER1_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;     //Brings Pin Low for Keypress&#xD;&#xA;     //Serial.println(&quot;We're in Timer 1&quot;);&#xD;&#xA;     pinMode(waveout,OUTPUT);&#xD;&#xA;     digitalWrite(waveout, LOW);&#xD;&#xA;    &#xD;&#xA;     //Stop Timer 1&#xD;&#xA;     TCCR1B = 0;                      // stop timer&#xD;&#xA;     TIMSK1 = 0;                      // cancel timer interrupt&#xD;&#xA;     &#xD;&#xA;     //Disables Interrupts Before Messing&#xD;&#xA;     cli();&#xD;&#xA;     // set up Timer 2&#xD;&#xA;     TCCR2A = 0;  // normal mode&#xD;&#xA;     TCCR2B = 0;&#xD;&#xA;     //  TCCR2A = bit(WGM21) | bit(CS21);  // CTC, scale to clock / 8&#xD;&#xA;     TCCR2A = (1 &lt;&lt; WGM21); //Enables CTC for timer &#xD;&#xA;     TCCR2B = (1 &lt;&lt; CS21); //Sets 8 bit prescaler&#xD;&#xA;     OCR2A = groundtime;          // time before timer fires&#xD;&#xA;     TIMSK2 = (1 &lt;&lt; OCIE2A);&#xD;&#xA;      &#xD;&#xA;     //Cancel Rising Interrupt on D3&#xD;&#xA;     EIFR = bit (INTF1); &#xD;&#xA;     //Reenables interrupts&#xD;&#xA;     sei();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    //Timer Interrupt for Low Period&#xD;&#xA;    ISR(TIMER2_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;    //Serial.println(&quot;WE'RE IN TIMER2&quot;);&#xD;&#xA;    //Brings Output pin high&#xD;&#xA;    digitalWrite(waveout, HIGH);&#xD;&#xA;      &#xD;&#xA;    //Stop Timer 2&#xD;&#xA;    TCCR2B = 0;                      // stop timer&#xD;&#xA;    TIMSK2 = 0;                      // cancel timer interrupt  &#xD;&#xA;    &#xD;&#xA;    //Cancel Rising Interrupt on D3&#xD;&#xA;     EIFR = bit (INTF1);   &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      // put your setup code here, to run once:&#xD;&#xA;    &#xD;&#xA;    //Sets all the pins for output use&#xD;&#xA;    for(int i=0;i&lt;8;i++)&#xD;&#xA;    {&#xD;&#xA;      pinMode(pins[i], INPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    //Sets Reference Pin as Input&#xD;&#xA;    pinMode(3,INPUT);&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    //Begins Serial&#xD;&#xA;    Serial.begin(115200);&#xD;&#xA;    &#xD;&#xA;    //Cancels Timer 1&#xD;&#xA;    TCCR1A = 0;  // normal mode&#xD;&#xA;    TCCR1B = 0;  // stop timer&#xD;&#xA;    TIMSK1 = 0;   // cancel timer interrupt&#xD;&#xA;    &#xD;&#xA;    //Cancels Timer 2&#xD;&#xA;     TCCR2A = 0;&#xD;&#xA;     TCCR2B = 0;                      // stop timer&#xD;&#xA;     TIMSK2 = 0;                      // cancel timer interrupt  &#xD;&#xA;    detachInterrupt(1);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;    &#xD;&#xA;      //Time of Ground Drop(2 mS), Universal for all letters and offsets&#xD;&#xA;      groundtime = 40000;     // spark time (4000 * 500 nS) = 2 mS&#xD;&#xA;       &#xD;&#xA;      // because of prescaler of 8, each unit is 500 nS (0.5 µS)&#xD;&#xA;      &#xD;&#xA;         if(Serial.available()&gt; 0);&#xD;&#xA;        {&#xD;&#xA;       //Reads Serial Value and assigns to incomingByte&#xD;&#xA;       incomingByte = Serial.read();&#xD;&#xA;       attachInterrupt(1,rising,RISING);&#xD;&#xA;        }&#xD;&#xA;      //  noInterrupts ();  // atomic change of the time amount&#xD;&#xA;    &#xD;&#xA;       //In this area, we'll set the output pin to be used by the timing interrupt, &#xD;&#xA;       //and the time delay off the default waveform present on pin 4&#xD;&#xA;       &#xD;&#xA;       //We can use switch case arrangement, don't know if that's the optimal setup though    &#xD;&#xA;     switch(incomingByte)&#xD;&#xA;     {&#xD;&#xA;       default:&#xD;&#xA;       //Do Nothing&#xD;&#xA;       break;&#xD;&#xA;    &#xD;&#xA;       //Cases FOR ALL THE LETTERS&#xD;&#xA;       case 'a':&#xD;&#xA;       break;&#xD;&#xA;       case 'b':&#xD;&#xA;       break;&#xD;&#xA;       case 'c':&#xD;&#xA;       break;&#xD;&#xA;       case 'd':&#xD;&#xA;       break;&#xD;&#xA;       case 'e':&#xD;&#xA;       break;&#xD;&#xA;       case 'f':&#xD;&#xA;       break;&#xD;&#xA;       case 'g':&#xD;&#xA;       break;&#xD;&#xA;       case 'h':&#xD;&#xA;       break;&#xD;&#xA;       case 'i':&#xD;&#xA;       break;&#xD;&#xA;       case 'j':&#xD;&#xA;       break;&#xD;&#xA;       case 'k':&#xD;&#xA;       break;&#xD;&#xA;       case 'l':&#xD;&#xA;       break;&#xD;&#xA;       case 'm':&#xD;&#xA;       break;&#xD;&#xA;       case 'n':&#xD;&#xA;       break;&#xD;&#xA;       case 'o':&#xD;&#xA;       break;&#xD;&#xA;       case 'p':&#xD;&#xA;       break;&#xD;&#xA;       case 'q':&#xD;&#xA;       break;&#xD;&#xA;       case 'r':&#xD;&#xA;       //Output pin 17 Frequency Pin 10&#xD;&#xA;       //microseconds&#xD;&#xA;       timerhigh=8000;&#xD;&#xA;       waveout=9;&#xD;&#xA;       break;&#xD;&#xA;       case 's':&#xD;&#xA;       break;&#xD;&#xA;       case 't':&#xD;&#xA;       break;&#xD;&#xA;       case 'u':&#xD;&#xA;       break;&#xD;&#xA;       case 'v':&#xD;&#xA;       break;&#xD;&#xA;       case 'w':&#xD;&#xA;       break;&#xD;&#xA;       case 'x':&#xD;&#xA;       break;&#xD;&#xA;       case 'y':&#xD;&#xA;       break;&#xD;&#xA;       case 'z':&#xD;&#xA;       break;&#xD;&#xA;       &#xD;&#xA;       //Cases FOR ALL THE NUMBERS&#xD;&#xA;       case '0':&#xD;&#xA;       break;&#xD;&#xA;       case '1':&#xD;&#xA;       break;&#xD;&#xA;       case '2':&#xD;&#xA;       break;&#xD;&#xA;       case '3':&#xD;&#xA;       break;&#xD;&#xA;       case '4':&#xD;&#xA;       break;&#xD;&#xA;       case '5':&#xD;&#xA;       break;&#xD;&#xA;       case '6':&#xD;&#xA;       break;&#xD;&#xA;       case '7':&#xD;&#xA;       break;&#xD;&#xA;       case '8':&#xD;&#xA;       break;&#xD;&#xA;       case '9':&#xD;&#xA;       break;&#xD;&#xA;       &#xD;&#xA;       //Cases FOR ALL THE PUNCTUATION&#xD;&#xA;       case '.':&#xD;&#xA;       break;&#xD;&#xA;       case ',':&#xD;&#xA;       break;&#xD;&#xA;       case '!':&#xD;&#xA;       break;&#xD;&#xA;       case '&quot;':&#xD;&#xA;       break;&#xD;&#xA;       case '#':&#xD;&#xA;       break;&#xD;&#xA;       case '$':&#xD;&#xA;       break;&#xD;&#xA;       case '%':&#xD;&#xA;       break;      &#xD;&#xA;     }&#xD;&#xA;        &#xD;&#xA;    //Enables Rising Interrupt for 0ms detection&#xD;&#xA;    //attachInterrupt(1,rising,RISING);&#xD;&#xA;        &#xD;&#xA;    //Reenables interrupts after offset time change&#xD;&#xA;    //interrupts ();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2061" PostHistoryTypeId="24" PostId="649" RevisionGUID="8887d242-e0c9-4c96-9949-5a87da89d253" CreationDate="2014-03-14T21:36:17.583" Comment="Proposed by 261 approved by 11 edit id of 233" />
  <row Id="2062" PostHistoryTypeId="5" PostId="739" RevisionGUID="969badca-c2a8-44a9-a1b5-99733b8d7f8c" CreationDate="2014-03-15T06:09:29.417" UserId="618" Comment="added 181 characters in body" Text="Uploading simple sketches seems to work when I run the Arduino program as root (`sudo`). I would like to run it as a regular user. Has anyone faced the same problem before and fixed it?&#xD;&#xA;&#xD;&#xA;Here is what I obtained from `lsusb`:&#xD;&#xA;&#xD;&#xA;    $ lsusb&#xD;&#xA;    Bus 002 Device 022: ID 2341:0043 Arduino SA Uno R3 (CDC ACM)&#xD;&#xA;&#xD;&#xA;And the Arduino program identifies it as `/dev/ttyACM0`. Here are its permissions: &#xD;&#xA;&#xD;&#xA;    $ ls -l /dev/ttyACM0 &#xD;&#xA;    crw-rw---T 1 root dialout 166, 0 Mar 14 22:03 /dev/ttyACM0&#xD;&#xA;&#xD;&#xA;Here is the output from `id`&#xD;&#xA;  &#xD;&#xA;    groups=1000(abhiram),20(dialout),24(cdrom),25(floppy),29(audio),&#xD;&#xA;    30(dip),44(video),46(plugdev),105(scanner),110(bluetooth),112(netdev)&#xD;&#xA;&#xD;&#xA;When I upload an sketch from the examples, as a regular user, I encounter this error:&#xD;&#xA;    &#xD;&#xA;    avrdude:stk500_recv(): programmer not responding&#xD;&#xA;Any suggestions would be welcome." />
  <row Id="2063" PostHistoryTypeId="5" PostId="739" RevisionGUID="1ae6d12d-c56b-4c39-9c92-5d07aafbae49" CreationDate="2014-03-15T06:41:26.590" UserId="618" Comment="deleted 3 characters in body" Text="Uploading simple sketches seems to work when I run the Arduino program as root (`sudo`). I would like to run it as a regular user. Has anyone faced the same problem before and fixed it?&#xD;&#xA;&#xD;&#xA;Here is what I obtained from `lsusb`:&#xD;&#xA;&#xD;&#xA;    $ lsusb&#xD;&#xA;    Bus 002 Device 022: ID 2341:0043 Arduino SA Uno R3 (CDC ACM)&#xD;&#xA;&#xD;&#xA;And the Arduino program identifies it as `/dev/ttyACM0`. Here are its permissions: &#xD;&#xA;&#xD;&#xA;    $ ls -l /dev/ttyACM0 &#xD;&#xA;    crw-rw---T 1 root dialout 166, 0 Mar 14 22:03 /dev/ttyACM0&#xD;&#xA;&#xD;&#xA;Here is the output from `id`&#xD;&#xA;  &#xD;&#xA;    groups=1000(abhiram),20(dialout),24(cdrom),25(floppy),29(audio),&#xD;&#xA;    30(dip),44(video),46(plugdev),105(scanner),110(bluetooth),112(netdev)&#xD;&#xA;&#xD;&#xA;When I upload an sketch from the examples, as a regular user, I encounter this error:&#xD;&#xA;    &#xD;&#xA;    avrdude:stk500_recv(): programmer not responding&#xD;&#xA;&#xD;&#xA;Any suggestions are welcome." />
  <row Id="2065" PostHistoryTypeId="12" PostId="239" RevisionGUID="fed9564c-501e-48ed-a190-a77476eb8797" CreationDate="2014-03-15T09:07:14.523" UserId="42" Comment="via Vote" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;}]}" />
  <row Id="2066" PostHistoryTypeId="2" PostId="743" RevisionGUID="53af3f4d-b51d-4ae7-8adb-5d4e9aa93a84" CreationDate="2014-03-15T10:22:25.003" UserId="624" Text="You could use the makefile &#xD;&#xA;https://github.com/sudar/Arduino-Makefile&#xD;&#xA;for compiling Arduino codes. You don't necessarily need the IDE.&#xD;&#xA;" />
  <row Id="2067" PostHistoryTypeId="5" PostId="239" RevisionGUID="95a8f708-c699-42a7-89ab-fd963a31e9d9" CreationDate="2014-03-15T17:30:24.420" UserId="84" Comment="Added further details (summed up) of what can be found in the link" Text="In addition to what others have said (on which I fully agree), I would advise to read [this adafruit article][1] about memory; it's well written, explains a lot of things about memory and provide hints on how to optimize it.&#xD;&#xA;&#xD;&#xA;At the end of the read, I think you would get a quite complete answer to your question.&#xD;&#xA;&#xD;&#xA;To sum it up, you have 2 possible optimization targets (depending on where you memory problems are located):&#xD;&#xA;&#xD;&#xA;- **Flash** (ie Program Memory); for this, you can:&#xD;&#xA;    - remove dead code (e.g. any code that is included but not used) and unused variables (that one also helps with SRAM)&#xD;&#xA;    - factor out duplicated code&#xD;&#xA;    - remove the bootloader altogether (you can gain between 0.5K for a UNO and 2 or 4K for other Arduino models); this has some downsides though&#xD;&#xA;- **SRAM** (ie stack, heap and static data); for this you can:&#xD;&#xA;    - remove unused variables&#xD;&#xA;    - optimize the size of each variable (eg don't use long -4 bytes- if you need only int -2 bytes)&#xD;&#xA;    - use the right scope for your variables (and prefer stack to static data when possible)&#xD;&#xA;    - reduce buffers size to the strict minimum&#xD;&#xA;    - move constant data to PROGMEM (ie your static data will stay in Flash memory and won't get copied to SRAM at program start); that also applies to constant strings for which you can use `F()` macro)&#xD;&#xA;    - avoid dynamic allocation if it is not absolutely necessary; you will avoid a *fragmented heap* that may not shrink even after freeing memory&#xD;&#xA;&#xD;&#xA;An additional approach to reduce SRAM usage is also described (but seldom used, because it is a bit heavy when coding and not very efficient), it consists in using EEPROM to store data built by your program, but not used until later when some conditions occur, when data can be loaded back from EEPROM.&#xD;&#xA;&#xD;&#xA;  [1]: http://learn.adafruit.com/memories-of-an-arduino/you-know-you-have-a-memory-problem-when-dot-dot-dot" />
  <row Id="2068" PostHistoryTypeId="2" PostId="744" RevisionGUID="4a0e059e-794c-4bb1-8423-da90fa06cfbd" CreationDate="2014-03-15T19:33:42.287" UserId="196" Text="I downloaded Arduino code from this: https://github.com/BabyWrassler/MissionControl/ Github, and got the  error message below.![Error message][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;It is designed to work with a Raspberry Pi, and I installed the two Adafruit Libraries.  I also have not hooked it up to either the pi, or the two Adafruit devices, but that is partly because I cannot get it to run without the error message.  Sorry I put a picture instead of typing the error message, but I thought it would be easier to see the highlighting and the different places it put the error messages.&#xD;&#xA;&#xD;&#xA;Thank you.&#xD;&#xA;  [1]: http://i.stack.imgur.com/v7Wjt.jpg" />
  <row Id="2069" PostHistoryTypeId="1" PostId="744" RevisionGUID="4a0e059e-794c-4bb1-8423-da90fa06cfbd" CreationDate="2014-03-15T19:33:42.287" UserId="196" Text="Arduino error message that I don't understand" />
  <row Id="2070" PostHistoryTypeId="3" PostId="744" RevisionGUID="4a0e059e-794c-4bb1-8423-da90fa06cfbd" CreationDate="2014-03-15T19:33:42.287" UserId="196" Text="&lt;sketch&gt;" />
  <row Id="2071" PostHistoryTypeId="6" PostId="665" RevisionGUID="2cc31c3c-3eca-4e3b-98fc-a690455a822e" CreationDate="2014-03-15T20:42:22.140" UserId="213" Comment="tags" Text="&lt;power&gt;&lt;solar&gt;" />
  <row Id="2072" PostHistoryTypeId="2" PostId="745" RevisionGUID="132b27ec-a73a-47fc-b25b-7478ec8ba09c" CreationDate="2014-03-15T20:45:08.277" UserId="-1" Text="" />
  <row Id="2073" PostHistoryTypeId="2" PostId="746" RevisionGUID="3abf5fad-7b63-4071-b182-22c6c2741bfb" CreationDate="2014-03-15T20:45:08.277" UserId="-1" Text="" />
  <row Id="2074" PostHistoryTypeId="5" PostId="746" RevisionGUID="1d550e70-97f7-4719-98c0-c2550b6c4336" CreationDate="2014-03-15T21:05:03.387" UserId="213" Comment="added 23 characters in body" Text="Solar powered projects." />
  <row Id="2075" PostHistoryTypeId="24" PostId="746" RevisionGUID="1d550e70-97f7-4719-98c0-c2550b6c4336" CreationDate="2014-03-15T21:05:03.387" Comment="Proposed by 213 approved by 11 edit id of 235" />
  <row Id="2076" PostHistoryTypeId="5" PostId="745" RevisionGUID="6e2f18cf-5b5b-4a6d-8570-ab5651d54e5a" CreationDate="2014-03-15T21:05:10.760" UserId="213" Comment="added 179 characters in body" Text="Solar power approaches to powering an Arduino project.  This may include power generation, buffering with batteries or smoothing capacitors, and interfacing with the board itself." />
  <row Id="2077" PostHistoryTypeId="24" PostId="745" RevisionGUID="6e2f18cf-5b5b-4a6d-8570-ab5651d54e5a" CreationDate="2014-03-15T21:05:10.760" Comment="Proposed by 213 approved by 11 edit id of 234" />
  <row Id="2078" PostHistoryTypeId="5" PostId="514" RevisionGUID="293cb595-2097-41ce-86d3-5de1036a3594" CreationDate="2014-03-15T21:05:15.480" UserId="213" Comment="re-organized to make it concise." Text="A sensor is a converter that measures a physical quantity and converts it into an analog or digital signal which can be read by an Arduino. " />
  <row Id="2079" PostHistoryTypeId="24" PostId="514" RevisionGUID="293cb595-2097-41ce-86d3-5de1036a3594" CreationDate="2014-03-15T21:05:15.480" Comment="Proposed by 213 approved by 11 edit id of 236" />
  <row Id="2080" PostHistoryTypeId="5" PostId="515" RevisionGUID="3c35f20b-7248-411a-a5d9-9a8e7d154700" CreationDate="2014-03-15T21:06:46.580" UserId="213" Comment="re-organized to make it concise." Text="Use this tag for questions about selecting, connecting, using, and debugging sensors." />
  <row Id="2081" PostHistoryTypeId="24" PostId="515" RevisionGUID="3c35f20b-7248-411a-a5d9-9a8e7d154700" CreationDate="2014-03-15T21:06:46.580" Comment="Proposed by 213 approved by 11 edit id of 237" />
  <row Id="2082" PostHistoryTypeId="2" PostId="747" RevisionGUID="56276944-6778-4b99-b8be-fd9d14d9d846" CreationDate="2014-03-15T22:38:07.423" UserId="562" Text="I have Arduino Leonardo board operating lots of AC relays in quite noisy environment. USB works unstable, which sometimes causes the board to hang, so I decided to use secondary serial connection as &quot;debug console&quot;:&#xD;&#xA;&#xD;&#xA;      Serial1.begin(115200); &#xD;&#xA;      .....&#xD;&#xA;      .....&#xD;&#xA;      if (Serial1.available()) {&#xD;&#xA;        char ch = Serial1.read();&#xD;&#xA;        if ( isalnum(ch) ) {&#xD;&#xA;          switch (ch) {&#xD;&#xA;            case 'M': {&#xD;&#xA;              turnOn_pin_Motor();&#xD;&#xA;              break;&#xD;&#xA;            }&#xD;&#xA;            case 'm': {&#xD;&#xA;              turnOff_pin_Motor();&#xD;&#xA;              break;&#xD;&#xA;            }&#xD;&#xA;            .......&#xD;&#xA;&#xD;&#xA;My problem is that noise affects Serial1 the same way it messes USB (but at least it doesn't cause it to freeze). I'd like to use some sort of error checking to prevent Leonardo from acting on &quot;phantom&quot; commands. I could, for example, prefix each keyboard command my Arduino should receive with special symbol, maybe &quot;!&quot;.&#xD;&#xA;&#xD;&#xA;So I must be reading one char, checking if it is &quot;!&quot; and reading second character.&#xD;&#xA;&#xD;&#xA;Unfortunately, I can't modify my code so it would use 2-character buffer and shift its contents as characters arrive, without locking the main loop while waiting for the next char. Any hints on what should I do in this case?" />
  <row Id="2083" PostHistoryTypeId="1" PostId="747" RevisionGUID="56276944-6778-4b99-b8be-fd9d14d9d846" CreationDate="2014-03-15T22:38:07.423" UserId="562" Text="Reading multiple bytes from *software* serial" />
  <row Id="2084" PostHistoryTypeId="3" PostId="747" RevisionGUID="56276944-6778-4b99-b8be-fd9d14d9d846" CreationDate="2014-03-15T22:38:07.423" UserId="562" Text="&lt;serial&gt;" />
  <row Id="2085" PostHistoryTypeId="36" PostId="748" RevisionGUID="9ca4559e-031e-429a-90b3-60dc0eb08147" CreationDate="2014-03-15T23:37:19.240" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/102814/is-my-arduino-destroyed-or-are-the-pins-destroyed" />
  <row Id="2086" PostHistoryTypeId="36" PostId="749" RevisionGUID="20eb422e-1c89-473e-b3e6-833d8f0321fe" CreationDate="2014-03-15T23:37:19.240" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/102814/is-my-arduino-destroyed-or-are-the-pins-destroyed/102833#102833" />
  <row Id="2087" PostHistoryTypeId="2" PostId="749" RevisionGUID="02943c05-39d0-4a01-843b-e40935fff172" CreationDate="2014-03-13T20:19:28.100" UserId="467" Text="Try running the blink LED, on a different terminals.&#xD;&#xA;If the LED is working properly, then most likely the pins are destroyed.&#xD;&#xA;Why are they destroyed?&#xD;&#xA;Most likely, you've withdrawn more current than the pins can actually provide.&#xD;&#xA;&#xD;&#xA;According to the datasheet of the Arduino uno, the IO pins can handle up to 40mA.&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;The only possible way to solve this problem is to change the IC (Atmega328) by another one. It's not guranteed that it will work, but the microcontroller is reletively cheap.&#xD;&#xA;&#xD;&#xA;The definite answer can not be determined unless you showed us a schematic of your connection.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/eapOV.jpg" />
  <row Id="2088" PostHistoryTypeId="2" PostId="748" RevisionGUID="99affa00-991b-403c-ae7b-097be59d7027" CreationDate="2014-03-13T18:06:28.733" UserDisplayName="Kam" Text="I made a working model of Bluetooth light control with arduino and Bluetooth. Everything worked fine and then after some time I connected the circuit again it didn't work and the pins 7,10,11,12 aren't working . I was using a Bluetooth shield but I tried the simple LED flash program and even that's not working .&#xD;&#xA;&#xD;&#xA;Please suggest any good way of making it working again or at least explain what happened with it." />
  <row Id="2089" PostHistoryTypeId="1" PostId="748" RevisionGUID="99affa00-991b-403c-ae7b-097be59d7027" CreationDate="2014-03-13T18:06:28.733" UserDisplayName="Kam" Text="Is my Arduino destroyed or are the pins destroyed?" />
  <row Id="2090" PostHistoryTypeId="3" PostId="748" RevisionGUID="99affa00-991b-403c-ae7b-097be59d7027" CreationDate="2014-03-13T18:06:28.733" UserDisplayName="Kam" Text="&lt;untagged&gt;" />
  <row Id="2091" PostHistoryTypeId="6" PostId="748" RevisionGUID="6fb2fd60-5f47-46ad-a808-68b6a60fd296" CreationDate="2014-03-16T00:20:57.963" UserId="11" Comment="edited tags" Text="&lt;pins&gt;" />
  <row Id="2092" PostHistoryTypeId="2" PostId="750" RevisionGUID="38083e7b-5de9-4657-8ace-b591218ff47b" CreationDate="2014-03-16T01:33:14.700" UserId="633" Text="I have a few Arduino Pro Micro clones (cheap chineese stuff) and would like to power them with 12V power supply(same as fan voltage). According to the [Arduino Pro Micro spec][1] the RAW pin can take 3.35 -12 V (3.3V model). In practice this means a 12V PSU cannot be used as they are almost allways over 12V with low load. I read that the voltage regulator in this board is capable up to 16V input. I tried plugging in a cheap 12V power adapter that read 15.1V with no load but a component on the arduino board actually exploded instantly. The board seems to work still when powered from usb programmer. Component that burned out is just above VCC, RST and GND pins.&#xD;&#xA;&#xD;&#xA;Why did this happen? What did I just damage and most importantly what is a safe voltage level to use? I already have a few 12V switching power supplies it would be a shame if I could not use them.&#xD;&#xA;&#xD;&#xA;P.S. the ground of the 12V PSU is shared with arduino ground pin, not sure if this might be the cause.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardProMini#.UyT9APl_sz0" />
  <row Id="2093" PostHistoryTypeId="1" PostId="750" RevisionGUID="38083e7b-5de9-4657-8ace-b591218ff47b" CreationDate="2014-03-16T01:33:14.700" UserId="633" Text="Arduino Pro Micro (3.3V version) input voltage range / tolerance" />
  <row Id="2094" PostHistoryTypeId="3" PostId="750" RevisionGUID="38083e7b-5de9-4657-8ace-b591218ff47b" CreationDate="2014-03-16T01:33:14.700" UserId="633" Text="&lt;voltage-level&gt;" />
  <row Id="2095" PostHistoryTypeId="5" PostId="750" RevisionGUID="b8a3ef54-e902-4afe-a053-aec35369fb9e" CreationDate="2014-03-16T02:17:02.187" UserId="65" Comment="deleted 3 characters in body; edited tags" Text="I have a few Arduino Pro Micro clones (cheap Chinese stuff) and would like to power them with 12V power supply (same as fan voltage). According to the [Arduino Pro Micro spec][1] the RAW pin can take 3.35-12V (3.3V model). In practice this means a 12V PSU cannot be used as they are almost always over 12V with low load. I read that the voltage regulator in this board is capable up to 16V input. I tried plugging in a cheap 12V power adapter that read 15.1V with no load but a component on the Arduino board actually exploded instantly. The board seems to work still when powered from usb programmer. Component that burned out is just above VCC, RST and GND pins.&#xD;&#xA;&#xD;&#xA;Why did this happen? What did I just damage and most importantly what is a safe voltage level to use? I already have a few 12V switching power supplies it would be a shame if I could not use them.&#xD;&#xA;&#xD;&#xA;P.S. the ground of the 12V PSU is shared with Arduino ground pin, not sure if this might be the cause.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardProMini#.UyT9APl_sz0" />
  <row Id="2096" PostHistoryTypeId="6" PostId="750" RevisionGUID="b8a3ef54-e902-4afe-a053-aec35369fb9e" CreationDate="2014-03-16T02:17:02.187" UserId="65" Comment="deleted 3 characters in body; edited tags" Text="&lt;clones&gt;&lt;voltage-level&gt;&lt;arduino-pro&gt;" />
  <row Id="2098" PostHistoryTypeId="5" PostId="744" RevisionGUID="415179ee-96c1-47f5-8cb4-a524040f33c9" CreationDate="2014-03-16T02:41:26.317" UserId="65" Comment="deleted 7 characters in body; edited tags" Text="I downloaded Arduino code from this: https://github.com/BabyWrassler/MissionControl/ Github, and got the  error message below.&#xD;&#xA;&#xD;&#xA;![Error message][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;It is designed to work with a Raspberry Pi, and I installed the two Adafruit libraries.  I also have not hooked it up to either the Pi, or the two Adafruit devices, but that is partly because I cannot get it to run without the error message.  Sorry I put a picture instead of typing the error message, but I thought it would be easier to see the highlighting and the different places it put the error messages.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/v7Wjtl.jpg" />
  <row Id="2099" PostHistoryTypeId="6" PostId="744" RevisionGUID="415179ee-96c1-47f5-8cb4-a524040f33c9" CreationDate="2014-03-16T02:41:26.317" UserId="65" Comment="deleted 7 characters in body; edited tags" Text="&lt;library&gt;&lt;sketch&gt;" />
  <row Id="2100" PostHistoryTypeId="5" PostId="750" RevisionGUID="450be3e3-7090-4eea-829c-93ce9a60775b" CreationDate="2014-03-16T04:08:23.860" UserId="633" Comment="deleted 2 characters in body" Text="I have a few Arduino Pro Mini clones (cheap Chinese stuff) and would like to power them with 12V power supply (same as fan voltage). According to the [Arduino Pro Mini spec][1] the RAW pin can take 3.35-12V (3.3V model). In practice this means a 12V PSU cannot be used as they are almost always over 12V with low load. I read that the voltage regulator in this board is capable up to 16V input. I tried plugging in a cheap 12V power adapter that read 15.1V with no load but a component on the Arduino board actually exploded instantly. The board seems to work still when powered from usb programmer. Component that burned out is just above VCC, RST and GND pins.&#xD;&#xA;&#xD;&#xA;Why did this happen? What did I just damage and most importantly what is a safe voltage level to use? I already have a few 12V switching power supplies it would be a shame if I could not use them.&#xD;&#xA;&#xD;&#xA;P.S. the ground of the 12V PSU is shared with Arduino ground pin, not sure if this might be the cause.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardProMini#.UyT9APl_sz0" />
  <row Id="2102" PostHistoryTypeId="2" PostId="752" RevisionGUID="04b1a65a-5102-451b-a9d5-46084c4fdbd4" CreationDate="2014-03-16T08:16:06.193" UserId="84" Text="The component that exploded during your test is a capacitor.&#xD;&#xA;&#xD;&#xA;According to the position on the board you mentioned, it is one of the 2 electrolytic capacitors used on both sides of the 3.3V regulator (I would say that's probably the upstream capcitor).&#xD;&#xA;&#xD;&#xA;There are [a few reasons why a capacitor may explode][1]:&#xD;&#xA;&#xD;&#xA;- apply an inverted voltage to it (polarized capacitors only)&#xD;&#xA;- apply a voltage above its rating&#xD;&#xA;- apply a current above its rating&#xD;&#xA;&#xD;&#xA;Your situation is probably the 2nd one: too high voltage applied.&#xD;&#xA;&#xD;&#xA;According to Sparkfun original schematics, this capacitor must be polarized with 10uF capacity. Unfortunately the schematics do not mention the maximum voltage.&#xD;&#xA;&#xD;&#xA;According to the [specification for the original board][2], the maximum voltage for this cap should be at least 12V, but there is no guarantee that it is anthing above than 12V. Hence, you have to consider **12V is the maximum voltage applicable** to your board (on the RAW pin).&#xD;&#xA;&#xD;&#xA;In addition, you have mentioned you are using a cheap chinese clone, it is perfectly possible (although not expected, as it would make the board operate differently than the original specs) that this one uses a lower voltage cap (eg 10V) which would be a bit cheaper.&#xD;&#xA;&#xD;&#xA;If you do want to reuse your 12V PSU, you will have to ensure that its output voltage never exceeds 12V, for this you are left with a few options:&#xD;&#xA;&#xD;&#xA;- use a [voltage divider][3] made of 2 resistors: you must first know the max voltage output of your PSU and then calculate resistance values to get 12V based on that max voltage. That's easy but it can waste a lot of energy&#xD;&#xA;- use a 12V [Zener diode][4] outside your PSU&#xD;&#xA;- use a 12V [voltage regulator][5] circuit after your PSU: that one is the safest, but also the most expensive solution&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Capacitor#Hazards_and_safety&#xD;&#xA;  [2]: http://arduino.cc/en/Main/ArduinoBoardProMini&#xD;&#xA;  [3]: http://en.wikipedia.org/wiki/Voltage_divider&#xD;&#xA;  [4]: http://en.wikipedia.org/wiki/Zener_diode&#xD;&#xA;  [5]: http://en.wikipedia.org/wiki/Voltage_regulator" />
  <row Id="2103" PostHistoryTypeId="2" PostId="753" RevisionGUID="10fc97f5-ff92-4ac1-8772-c87b21a20c66" CreationDate="2014-03-16T08:28:34.017" UserId="84" Text="It seems to me that those Adafruit libraries were not correctly installed on your PC or your sketch.&#xD;&#xA;&#xD;&#xA;In addition to downloading and installing the library onto the Arduino library directory (on Windows, that's normally `C:\Users\UserName\Documents\Arduino\libraries`), when you want to use that library with Arduino IDE, you must add the library for your sketch with the menu command &quot;**Sketch -&gt; Import Library...**&quot;&#xD;&#xA;&#xD;&#xA;**Important note**: it seems just adding `#include &quot;library.h&quot;` does not work with Arduino IDE, you absolutely need to use the menu." />
  <row Id="2104" PostHistoryTypeId="5" PostId="752" RevisionGUID="31dd9291-acad-4cb4-936f-3e13322b7bef" CreationDate="2014-03-16T08:34:00.160" UserId="84" Comment="Added 4th solution as suggested in comment" Text="The component that exploded during your test is a capacitor.&#xD;&#xA;&#xD;&#xA;According to the position on the board you mentioned, it is one of the 2 electrolytic capacitors used on both sides of the 3.3V regulator (I would say that's probably the upstream capcitor).&#xD;&#xA;&#xD;&#xA;There are [a few reasons why a capacitor may explode][1]:&#xD;&#xA;&#xD;&#xA;- apply an inverted voltage to it (polarized capacitors only)&#xD;&#xA;- apply a voltage above its rating&#xD;&#xA;- apply a current above its rating&#xD;&#xA;&#xD;&#xA;Your situation is probably the 2nd one: too high voltage applied.&#xD;&#xA;&#xD;&#xA;According to Sparkfun original schematics, this capacitor must be polarized with 10uF capacity. Unfortunately the schematics do not mention the maximum voltage.&#xD;&#xA;&#xD;&#xA;According to the [specification for the original board][2], the maximum voltage for this cap should be at least 12V, but there is no guarantee that it is anthing above than 12V. Hence, you have to consider **12V is the maximum voltage applicable** to your board (on the RAW pin).&#xD;&#xA;&#xD;&#xA;In addition, you have mentioned you are using a cheap chinese clone, it is perfectly possible (although not expected, as it would make the board operate differently than the original specs) that this one uses a lower voltage cap (eg 10V) which would be a bit cheaper.&#xD;&#xA;&#xD;&#xA;If you do want to reuse your 12V PSU, you will have to ensure that its output voltage never exceeds 12V, for this you are left with a few options:&#xD;&#xA;&#xD;&#xA;- use a [voltage divider][3] made of 2 resistors: you must first know the max voltage output of your PSU and then calculate resistance values to get 12V based on that max voltage. That's easy but it can waste a lot of energy&#xD;&#xA;- use a 12V [Zener diode][4] outside your PSU&#xD;&#xA;- use a 12V [voltage regulator][5] circuit after your PSU: that one is the safest, but also the most expensive solution&#xD;&#xA;&#xD;&#xA;**Edit:**&#xD;&#xA;&#xD;&#xA;Of course, if you have already done it and are equipped for it, you can find replacements for the capacitor that has exploded and buy a higher-voltage one, then replace it on your boards; that will reauire good soldering/desoldering equipement usable for surface-mounted components.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Capacitor#Hazards_and_safety&#xD;&#xA;  [2]: http://arduino.cc/en/Main/ArduinoBoardProMini&#xD;&#xA;  [3]: http://en.wikipedia.org/wiki/Voltage_divider&#xD;&#xA;  [4]: http://en.wikipedia.org/wiki/Zener_diode&#xD;&#xA;  [5]: http://en.wikipedia.org/wiki/Voltage_regulator" />
  <row Id="2105" PostHistoryTypeId="5" PostId="539" RevisionGUID="4ac5df3e-e85b-452f-bc79-15ed1e357400" CreationDate="2014-03-16T09:14:55.600" UserId="510" Comment="Copy edited. Removed meta information (this belongs in comments, if any). (its = possessive, it's = &quot;it is&quot; or &quot;it has&quot;. See for example &lt;http://www.wikihow.com/Use-its-and-it's&gt;.)" Text="I have 2 Lowpowerlab WaterMote's talking to each other using the 'out of the box' pre-installed [sketch][1] that just confirm they're talking to each other. I verified this by opening a COM connection and saw traffic of 'receiving packets...' That was just to show that they are functioning and talking to each other.&#xD;&#xA;&#xD;&#xA;Now, using Arduino IDE on Mac&amp;nbsp;OS&amp;nbsp;X 1.9.x (Lion?) I have loaded the WaterMote sketch (found on [Github][2]) on the Moteino with the sensor (not the gateway) as it should be. The traffic looks like it's working, except the text being transmitted (number of Gallons) stays the same at 0.02 Gallons.&#xD;&#xA;&#xD;&#xA;So... I want to debug the WaterMote sketch, *but* I do not see an option in my Arduino IDE on Mac&amp;nbsp;OS&amp;nbsp;X. Is there a way to debug sketches using Macs? Searching online shows various and preferred options, but mostly on Windows (of which I don't have any at home).&#xD;&#xA;&#xD;&#xA;My current setup&#xD;&#xA;&#xD;&#xA; - Moteino Gateway (as out of the box) connected to a [Raspberry Pi][3] (with ssh enabled)&#xD;&#xA;  - Connected via USB to the RasPi&#xD;&#xA; - Moteino with WaterMote sketch loaded&#xD;&#xA;  - Connected via USB to the MacBook Pro&#xD;&#xA;  - Arduino IDE running, but I see strange &quot;[][][]&quot; square output in the Serial connection.&#xD;&#xA;  - I do not know what to make of this since that text is not in the WaterMote sketch.&#xD;&#xA;&#xD;&#xA;Is there a way to debug sketches loaded on Arduino clones using Arduino IDE on Macs?&#xD;&#xA;&#xD;&#xA;I found a debugging article:&#xD;&#xA;&#xD;&#xA; - [Visual Micro][4]&#xD;&#xA;&#xD;&#xA;  [1]: http://www.arduino.cc/en/Tutorial/Sketch&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/GitHub&#xD;&#xA;  [3]: http://en.wikipedia.org/wiki/Raspberry_Pi&#xD;&#xA;  [4]: http://www.instructables.com/id/Arduino-Debugging-Breakpoints-Tracepoints-and-E/&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2106" PostHistoryTypeId="4" PostId="539" RevisionGUID="4ac5df3e-e85b-452f-bc79-15ed1e357400" CreationDate="2014-03-16T09:14:55.600" UserId="510" Comment="Copy edited. Removed meta information (this belongs in comments, if any). (its = possessive, it's = &quot;it is&quot; or &quot;it has&quot;. See for example &lt;http://www.wikihow.com/Use-its-and-it's&gt;.)" Text="How to debug an Arduino sketch on a Mac?" />
  <row Id="2107" PostHistoryTypeId="24" PostId="539" RevisionGUID="4ac5df3e-e85b-452f-bc79-15ed1e357400" CreationDate="2014-03-16T09:14:55.600" Comment="Proposed by 510 approved by 65, 83 edit id of 238" />
  <row Id="2108" PostHistoryTypeId="5" PostId="637" RevisionGUID="67829e38-932d-4845-aaed-b86de9e91f68" CreationDate="2014-03-16T09:35:43.830" UserId="84" Comment="Put further info" Text="For hot temperature, just follow the datasheet.&#xD;&#xA;&#xD;&#xA;For low temperature, I remember someone last year trying to [overclock a UNO with liquid nitrogen][1] so I guess you won't ever meet any problems with low temps :-)&#xD;&#xA;&#xD;&#xA;In [his blog][2], that person shows that he could run his UNO at 65 MHz by reducing temperature to -196°C.&#xD;&#xA;&#xD;&#xA;Of course, the process was more complex than just reducing the temperature and checking what happens: a lot of improvements were performed on the board.&#xD;&#xA;&#xD;&#xA;The blog explains very well how various components can react to cryogenic temperatures; the major issues seemed to be capacitors which capacitance **dramatically** reduces under low temperatures.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://blog.arduino.cc/2013/08/29/overclocking-arduino-with-liquid-nitrogen/&#xD;&#xA;  [2]: http://3.14.by/en/read/arduino-liquid-nitrogen-overclocking" />
  <row Id="2109" PostHistoryTypeId="2" PostId="754" RevisionGUID="a6e078c4-1e10-48d0-860a-e2f11c84716d" CreationDate="2014-03-16T09:43:55.223" UserId="136" Text="This answer doesn't directly answer the question, but still will result in the same end result.&#xD;&#xA;&#xD;&#xA;The Arduino IDE uses temporary directories to store build files, including the original sketch as well as the HEX and intermediate files.&#xD;&#xA;&#xD;&#xA;On a Mac, these are /var/folders by default, and on a Windows machine Local Settings\Temp\ (which depending on the version of Windows could be in several places).&#xD;&#xA;&#xD;&#xA;I've found that especially in Windows, these build files don't get deleted when you close the sketch or IDE, so may exist on your machine for far longer than you would think.&#xD;&#xA;&#xD;&#xA;Also, by default, Crashplan, Backblaze and Time Machine back-up these locations, so even if they have been deleted, they may still be in a backup.&#xD;&#xA;&#xD;&#xA;The advantage here is that you will recover C code rather than ASM." />
  <row Id="2110" PostHistoryTypeId="2" PostId="755" RevisionGUID="1cf3765b-9fa1-4b11-9a07-86581aa72c2a" CreationDate="2014-03-16T10:25:12.787" UserId="136" Text="The genuine Pro Mini's use a [MIC5205 regulator][1] which should accept up to 16V at it's input normally, with an absolute maximum of 20V. It's unlikely that the regulator would be damaged by 15.1V.&#xD;&#xA;&#xD;&#xA;However, the component you have indicated that has blown is a capacitor. SMD capacitors are available in different voltage ratings, typically 4V, 6.3V, 10V, 16V, 25V, 35V and 50V (and above, but let's ignore them for this). It's rare to see any intermediate values.&#xD;&#xA;&#xD;&#xA;SMD capacitors are very intolerant of being used at a higher voltage than specified. This is especially true of electrolytic and tantalum capacitors. The blown capacitor on the genuine Pro Mini's is polarised (the grey band not he package and the schematic indicates this), so we can infer it is either electrolytic or tantalum. A 10µF SMD electrolytic is unlikely to be in this package, so it is almost certainly a tantalum.&#xD;&#xA;&#xD;&#xA;Sparkfun sell [10µF tantalums][2], and they are rated at 16V. It's quite likely these are the same ones used on the Pro Mini. 15.1V is very close to 16V - in fact, if this is a poorly smoothed power supply, the meter might show 15.1V but the peaks could well be 16V or even 20V. It is recommended that you de-rate the voltage ratings on tantalums by 50% at least.&#xD;&#xA;&#xD;&#xA;It's really important to realise that most low-cost DC power supplies are not regulated and produce a very bumpy output voltage with no regulation:&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;Tantalums also have no tolerance for reverse voltage, so if you did apply reverse voltage, it would pop.&#xD;&#xA;&#xD;&#xA;So it is quite likely that you over-volted the cap and blew it. You could replace them with higher rated capacitors - I would go for 35V ones if you want to supply 15.1V. Desoldering and desoldering a single capacitor is relatively easy as long as the pads haven't been damaged. Realistically, you could use a normal leaded 10uF electrolytic between RAW and GND instead of the SMD one.&#xD;&#xA;&#xD;&#xA;There is a further consideration that dropping from 15.1V to 3.3V on a SMD regulator is not a great idea. You will need to burn off a lot of power.&#xD;&#xA;&#xD;&#xA;The MC5205 can dissipate 455mW with a minimal PCB footprint (which the Pro Mini has) with a 25°C ambient:&#xD;&#xA;&#xD;&#xA;![Thermal calc][4]&#xD;&#xA;&#xD;&#xA;So, we know the maximum power we can dissipate, and we know the voltage drop - we can then calculate the current:&#xD;&#xA;&#xD;&#xA;P = (Vin - Vout) * I&#xD;&#xA;&#xD;&#xA;0.455 / (15.1 - 3.3) = I&#xD;&#xA;&#xD;&#xA;I = 38.5mA&#xD;&#xA;&#xD;&#xA;This isn't very much at all. You might want to consider regulating off the board, and probably with a switching regulator rather than linear regulator.&#xD;&#xA;&#xD;&#xA;I also note your PS:&#xD;&#xA;&#xD;&#xA;&gt; the ground of the 12V PSU is shared with Arduino ground pin, not sure&#xD;&#xA;&gt; if this might be the cause.&#xD;&#xA;&#xD;&#xA;If they weren't shared, there would be no way that this could work. They need to be shared otherwise the Vcc from the power supply is not referenced to anything and may as well not be there.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.micrel.com/_PDF/mic5205.pdf&#xD;&#xA;  [2]: https://www.sparkfun.com/products/11244&#xD;&#xA;  [3]: http://i.stack.imgur.com/ihvi5.gif&#xD;&#xA;  [4]: http://i.stack.imgur.com/lBlQZ.png" />
  <row Id="2111" PostHistoryTypeId="5" PostId="755" RevisionGUID="2a521eb9-5ce5-48d4-842c-00a8ca975d69" CreationDate="2014-03-16T10:46:31.733" UserId="136" Comment="Maybe regulator is popped." Text="The genuine Pro Mini's use a [MIC5205 regulator][1] which should accept up to 16V at it's input normally, with an absolute maximum of 20V. It's unlikely that the regulator would be damaged by 15.1V.&#xD;&#xA;&#xD;&#xA;However, the component you have indicated that has blown is a capacitor. SMD capacitors are available in different voltage ratings, typically 4V, 6.3V, 10V, 16V, 25V, 35V and 50V (and above, but let's ignore them for this). It's rare to see any intermediate values.&#xD;&#xA;&#xD;&#xA;SMD capacitors are very intolerant of being used at a higher voltage than specified. This is especially true of electrolytic and tantalum capacitors. The blown capacitor on the genuine Pro Mini's is polarised (the grey band not he package and the schematic indicates this), so we can infer it is either electrolytic or tantalum. A 10µF SMD electrolytic is unlikely to be in this package, so it is almost certainly a tantalum.&#xD;&#xA;&#xD;&#xA;Sparkfun sell [10µF tantalums][2], and they are rated at 16V. It's quite likely these are the same ones used on the Pro Mini. 15.1V is very close to 16V - in fact, if this is a poorly smoothed power supply, the meter might show 15.1V but the peaks could well be 16V or even 20V. It is recommended that you de-rate the voltage ratings on tantalums by 50% at least.&#xD;&#xA;&#xD;&#xA;It's really important to realise that most low-cost DC power supplies are not regulated and produce a very bumpy output voltage with no regulation:&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;Tantalums also have no tolerance for reverse voltage, so if you did apply reverse voltage, it would pop.&#xD;&#xA;&#xD;&#xA;So it is quite likely that you over-volted the cap and blew it. You could replace them with higher rated capacitors - I would go for 35V ones if you want to supply 15.1V. Desoldering and desoldering a single capacitor is relatively easy as long as the pads haven't been damaged. Realistically, you could use a normal leaded 10uF electrolytic between RAW and GND instead of the SMD one.&#xD;&#xA;&#xD;&#xA;**EDIT:** However, looking at the data sheet for the regulator, it shouldn't really matter if that 10uF is there or not:&#xD;&#xA;&#xD;&#xA;&gt; A 1μF capacitor should be placed from IN to GND if there is more than&#xD;&#xA;&gt; 10 inches of wire between the input and the ac filter capacitor or if&#xD;&#xA;&gt; a battery is used as the input.&#xD;&#xA;&#xD;&#xA;Some regulators absolutely require an input capacitor, with others it is just advisable. This looks like it is just advisable. So if it isn't working on external power now, you may have blown the regulator as well.&#xD;&#xA;&#xD;&#xA;Even if the clone board uses a different SMD regulator, their characteristics are all very similar. As stated, some do need a capacitor on the input to work, so replacing it might fix it.&#xD;&#xA;&#xD;&#xA;There is a further consideration that dropping from 15.1V to 3.3V on a SMD regulator is not a great idea. You will need to burn off a lot of power.&#xD;&#xA;&#xD;&#xA;The MC5205 can dissipate 455mW with a minimal PCB footprint (which the Pro Mini has) with a 25°C ambient:&#xD;&#xA;&#xD;&#xA;![Thermal calc][4]&#xD;&#xA;&#xD;&#xA;So, we know the maximum power we can dissipate, and we know the voltage drop - we can then calculate the current:&#xD;&#xA;&#xD;&#xA;P = (Vin - Vout) * I&#xD;&#xA;&#xD;&#xA;0.455 / (15.1 - 3.3) = I&#xD;&#xA;&#xD;&#xA;I = 38.5mA&#xD;&#xA;&#xD;&#xA;This isn't very much at all. You might want to consider regulating off the board, and probably with a switching regulator rather than linear regulator.&#xD;&#xA;&#xD;&#xA;I also note your PS:&#xD;&#xA;&#xD;&#xA;&gt; the ground of the 12V PSU is shared with Arduino ground pin, not sure&#xD;&#xA;&gt; if this might be the cause.&#xD;&#xA;&#xD;&#xA;If they weren't shared, there would be no way that this could work. They need to be shared otherwise the Vcc from the power supply is not referenced to anything and may as well not be there.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.micrel.com/_PDF/mic5205.pdf&#xD;&#xA;  [2]: https://www.sparkfun.com/products/11244&#xD;&#xA;  [3]: http://i.stack.imgur.com/ihvi5.gif&#xD;&#xA;  [4]: http://i.stack.imgur.com/lBlQZ.png&#xD;&#xA;" />
  <row Id="2112" PostHistoryTypeId="2" PostId="756" RevisionGUID="2cbb1e2c-979e-49db-a487-457890b4c62f" CreationDate="2014-03-16T10:52:39.307" UserId="136" Text="I've noticed some irritating differences between the Arduino IDE and Stino (mainly around including certain header files). These are likely bugs that need following up with one or both of the parties, but in the meantime, I would like my code to compile with both of them without editing. This is because I do not want to lock any users out of using my code.&#xD;&#xA;&#xD;&#xA;Are there any macros or similar that are readily available (as in, require no modification of the toolchain or IDE) that would allow me to detect which is in use?&#xD;&#xA;&#xD;&#xA;For example, in many libraries, there is this snippet:&#xD;&#xA;&#xD;&#xA;    #if ARDUINO &gt;= 100&#xD;&#xA;      #include &quot;Arduino.h&quot;&#xD;&#xA;    #else&#xD;&#xA;      #include &quot;WProgram.h&quot;&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;However both Stino and Arduino define this." />
  <row Id="2113" PostHistoryTypeId="1" PostId="756" RevisionGUID="2cbb1e2c-979e-49db-a487-457890b4c62f" CreationDate="2014-03-16T10:52:39.307" UserId="136" Text="Is there a way to detect if Arduino, Stino or another IDE/toolchain is in use?" />
  <row Id="2114" PostHistoryTypeId="3" PostId="756" RevisionGUID="2cbb1e2c-979e-49db-a487-457890b4c62f" CreationDate="2014-03-16T10:52:39.307" UserId="136" Text="&lt;ide&gt;&lt;build&gt;" />
  <row Id="2115" PostHistoryTypeId="2" PostId="757" RevisionGUID="746d87c2-affd-4e07-ac6c-e4cc98a89604" CreationDate="2014-03-16T11:31:29.970" UserId="136" Text="Nearly all modern Arduino boards use the [Optiboot bootloader][1]. Compared to the ATmegaboot used before, this is smaller in flash terms (by about 1.5KB) and faster in upload speed (115.2k vs 57.6k) and starts your sketch quicker (the delay whilst waiting after reset is shorter).&#xD;&#xA;&#xD;&#xA;Are there any alternatives to the Optiboot bootloader? Specifically, are there any smaller (in flash terms) boot loaders? What differences do they have?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://code.google.com/p/optiboot/" />
  <row Id="2116" PostHistoryTypeId="1" PostId="757" RevisionGUID="746d87c2-affd-4e07-ac6c-e4cc98a89604" CreationDate="2014-03-16T11:31:29.970" UserId="136" Text="What alternatives are there to the Optiboot bootloader?" />
  <row Id="2117" PostHistoryTypeId="3" PostId="757" RevisionGUID="746d87c2-affd-4e07-ac6c-e4cc98a89604" CreationDate="2014-03-16T11:31:29.970" UserId="136" Text="&lt;bootloader&gt;" />
  <row Id="2118" PostHistoryTypeId="2" PostId="758" RevisionGUID="ec920a0a-a62c-4d03-a843-a5c2f5fa9b50" CreationDate="2014-03-16T11:45:16.947" UserId="136" Text="Serial1 on the Arduino Leonardo is hardware serial, not software. &#xD;&#xA;&#xD;&#xA;There are several ways to read in multiple bytes from Serial.&#xD;&#xA;&#xD;&#xA;Instead of detecting `Serial.available()` (i.e. non-zero), change it to `Serial.available() &gt;= 2`&#xD;&#xA;&#xD;&#xA;    if (Serial.available() &gt;= 2) {&#xD;&#xA;      for (int i=0; i&lt;2; i++) {&#xD;&#xA;        buffer[i] = Serial.read();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Or you can leave it as it is, and read into the buffer one at a time.&#xD;&#xA;&#xD;&#xA;    static int bufferIndex;&#xD;&#xA;    &#xD;&#xA;    if (Serial.available())&#xD;&#xA;    {&#xD;&#xA;    	buffer[bufferIndex++] = Serial.read()&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You'll need to detect the contents of the buffer in another `if` statement, and also deal with the bounds of the index.&#xD;&#xA;&#xD;&#xA;Honestly though, noise is your issue here - this is an example of an [XY problem][1]. There's nothing inherent in using a microcontroller with relays that should mean that serial won't work.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://meta.stackoverflow.com/questions/66377/what-is-the-xy-problem" />
  <row Id="2119" PostHistoryTypeId="33" PostId="725" RevisionGUID="75bb35c0-5aca-4505-a9ee-c4630f151519" CreationDate="2014-03-16T11:47:23.320" UserId="136" Comment="4" />
  <row Id="2120" PostHistoryTypeId="13" PostId="239" RevisionGUID="505d2d43-a34a-4cab-949b-6c4af40b0eec" CreationDate="2014-03-16T12:54:15.760" UserId="220" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:220,&quot;DisplayName&quot;:&quot;Annonomus Person&quot;}]}" />
  <row Id="2121" PostHistoryTypeId="2" PostId="759" RevisionGUID="0d81bdf8-9c97-4a09-8fd8-0044db7a9d4e" CreationDate="2014-03-16T13:54:12.883" UserId="453" Text="I would like to constantly save data coming from sensors (for an activity tracker) while consuming as less battery as possible (I'd like to have a 4/5 days autonomy on a 3000 mAh battery) but I can't find the best way to save about 2 kBytes/s on a memory large enough to contain several days of data.&#xD;&#xA;Any ideas ?" />
  <row Id="2122" PostHistoryTypeId="1" PostId="759" RevisionGUID="0d81bdf8-9c97-4a09-8fd8-0044db7a9d4e" CreationDate="2014-03-16T13:54:12.883" UserId="453" Text="Most power efficient way to constantly save 2 kilobytes of data per second" />
  <row Id="2123" PostHistoryTypeId="3" PostId="759" RevisionGUID="0d81bdf8-9c97-4a09-8fd8-0044db7a9d4e" CreationDate="2014-03-16T13:54:12.883" UserId="453" Text="&lt;battery&gt;" />
  <row Id="2124" PostHistoryTypeId="2" PostId="760" RevisionGUID="90df9e78-a53f-43cf-8eac-1171508936af" CreationDate="2014-03-16T13:59:26.437" UserId="639" Text="On my Arduino Uno R3 and Arduino Mega R3, there are 5V and 3.3V pins. &#xD;&#xA;&#xD;&#xA;However on this page http://arduino.cc/en/reference/board, there is a 5V and 9V pin but no 3.3V pin. The page at http://playground.arduino.cc/Learning/WhatAdapter also mentions a 9V pin. &#xD;&#xA;&#xD;&#xA;Why is there a discrepency?&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/YBmuc.png" />
  <row Id="2125" PostHistoryTypeId="1" PostId="760" RevisionGUID="90df9e78-a53f-43cf-8eac-1171508936af" CreationDate="2014-03-16T13:59:26.437" UserId="639" Text="3.3V, 5V and 9V pins on Arduino" />
  <row Id="2126" PostHistoryTypeId="3" PostId="760" RevisionGUID="90df9e78-a53f-43cf-8eac-1171508936af" CreationDate="2014-03-16T13:59:26.437" UserId="639" Text="&lt;arduino-uno&gt;&lt;pins&gt;&lt;power&gt;&lt;arduino-mega&gt;" />
  <row Id="2127" PostHistoryTypeId="6" PostId="759" RevisionGUID="468d8980-9899-409d-bf52-3500ddffc235" CreationDate="2014-03-16T14:16:29.433" UserId="65" Comment="edited tags" Text="&lt;battery&gt;&lt;system-design&gt;" />
  <row Id="2128" PostHistoryTypeId="2" PostId="761" RevisionGUID="a7ab33a3-bb75-4d13-955e-78041e4effa2" CreationDate="2014-03-16T14:34:59.450" UserId="65" Text="There are three power pins on the Arduino Uno and on the Mega:&#xD;&#xA;&#xD;&#xA;- 5V - Labelled as 5V. Can be used to power other 5V devices.&#xD;&#xA;- 3.3V - Labelled as 3.3V. Can be used to power other 3.3V devices.&#xD;&#xA;- Vin - This also referred to as the 9V pin that is shown in the schematic. This is used to power the Arduino board itself, usually using a 9V battery.&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/cpfrj.jpg" />
  <row Id="2129" PostHistoryTypeId="2" PostId="762" RevisionGUID="a08ff86e-97ba-4ce2-bd6e-70d427ae67d7" CreationDate="2014-03-16T14:36:30.767" UserId="84" Text="The link you provide looks rather old and I don't think it applies to UNO Revision 3 as it has more pins than on the diagram you show.&#xD;&#xA;&#xD;&#xA;I suggest you rather take a look at this [Arduino UNO link][1] which contains uptodate information about the UNO; in there you will see that for R3, the &quot;power rail&quot; has been extended and has the following pins, left to right:&#xD;&#xA;&#xD;&#xA;- 1 unlabeled pin (can't remember what it is)&#xD;&#xA;- 1 **IOREF** pin (used by shields to know if they should operate as 3.3V or 5V devices)&#xD;&#xA;- **3.3V** regulated output&#xD;&#xA;- **5V** regulated output&#xD;&#xA;- 2 **GND** pins&#xD;&#xA;- **Vin** pin: this pin can be used in 2 different ways:&#xD;&#xA;    - either as a voltage supply input (instead of using the power plug or the USB); the input voltage should be in 7-12V range and will be regulated internally (by the board circuits) to 5V&#xD;&#xA;    - or an output supply voltage (if you plugged voltage supply through the power plug or the USB plug) that is a &quot;copy&quot; of the voltage input through the power plug or USB plug (not regulated yet)&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardUno" />
  <row Id="2130" PostHistoryTypeId="5" PostId="761" RevisionGUID="a97632c0-2f82-452d-9d4b-66fe59fe114f" CreationDate="2014-03-16T14:42:43.467" UserId="65" Comment="added 7 characters in body" Text="There are three power supply pins on the Arduino Uno and on the Mega:&#xD;&#xA;&#xD;&#xA;- 5V - Labelled as 5V. Can be used to power other 5V devices.&#xD;&#xA;- 3.3V - Labelled as 3.3V. Can be used to power other 3.3V devices.&#xD;&#xA;- Vin - This also referred to as the 9V pin that is shown in the schematic. This is used to power the Arduino board itself, usually using a 9V battery.&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/cpfrj.jpg" />
  <row Id="2132" PostHistoryTypeId="2" PostId="763" RevisionGUID="8d298fae-ca0c-4e43-9021-a1dc7e626f23" CreationDate="2014-03-16T15:00:54.307" UserId="304" Text="I would like to know how much RAM I am using in my project, as far as I can tell, there's no way to actually work that out (other than going through and calculating it myself). I have got to a stage in a rather large project where I have determined that I am running out of RAM. &#xD;&#xA;&#xD;&#xA;I have determined this because I can add a section and then all hell breaks loose somewhere else in my code for no apparent reason. If I `#ifndef` that section out, it works again. There is nothing programatically wrong with the new code. &#xD;&#xA;&#xD;&#xA;I suspected for a while that I was getting to the end of available RAM. I don't think I'm using too much stack (although it's possible), what is the best way to determine how much RAM I am actually using?&#xD;&#xA;&#xD;&#xA;Going through and trying to work it out, I have problems when I get to enums and structs; how much memory do they cost? " />
  <row Id="2133" PostHistoryTypeId="1" PostId="763" RevisionGUID="8d298fae-ca0c-4e43-9021-a1dc7e626f23" CreationDate="2014-03-16T15:00:54.307" UserId="304" Text="I'm using too much RAM. How can this be measured?" />
  <row Id="2134" PostHistoryTypeId="3" PostId="763" RevisionGUID="8d298fae-ca0c-4e43-9021-a1dc7e626f23" CreationDate="2014-03-16T15:00:54.307" UserId="304" Text="&lt;sram&gt;" />
  <row Id="2135" PostHistoryTypeId="2" PostId="764" RevisionGUID="c979d5e6-172f-42d7-bfb4-e502fd7fb883" CreationDate="2014-03-16T15:15:03.480" UserId="65" Text="&gt; I suspected for a while that I was getting to the end of available RAM. I don't think I'm using too much stack (although it's possible), what is the best way to determine how much RAM I am actually using?&#xD;&#xA;&#xD;&#xA;It would be best to use a combination of manual estimation and by using the `sizeof` operator. If all your declarations are static, then this should give you an accurate picture.&#xD;&#xA;&#xD;&#xA;If you are using dynamic allocations, then you may run into a problem once you start deallocating the memory. This is due to memory fragmentation on the heap. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&gt; Going through and trying to work it out, I have problems when I get to enums and structs; how much memory do they cost?&#xD;&#xA;&#xD;&#xA;An enum takes as much space as an `int`. So, if you have a set of 10 elements in a `enum` declaration, that would be `10*sizeof(int)`. Also, every variable that uses an enumeration is simply an `int`.&#xD;&#xA;&#xD;&#xA;For structures, it would be easiest to use `sizeof` to find out. Structures occupy a (minimum) space equal to sum of its members. If the compiler does structure alignment, then it may be more, however this is unlikely in the case of `avr-gcc`.&#xD;&#xA;" />
  <row Id="2136" PostHistoryTypeId="2" PostId="765" RevisionGUID="e8c30648-db84-4a93-aa23-720b3b1e203b" CreationDate="2014-03-16T15:18:53.663" UserId="8" Text="I think the problem is with your bootloader, but not in the way you think.&#xD;&#xA;&#xD;&#xA;When an Arduino starts up, a bootloader profiting several tasks, such as looking for a serial host or loading program data from flash is going to take a lot more energy than a sleeping Arduino.&#xD;&#xA;&#xD;&#xA;I think the reason why your Arduino will not start is because the bootloader requires an accurate clock source, but applying 3v to it will mess up that clock and it will perhaps crash or wait for 3.3v to be applied for a stable source.&#xD;&#xA;&#xD;&#xA;Looking at the datasheet:&#xD;&#xA;&#xD;&#xA;![copyright ATMEL][1]&#xD;&#xA;&#xD;&#xA;We see that current draw while waking up (running the bootloader) is probably going to be around 2mA, while sleeping current is about *0.8 microamps*. This could certainly lead to a blackout on startup without the proper current. &#xD;&#xA;&#xD;&#xA;Perhaps you should only turn it on with 5v power, or maybe you need a higher current, higher voltage battery.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/NZAHA.jpg" />
  <row Id="2137" PostHistoryTypeId="6" PostId="460" RevisionGUID="063d70df-9520-44ef-ba3f-a5f04ae658c9" CreationDate="2014-03-16T15:19:10.200" UserId="65" Comment="edited tags" Text="&lt;arduino-uno&gt;&lt;safety&gt;&lt;flash&gt;" />
  <row Id="2138" PostHistoryTypeId="6" PostId="682" RevisionGUID="71b700e6-6008-4c32-888d-4ceaa73d4f13" CreationDate="2014-03-16T15:19:31.437" UserId="65" Comment="edited tags" Text="&lt;programming&gt;&lt;sram&gt;&lt;eeprom&gt;" />
  <row Id="2139" PostHistoryTypeId="2" PostId="766" RevisionGUID="b0571d7c-027a-4d6c-9c36-239f753734cf" CreationDate="2014-03-16T16:40:08.613" UserDisplayName="user641" Text="I got an Arduino Uno to play around with, and started to actually dive in. During a program that I am writing for a friend, it suddenly stopped outputting to the serial monitor. When I comment out the part I added (the for loop for changing the names), it still doesn't respond. Please help!&#xD;&#xA;&#xD;&#xA;Pastebin:http://pastebin.com/0ynqyftG" />
  <row Id="2140" PostHistoryTypeId="1" PostId="766" RevisionGUID="b0571d7c-027a-4d6c-9c36-239f753734cf" CreationDate="2014-03-16T16:40:08.613" UserDisplayName="user641" Text="Arduino Not Responding During Program" />
  <row Id="2141" PostHistoryTypeId="3" PostId="766" RevisionGUID="b0571d7c-027a-4d6c-9c36-239f753734cf" CreationDate="2014-03-16T16:40:08.613" UserDisplayName="user641" Text="&lt;arduino-uno&gt;" />
  <row Id="2142" PostHistoryTypeId="2" PostId="767" RevisionGUID="7daa953e-9e57-489f-96a6-53ee3b33a915" CreationDate="2014-03-16T16:59:39.360" UserId="643" Text="the string array is too big for ram, place it in flash with the fucntion F()&#xD;&#xA;&#xD;&#xA;    Serial.println(F(&quot;This string will be stored in flash memory&quot;));&#xD;&#xA;&#xD;&#xA;also a detailed example with array with explanation cn be found [here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://forum.arduino.cc/index.php/topic,145756.0.html" />
  <row Id="2143" PostHistoryTypeId="2" PostId="768" RevisionGUID="0625a78e-656b-4ea4-ad9e-d66490eb0c54" CreationDate="2014-03-16T17:00:01.457" UserId="65" Text="You have mixed up your comparison and assignment operators in two instances:&#xD;&#xA;&#xD;&#xA;First is towards the end of `setup`.&#xD;&#xA;&#xD;&#xA;      for (int i = 0 ; i &lt; 152 ; i++){&#xD;&#xA;          //if (currentID = i){ //This is assignment, not comparison&#xD;&#xA;          //This is a comparison operation&#xD;&#xA;            if (currentID == i){&#xD;&#xA;            pokemonName = nameArray[i];&#xD;&#xA;            Serial.print(pokemonName);&#xD;&#xA;            break;&#xD;&#xA;          }&#xD;&#xA;       }&#xD;&#xA;&#xD;&#xA;Second, is in the function definition of `nameChange`.&#xD;&#xA;&#xD;&#xA;    void nameChange(int currentID){&#xD;&#xA;       for (int i = 0 ; i &lt; 152 ; i++){&#xD;&#xA;          //if (currentID = i){ //This is an assignment operation, not comparison.&#xD;&#xA;          //This is a comparison operation&#xD;&#xA;            if (currentID == i){&#xD;&#xA;            pokemonName = nameArray[i];&#xD;&#xA;            break;&#xD;&#xA;          }&#xD;&#xA;       }" />
  <row Id="2144" PostHistoryTypeId="6" PostId="766" RevisionGUID="4ae5ad8e-4215-499a-9863-65e0f62eb2bb" CreationDate="2014-03-16T17:00:16.397" UserId="65" Comment="edited tags" Text="&lt;arduino-uno&gt;&lt;programming&gt;" />
  <row Id="2145" PostHistoryTypeId="5" PostId="768" RevisionGUID="4e5f5e24-c6b1-4286-a7d9-c010dcc899ec" CreationDate="2014-03-16T17:07:52.287" UserId="65" Comment="[Edit removed during grace period]; added 85 characters in body" Text="You have mixed up your comparison and assignment operators in two instances:&#xD;&#xA;&#xD;&#xA;First is towards the end of `setup`.&#xD;&#xA;&#xD;&#xA;      for (int i = 0 ; i &lt; 152 ; i++){&#xD;&#xA;          //if (currentID = i){ //This is assignment, not comparison&#xD;&#xA;          //This is a comparison operation&#xD;&#xA;            if (currentID == i){&#xD;&#xA;            pokemonName = nameArray[i];&#xD;&#xA;            Serial.print(pokemonName);&#xD;&#xA;            break;&#xD;&#xA;          }&#xD;&#xA;       }&#xD;&#xA;&#xD;&#xA;Second, is in the function definition of `nameChange`.&#xD;&#xA;&#xD;&#xA;    void nameChange(int currentID){&#xD;&#xA;       for (int i = 0 ; i &lt; 152 ; i++){&#xD;&#xA;          //if (currentID = i){ //This is an assignment operation, not comparison.&#xD;&#xA;          //This is a comparison operation&#xD;&#xA;            if (currentID == i){&#xD;&#xA;            pokemonName = nameArray[i];&#xD;&#xA;            break;&#xD;&#xA;          }&#xD;&#xA;       }&#xD;&#xA;&#xD;&#xA;Also, you have defined a constant `numPokemon` but are not using it at any point." />
  <row Id="2146" PostHistoryTypeId="2" PostId="769" RevisionGUID="4d2eb992-0c53-4ed2-b76c-e163f7684b84" CreationDate="2014-03-16T17:10:07.630" UserId="136" Text="The primary reason that this isn't working is that you are using more RAM than the ATmega328 has (2Kbytes). &#xD;&#xA;&#xD;&#xA;The array nameArray is huge. Each one of those characters is 1 byte, it's ~1.1k in itself. Add in Serial, TrueRandom and String, and you are over the limit. It could be you are right on the bounds and calling a single function pushes the stack over it's limit.&#xD;&#xA;&#xD;&#xA;To save size, you can place the strings in flash. There is functionality to do this in Arduino, namely [PROGMEM directive][1] from underlying AVR-GCC and F() from Arduino. Making arrays of string is quite painful though, and using the [Flash library][2] helps here.&#xD;&#xA;&#xD;&#xA;Personally I would avoid String for anything like this. The insides of String use dynamic memory allocation and when you are near the limits of RAM, it really isn't helpful. You lose a lot of ease of use by moving to arrays of char though.&#xD;&#xA;&#xD;&#xA;You are also using assignment instead of comparison in your code:&#xD;&#xA;&#xD;&#xA;    if (currentID = i){&#xD;&#xA;       pokemonName = nameArray[i];&#xD;&#xA;       Serial.print(pokemonName);&#xD;&#xA;       break;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This needs to be `currentID == i`.&#xD;&#xA;&#xD;&#xA;I'm not confident what you are doing here though. If you want to get the *i* th element from the array, then just do&#xD;&#xA;&#xD;&#xA;    pokemonName = nameArray[currentID]&#xD;&#xA;&#xD;&#xA;You also have an odd conditional at the beginning where you check for an EEPROM value being non zero, and then the else reads out the EEPROM value which by definition must be zero.&#xD;&#xA;&#xD;&#xA;Also, you have a define for `numPokemon` but you aren't using it for the bounds on your for loops.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/PROGMEM#.UyXZldzGnHg&#xD;&#xA;  [2]: http://arduiniana.org/libraries/flash/" />
  <row Id="2147" PostHistoryTypeId="2" PostId="770" RevisionGUID="a3c8e13b-05e1-49c7-827e-347e12fd2343" CreationDate="2014-03-16T17:23:31.177" UserId="8" Text="This would be possible with a standard SD card.&#xD;&#xA;&#xD;&#xA;**Capacity**&#xD;&#xA;&#xD;&#xA;Using some simple calculations, I was able to find that writing at 2kB/s for 5 days would only consume 0.8GB. You could probably get by with a 1 or 2 GB card.&#xD;&#xA;&#xD;&#xA;**Speed**&#xD;&#xA;&#xD;&#xA;I found [this benchmark](http://forum.arduino.cc/index.php/topic,109862.0.html), which says it is possible to write SD card data from an Arduino at 192 kB/s, which should be more than enough for your needs.&#xD;&#xA;&#xD;&#xA;There are a lot of great tutorials and examples out there for using an SD card with an Arduino. The [official documentation](http://arduino.cc/en/Reference/SD) is always a good place to start." />
  <row Id="2148" PostHistoryTypeId="2" PostId="771" RevisionGUID="27eebaaa-4b77-45bd-bf52-f8ba46f9085e" CreationDate="2014-03-16T18:30:53.387" UserId="642" Text="I'm using a PROGMEM char* to store a massive array. When I try to print a certain part of the array, the message comes out mangled. How do I fix this?&#xD;&#xA;&#xD;&#xA;The output should be &quot;Poliwag&quot;, but it comes out as &quot;arow&quot;.&#xD;&#xA;&#xD;&#xA;Pastebin:http://pastebin.com/cztV5y4q" />
  <row Id="2149" PostHistoryTypeId="1" PostId="771" RevisionGUID="27eebaaa-4b77-45bd-bf52-f8ba46f9085e" CreationDate="2014-03-16T18:30:53.387" UserId="642" Text="Unrecognizable Message From PROGMEM char*" />
  <row Id="2150" PostHistoryTypeId="3" PostId="771" RevisionGUID="27eebaaa-4b77-45bd-bf52-f8ba46f9085e" CreationDate="2014-03-16T18:30:53.387" UserId="642" Text="&lt;arduino-uno&gt;&lt;progmem&gt;" />
  <row Id="2151" PostHistoryTypeId="2" PostId="772" RevisionGUID="b4fce489-4a79-4e7a-9f12-33e53aeb65e2" CreationDate="2014-03-16T18:36:13.757" UserId="368" Text="The way you've written in, the *pointer* is stored in flash, but the strings are stored in *SRAM*. Read &lt;a href=&quot;http://www.nongnu.org/avr-libc/user-manual/pgmspace.html&quot;&gt;the appropriate documentation&lt;/a&gt; (also found in the &lt;a href=&quot;http://arduino.cc/en/Reference/PROGMEM&quot;&gt;Arduino reference&lt;/a&gt;) more closely, and do as it says.&#xD;&#xA;&#xD;&#xA;    char nmPokemon0[] PROGMEM = &quot;MISSINGNO&quot;;&#xD;&#xA;    char nmPokemon1[] PROGMEM = &quot;Bulbasaur&quot;;&#xD;&#xA;     ...&#xD;&#xA;    &#xD;&#xA;    PGM_P nameArray[] PROGMEM =&#xD;&#xA;    {&#xD;&#xA;      nmPokemon0, nmPokemon1, ...&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2152" PostHistoryTypeId="5" PostId="772" RevisionGUID="488d6846-3418-4108-a3f6-fe485a5fed23" CreationDate="2014-03-16T18:44:57.103" UserId="368" Comment="added 146 characters in body" Text="The way you've written in, the *pointer* is stored in flash, but the strings are stored in *SRAM*. Read &lt;a href=&quot;http://www.nongnu.org/avr-libc/user-manual/pgmspace.html&quot;&gt;the appropriate documentation&lt;/a&gt; (also found in the &lt;a href=&quot;http://arduino.cc/en/Reference/PROGMEM&quot;&gt;Arduino reference&lt;/a&gt;) more closely, and do as it says.&#xD;&#xA;&#xD;&#xA;    char nmPokemon0[] PROGMEM = &quot;MISSINGNO&quot;;&#xD;&#xA;    char nmPokemon1[] PROGMEM = &quot;Bulbasaur&quot;;&#xD;&#xA;     ...&#xD;&#xA;    &#xD;&#xA;    PGM_P nameArray[] PROGMEM =&#xD;&#xA;    {&#xD;&#xA;      nmPokemon0, nmPokemon1, ...&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;And don't forget to copy the string to SRAM as shown further down before outputting it, since `Serial.println()` can't work directly with flash.&#xD;&#xA;" />
  <row Id="2153" PostHistoryTypeId="5" PostId="759" RevisionGUID="8aaf1776-edfd-418e-aefa-e3dda23ddc2e" CreationDate="2014-03-16T19:43:08.150" UserId="84" Comment="completed question based on all comments answered by OP" Text="I would like to constantly save data coming from sensors (for an activity tracker) while consuming as less battery as possible (I'd like to have a 4/5 days autonomy on a 3000 mAh battery) but I can't find the best way to save about 2 kBytes/s on a memory large enough to contain several days of data.&#xD;&#xA;&#xD;&#xA;Sensors would be read at a rate of 20 times per second and produce about 100 bytes each time.&#xD;&#xA;&#xD;&#xA;What options do I have in order to:&#xD;&#xA;&#xD;&#xA;- store such an amount of data (hardware)?&#xD;&#xA;- ensure the system can work properly with required autonomy?" />
  <row Id="2154" PostHistoryTypeId="24" PostId="759" RevisionGUID="8aaf1776-edfd-418e-aefa-e3dda23ddc2e" CreationDate="2014-03-16T19:43:08.150" Comment="Proposed by 84 approved by 136, 83 edit id of 239" />
  <row Id="2156" PostHistoryTypeId="2" PostId="773" RevisionGUID="dc79e3f1-1afa-4574-b528-e2e892ab1f97" CreationDate="2014-03-16T20:03:56.367" UserId="136" Text="There are two constraints here, and I think it might back you into a corner. Size and then power.&#xD;&#xA;&#xD;&#xA;2Kbyte/s is 2*60*60*24/1024 = 168.75Mbyte/day. This is a lot. The only readily available technology that can be used with a small microprocessor that can store this volume of data is an SD card. There are no serial EEPROM or flash chips this large, and the Arduino, as far as I know, can't deal with the NAND flash used in USB sticks and SD cards.&#xD;&#xA;&#xD;&#xA;However, SD cards can be relatively power hungry. They draw between 5mA and 100mA when writing, typically around 30-50mA. The SD spec says the maximum is 200mA. Writing is also quite lengthy as they operate on blocks of data rather than individual cells. I've never done a full analysis of how much power they use, but it is not insignificant and much, much more than serial EEPROM or flash.&#xD;&#xA;&#xD;&#xA;So your only choice, if you have to store that much, is to go with SD cards.&#xD;&#xA;&#xD;&#xA;I would investigate compressing the data. Even very basic schemes can make a huge difference." />
  <row Id="2157" PostHistoryTypeId="5" PostId="771" RevisionGUID="477a5d04-29de-4e31-a834-91a698ee8934" CreationDate="2014-03-16T20:04:20.663" UserId="470" Comment="attached code" Text="I'm using a PROGMEM char* to store a massive array. When I try to print a certain part of the array, the message comes out mangled. How do I fix this?&#xD;&#xA;&#xD;&#xA;The output should be &quot;Poliwag&quot;, but it comes out as &quot;arow&quot;.&#xD;&#xA;&#xD;&#xA;Pastebin:http://pastebin.com/cztV5y4q&#xD;&#xA;&#xD;&#xA;&lt;!-- language-all: lang-c --&gt;&#xD;&#xA;&#xD;&#xA;    #include &lt;TrueRandom.h&gt;&#xD;&#xA;    #include &lt;EEPROM.h&gt;&#xD;&#xA;    #define numPokemon 151&#xD;&#xA;    PROGMEM char* nameArray[] = {&quot;MISSINGNO&quot;,&quot;Bulbasaur&quot;,&quot;Ivysaur&quot;,&quot;Venusaur&quot;,&quot;Charmander&quot;,&quot;Charmeleon&quot;,&quot;Charizard&quot;,&quot;Squirtle&quot;,&#xD;&#xA;    &quot;Wartortle&quot;,&quot;Blastoise&quot;,&quot;Caterpie&quot;,&quot;Metapod&quot;,&quot;Butterfree&quot;,&quot;Weedle&quot;,&quot;Kakuna&quot;,&quot;Beedrill&quot;,&quot;Pidgey&quot;,&quot;Pidgeotto&quot;,&#xD;&#xA;    &quot;Pidgeot&quot;,&quot;Rattata&quot;,&quot;Raticate&quot;,&quot;Spearow&quot;,&quot;Fearow&quot;,&quot;Ekans&quot;,&quot;Arbok&quot;,&quot;Pikachu&quot;,&quot;Raichu&quot;,&quot;Sandshrew&quot;,&quot;Sandslash&quot;,&#xD;&#xA;    &quot;Nidoran♀&quot;,&quot;Nidorina&quot;,&quot;Nidoqueen&quot;,&quot;Nidoran♂&quot;,&quot;Nidorino&quot;,&quot;Nidoking&quot;,&quot;Clefairy&quot;,&quot;Clefable&quot;,&quot;Vulpix&quot;,&quot;Ninetales&quot;,&quot;Jigglypuff&quot;,&#xD;&#xA;    &quot;Wigglytuff&quot;,&quot;Zubat&quot;,&quot;Golbat&quot;,&quot;Oddish&quot;,&quot;Gloom&quot;,&quot;Vileplume&quot;,&quot;Paras&quot;,&quot;Parasect&quot;,&quot;Venonat&quot;,&quot;Venomoth&quot;,&quot;Diglett&quot;,&quot;Dugtrio&quot;,&quot;Meowth&quot;,&#xD;&#xA;    &quot;Persian&quot;,&quot;Psyduck&quot;,&quot;Golduck&quot;,&quot;Mankey&quot;,&quot;Primeape&quot;,&quot;Growlithe&quot;,&quot;Arcanine&quot;,&quot;Poliwag&quot;,&quot;Poliwhirl&quot;,&quot;Poliwrath&quot;,&quot;Abra&quot;,&quot;Kadabra&quot;,&quot;Alakazam&quot;,&#xD;&#xA;    &quot;Machop&quot;,&quot;Machoke&quot;,&quot;Machamp&quot;,&quot;Bellsprout&quot;,&quot;Weepinbell&quot;,&quot;Victreebel&quot;,&quot;Tentacool&quot;,&quot;Tentacruel&quot;,&quot;Geodude&quot;,&quot;Graveler&quot;,&quot;Golem&quot;,&quot;Ponyta&quot;,&quot;Rapidash&quot;,&#xD;&#xA;    &quot;Slowpoke&quot;,&quot;Slowbro&quot;,&quot;Magnemite&quot;,&quot;Magneton&quot;,&quot;Farfetch`d&quot;,&quot;Doduo&quot;,&quot;Dodrio&quot;,&quot;Seel&quot;,&quot;Dewgong&quot;,&quot;Grimer&quot;,&quot;Muk&quot;,&quot;Shellder&quot;,&quot;Cloyster&quot;,&quot;Gastly&quot;,&quot;Haunter&quot;,&#xD;&#xA;    &quot;Gengar&quot;,&quot;Onix&quot;,&quot;Drowzee&quot;,&quot;Hypno&quot;,&quot;Krabby&quot;,&quot;Kingler&quot;,&quot;Voltorb&quot;,&quot;Electrode&quot;,&quot;Exeggcute&quot;,&quot;Exeggutor&quot;,&quot;Cubone&quot;,&quot;Marowak&quot;,&quot;Hitmonlee&quot;,&quot;Hitmonchan&quot;,&quot;Lickitung&quot;,&#xD;&#xA;    &quot;Koffing&quot;,&quot;Weezing&quot;,&quot;Rhyhorn&quot;,&quot;Rhydon&quot;,&quot;Chansey&quot;,&quot;Tangela&quot;,&quot;Kangaskhan&quot;,&quot;Horsea&quot;,&quot;Seadra&quot;,&quot;Goldeen&quot;,&quot;Seaking&quot;,&quot;Staryu&quot;,&quot;Starmie&quot;,&quot;Mr. Mime&quot;,&quot;Scyther&quot;,&quot;Jynx&quot;,&#xD;&#xA;    &quot;Electabuzz&quot;,&quot;Magmar&quot;,&quot;Pinsir&quot;,&quot;Tauros&quot;,&quot;Magikarp&quot;,&quot;Gyarados&quot;,&quot;Lapras&quot;,&quot;Ditto&quot;,&quot;Eevee&quot;,&quot;Vaporeon&quot;,&quot;Jolteon&quot;,&quot;Flareon&quot;,&quot;Porygon&quot;,&quot;Omanyte&quot;,&quot;Omastar&quot;,&quot;Kabuto&quot;,&quot;Kabutops&quot;,&#xD;&#xA;    &quot;Aerodactyl&quot;,&quot;Snorlax&quot;,&quot;Articuno&quot;,&quot;Zapdos&quot;,&quot;Moltres&quot;,&quot;Dratini&quot;,&quot;Dragonair&quot;,&quot;Dragonite&quot;,&quot;Mewtwo&quot;,&quot;Mew&quot;&#xD;&#xA;    };&#xD;&#xA;    int a = 0;&#xD;&#xA;    int b = 0;&#xD;&#xA;    int value;&#xD;&#xA;    String pokemonName = &quot;Missingno&quot;;&#xD;&#xA;    int currentID = TrueRandom.random(1,numPokemon+1);&#xD;&#xA;    // a = CurrentID&#xD;&#xA;    void setup(){&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      if (EEPROM.read(a)!=0){&#xD;&#xA;        currentID = EEPROM.read(a);&#xD;&#xA;        Serial.print(&quot;The Stored ID is &quot;);&#xD;&#xA;        Serial.println(EEPROM.read(a));&#xD;&#xA;        Serial.println(&quot;Stored = true&quot;);&#xD;&#xA;      }else{&#xD;&#xA;        value = EEPROM.read(a);&#xD;&#xA;        Serial.println(value);&#xD;&#xA;        EEPROM.write(a,currentID);&#xD;&#xA;        value = EEPROM.read(a);&#xD;&#xA;        Serial.println(value);&#xD;&#xA;        Serial.println(&quot;Stored = false&quot;);&#xD;&#xA;      }&#xD;&#xA;      pokemonName = nameArray[currentID];&#xD;&#xA;      Serial.println(pokemonName);&#xD;&#xA;    }&#xD;&#xA;    void loop(){&#xD;&#xA;      &#xD;&#xA;    }" />
  <row Id="2158" PostHistoryTypeId="24" PostId="771" RevisionGUID="477a5d04-29de-4e31-a834-91a698ee8934" CreationDate="2014-03-16T20:04:20.663" Comment="Proposed by 470 approved by 83, 136 edit id of 240" />
  <row Id="2159" PostHistoryTypeId="2" PostId="774" RevisionGUID="52e40523-bb65-4321-b15c-b5eb09a61953" CreationDate="2014-03-16T20:31:20.670" UserId="83" Text="When you figure out how to locate the generated .elf file in your temporary directory, you can execute this command to dump a SRAM usage:&#xD;&#xA;&#xD;&#xA;    avr-objdump -S -j .bss project.elf&#xD;&#xA;&#xD;&#xA;    project.elf:     file format elf32-avr&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Disassembly of section .bss:&#xD;&#xA;    &#xD;&#xA;    00800060 &lt;__bss_start&gt;:&#xD;&#xA;            ...&#xD;&#xA;    &#xD;&#xA;    00800070 &lt;measurementReady&gt;:&#xD;&#xA;            ...&#xD;&#xA;    &#xD;&#xA;    00800071 &lt;cycles&gt;:&#xD;&#xA;            ...&#xD;&#xA;    &#xD;&#xA;    00800073 &lt;measurement&gt;:&#xD;&#xA;      800073:       00 00 00 00                                         ....&#xD;&#xA;    &#xD;&#xA;    00800077 &lt;measurementStart&gt;:&#xD;&#xA;      800077:       00 00 00 00                                         ....&#xD;&#xA;    &#xD;&#xA;    0080007b &lt;timerOverflows&gt;:&#xD;&#xA;      80007b:       00 00 00 00" />
  <row Id="2160" PostHistoryTypeId="5" PostId="774" RevisionGUID="a137d546-fb28-42b6-9ef4-5dc8f6d5a273" CreationDate="2014-03-16T20:36:31.330" UserId="83" Comment="added 75 characters in body" Text="When you figure out how to locate the generated .elf file in your temporary directory, you can execute the command below to dump a SRAM usage, where `project.elf` is to be replaced with the generated `.elf` file:&#xD;&#xA;&#xD;&#xA;    avr-objdump -S -j .bss project.elf&#xD;&#xA;&#xD;&#xA;    project.elf:     file format elf32-avr&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Disassembly of section .bss:&#xD;&#xA;    &#xD;&#xA;    00800060 &lt;__bss_start&gt;:&#xD;&#xA;            ...&#xD;&#xA;    &#xD;&#xA;    00800070 &lt;measurementReady&gt;:&#xD;&#xA;            ...&#xD;&#xA;    &#xD;&#xA;    00800071 &lt;cycles&gt;:&#xD;&#xA;            ...&#xD;&#xA;    &#xD;&#xA;    00800073 &lt;measurement&gt;:&#xD;&#xA;      800073:       00 00 00 00                                         ....&#xD;&#xA;    &#xD;&#xA;    00800077 &lt;measurementStart&gt;:&#xD;&#xA;      800077:       00 00 00 00                                         ....&#xD;&#xA;    &#xD;&#xA;    0080007b &lt;timerOverflows&gt;:&#xD;&#xA;      80007b:       00 00 00 00&#xD;&#xA;&#xD;&#xA;Notice that this doesn't show stack or dynamic memory use as Ignacio Vazquez-Abrams noted in the comments below." />
  <row Id="2161" PostHistoryTypeId="5" PostId="774" RevisionGUID="5f6eb6a1-354f-438f-af77-22380a32266c" CreationDate="2014-03-16T20:47:10.420" UserId="83" Comment="added 301 characters in body" Text="When you figure out how to locate the generated .elf file in your temporary directory, you can execute the command below to dump a SRAM usage, where `project.elf` is to be replaced with the generated `.elf` file:&#xD;&#xA;&#xD;&#xA;    avr-objdump -S -j .bss project.elf&#xD;&#xA;&#xD;&#xA;    project.elf:     file format elf32-avr&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Disassembly of section .bss:&#xD;&#xA;    &#xD;&#xA;    00800060 &lt;__bss_start&gt;:&#xD;&#xA;            ...&#xD;&#xA;    &#xD;&#xA;    00800070 &lt;measurementReady&gt;:&#xD;&#xA;            ...&#xD;&#xA;    &#xD;&#xA;    00800071 &lt;cycles&gt;:&#xD;&#xA;            ...&#xD;&#xA;    &#xD;&#xA;    00800073 &lt;measurement&gt;:&#xD;&#xA;      800073:       00 00 00 00                                         ....&#xD;&#xA;    &#xD;&#xA;    00800077 &lt;measurementStart&gt;:&#xD;&#xA;      800077:       00 00 00 00                                         ....&#xD;&#xA;    &#xD;&#xA;    0080007b &lt;timerOverflows&gt;:&#xD;&#xA;      80007b:       00 00 00 00&#xD;&#xA;&#xD;&#xA;Notice that this doesn't show stack or dynamic memory use as Ignacio Vazquez-Abrams noted in the comments below.&#xD;&#xA;&#xD;&#xA;Additionally a `avr-objdump -S -j .data project.elf` can be checked, but none of my programs output anything with that so I can't tell for sure if it is useful. It [supposed to list](http://mcuoneclipse.com/2013/04/14/text-data-and-bss-code-and-data-size-explained/) 'initialized (non-zero) data'." />
  <row Id="2162" PostHistoryTypeId="5" PostId="744" RevisionGUID="bd498445-7199-4bb8-adf9-21529f8013fd" CreationDate="2014-03-16T22:18:33.660" UserId="196" Comment="added 560 characters in body" Text="I downloaded Arduino code from this: https://github.com/BabyWrassler/MissionControl/ Github, and got the  error message below.&#xD;&#xA;&#xD;&#xA;![Error message][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;It is designed to work with a Raspberry Pi, and I installed the two Adafruit libraries.  I also have not hooked it up to either the Pi, or the two Adafruit devices, but that is partly because I cannot get it to run without the error message.  Sorry I put a picture instead of typing the error message, but I thought it would be easier to see the highlighting and the different places it put the error messages.&#xD;&#xA;&#xD;&#xA;Update:&#xD;&#xA;Here is what the text said: &#xD;&#xA;`Adafruit_LEDBackpack matrixA = Adafruit_LEDBackpack();`&#xD;&#xA;The orange bar says:&#xD;&#xA;    Variable or field ‘matrixOff‘ declared void&#xD;&#xA;I cannot tell what of the following was from before, but here is the entire console log:&#xD;&#xA;    mcDesk.ino:2:53: error: Adafruit_LEDBackpack.h: No such file or directory&#xD;&#xA;    mcDesk.ino:3:45: error: Adafruit_GFX.h: No such file or directory&#xD;&#xA;    mcDesk:11: error: Variable or field ‘matrixOff‘ declared void&#xD;&#xA;    mcDesk:11:'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;    mcDesk&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/v7Wjtl.jpg" />
  <row Id="2163" PostHistoryTypeId="5" PostId="744" RevisionGUID="09bf0c2d-2647-4af0-b288-9a4c297260fb" CreationDate="2014-03-16T22:24:51.910" UserId="196" Comment="added 560 characters in body - error console" Text="I downloaded Arduino code from this: https://github.com/BabyWrassler/MissionControl/ Github, and got the  error message below.&#xD;&#xA;&#xD;&#xA;![Error message][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;It is designed to work with a Raspberry Pi, and I installed the two Adafruit libraries.  I also have not hooked it up to either the Pi, or the two Adafruit devices, but that is partly because I cannot get it to run without the error message.  Sorry I put a picture instead of typing the error message, but I thought it would be easier to see the highlighting and the different places it put the error messages.&#xD;&#xA;&#xD;&#xA;Update:&#xD;&#xA;Here is what the text said: &#xD;&#xA;`Adafruit_LEDBackpack matrixA = Adafruit_LEDBackpack();`&#xD;&#xA;The orange bar says:&#xD;&#xA;    Variable or field ‘matrixOff‘ declared void&#xD;&#xA;I cannot tell what of the following was from before, but here is the entire console log:&#xD;&#xA;&#xD;&#xA;        mcDesk.ino:2:53: error: Adafruit_LEDBackpack.h: No such file or directory&#xD;&#xA;        mcDesk.ino:3:45: error: Adafruit_GFX.h: No such file or directory&#xD;&#xA;        mcDesk:11: error: variable or field 'matrixOff' declared void&#xD;&#xA;        mcDesk:11: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:11: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:12: error: variable or field 'ledOn' declared void&#xD;&#xA;        mcDesk:12: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:12: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:12: error: expected primary-expression before 'cat'&#xD;&#xA;        mcDesk:12: error: expected primary-expression before 'an'&#xD;&#xA;        mcDesk:13: error: variable or field 'ledOff' declared void&#xD;&#xA;        mcDesk:13: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:13: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:13: error: expected primary-expression before 'cat'&#xD;&#xA;        mcDesk:13: error: expected primary-expression before 'an'&#xD;&#xA;        mcDesk:14: error: variable or field 'dispMat' declared void&#xD;&#xA;        mcDesk:14: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:14: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:17: error: variable or field 'threeDigitDisp' declared void&#xD;&#xA;        mcDesk:17: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:17: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:17: error: expected primary-expression before 'cats'&#xD;&#xA;        mcDesk:17: error: expected primary-expression before 'ans'&#xD;&#xA;        mcDesk:17: error: expected primary-expression before 'number'&#xD;&#xA;        mcDesk:18: error: variable or field 'digitDisp' declared void&#xD;&#xA;        mcDesk:18: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:18: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:18: error: expected primary-expression before 'pos'&#xD;&#xA;        mcDesk:18: error: expected primary-expression before 'cat'&#xD;&#xA;        mcDesk:18: error: expected primary-expression before 'an'&#xD;&#xA;        mcDesk:18: error: expected primary-expression before 'num'&#xD;&#xA;        mcDesk:23: error: variable or field 'switchBars' declared void&#xD;&#xA;        mcDesk:23: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:23: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:23: error: expected primary-expression before 'grphCats'&#xD;&#xA;        mcDesk:23: error: expected primary-expression before 'grphAns'&#xD;&#xA;        mcDesk:23: error: expected primary-expression before 'cmnd'&#xD;&#xA;        mcDesk:23: error: expected primary-expression before 'offset'&#xD;&#xA;        mcDesk:24: error: variable or field 'barDisp' declared void&#xD;&#xA;        mcDesk:24: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:24: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:24: error: expected primary-expression before 'grphCats'&#xD;&#xA;        mcDesk:24: error: expected primary-expression before 'grphAns'&#xD;&#xA;        mcDesk:24: error: expected primary-expression before 'pos'&#xD;&#xA;        mcDesk:24: error: expected primary-expression before 'offset'&#xD;&#xA;        mcDesk:25: error: variable or field 'cBarDisp' declared void&#xD;&#xA;        mcDesk:25: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:25: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:25: error: expected primary-expression before 'grphCats'&#xD;&#xA;        mcDesk:25: error: expected primary-expression before 'grphAns'&#xD;&#xA;        mcDesk:25: error: expected primary-expression before 'pos'&#xD;&#xA;        mcDesk:25: error: expected primary-expression before 'offset'&#xD;&#xA;        mcDesk:11: error: 'Adafruit_LEDBackpack' does not name a type&#xD;&#xA;        mcDesk:12: error: 'Adafruit_LEDBackpack' does not name a type&#xD;&#xA;        mcDesk:13: error: 'Adafruit_LEDBackpack' does not name a type&#xD;&#xA;        mcDesk:14: error: 'Adafruit_LEDBackpack' does not name a type&#xD;&#xA;        mcDesk:15: error: 'Adafruit_LEDBackpack' does not name a type&#xD;&#xA;        mcDesk.ino: In function 'void decodeCommand()':&#xD;&#xA;        mcDesk:193: error: 'matrixE' was not declared in this scope&#xD;&#xA;        mcDesk:193: error: 'ledOn' was not declared in this scope&#xD;&#xA;        mcDesk:199: error: 'matrixE' was not declared in this scope&#xD;&#xA;        mcDesk:199: error: 'ledOff' was not declared in this scope&#xD;&#xA;        mcDesk:204: error: 'matrixC' was not declared in this scope&#xD;&#xA;        mcDesk:204: error: 'cBarDisp' was not declared in this scope&#xD;&#xA;        mcDesk.ino: In function 'void allMatrixOff()':&#xD;&#xA;        mcDesk:213: error: 'matrixA' was not declared in this scope&#xD;&#xA;        mcDesk:213: error: 'matrixOff' was not declared in this scope&#xD;&#xA;        mcDesk:214: error: 'matrixB' was not declared in this scope&#xD;&#xA;        mcDesk:215: error: 'matrixC' was not declared in this scope&#xD;&#xA;        mcDesk:216: error: 'matrixD' was not declared in this scope&#xD;&#xA;        mcDesk:217: error: 'matrixE' was not declared in this scope&#xD;&#xA;        mcDesk.ino: At global scope:&#xD;&#xA;        mcDesk:220: error: variable or field 'matrixOff' declared void&#xD;&#xA;        mcDesk:220: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:220: error: expected primary-expression before 'buffer'&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/v7Wjtl.jpg" />
  <row Id="2164" PostHistoryTypeId="5" PostId="744" RevisionGUID="eeb9a217-3f84-4e13-81a9-e167587c7c8b" CreationDate="2014-03-16T22:30:03.590" UserId="196" Comment="added 560 characters in body - error console" Text="I downloaded Arduino code from this: https://github.com/BabyWrassler/MissionControl/ Github, and got the  error message below.&#xD;&#xA;&#xD;&#xA;It is designed to work with a Raspberry Pi, and I installed the two Adafruit libraries.  I also have not hooked it up to either the Pi, or the two Adafruit devices, but that is partly because I cannot get it to run without the error message.&#xD;&#xA;&#xD;&#xA;Update:&#xD;&#xA;Here is what was highlighted: &#xD;&#xA;`Adafruit_LEDBackpack matrixA = Adafruit_LEDBackpack();`&#xD;&#xA;The orange bar says:&#xD;&#xA;    Variable or field ‘matrixOff‘ declared void&#xD;&#xA;I cannot tell what of the following was from before, but here is the entire console log:&#xD;&#xA;&#xD;&#xA;        mcDesk.ino:2:53: error: Adafruit_LEDBackpack.h: No such file or directory&#xD;&#xA;        mcDesk.ino:3:45: error: Adafruit_GFX.h: No such file or directory&#xD;&#xA;        mcDesk:11: error: variable or field 'matrixOff' declared void&#xD;&#xA;        mcDesk:11: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:11: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:12: error: variable or field 'ledOn' declared void&#xD;&#xA;        mcDesk:12: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:12: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:12: error: expected primary-expression before 'cat'&#xD;&#xA;        mcDesk:12: error: expected primary-expression before 'an'&#xD;&#xA;        mcDesk:13: error: variable or field 'ledOff' declared void&#xD;&#xA;        mcDesk:13: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:13: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:13: error: expected primary-expression before 'cat'&#xD;&#xA;        mcDesk:13: error: expected primary-expression before 'an'&#xD;&#xA;        mcDesk:14: error: variable or field 'dispMat' declared void&#xD;&#xA;        mcDesk:14: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:14: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:17: error: variable or field 'threeDigitDisp' declared void&#xD;&#xA;        mcDesk:17: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:17: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:17: error: expected primary-expression before 'cats'&#xD;&#xA;        mcDesk:17: error: expected primary-expression before 'ans'&#xD;&#xA;        mcDesk:17: error: expected primary-expression before 'number'&#xD;&#xA;        mcDesk:18: error: variable or field 'digitDisp' declared void&#xD;&#xA;        mcDesk:18: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:18: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:18: error: expected primary-expression before 'pos'&#xD;&#xA;        mcDesk:18: error: expected primary-expression before 'cat'&#xD;&#xA;        mcDesk:18: error: expected primary-expression before 'an'&#xD;&#xA;        mcDesk:18: error: expected primary-expression before 'num'&#xD;&#xA;        mcDesk:23: error: variable or field 'switchBars' declared void&#xD;&#xA;        mcDesk:23: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:23: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:23: error: expected primary-expression before 'grphCats'&#xD;&#xA;        mcDesk:23: error: expected primary-expression before 'grphAns'&#xD;&#xA;        mcDesk:23: error: expected primary-expression before 'cmnd'&#xD;&#xA;        mcDesk:23: error: expected primary-expression before 'offset'&#xD;&#xA;        mcDesk:24: error: variable or field 'barDisp' declared void&#xD;&#xA;        mcDesk:24: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:24: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:24: error: expected primary-expression before 'grphCats'&#xD;&#xA;        mcDesk:24: error: expected primary-expression before 'grphAns'&#xD;&#xA;        mcDesk:24: error: expected primary-expression before 'pos'&#xD;&#xA;        mcDesk:24: error: expected primary-expression before 'offset'&#xD;&#xA;        mcDesk:25: error: variable or field 'cBarDisp' declared void&#xD;&#xA;        mcDesk:25: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:25: error: expected primary-expression before 'buffer'&#xD;&#xA;        mcDesk:25: error: expected primary-expression before 'grphCats'&#xD;&#xA;        mcDesk:25: error: expected primary-expression before 'grphAns'&#xD;&#xA;        mcDesk:25: error: expected primary-expression before 'pos'&#xD;&#xA;        mcDesk:25: error: expected primary-expression before 'offset'&#xD;&#xA;        mcDesk:11: error: 'Adafruit_LEDBackpack' does not name a type&#xD;&#xA;        mcDesk:12: error: 'Adafruit_LEDBackpack' does not name a type&#xD;&#xA;        mcDesk:13: error: 'Adafruit_LEDBackpack' does not name a type&#xD;&#xA;        mcDesk:14: error: 'Adafruit_LEDBackpack' does not name a type&#xD;&#xA;        mcDesk:15: error: 'Adafruit_LEDBackpack' does not name a type&#xD;&#xA;        mcDesk.ino: In function 'void decodeCommand()':&#xD;&#xA;        mcDesk:193: error: 'matrixE' was not declared in this scope&#xD;&#xA;        mcDesk:193: error: 'ledOn' was not declared in this scope&#xD;&#xA;        mcDesk:199: error: 'matrixE' was not declared in this scope&#xD;&#xA;        mcDesk:199: error: 'ledOff' was not declared in this scope&#xD;&#xA;        mcDesk:204: error: 'matrixC' was not declared in this scope&#xD;&#xA;        mcDesk:204: error: 'cBarDisp' was not declared in this scope&#xD;&#xA;        mcDesk.ino: In function 'void allMatrixOff()':&#xD;&#xA;        mcDesk:213: error: 'matrixA' was not declared in this scope&#xD;&#xA;        mcDesk:213: error: 'matrixOff' was not declared in this scope&#xD;&#xA;        mcDesk:214: error: 'matrixB' was not declared in this scope&#xD;&#xA;        mcDesk:215: error: 'matrixC' was not declared in this scope&#xD;&#xA;        mcDesk:216: error: 'matrixD' was not declared in this scope&#xD;&#xA;        mcDesk:217: error: 'matrixE' was not declared in this scope&#xD;&#xA;        mcDesk.ino: At global scope:&#xD;&#xA;        mcDesk:220: error: variable or field 'matrixOff' declared void&#xD;&#xA;        mcDesk:220: error: 'Adafruit_LEDBackpack' was not declared in this scope&#xD;&#xA;        mcDesk:220: error: expected primary-expression before 'buffer'&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/v7Wjtl.jpg" />
  <row Id="2165" PostHistoryTypeId="2" PostId="775" RevisionGUID="be3136fc-573a-42ca-ac9a-aa97015b168e" CreationDate="2014-03-16T22:30:21.940" UserId="642" Text="I wrote a program using PROGMEM for massive string arrays. One of the arrays worked, but when I added the second one, the serial output only puts out &quot;th&quot;.&#xD;&#xA;&#xD;&#xA;Pastebin Code: http://pastebin.com/9U7QZQKn" />
  <row Id="2166" PostHistoryTypeId="1" PostId="775" RevisionGUID="be3136fc-573a-42ca-ac9a-aa97015b168e" CreationDate="2014-03-16T22:30:21.940" UserId="642" Text="PROGMEM char* mangled text" />
  <row Id="2167" PostHistoryTypeId="3" PostId="775" RevisionGUID="be3136fc-573a-42ca-ac9a-aa97015b168e" CreationDate="2014-03-16T22:30:21.940" UserId="642" Text="&lt;arduino-uno&gt;&lt;progmem&gt;" />
  <row Id="2168" PostHistoryTypeId="2" PostId="776" RevisionGUID="79066422-81be-4fdb-9f0c-0f77abc6f16d" CreationDate="2014-03-16T22:56:22.960" UserId="136" Text="Your declaration of char buffers is done like so:&#xD;&#xA;&#xD;&#xA;    char* move1 = &quot;N/A&quot;;&#xD;&#xA;&#xD;&#xA;This will only allocate 3 characters.&#xD;&#xA;&#xD;&#xA;You need to do:&#xD;&#xA;&#xD;&#xA;    char buffer[16];&#xD;&#xA;&#xD;&#xA;Where the length is long enough to hold your string." />
  <row Id="2169" PostHistoryTypeId="2" PostId="777" RevisionGUID="8bb11d9f-7b89-41f9-b009-1dbaae3f56a5" CreationDate="2014-03-16T23:29:39.897" UserId="470" Text="You can use the functions provided [AVRGCC: Monitoring Stack Usage](http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;t=52249)&#xD;&#xA;&#xD;&#xA;The function was intended to check the stack usage but what it reports is the actual RAM that has never been used (during execution). It does so by &quot;painting&quot; (filling) the RAM with a knows value (0xC5) and then checking the RAM area, counting how many bytes have still the same initial value, which means that they have not changed.  &#xD;&#xA;Basically the report will show the RAM that has not been used and therefor you can calculate the max RAM used (Total RAM - reported RAM).&#xD;&#xA;&#xD;&#xA;There are two functions:&#xD;&#xA;&#xD;&#xA; - **StackPaint** is executed automatically during initialization and &quot;paints&quot; the RAM with the value 0xC5 (can be changed if needed).&#xD;&#xA;&#xD;&#xA; - **StackCount** can be called at any point to count the RAM that hasn't been used.&#xD;&#xA;&#xD;&#xA;Here is an example of usage. Doesn't do much but is intended to show how to use the functions.&#xD;&#xA;&#xD;&#xA;&lt;!-- language-all: lang-c --&gt;&#xD;&#xA;&#xD;&#xA;    // -----------------------------------------------------------------------------&#xD;&#xA;    extern uint8_t _end;&#xD;&#xA;    extern uint8_t __stack;&#xD;&#xA;    &#xD;&#xA;    void StackPaint(void) __attribute__ ((naked)) __attribute__ ((section (&quot;.init1&quot;)));&#xD;&#xA;    &#xD;&#xA;    void StackPaint(void)&#xD;&#xA;    {&#xD;&#xA;    #if 0&#xD;&#xA;        uint8_t *p = &amp;_end;&#xD;&#xA;    &#xD;&#xA;        while(p &lt;= &amp;__stack)&#xD;&#xA;        {&#xD;&#xA;            *p = 0xc5;&#xD;&#xA;            p++;&#xD;&#xA;        }&#xD;&#xA;    #else&#xD;&#xA;        __asm volatile (&quot;    ldi r30,lo8(_end)\n&quot;&#xD;&#xA;                        &quot;    ldi r31,hi8(_end)\n&quot;&#xD;&#xA;                        &quot;    ldi r24,lo8(0xc5)\n&quot; /* STACK_CANARY = 0xc5 */&#xD;&#xA;                        &quot;    ldi r25,hi8(__stack)\n&quot;&#xD;&#xA;                        &quot;    rjmp .cmp\n&quot;&#xD;&#xA;                        &quot;.loop:\n&quot;&#xD;&#xA;                        &quot;    st Z+,r24\n&quot;&#xD;&#xA;                        &quot;.cmp:\n&quot;&#xD;&#xA;                        &quot;    cpi r30,lo8(__stack)\n&quot;&#xD;&#xA;                        &quot;    cpc r31,r25\n&quot;&#xD;&#xA;                        &quot;    brlo .loop\n&quot;&#xD;&#xA;                        &quot;    breq .loop&quot;::);&#xD;&#xA;    #endif&#xD;&#xA;    } &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t StackCount(void)&#xD;&#xA;    {&#xD;&#xA;        const uint8_t *p = &amp;_end;&#xD;&#xA;        uint16_t       c = 0;&#xD;&#xA;    &#xD;&#xA;        while(*p == 0xc5 &amp;&amp; p &lt;= &amp;__stack)&#xD;&#xA;        {&#xD;&#xA;            p++;&#xD;&#xA;            c++;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return c;&#xD;&#xA;    } &#xD;&#xA;    &#xD;&#xA;    // -----------------------------------------------------------------------------&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;    &#xD;&#xA;    Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      // put your main code here, to run repeatedly:&#xD;&#xA;    Serial.println(StackCount(), DEC);  // calls StackCount() to report the unused RAM&#xD;&#xA;    delay(1000);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2170" PostHistoryTypeId="5" PostId="777" RevisionGUID="44739a99-2f3a-40b3-9975-6f7e79b045bd" CreationDate="2014-03-17T00:22:43.143" UserId="470" Comment="deleted 17 characters in body" Text="You can use the functions provided [AVRGCC: Monitoring Stack Usage](http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;t=52249)&#xD;&#xA;&#xD;&#xA;The function was intended to check the stack usage but what it reports is the actual RAM that has never been used (during execution). It does so by &quot;painting&quot; (filling) the RAM with a known value (0xC5), and then checking the RAM area counting how many bytes have still the same initial value.  &#xD;&#xA;The report will show the RAM that has not been used (minimum free RAM) and therefor you can calculate the max RAM that has been used (Total RAM - reported RAM).&#xD;&#xA;&#xD;&#xA;There are two functions:&#xD;&#xA;&#xD;&#xA; - **StackPaint** is executed automatically during initialization and &quot;paints&quot; the RAM with the value 0xC5 (can be changed if needed).&#xD;&#xA;&#xD;&#xA; - **StackCount** can be called at any point to count the RAM that hasn't been used.&#xD;&#xA;&#xD;&#xA;Here is an example of usage. Doesn't do much but is intended to show how to use the functions.&#xD;&#xA;&#xD;&#xA;&lt;!-- language-all: lang-c --&gt;&#xD;&#xA;&#xD;&#xA;    // -----------------------------------------------------------------------------&#xD;&#xA;    extern uint8_t _end;&#xD;&#xA;    extern uint8_t __stack;&#xD;&#xA;    &#xD;&#xA;    void StackPaint(void) __attribute__ ((naked)) __attribute__ ((section (&quot;.init1&quot;)));&#xD;&#xA;    &#xD;&#xA;    void StackPaint(void)&#xD;&#xA;    {&#xD;&#xA;    #if 0&#xD;&#xA;        uint8_t *p = &amp;_end;&#xD;&#xA;    &#xD;&#xA;        while(p &lt;= &amp;__stack)&#xD;&#xA;        {&#xD;&#xA;            *p = 0xc5;&#xD;&#xA;            p++;&#xD;&#xA;        }&#xD;&#xA;    #else&#xD;&#xA;        __asm volatile (&quot;    ldi r30,lo8(_end)\n&quot;&#xD;&#xA;                        &quot;    ldi r31,hi8(_end)\n&quot;&#xD;&#xA;                        &quot;    ldi r24,lo8(0xc5)\n&quot; /* STACK_CANARY = 0xc5 */&#xD;&#xA;                        &quot;    ldi r25,hi8(__stack)\n&quot;&#xD;&#xA;                        &quot;    rjmp .cmp\n&quot;&#xD;&#xA;                        &quot;.loop:\n&quot;&#xD;&#xA;                        &quot;    st Z+,r24\n&quot;&#xD;&#xA;                        &quot;.cmp:\n&quot;&#xD;&#xA;                        &quot;    cpi r30,lo8(__stack)\n&quot;&#xD;&#xA;                        &quot;    cpc r31,r25\n&quot;&#xD;&#xA;                        &quot;    brlo .loop\n&quot;&#xD;&#xA;                        &quot;    breq .loop&quot;::);&#xD;&#xA;    #endif&#xD;&#xA;    } &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t StackCount(void)&#xD;&#xA;    {&#xD;&#xA;        const uint8_t *p = &amp;_end;&#xD;&#xA;        uint16_t       c = 0;&#xD;&#xA;    &#xD;&#xA;        while(*p == 0xc5 &amp;&amp; p &lt;= &amp;__stack)&#xD;&#xA;        {&#xD;&#xA;            p++;&#xD;&#xA;            c++;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        return c;&#xD;&#xA;    } &#xD;&#xA;    &#xD;&#xA;    // -----------------------------------------------------------------------------&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;    &#xD;&#xA;    Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      // put your main code here, to run repeatedly:&#xD;&#xA;    Serial.println(StackCount(), DEC);  // calls StackCount() to report the unused RAM&#xD;&#xA;    delay(1000);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2171" PostHistoryTypeId="2" PostId="778" RevisionGUID="871cfcd2-4c07-4f48-acac-6add1d2a0518" CreationDate="2014-03-17T05:40:33.517" UserId="84" Text="I see one major flaw in your code, related to index usage on arrays.&#xD;&#xA;&#xD;&#xA;Arrays in C and C++ are using a **0-based index**, meaning that, for an array containing `N` elements:&#xD;&#xA;&#xD;&#xA;- the first element is accessible with index `0`&#xD;&#xA;- the last element is accessible with index `(N-1)`&#xD;&#xA;&#xD;&#xA;However, your code uses `TrueRandom.random(1,numPokemon+1);` which means you'll get an index between `1` and `numPokemon` (included), if you get the `numPokemon` value for your index, then you'll get garbage as it will try access some other part of memory.&#xD;&#xA;&#xD;&#xA;Maybe that is not the only problem in your code, but this one is a major bug." />
  <row Id="2172" PostHistoryTypeId="5" PostId="776" RevisionGUID="41b43581-ce58-4c9a-b9f7-5bf410172584" CreationDate="2014-03-17T06:26:37.890" UserId="136" Comment="added 82 characters in body" Text="Your declaration of char buffers is done like so:&#xD;&#xA;&#xD;&#xA;    char* move1 = &quot;N/A&quot;;&#xD;&#xA;&#xD;&#xA;This will only allocate 3 characters with an additional one for null termination i.e. not long enough to hold the name.&#xD;&#xA;&#xD;&#xA;You need to do:&#xD;&#xA;&#xD;&#xA;    char buffer[16];&#xD;&#xA;&#xD;&#xA;Where the length is long enough to hold your string." />
  <row Id="2173" PostHistoryTypeId="5" PostId="774" RevisionGUID="56f37e55-5214-4248-8dd3-db077ea803a7" CreationDate="2014-03-17T06:57:04.527" UserId="83" Comment="added 150 characters in body" Text="When you figure out how to locate the generated .elf file in your temporary directory, you can execute the command below to dump a SRAM usage, where `project.elf` is to be replaced with the generated `.elf` file. The advantage of this output is the ability to inspect *how* your SRAM is used. Do all the variables need to be global, are they really all required?&#xD;&#xA;&#xD;&#xA;    avr-objdump -S -j .bss project.elf&#xD;&#xA;&#xD;&#xA;    project.elf:     file format elf32-avr&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Disassembly of section .bss:&#xD;&#xA;    &#xD;&#xA;    00800060 &lt;__bss_start&gt;:&#xD;&#xA;            ...&#xD;&#xA;    &#xD;&#xA;    00800070 &lt;measurementReady&gt;:&#xD;&#xA;            ...&#xD;&#xA;    &#xD;&#xA;    00800071 &lt;cycles&gt;:&#xD;&#xA;            ...&#xD;&#xA;    &#xD;&#xA;    00800073 &lt;measurement&gt;:&#xD;&#xA;      800073:       00 00 00 00                                         ....&#xD;&#xA;    &#xD;&#xA;    00800077 &lt;measurementStart&gt;:&#xD;&#xA;      800077:       00 00 00 00                                         ....&#xD;&#xA;    &#xD;&#xA;    0080007b &lt;timerOverflows&gt;:&#xD;&#xA;      80007b:       00 00 00 00&#xD;&#xA;&#xD;&#xA;Notice that this doesn't show stack or dynamic memory use as Ignacio Vazquez-Abrams noted in the comments below.&#xD;&#xA;&#xD;&#xA;Additionally a `avr-objdump -S -j .data project.elf` can be checked, but none of my programs output anything with that so I can't tell for sure if it is useful. It [supposed to list](http://mcuoneclipse.com/2013/04/14/text-data-and-bss-code-and-data-size-explained/) 'initialized (non-zero) data'." />
  <row Id="2174" PostHistoryTypeId="5" PostId="763" RevisionGUID="3769e4f0-0f83-45f7-a7db-8fb88d34b202" CreationDate="2014-03-17T08:54:54.070" UserId="304" Comment="added code example.... also asked for help on interpreting avr-size" Text="I would like to know how much RAM I am using in my project, as far as I can tell, there's no way to actually work that out (other than going through and calculating it myself). I have got to a stage in a rather large project where I have determined that I am running out of RAM. &#xD;&#xA;&#xD;&#xA;I have determined this because I can add a section and then all hell breaks loose somewhere else in my code for no apparent reason. If I `#ifndef` that section out, it works again. There is nothing programatically wrong with the new code. &#xD;&#xA;&#xD;&#xA;I suspected for a while that I was getting to the end of available RAM. I don't think I'm using too much stack (although it's possible), what is the best way to determine how much RAM I am actually using?&#xD;&#xA;&#xD;&#xA;Going through and trying to work it out, I have problems when I get to enums and structs; how much memory do they cost? &#xD;&#xA;&#xD;&#xA;edit: this is the actual code that started producing problem:&#xD;&#xA;&#xD;&#xA;    //#define NOEEPROM 1&#xD;&#xA;    #define EEPROMSAVE 0&#xD;&#xA;    #define EEPROMREAD 1&#xD;&#xA;&#xD;&#xA;    // members of EEPROM SETTINGS //&#xD;&#xA;    uint8_t debug               = DEBUG;                               &#xD;&#xA;    uint8_t clear_eeprom        = 0;                             &#xD;&#xA;    uint8_t auto_dimming        = 1;&#xD;&#xA;    uint8_t lane_door_tone      = 0;&#xD;&#xA;    uint8_t limited_menu        = 0;&#xD;&#xA;    &#xD;&#xA;    #ifndef NOEEPROM&#xD;&#xA;    uint8_t t_debug             = debug;&#xD;&#xA;    uint8_t t_clear_eeprom      = clear_eeprom;&#xD;&#xA;    uint8_t t_auto_dimming      = auto_dimming;&#xD;&#xA;    uint8_t t_lane_door_tone    = lane_door_tone;&#xD;&#xA;    uint8_t t_limited_menu      = limited_menu;&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;in `setup(){}`&#xD;&#xA;&#xD;&#xA;    if(EEPROMREAD) loadFromEEPROM();&#xD;&#xA;&#xD;&#xA;in a misc file&#xD;&#xA;&#xD;&#xA;    void loadFromEEPROM(){&#xD;&#xA;      if(EEPROM.read(EEPROM_START)==1){&#xD;&#xA;          debug =          EEPROM.read(EEPROM_START+1);&#xD;&#xA;          clear_eeprom =   0; //EEPROM.read(EEPROM_START+2, clear_eeprom);&#xD;&#xA;          auto_dimming =   EEPROM.read(EEPROM_START+3);&#xD;&#xA;          lane_door_tone = EEPROM.read(EEPROM_START+4);&#xD;&#xA;          limited_menu =   EEPROM.read(EEPROM_START+5);&#xD;&#xA;      } else {&#xD;&#xA;        // load defaults&#xD;&#xA;        debug          = DEBUG;                               &#xD;&#xA;        clear_eeprom   = 0;                             &#xD;&#xA;        auto_dimming   = 1;&#xD;&#xA;        lane_door_tone = 0;&#xD;&#xA;        limited_menu   = 0;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;called from `loop(){}`&#xD;&#xA;&#xD;&#xA;    void drawSettings(){  &#xD;&#xA;      if(menu==SETTINGS){&#xD;&#xA;        uint16_t x = 100;&#xD;&#xA;        uint16_t y = 10;&#xD;&#xA;        uint16_t s = 40;&#xD;&#xA;        uint8_t  f = 22;&#xD;&#xA;    &#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;show debug info&quot;));&#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;clear calibration data&quot;));&#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;auto brightness&quot;));&#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;lane door tone&quot;));&#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;limited menu&quot;));&#xD;&#xA;        &#xD;&#xA;        x -= 30; y = 10;&#xD;&#xA;        int tag = TAG_SETTINGS;&#xD;&#xA;      #ifndef NOEEPROM&#xD;&#xA;        checkbox(x, y+=s, tag++, t_debug);&#xD;&#xA;        checkbox(x, y+=s, tag++, t_clear_eeprom);&#xD;&#xA;        checkbox(x, y+=s, tag++, t_auto_dimming);&#xD;&#xA;        checkbox(x, y+=s, tag++, t_lane_door_tone);&#xD;&#xA;        checkbox(x, y+=s, tag++, t_limited_menu);&#xD;&#xA;      #else&#xD;&#xA;        checkbox(x, y+=s, tag++, debug);&#xD;&#xA;        checkbox(x, y+=s, tag++, clear_eeprom);&#xD;&#xA;        checkbox(x, y+=s, tag++, auto_dimming);&#xD;&#xA;        checkbox(x, y+=s, tag++, lane_door_tone);&#xD;&#xA;        checkbox(x, y+=s, tag++, limited_menu);&#xD;&#xA;      #endif&#xD;&#xA;        GD.Tag(TAG_SAVE_SETTINGS);&#xD;&#xA;        GD.cmd_button(MAXX-50,MAXY-40,45,25,f,0,&quot;Save&quot;);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;also called in the main loop is a file that controls the SETTINGS screen:&#xD;&#xA;&#xD;&#xA;        ...&#xD;&#xA;        switch (btag){&#xD;&#xA;    #ifndef NOEEPROM      &#xD;&#xA;          case TAG_SETTINGS:&#xD;&#xA;            t_debug = !t_debug;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+1:&#xD;&#xA;            t_clear_eeprom = !t_clear_eeprom;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+2:&#xD;&#xA;            t_auto_dimming = !t_auto_dimming;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+3:&#xD;&#xA;            t_lane_door_tone = !t_lane_door_tone;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+4:&#xD;&#xA;            t_limited_menu = !t_limited_menu;&#xD;&#xA;            break;&#xD;&#xA;    #else&#xD;&#xA;          case TAG_SETTINGS:&#xD;&#xA;            debug = !debug;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+1:&#xD;&#xA;            clear_eeprom = !clear_eeprom;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+2:&#xD;&#xA;            auto_dimming = !auto_dimming;&#xD;&#xA;            if(!auto_dimming) {&#xD;&#xA;               setBrightness(128);   &#xD;&#xA;            }&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+3:&#xD;&#xA;            lane_door_tone = !lane_door_tone;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+4:&#xD;&#xA;            limited_menu = !limited_menu;&#xD;&#xA;            break;&#xD;&#xA;    #endif&#xD;&#xA;        }&#xD;&#xA;        buttonDelay=1;&#xD;&#xA;      } else if (btag == TAG_SAVE_SETTINGS) {&#xD;&#xA;    #ifndef NOEEPROM&#xD;&#xA;        if(menu==SETTINGS &amp;&amp; EEPROMSAVE){&#xD;&#xA;          debug = t_debug;&#xD;&#xA;          &#xD;&#xA;          EEPROM.write(EEPROM_START  , 1);&#xD;&#xA;          EEPROM.write(EEPROM_START+1, t_debug);&#xD;&#xA;          if (t_clear_eeprom){&#xD;&#xA;            EEPROM.write(EEPROM_START+2,EEPROM.read(0));&#xD;&#xA;            EEPROM.write(0,0);&#xD;&#xA;          } else if(clear_eeprom == true &amp;&amp; t_clear_eeprom == false){&#xD;&#xA;            EEPROM.write(0,EEPROM.read(EEPROM_START+2));&#xD;&#xA;          }&#xD;&#xA;          EEPROM.write(EEPROM_START+3,t_auto_dimming);&#xD;&#xA;          EEPROM.write(EEPROM_START+4,t_lane_door_tone);&#xD;&#xA;          EEPROM.write(EEPROM_START+5,t_limited_menu);&#xD;&#xA;        }&#xD;&#xA;        debug             = t_debug;&#xD;&#xA;        clear_eeprom      = t_clear_eeprom;&#xD;&#xA;        auto_dimming      = t_auto_dimming;&#xD;&#xA;        lane_door_tone    = t_lane_door_tone;&#xD;&#xA;        limited_menu      = t_limited_menu;&#xD;&#xA;    #endif&#xD;&#xA;        menu=MAINMENU;&#xD;&#xA;        ...&#xD;&#xA;&#xD;&#xA;I could have missed some code out, but that is the essence of it.&#xD;&#xA;&#xD;&#xA;ALSO, I have edited the file so much since starting, these are not the actual result I initially got, but they are what I am getting now. &#xD;&#xA;&#xD;&#xA;      text	   data	    bss	    dec	    hex	filename&#xD;&#xA;     17554	    844	    449	  18847	   499f	HA15_20140317w.cpp.elf&#xD;&#xA;     16316	    694	    409	  17419	   440b	HA15_20140317w.cpp.elf&#xD;&#xA;&#xD;&#xA;The first line (with text 17554) was not working, after much editing, the second line (with text 16316) is working as it should. &#xD;&#xA;&#xD;&#xA;How do I actually interpret that information? &#xD;&#xA;&#xD;&#xA;So far my understanding is: &#xD;&#xA;&#xD;&#xA;    `TEXT` is program instruction memory&#xD;&#xA;    `DATA` is variables (unitialised?) in program memory&#xD;&#xA;    `BSS`  is variables occupying RAM&#xD;&#xA;&#xD;&#xA;since BSS is considerably less than 1024 bytes, why does the second work, but the first doesn't? If it's `DATA+BSS` then both occupy more than 1024. " />
  <row Id="2175" PostHistoryTypeId="5" PostId="763" RevisionGUID="8f8bd206-5977-4085-9be5-97947e011b50" CreationDate="2014-03-17T09:49:29.593" UserId="304" Comment="added 360 characters in body" Text="I would like to know how much RAM I am using in my project, as far as I can tell, there's no way to actually work that out (other than going through and calculating it myself). I have got to a stage in a rather large project where I have determined that I am running out of RAM. &#xD;&#xA;&#xD;&#xA;I have determined this because I can add a section and then all hell breaks loose somewhere else in my code for no apparent reason. If I `#ifndef` that section out, it works again. There is nothing programatically wrong with the new code. &#xD;&#xA;&#xD;&#xA;I suspected for a while that I was getting to the end of available RAM. I don't think I'm using too much stack (although it's possible), what is the best way to determine how much RAM I am actually using?&#xD;&#xA;&#xD;&#xA;Going through and trying to work it out, I have problems when I get to enums and structs; how much memory do they cost? &#xD;&#xA;&#xD;&#xA;edit: I've included this code, since this was what I introduced and the problem started. However, the problem wasn't with this code. This code (with `NOEEPROM` defined or not) worked fine. It was (essentially) the serial received code that stuffed up. My assumption being, that SerialEvent is probably the last thing to be compiled and it's variables are right at the end of memory, and hence they're getting corrupted.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    //#define NOEEPROM 1&#xD;&#xA;    #define EEPROMSAVE 0&#xD;&#xA;    #define EEPROMREAD 1&#xD;&#xA;&#xD;&#xA;    // members of EEPROM SETTINGS //&#xD;&#xA;    uint8_t debug               = DEBUG;                               &#xD;&#xA;    uint8_t clear_eeprom        = 0;                             &#xD;&#xA;    uint8_t auto_dimming        = 1;&#xD;&#xA;    uint8_t lane_door_tone      = 0;&#xD;&#xA;    uint8_t limited_menu        = 0;&#xD;&#xA;    &#xD;&#xA;    #ifndef NOEEPROM&#xD;&#xA;    uint8_t t_debug             = debug;&#xD;&#xA;    uint8_t t_clear_eeprom      = clear_eeprom;&#xD;&#xA;    uint8_t t_auto_dimming      = auto_dimming;&#xD;&#xA;    uint8_t t_lane_door_tone    = lane_door_tone;&#xD;&#xA;    uint8_t t_limited_menu      = limited_menu;&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;in `setup(){}`&#xD;&#xA;&#xD;&#xA;    if(EEPROMREAD) loadFromEEPROM();&#xD;&#xA;&#xD;&#xA;in a misc file&#xD;&#xA;&#xD;&#xA;    void loadFromEEPROM(){&#xD;&#xA;      if(EEPROM.read(EEPROM_START)==1){&#xD;&#xA;          debug =          EEPROM.read(EEPROM_START+1);&#xD;&#xA;          clear_eeprom =   0; //EEPROM.read(EEPROM_START+2, clear_eeprom);&#xD;&#xA;          auto_dimming =   EEPROM.read(EEPROM_START+3);&#xD;&#xA;          lane_door_tone = EEPROM.read(EEPROM_START+4);&#xD;&#xA;          limited_menu =   EEPROM.read(EEPROM_START+5);&#xD;&#xA;      } else {&#xD;&#xA;        // load defaults&#xD;&#xA;        debug          = DEBUG;                               &#xD;&#xA;        clear_eeprom   = 0;                             &#xD;&#xA;        auto_dimming   = 1;&#xD;&#xA;        lane_door_tone = 0;&#xD;&#xA;        limited_menu   = 0;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;called from `loop(){}`&#xD;&#xA;&#xD;&#xA;    void drawSettings(){  &#xD;&#xA;      if(menu==SETTINGS){&#xD;&#xA;        uint16_t x = 100;&#xD;&#xA;        uint16_t y = 10;&#xD;&#xA;        uint16_t s = 40;&#xD;&#xA;        uint8_t  f = 22;&#xD;&#xA;    &#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;show debug info&quot;));&#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;clear calibration data&quot;));&#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;auto brightness&quot;));&#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;lane door tone&quot;));&#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;limited menu&quot;));&#xD;&#xA;        &#xD;&#xA;        x -= 30; y = 10;&#xD;&#xA;        int tag = TAG_SETTINGS;&#xD;&#xA;      #ifndef NOEEPROM&#xD;&#xA;        checkbox(x, y+=s, tag++, t_debug);&#xD;&#xA;        checkbox(x, y+=s, tag++, t_clear_eeprom);&#xD;&#xA;        checkbox(x, y+=s, tag++, t_auto_dimming);&#xD;&#xA;        checkbox(x, y+=s, tag++, t_lane_door_tone);&#xD;&#xA;        checkbox(x, y+=s, tag++, t_limited_menu);&#xD;&#xA;      #else&#xD;&#xA;        checkbox(x, y+=s, tag++, debug);&#xD;&#xA;        checkbox(x, y+=s, tag++, clear_eeprom);&#xD;&#xA;        checkbox(x, y+=s, tag++, auto_dimming);&#xD;&#xA;        checkbox(x, y+=s, tag++, lane_door_tone);&#xD;&#xA;        checkbox(x, y+=s, tag++, limited_menu);&#xD;&#xA;      #endif&#xD;&#xA;        GD.Tag(TAG_SAVE_SETTINGS);&#xD;&#xA;        GD.cmd_button(MAXX-50,MAXY-40,45,25,f,0,&quot;Save&quot;);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;also called in the main loop is a file that controls the SETTINGS screen:&#xD;&#xA;&#xD;&#xA;        ...&#xD;&#xA;        switch (btag){&#xD;&#xA;    #ifndef NOEEPROM      &#xD;&#xA;          case TAG_SETTINGS:&#xD;&#xA;            t_debug = !t_debug;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+1:&#xD;&#xA;            t_clear_eeprom = !t_clear_eeprom;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+2:&#xD;&#xA;            t_auto_dimming = !t_auto_dimming;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+3:&#xD;&#xA;            t_lane_door_tone = !t_lane_door_tone;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+4:&#xD;&#xA;            t_limited_menu = !t_limited_menu;&#xD;&#xA;            break;&#xD;&#xA;    #else&#xD;&#xA;          case TAG_SETTINGS:&#xD;&#xA;            debug = !debug;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+1:&#xD;&#xA;            clear_eeprom = !clear_eeprom;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+2:&#xD;&#xA;            auto_dimming = !auto_dimming;&#xD;&#xA;            if(!auto_dimming) {&#xD;&#xA;               setBrightness(128);   &#xD;&#xA;            }&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+3:&#xD;&#xA;            lane_door_tone = !lane_door_tone;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+4:&#xD;&#xA;            limited_menu = !limited_menu;&#xD;&#xA;            break;&#xD;&#xA;    #endif&#xD;&#xA;        }&#xD;&#xA;        buttonDelay=1;&#xD;&#xA;      } else if (btag == TAG_SAVE_SETTINGS) {&#xD;&#xA;    #ifndef NOEEPROM&#xD;&#xA;        if(menu==SETTINGS &amp;&amp; EEPROMSAVE){&#xD;&#xA;          debug = t_debug;&#xD;&#xA;          &#xD;&#xA;          EEPROM.write(EEPROM_START  , 1);&#xD;&#xA;          EEPROM.write(EEPROM_START+1, t_debug);&#xD;&#xA;          if (t_clear_eeprom){&#xD;&#xA;            EEPROM.write(EEPROM_START+2,EEPROM.read(0));&#xD;&#xA;            EEPROM.write(0,0);&#xD;&#xA;          } else if(clear_eeprom == true &amp;&amp; t_clear_eeprom == false){&#xD;&#xA;            EEPROM.write(0,EEPROM.read(EEPROM_START+2));&#xD;&#xA;          }&#xD;&#xA;          EEPROM.write(EEPROM_START+3,t_auto_dimming);&#xD;&#xA;          EEPROM.write(EEPROM_START+4,t_lane_door_tone);&#xD;&#xA;          EEPROM.write(EEPROM_START+5,t_limited_menu);&#xD;&#xA;        }&#xD;&#xA;        debug             = t_debug;&#xD;&#xA;        clear_eeprom      = t_clear_eeprom;&#xD;&#xA;        auto_dimming      = t_auto_dimming;&#xD;&#xA;        lane_door_tone    = t_lane_door_tone;&#xD;&#xA;        limited_menu      = t_limited_menu;&#xD;&#xA;    #endif&#xD;&#xA;        menu=MAINMENU;&#xD;&#xA;        ...&#xD;&#xA;&#xD;&#xA;I could have missed some code out, but that is the essence of it.&#xD;&#xA;&#xD;&#xA;ALSO, I have edited the file so much since starting, these are not the actual result I initially got, but they are what I am getting now. &#xD;&#xA;&#xD;&#xA;      text	   data	    bss	    dec	    hex	filename&#xD;&#xA;     17554	    844	    449	  18847	   499f	HA15_20140317w.cpp.elf&#xD;&#xA;     16316	    694	    409	  17419	   440b	HA15_20140317w.cpp.elf&#xD;&#xA;&#xD;&#xA;The first line (with text 17554) was not working, after much editing, the second line (with text 16316) is working as it should. &#xD;&#xA;&#xD;&#xA;How do I actually interpret that information? &#xD;&#xA;&#xD;&#xA;So far my understanding is: &#xD;&#xA;&#xD;&#xA;    `TEXT` is program instruction memory&#xD;&#xA;    `DATA` is variables (unitialised?) in program memory&#xD;&#xA;    `BSS`  is variables occupying RAM&#xD;&#xA;&#xD;&#xA;since BSS is considerably less than 1024 bytes, why does the second work, but the first doesn't? If it's `DATA+BSS` then both occupy more than 1024. " />
  <row Id="2176" PostHistoryTypeId="5" PostId="763" RevisionGUID="74b8d6ba-1bc9-49c4-afa3-a007138a9756" CreationDate="2014-03-17T10:33:54.233" UserId="304" Comment="added further findings" Text="I would like to know how much RAM I am using in my project, as far as I can tell, there's no way to actually work that out (other than going through and calculating it myself). I have got to a stage in a rather large project where I have determined that I am running out of RAM. &#xD;&#xA;&#xD;&#xA;I have determined this because I can add a section and then all hell breaks loose somewhere else in my code for no apparent reason. If I `#ifndef` that section out, it works again. There is nothing programatically wrong with the new code. &#xD;&#xA;&#xD;&#xA;I suspected for a while that I was getting to the end of available RAM. I don't think I'm using too much stack (although it's possible), what is the best way to determine how much RAM I am actually using?&#xD;&#xA;&#xD;&#xA;Going through and trying to work it out, I have problems when I get to enums and structs; how much memory do they cost? &#xD;&#xA;&#xD;&#xA;edit: I've included this code, since this was what I introduced and the problem started. However, the problem wasn't with this code. This code (with `NOEEPROM` defined or not) worked fine. It was (essentially) the serial received code that stuffed up. My assumption being, that SerialEvent is probably the last thing to be compiled and it's variables are right at the end of memory, and hence they're getting corrupted.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    //#define NOEEPROM 1&#xD;&#xA;    #define EEPROMSAVE 0&#xD;&#xA;    #define EEPROMREAD 1&#xD;&#xA;&#xD;&#xA;    // members of EEPROM SETTINGS //&#xD;&#xA;    uint8_t debug               = DEBUG;                               &#xD;&#xA;    uint8_t clear_eeprom        = 0;                             &#xD;&#xA;    uint8_t auto_dimming        = 1;&#xD;&#xA;    uint8_t lane_door_tone      = 0;&#xD;&#xA;    uint8_t limited_menu        = 0;&#xD;&#xA;    &#xD;&#xA;    #ifndef NOEEPROM&#xD;&#xA;    uint8_t t_debug             = debug;&#xD;&#xA;    uint8_t t_clear_eeprom      = clear_eeprom;&#xD;&#xA;    uint8_t t_auto_dimming      = auto_dimming;&#xD;&#xA;    uint8_t t_lane_door_tone    = lane_door_tone;&#xD;&#xA;    uint8_t t_limited_menu      = limited_menu;&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;in `setup(){}`&#xD;&#xA;&#xD;&#xA;    if(EEPROMREAD) loadFromEEPROM();&#xD;&#xA;&#xD;&#xA;in a misc file&#xD;&#xA;&#xD;&#xA;    void loadFromEEPROM(){&#xD;&#xA;      if(EEPROM.read(EEPROM_START)==1){&#xD;&#xA;          debug =          EEPROM.read(EEPROM_START+1);&#xD;&#xA;          clear_eeprom =   0; //EEPROM.read(EEPROM_START+2, clear_eeprom);&#xD;&#xA;          auto_dimming =   EEPROM.read(EEPROM_START+3);&#xD;&#xA;          lane_door_tone = EEPROM.read(EEPROM_START+4);&#xD;&#xA;          limited_menu =   EEPROM.read(EEPROM_START+5);&#xD;&#xA;      } else {&#xD;&#xA;        // load defaults&#xD;&#xA;        debug          = DEBUG;                               &#xD;&#xA;        clear_eeprom   = 0;                             &#xD;&#xA;        auto_dimming   = 1;&#xD;&#xA;        lane_door_tone = 0;&#xD;&#xA;        limited_menu   = 0;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;called from `loop(){}`&#xD;&#xA;&#xD;&#xA;    void drawSettings(){  &#xD;&#xA;      if(menu==SETTINGS){&#xD;&#xA;        uint16_t x = 100;&#xD;&#xA;        uint16_t y = 10;&#xD;&#xA;        uint16_t s = 40;&#xD;&#xA;        uint8_t  f = 22;&#xD;&#xA;    &#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;show debug info&quot;));&#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;clear calibration data&quot;));&#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;auto brightness&quot;));&#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;lane door tone&quot;));&#xD;&#xA;        GD.cmd_text(x, y+=s, f, 0, (&quot;limited menu&quot;));&#xD;&#xA;        &#xD;&#xA;        x -= 30; y = 10;&#xD;&#xA;        int tag = TAG_SETTINGS;&#xD;&#xA;      #ifndef NOEEPROM&#xD;&#xA;        checkbox(x, y+=s, tag++, t_debug);&#xD;&#xA;        checkbox(x, y+=s, tag++, t_clear_eeprom);&#xD;&#xA;        checkbox(x, y+=s, tag++, t_auto_dimming);&#xD;&#xA;        checkbox(x, y+=s, tag++, t_lane_door_tone);&#xD;&#xA;        checkbox(x, y+=s, tag++, t_limited_menu);&#xD;&#xA;      #else&#xD;&#xA;        checkbox(x, y+=s, tag++, debug);&#xD;&#xA;        checkbox(x, y+=s, tag++, clear_eeprom);&#xD;&#xA;        checkbox(x, y+=s, tag++, auto_dimming);&#xD;&#xA;        checkbox(x, y+=s, tag++, lane_door_tone);&#xD;&#xA;        checkbox(x, y+=s, tag++, limited_menu);&#xD;&#xA;      #endif&#xD;&#xA;        GD.Tag(TAG_SAVE_SETTINGS);&#xD;&#xA;        GD.cmd_button(MAXX-50,MAXY-40,45,25,f,0,&quot;Save&quot;);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;also called in the main loop is a file that controls the SETTINGS screen:&#xD;&#xA;&#xD;&#xA;        ...&#xD;&#xA;        switch (btag){&#xD;&#xA;    #ifndef NOEEPROM      &#xD;&#xA;          case TAG_SETTINGS:&#xD;&#xA;            t_debug = !t_debug;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+1:&#xD;&#xA;            t_clear_eeprom = !t_clear_eeprom;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+2:&#xD;&#xA;            t_auto_dimming = !t_auto_dimming;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+3:&#xD;&#xA;            t_lane_door_tone = !t_lane_door_tone;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+4:&#xD;&#xA;            t_limited_menu = !t_limited_menu;&#xD;&#xA;            break;&#xD;&#xA;    #else&#xD;&#xA;          case TAG_SETTINGS:&#xD;&#xA;            debug = !debug;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+1:&#xD;&#xA;            clear_eeprom = !clear_eeprom;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+2:&#xD;&#xA;            auto_dimming = !auto_dimming;&#xD;&#xA;            if(!auto_dimming) {&#xD;&#xA;               setBrightness(128);   &#xD;&#xA;            }&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+3:&#xD;&#xA;            lane_door_tone = !lane_door_tone;&#xD;&#xA;            break;&#xD;&#xA;          case TAG_SETTINGS+4:&#xD;&#xA;            limited_menu = !limited_menu;&#xD;&#xA;            break;&#xD;&#xA;    #endif&#xD;&#xA;        }&#xD;&#xA;        buttonDelay=1;&#xD;&#xA;      } else if (btag == TAG_SAVE_SETTINGS) {&#xD;&#xA;    #ifndef NOEEPROM&#xD;&#xA;        if(menu==SETTINGS &amp;&amp; EEPROMSAVE){&#xD;&#xA;          debug = t_debug;&#xD;&#xA;          &#xD;&#xA;          EEPROM.write(EEPROM_START  , 1);&#xD;&#xA;          EEPROM.write(EEPROM_START+1, t_debug);&#xD;&#xA;          if (t_clear_eeprom){&#xD;&#xA;            EEPROM.write(EEPROM_START+2,EEPROM.read(0));&#xD;&#xA;            EEPROM.write(0,0);&#xD;&#xA;          } else if(clear_eeprom == true &amp;&amp; t_clear_eeprom == false){&#xD;&#xA;            EEPROM.write(0,EEPROM.read(EEPROM_START+2));&#xD;&#xA;          }&#xD;&#xA;          EEPROM.write(EEPROM_START+3,t_auto_dimming);&#xD;&#xA;          EEPROM.write(EEPROM_START+4,t_lane_door_tone);&#xD;&#xA;          EEPROM.write(EEPROM_START+5,t_limited_menu);&#xD;&#xA;        }&#xD;&#xA;        debug             = t_debug;&#xD;&#xA;        clear_eeprom      = t_clear_eeprom;&#xD;&#xA;        auto_dimming      = t_auto_dimming;&#xD;&#xA;        lane_door_tone    = t_lane_door_tone;&#xD;&#xA;        limited_menu      = t_limited_menu;&#xD;&#xA;    #endif&#xD;&#xA;        menu=MAINMENU;&#xD;&#xA;        ...&#xD;&#xA;&#xD;&#xA;I could have missed some code out, but that is the essence of it.&#xD;&#xA;&#xD;&#xA;ALSO, I have edited the file so much since starting, these are not the actual result I initially got, but they are what I am getting now. &#xD;&#xA;&#xD;&#xA;      text	   data	    bss	    dec	    hex	filename&#xD;&#xA;     17554	    844	    449	  18847	   499f	HA15_20140317w.cpp.elf&#xD;&#xA;     16316	    694	    409	  17419	   440b	HA15_20140317w.cpp.elf&#xD;&#xA;     17346	    790	    426	  18562	   4882	HA15_20140317w.cpp.elf&#xD;&#xA;&#xD;&#xA;The first line (with text 17554) was not working, after much editing, the second line (with text 16316) is working as it should. &#xD;&#xA;&#xD;&#xA;_edit: the third line has everything working, serial reading, my new functions, etc. I essentially removed some global variables and duplicate code. I mention this because (as suspected) it's not about this code per sae, it has to be about the RAM usage. Which brings me back to the original question, &quot;how to best measure it&quot; I'm still checking out some answers, thanks._&#xD;&#xA;&#xD;&#xA;How do I actually interpret the above information? &#xD;&#xA;&#xD;&#xA;So far my understanding is: &#xD;&#xA;&#xD;&#xA;    `TEXT` is program instruction memory&#xD;&#xA;    `DATA` is variables (unitialised?) in program memory&#xD;&#xA;    `BSS`  is variables occupying RAM&#xD;&#xA;&#xD;&#xA;since BSS is considerably less than 1024 bytes, why does the second work, but the first doesn't? If it's `DATA+BSS` then both occupy more than 1024. " />
  <row Id="2177" PostHistoryTypeId="2" PostId="779" RevisionGUID="245ea064-62d1-4ded-833f-0ccf135915db" CreationDate="2014-03-17T11:16:07.667" UserId="42" Text="I bought a Gertboard a while ago, and one of the features it has on-board is an ATMega328 (DIP). However, since the Gertboard is designed for use with the Raspberry Pi, it only operates at 3.3v, so the clock speed is limited to ~12MHz.&#xD;&#xA;&#xD;&#xA;Programming it via the Raspberry Pi is quite cumbersome though. Instead, I'd like to transfer the chip to an Arduino Uno board so I can upload sketches from my desktop PC. I would then transfer it back to the Gertboard for normal operation.&#xD;&#xA;&#xD;&#xA;The problem is that my Uno operates at the more typical 5v / 16MHz.&#xD;&#xA;&#xD;&#xA;Is it safe to attempt this? Do I need to make any configuration changes in the IDE to tell it to account for a different clock speed?" />
  <row Id="2178" PostHistoryTypeId="1" PostId="779" RevisionGUID="245ea064-62d1-4ded-833f-0ccf135915db" CreationDate="2014-03-17T11:16:07.667" UserId="42" Text="Can I program a 3.3v chip on a 5v board?" />
  <row Id="2179" PostHistoryTypeId="3" PostId="779" RevisionGUID="245ea064-62d1-4ded-833f-0ccf135915db" CreationDate="2014-03-17T11:16:07.667" UserId="42" Text="&lt;arduino-uno&gt;&lt;safety&gt;&lt;uploading&gt;&lt;atmega328&gt;&lt;oscillator-clock&gt;" />
  <row Id="2180" PostHistoryTypeId="2" PostId="780" RevisionGUID="a4003b20-d59e-45cb-8e68-c8958326c5ec" CreationDate="2014-03-17T11:27:13.300" UserId="368" Text="The clock speed selected will affect both `delay*()` and `millis()`/`micros()` as well as the functions in `&lt;util/delay.h&gt;`, therefore you *must* use the target system's correct clock speed if you are using any of these functions. This can be easily done by editing `boards.txt` and copying an existing entry for the Uno and changing the value of the `f_cpu` parameter to match the target system (in this case, `12000000`).&#xD;&#xA;&#xD;&#xA;The difference in voltage does not matter, since the chip can run at either voltage and no connection is being made between the 5V system and the 3.3V system." />
  <row Id="2181" PostHistoryTypeId="5" PostId="763" RevisionGUID="0b6ecfa6-026e-4ee9-a00a-b3f9870a2394" CreationDate="2014-03-17T15:15:47.650" UserId="304" Comment="removed code :)" Text="I would like to know how much RAM I am using in my project, as far as I can tell, there's no way to actually work that out (other than going through and calculating it myself). I have got to a stage in a rather large project where I have determined that I am running out of RAM. &#xD;&#xA;&#xD;&#xA;I have determined this because I can add a section and then all hell breaks loose **somewhere else in my code** for no apparent reason. If I `#ifndef` something else out, it works again. There is nothing programatically wrong with the new code. &#xD;&#xA;&#xD;&#xA;I suspected for a while that I was getting to the end of available RAM. I don't think I'm using too much stack (although it's possible), what is the best way to determine how much RAM I am actually using?&#xD;&#xA;&#xD;&#xA;Going through and trying to work it out, I have problems when I get to enums and structs; how much memory do they cost? &#xD;&#xA;&#xD;&#xA;_first_ edit: ALSO, I have edited my sketch so much since starting, these are not the actual results I initially got, but they are what I am getting now. &#xD;&#xA;&#xD;&#xA;      text	   data	    bss	    dec	    hex	filename&#xD;&#xA;     17554	    844	    449	  18847	   499f	HA15_20140317w.cpp.elf&#xD;&#xA;     16316	    694	    409	  17419	   440b	HA15_20140317w.cpp.elf&#xD;&#xA;     17346	    790	    426	  18562	   4882	HA15_20140317w.cpp.elf&#xD;&#xA;&#xD;&#xA;The first line (with text 17554) was not working, after much editing, the second line (with text 16316) is working as it should. &#xD;&#xA;&#xD;&#xA;_edit: the third line has everything working, serial reading, my new functions, etc. I essentially removed some global variables and duplicate code. I mention this because (as suspected) it's not about this code per sae, it has to be about the RAM usage. Which brings me back to the original question, &quot;how to best measure it&quot; I'm still checking out some answers, thanks._&#xD;&#xA;&#xD;&#xA;How do I actually interpret the above information? &#xD;&#xA;&#xD;&#xA;So far my understanding is: &#xD;&#xA;&#xD;&#xA;    `TEXT` is program instruction memory&#xD;&#xA;    `DATA` is variables (unitialised?) in program memory&#xD;&#xA;    `BSS`  is variables occupying RAM&#xD;&#xA;&#xD;&#xA;since BSS is considerably less than 1024 bytes, why does the second work, but the first doesn't? If it's `DATA+BSS` then both occupy more than 1024. &#xD;&#xA;&#xD;&#xA;**_re-edit:_ I edited the question to include the code, but now I've removed it because it really had nothing to do with the problem (other than maybe poor coding practices, variable declarations and the like). You can review the code by looking back through the edits if you _really_ want to see it. I wanted to get back to the question at hand, which was more based around: How to measure RAM usage.**&#xD;&#xA;" />
  <row Id="2182" PostHistoryTypeId="2" PostId="781" RevisionGUID="f630aab5-9e4d-4894-86d8-902330c29c24" CreationDate="2014-03-17T17:55:17.447" UserId="639" Text="Why is the Arduino able to accept ~5V from the USB, but requires a min of 7V when using an external power supply?" />
  <row Id="2183" PostHistoryTypeId="1" PostId="781" RevisionGUID="f630aab5-9e4d-4894-86d8-902330c29c24" CreationDate="2014-03-17T17:55:17.447" UserId="639" Text="Arduino USB Power vs External Power Supply" />
  <row Id="2184" PostHistoryTypeId="3" PostId="781" RevisionGUID="f630aab5-9e4d-4894-86d8-902330c29c24" CreationDate="2014-03-17T17:55:17.447" UserId="639" Text="&lt;arduino-uno&gt;&lt;power&gt;&lt;safety&gt;&lt;voltage-level&gt;" />
  <row Id="2185" PostHistoryTypeId="36" PostId="782" RevisionGUID="6134848c-ad54-485b-8e05-2e2728f98978" CreationDate="2014-03-17T17:57:09.113" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/103195/arduino-mega-not-flashable-with-xbee-pro-s2b" />
  <row Id="2186" PostHistoryTypeId="2" PostId="782" RevisionGUID="0c356edd-bdaa-44bf-a6c1-ad2637137178" CreationDate="2014-03-17T13:04:08.333" UserId="665" Text="I have an Arduino Mega 2560 with a [libelium XBee Shield][1]. If I have an XBee S2 mounted on it and set the two jumpers to the USB setting or remove them, I am able to flash a program onto my Arduino.&#xD;&#xA;&#xD;&#xA;However, when I'm mounting one of my XBee PRO S2B (I have three of them available and all behave the same) on the Arduino, no matter how I set the jumpers, it is not possible to flash anything on it. I always see `avrdude: stk500v2_getsync(): timeout communicating with programmer` in the Arduino IDE.&#xD;&#xA;&#xD;&#xA;Is the XBee PRO S2B incompatible with the Arduino or what might be the issue? I also tried to add an external power source additionally to the USB, but it didn't help either.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoXbeeShield#.UybqgHVSm4I" />
  <row Id="2187" PostHistoryTypeId="1" PostId="782" RevisionGUID="0c356edd-bdaa-44bf-a6c1-ad2637137178" CreationDate="2014-03-17T13:04:08.333" UserId="665" Text="Arduino Mega not flashable with XBee PRO S2B" />
  <row Id="2188" PostHistoryTypeId="3" PostId="782" RevisionGUID="0c356edd-bdaa-44bf-a6c1-ad2637137178" CreationDate="2014-03-17T13:04:08.333" UserId="665" Text="&lt;programming&gt;" />
  <row Id="2189" PostHistoryTypeId="2" PostId="783" RevisionGUID="780b9d86-cad1-4ea7-a3ec-9b1ffe0588c9" CreationDate="2014-03-17T18:09:00.250" UserId="313" Text="The design assumes USB provides a regulated 5v so no further regulation is necessary. The power connecter is meant to accept up a wider range of voltage and regulate to 5v, and regulators (the kind on the Arduino board) need that much higher voltage to provide regulation. If you already have a regulated +5v source you can supply to the 5v pin. You'll bypass the on-board regulator this way, so just know that it will then be up to you to provide clean power." />
  <row Id="2190" PostHistoryTypeId="2" PostId="784" RevisionGUID="8f179c5d-2c94-4cf6-bcf1-31c93e07a740" CreationDate="2014-03-17T18:45:41.993" UserId="642" Text="I am getting the error &quot;error: expected unqualified-id before 'do'&quot; multiple times for every do{&#xD;&#xA;}while(); loop I have... Any help?&#xD;&#xA;&#xD;&#xA;Pastebin:http://pastebin.com/DubuAEUs" />
  <row Id="2191" PostHistoryTypeId="1" PostId="784" RevisionGUID="8f179c5d-2c94-4cf6-bcf1-31c93e07a740" CreationDate="2014-03-17T18:45:41.993" UserId="642" Text="Expected Unqualified-ID Before 'do'(and 'while')" />
  <row Id="2192" PostHistoryTypeId="3" PostId="784" RevisionGUID="8f179c5d-2c94-4cf6-bcf1-31c93e07a740" CreationDate="2014-03-17T18:45:41.993" UserId="642" Text="&lt;arduino-uno&gt;" />
  <row Id="2193" PostHistoryTypeId="2" PostId="785" RevisionGUID="e97e0f57-d764-44c6-b869-5d91487d04a3" CreationDate="2014-03-17T18:49:12.523" UserId="407" Text="As JRobert stated, the barrel jack provides regulation to support higher voltages. The to this regulatory circuit, even if the supply is 5v, there will still be a voltage drop across the power supply components. This is why the rating is higher. " />
  <row Id="2194" PostHistoryTypeId="2" PostId="786" RevisionGUID="13ab383c-bad7-4257-8e1c-c1990aba3ae6" CreationDate="2014-03-17T20:15:13.410" UserId="136" Text="The do whiles are outside of the setup() or loop(), so they won't work. &#xD;&#xA;&#xD;&#xA;I would suggest doing a simple C/C++ tutorial like [this one][1] to get up to speed with how things work.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.learn-c.org" />
  <row Id="2195" PostHistoryTypeId="2" PostId="787" RevisionGUID="863fed37-f0b1-4832-99b5-c7cf47b69c54" CreationDate="2014-03-17T20:38:38.843" UserId="84" Text="The main issues you can have with memory usage at runtime are:&#xD;&#xA;&#xD;&#xA;- no available memory in the heap for dynamic allocations (`malloc` or `new`)&#xD;&#xA;- no room left on the stack when calling a function&#xD;&#xA;&#xD;&#xA;Both are actually the same as AVR SRAM (2K on Arduino) is used for both (in addition to static data which size never changes during program execution).&#xD;&#xA;&#xD;&#xA;Generally, dynamic memory allocation is seldom used on MCUs, only a few libraries typically use it (one of them is `String` class, which you mentioned you don't use, which is a good point).&#xD;&#xA;&#xD;&#xA;Hence, the most expected issue comes from stack overflow (i.e. when the stack grows towards the heap and overflows on it, and then -if the heap was not used at all- overflows on the static data zone of the SRAM" />
  <row Id="2196" PostHistoryTypeId="16" PostId="787" RevisionGUID="0f5c3afb-d1e1-462c-8966-6d8f6461e46d" CreationDate="2014-03-17T20:38:38.843" UserId="84" />
  <row Id="2197" PostHistoryTypeId="5" PostId="787" RevisionGUID="7d9dbb62-68e1-47b7-96fd-97d59b0954df" CreationDate="2014-03-17T20:52:48.270" UserId="84" Comment="Completed initial post that was mistakenly sent too early" Text="The main issues you can have with memory usage at runtime are:&#xD;&#xA;&#xD;&#xA;- no available memory in the **heap** for dynamic allocations (`malloc` or `new`)&#xD;&#xA;- no room left on the **stack** when calling a function&#xD;&#xA;&#xD;&#xA;Both are actually the same as the AVR **SRAM** (2K on Arduino) is used for both (in addition to **static data** which size never changes during program execution).&#xD;&#xA;&#xD;&#xA;Generally, dynamic memory allocation is seldom used on MCUs, only a few libraries typically use it (one of them is `String` class, which you mentioned you don't use, and that's a good point).&#xD;&#xA;&#xD;&#xA;The stack and the heap can be seen in the picture below (courtesy of [Adafruit][1]):&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;Hence, the most expected issue comes from stack overflow (i.e. when the stack grows towards the heap and overflows on it, and then -if the heap was not used at all- overflows on the static data zone of the SRAM. At that time, you have a high risk of either:&#xD;&#xA;&#xD;&#xA;- data corruption (i.e. the stack ovewrites heap or static data), giving you ununderstandable behavior&#xD;&#xA;- stack corruption (i.e. the heap or static data overwrites stack content), generally leading to a crash&#xD;&#xA;&#xD;&#xA;In order to know the amount of memory that's left between the top of the heap and the top of the stack (actually, we might call it the bottom if we represent both the heap and the stack on the same image as depicted below), you can use the following function:&#xD;&#xA;&#xD;&#xA;    int freeRam () {&#xD;&#xA;      extern int __heap_start, *__brkval; &#xD;&#xA;      int v; &#xD;&#xA;      return (int) &amp;v - (__brkval == 0 ? (int) &amp;__heap_start : (int) __brkval); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;In the code above, `__brkval` points to the top of the heap but is `0` when the heap has not been used, in which case `__heap_start` points to the bottom of the heap; `&amp;v` points of course to the top of the stack (this is the last variable pushed on the stack), hence the formula above returns the amount of memory available for the stack (or the heap if you use it) to grow.&#xD;&#xA;&#xD;&#xA;You can use this function in various locations of your code to try and find out where this size is getting dramatically reduced.&#xD;&#xA;&#xD;&#xA;  [1]: http://learn.adafruit.com/memories-of-an-arduino/measuring-free-memory&#xD;&#xA;  [2]: http://i.stack.imgur.com/waoHN.gif" />
  <row Id="2198" PostHistoryTypeId="5" PostId="787" RevisionGUID="ae6cc72f-61b2-4f0f-b373-acf2fd12f707" CreationDate="2014-03-17T21:12:59.113" UserId="84" Comment="Fixed some info about the bottom of the stack and added info on negative freeRam return" Text="The main issues you can have with memory usage at runtime are:&#xD;&#xA;&#xD;&#xA;- no available memory in the **heap** for dynamic allocations (`malloc` or `new`)&#xD;&#xA;- no room left on the **stack** when calling a function&#xD;&#xA;&#xD;&#xA;Both are actually the same as the AVR **SRAM** (2K on Arduino) is used for both (in addition to **static data** which size never changes during program execution).&#xD;&#xA;&#xD;&#xA;Generally, dynamic memory allocation is seldom used on MCUs, only a few libraries typically use it (one of them is `String` class, which you mentioned you don't use, and that's a good point).&#xD;&#xA;&#xD;&#xA;The stack and the heap can be seen in the picture below (courtesy of [Adafruit][1]):&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;Hence, the most expected issue comes from stack overflow (i.e. when the stack grows towards the heap and overflows on it, and then -if the heap was not used at all- overflows on the static data zone of the SRAM. At that time, you have a high risk of either:&#xD;&#xA;&#xD;&#xA;- data corruption (i.e. the stack ovewrites heap or static data), giving you ununderstandable behavior&#xD;&#xA;- stack corruption (i.e. the heap or static data overwrites stack content), generally leading to a crash&#xD;&#xA;&#xD;&#xA;In order to know the amount of memory that's left between the top of the heap and the top of the stack (actually, we might call it the bottom if we represent both the heap and the stack on the same image as depicted below), you can use the following function:&#xD;&#xA;&#xD;&#xA;    int freeRam () {&#xD;&#xA;      extern int __heap_start, *__brkval; &#xD;&#xA;      int v; &#xD;&#xA;      return (int) &amp;v - (__brkval == 0 ? (int) &amp;__heap_start : (int) __brkval); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;In the code above, `__brkval` points to the top of the heap but is `0` when the heap has not been used, in which case we use `&amp;__heap_start` which points to `__heap_start`, the first variable that marks the bottom of the heap; `&amp;v` points of course to the top of the stack (this is the last variable pushed on the stack), hence the formula above returns the amount of memory available for the stack (or the heap if you use it) to grow.&#xD;&#xA;&#xD;&#xA;You can use this function in various locations of your code to try and find out where this size is getting dramatically reduced.&#xD;&#xA;&#xD;&#xA;Of course, if ever you see this function return a negative number then it is too late: you have already overflown the stack!&#xD;&#xA;&#xD;&#xA;  [1]: http://learn.adafruit.com/memories-of-an-arduino/measuring-free-memory&#xD;&#xA;  [2]: http://i.stack.imgur.com/waoHN.gif" />
  <row Id="2199" PostHistoryTypeId="5" PostId="783" RevisionGUID="10b39a09-80e0-4270-a28d-ab07b55fd7ef" CreationDate="2014-03-17T21:35:50.473" UserId="313" Comment="minor re-wording, fixed typos." Text="The design assumes USB provides a regulated 5v so no further regulation is necessary. The power connecter is meant to accept a wider range of voltage and regulate it to 5v, and the kind of regulators used on the Arduino board need that much higher voltage to provide regulation. If you already have a regulated +5v source you can supply it to the 5v pin. You'll bypass the on-board regulator this way, so just know that it will then be up to you to provide clean power." />
  <row Id="2204" PostHistoryTypeId="2" PostId="789" RevisionGUID="624fe77b-e9de-420f-9476-ff853cbf754c" CreationDate="2014-03-18T00:21:02.903" UserId="173" Text="I am working on a heating control system for my home, but having problems with the temperature sensor reading higher than I expect.&#xD;&#xA;&#xD;&#xA;I have a 5V Arduino Mini Pro clone hooked up to a relay module, an HD47780 display and a Tiny RTC module, with a DS18B20 attached to it.&#xD;&#xA;&#xD;&#xA;The DS18B20 is powered from the 5v Vcc applied to the Tiny RTC module rather than using parasitic power on the DQ line (as I wasn't sure if the Onewire libraries supported this mode of operation) and the [DS18B20 datasheet][1] says that Vcc may be between 3.0v and 5.5v. I measured the regulated power from the Mini Pro's  being at 5.2v.&#xD;&#xA;&#xD;&#xA;I am comparing the temperature from the DS with the existing room thermostat and a desktop RS temperature monitor with two sensors. The readout from the DS is always around 1-2 degrees higher than the readout from the RS.&#xD;&#xA;&#xD;&#xA;Reading various forums I have heard that these sensors are quite accurate but can suffer from localised heating from components near them, so I moved the sensor onto a 20cm cable and positioned it well away from the rest of the electronics. This made no difference.&#xD;&#xA;&#xD;&#xA;I then read that the DS can become self heating if it is supplied with too high a Vcc voltage, so I added a Red LED with 1.7v drop and measured the new voltage over the DS as 3.5v, but again, after waiting for the temperatures to stabilise once more, this made no difference.&#xD;&#xA;&#xD;&#xA;Can anyone suggest why the DS may be reading high and what I can can do to prevent this?&#xD;&#xA;&#xD;&#xA;  [1]: http://datasheets.maximintegrated.com/en/ds/DS18B20.pdf" />
  <row Id="2205" PostHistoryTypeId="1" PostId="789" RevisionGUID="624fe77b-e9de-420f-9476-ff853cbf754c" CreationDate="2014-03-18T00:21:02.903" UserId="173" Text="My DS18B20 is reading high, how can I get it to return the correct temperature?" />
  <row Id="2206" PostHistoryTypeId="3" PostId="789" RevisionGUID="624fe77b-e9de-420f-9476-ff853cbf754c" CreationDate="2014-03-18T00:21:02.903" UserId="173" Text="&lt;sensors&gt;&lt;temperature-sensor&gt;" />
  <row Id="2207" PostHistoryTypeId="2" PostId="790" RevisionGUID="b27e1c38-605d-43d1-bd08-426ad9473d33" CreationDate="2014-03-18T00:38:24.110" UserId="633" Text="I have arduino Pro Mini 3.3V version with hc-05 module connected to 3.3V/GND and RXI/TX0 pins. I am then using my android phone to connect to the module. It shows up and pairs fine. Then I use BlueTerm app to view the output. I am seeing output that is occasionally as expected but mostly partially corrupted (characters replaced with random characters). &#xD;&#xA;&#xD;&#xA;I am using 9600 baud rate and trasmitting the following:&#xD;&#xA;&#xD;&#xA;    void serialTransmit(int data){&#xD;&#xA;      // send to raspberry pi or other device(s).&#xD;&#xA;      Serial.print(&quot;Serial Transmit: &quot;);&#xD;&#xA;      Serial.println(data); // this is hard coded as &quot;12&quot; for testing&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I tried switching rx/tx pins around but got same corrupt output. Tried changing baud rate but then it wouldn't transmit anything at all and default rate is 9600 so that was expected.&#xD;&#xA;&#xD;&#xA;What could be the cause?" />
  <row Id="2208" PostHistoryTypeId="1" PostId="790" RevisionGUID="b27e1c38-605d-43d1-bd08-426ad9473d33" CreationDate="2014-03-18T00:38:24.110" UserId="633" Text="Corrupted output from HC-05 Bluetooth module" />
  <row Id="2209" PostHistoryTypeId="3" PostId="790" RevisionGUID="b27e1c38-605d-43d1-bd08-426ad9473d33" CreationDate="2014-03-18T00:38:24.110" UserId="633" Text="&lt;arduino-pro&gt;" />
  <row Id="2210" PostHistoryTypeId="2" PostId="791" RevisionGUID="d6b9de5f-55ed-44cb-af47-0ecd4095b521" CreationDate="2014-03-18T00:42:09.173" UserId="46" Text="I'm trying to make an RF remote control using ATtiny85 running at 8MHz on internal oscillator, [this cheap RF 434MHz transmitter module](http://www.wenshing.com.tw/Products/RF_Module/ASK_RF_Transmitter_Module/TWS-DS-3_433.92MHz_Miniaturization_Wireless_Transmitter_Module/) (like the one below), and VirtualWire lib, **but had no success so far**. &#xD;&#xA;&#xD;&#xA;![RF transmitter][1]&#xD;&#xA;&#xD;&#xA;So, before I go any further, **is it possible to use VirtualWire with ATtiny85 running at 3.6V and 8MHz with its internal oscillator? If so, how?**&#xD;&#xA;&#xD;&#xA;I've found a few scattered sources of information on the Net about it, but couldn't make much sense of it. &#xD;&#xA;&#xD;&#xA;I have build ATMega328 versions of the receiver and transmitter using VirtualWire without any major problems. Both modules talk to each other will very little data drop out. Now, when I tried to replace the ATMega328 transmitter with a smaller version using the ATtiny85, I'm having problems. &#xD;&#xA;&#xD;&#xA;Here are the symptoms: &#xD;&#xA;&#xD;&#xA;1. The major one seem to be that when I add the VirtualWire include, **my sketch seems to slow down a lot**. So I figure it's a timing issue. But I'm not sure what the problem is.&#xD;&#xA;&#xD;&#xA;2. I put a scope on ATtiny85 pin 6 (PB1) but **I don't see anything being transmitted**. I think I've messed up with the pin names. &#xD;&#xA;&#xD;&#xA;3. I can make the LED blink and also can read the buttons without problems.&#xD;&#xA;&#xD;&#xA;Here are the schematics and the board design for the remote controller:&#xD;&#xA;&#xD;&#xA;![RC schematic][2]&#xD;&#xA;&#xD;&#xA;The board is currently powered by 2 AA NiMH batteries that are currently at 2.6V. I can make the ATtiny85 blink with that voltage. I plan to power the RC with a 3.6V CR2 lithum battery.&#xD;&#xA;&#xD;&#xA;Here are more details of my development enviroment:&#xD;&#xA;&#xD;&#xA;* Arduino IDE 1.05&#xD;&#xA;* I'm using ATtiny cores [from here](https://docs.google.com/file/d/0B4cPTBXMMjz9Q0NWN3Q1cWhuV0U/edit?pli=1)&#xD;&#xA;* I'm programming the ATtiny85 using an Arduino UNO R3 as ISP, without problems (it's working as I can make the ATtiny85 blink an LED).&#xD;&#xA;&#xD;&#xA;And here's my code:&#xD;&#xA;&#xD;&#xA;    #include &lt;VirtualWire.h&gt;&#xD;&#xA;    &#xD;&#xA;    #define VCC_PIN  A1&#xD;&#xA;    #define BTN_PIN  A2&#xD;&#xA;    #define LED_PIN  A3&#xD;&#xA;    #define TXD_PIN  PB1&#xD;&#xA;    &#xD;&#xA;    #define BLINK_UP_TIME  25&#xD;&#xA;    &#xD;&#xA;    #define BUTTON_NONE  0&#xD;&#xA;    #define BUTTON_1     1&#xD;&#xA;    #define BUTTON_2     2&#xD;&#xA;    #define BUTTON_3     3&#xD;&#xA;    #define BUTTON_4     4&#xD;&#xA;    #define BUTTON_5     5&#xD;&#xA;    #define BUTTON_6     6&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      pinMode(BTN_PIN, INPUT);&#xD;&#xA;      pinMode(TXD_PIN, OUTPUT);     &#xD;&#xA;      pinMode(VCC_PIN, OUTPUT);     &#xD;&#xA;      pinMode(LED_PIN, OUTPUT);     &#xD;&#xA;    &#xD;&#xA;      // leave RF transmitter off for now&#xD;&#xA;      digitalWrite(VCC_PIN, LOW);&#xD;&#xA;      &#xD;&#xA;      // Initialise the IO and ISR&#xD;&#xA;      vw_set_tx_pin(TXD_PIN);&#xD;&#xA;      vw_setup(2000);	 // Bits per sec&#xD;&#xA;    &#xD;&#xA;      // let the user know we are alive: heartbeat&#xD;&#xA;      blink(3, 50);&#xD;&#xA;      delay(1000);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    uint8_t buf[VW_MAX_MESSAGE_LEN];&#xD;&#xA;    uint8_t buflen = VW_MAX_MESSAGE_LEN;&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      byte button = ReadButtons();&#xD;&#xA;      if (button != BUTTON_NONE) {&#xD;&#xA;        // transmit button pressed&#xD;&#xA;        digitalWrite(LED_PIN, HIGH); // Flash a light to show transmitting&#xD;&#xA;        digitalWrite(VCC_PIN, HIGH); // turn tranmitter on&#xD;&#xA;        delay(10);&#xD;&#xA;        buf[0] = button;&#xD;&#xA;        vw_send(buf, 1);&#xD;&#xA;        vw_wait_tx(); // Wait until the whole message is gone&#xD;&#xA;        digitalWrite(LED_PIN, LOW); // turn off LED&#xD;&#xA;        digitalWrite(VCC_PIN, LOW); // turn tranmitter off&#xD;&#xA;      }&#xD;&#xA;      delay(100);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    byte ReadButtons()&#xD;&#xA;    {&#xD;&#xA;      unsigned int buttonVoltage = analogRead(BTN_PIN);&#xD;&#xA;      byte button = BUTTON_NONE;   // return no button pressed if the below checks don't write to btn&#xD;&#xA;      if      (buttonVoltage &lt; 10)   {    button = BUTTON_1; } &#xD;&#xA;      else if (buttonVoltage &lt; 200)  {    button = BUTTON_2; } &#xD;&#xA;      else if (buttonVoltage &lt; 400)  {    button = BUTTON_3; } &#xD;&#xA;      else if (buttonVoltage &lt; 550)  {    button = BUTTON_4; } &#xD;&#xA;      else if (buttonVoltage &lt; 720)  {    button = BUTTON_5; } &#xD;&#xA;      else if (buttonVoltage &lt; 900)  {    button = BUTTON_6; }&#xD;&#xA;      else if (buttonVoltage &gt; 1000) {    button = BUTTON_NONE; }&#xD;&#xA;      return( button );&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;So, **What's wrong with my setup?**&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/LHs0b.gif&#xD;&#xA;  [2]: http://i.stack.imgur.com/skxbK.png" />
  <row Id="2211" PostHistoryTypeId="1" PostId="791" RevisionGUID="d6b9de5f-55ed-44cb-af47-0ecd4095b521" CreationDate="2014-03-18T00:42:09.173" UserId="46" Text="RF remote control using VirtualWire on ATtiny85 running at 8MHz on internal oscillator" />
  <row Id="2212" PostHistoryTypeId="3" PostId="791" RevisionGUID="d6b9de5f-55ed-44cb-af47-0ecd4095b521" CreationDate="2014-03-18T00:42:09.173" UserId="46" Text="&lt;remote-control&gt;&lt;attiny&gt;&lt;virtualwire&gt;&lt;rf&gt;" />
  <row Id="2213" PostHistoryTypeId="5" PostId="789" RevisionGUID="9145ad27-72df-4d38-bb6e-f9022fedd851" CreationDate="2014-03-18T02:12:38.127" UserId="173" Comment="added 433 characters in body" Text="I am working on a heating control system for my home, but having problems with the temperature sensor reading higher than I expect.&#xD;&#xA;&#xD;&#xA;I have a 5V Arduino Mini Pro clone hooked up to a relay module, an HD47780 display and a Tiny RTC module, with a DS18B20 attached to it.&#xD;&#xA;&#xD;&#xA;The DS18B20 is powered from the 5v Vcc applied to the Tiny RTC module rather than using parasitic power on the DQ line (as I wasn't sure if the Onewire libraries supported this mode of operation) and the [DS18B20 datasheet][1] says that Vcc may be between 3.0v and 5.5v. I measured the regulated power from the Mini Pro's  being at 5.2v.&#xD;&#xA;&#xD;&#xA;I am comparing the temperature from the DS with the existing room thermostat (bi-metallic), an RS desktop temperature monitor with two sensors, a small ['thermo-hygrometer'][2] and a [bi-metallic fridge thermometer][3] (in the upper quarter of it's temperature range)&lt;sup&gt;&amp;dagger;&lt;/sup&gt;. The readout from the DS is always around 1-2 degrees higher than the readout from the other sensors, which are within a degree of each other.&#xD;&#xA;&#xD;&#xA;&lt;sup&gt;&amp;dagger; Not the actual one, but something similar.&lt;/sup&gt;&#xD;&#xA;&#xD;&#xA;Reading various forums I have heard that these sensors are quite accurate but can suffer from localised heating from components near them, so I moved the sensor onto a 20cm cable and positioned it well away from the rest of the electronics. This made no difference.&#xD;&#xA;&#xD;&#xA;I then read that the DS can become self heating if it is supplied with too high a Vcc voltage, so I added a Red LED with 1.7v drop and measured the new voltage over the DS as 3.5v, but again, after waiting for the temperatures to stabilise once more, this made no difference.&#xD;&#xA;&#xD;&#xA;Can anyone suggest why the DS may be reading high and what I can can do to prevent this?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://datasheets.maximintegrated.com/en/ds/DS18B20.pdf&#xD;&#xA;  [2]: http://i01.i.aliimg.com/photo/v4/376190273/In_out_Thermo_Hygrometer_HC520.jpg&#xD;&#xA;  [3]: http://ecx.images-amazon.com/images/I/71sVnFU5AQL._SL1436_.jpg" />
  <row Id="2214" PostHistoryTypeId="2" PostId="792" RevisionGUID="19563ef7-0ddd-4caf-9e03-749a913cb66c" CreationDate="2014-03-18T08:48:53.803" UserId="136" Text="I've put a lot of DS18B20 sensors in place now on various sensor nodes - maybe 50 or so. I've learnt a bit about the readings returned from them. I know you have isolated some of these as not being the cause, but it is good to confirm that they are issues.&#xD;&#xA;&#xD;&#xA;I don't know if you are using Celsius or Fahrenheit, so the degree of the problem isn't clear.&#xD;&#xA;&#xD;&#xA;**Localised heating**&#xD;&#xA;&#xD;&#xA;I don't think of Arduino as a &quot;hot&quot; chip, but putting a DS18B20 in an enclosure with an Arduino and LCD caused me to see readings 2-3°C higher than expected.&#xD;&#xA;&#xD;&#xA;Moving it outside the enclosure fixed this.&#xD;&#xA;&#xD;&#xA;**Heating from high Vcc/frequent conversions**&#xD;&#xA;&#xD;&#xA;If you supply the chip with a high Vcc and perform frequent conversions (i.e. as frequently as you can), the chip does warm up. I have seen this increase readings by 1-2°C.&#xD;&#xA;&#xD;&#xA;I haven't seen the problem with high Vcc alone, but I operate most DS18B20 in parasitic mode and convert at most once every 10s. The ones operated in active mode generally have the powered turned off when not being used.&#xD;&#xA;&#xD;&#xA;OneWire and DallasTemperature do support parasitic mode.&#xD;&#xA;&#xD;&#xA;**Not all temperature sensors are created equal**&#xD;&#xA;&#xD;&#xA;I had a number of temperature sensors before I started playing around with DS18B20. Almost without exception, these under-read. Most of them are based on thermistors and calibration is poor. I thought the DS18B20 were over reading, but when I used a good thermocouple and meter, I could validate that they were correct.&#xD;&#xA;&#xD;&#xA;This was about learning to trust the DS18B20.&#xD;&#xA;&#xD;&#xA;**Heat conducted along wire**&#xD;&#xA;&#xD;&#xA;If you have the sensors on a wire, the wire conducts a surprising amount of heat. This can be an issue when running wiring along pipes.&#xD;&#xA;&#xD;&#xA;**Fake DS18B20**&#xD;&#xA;&#xD;&#xA;These sensors are very popular, and this seems to have caused fakes to appear. I have a batch of stainless steel waterproof sensors that over-read and the timings were out. They worked with the OneWire library, but not a DS2482 OneWire master. I have heard of the normal TO-92 cased ones being fake as well." />
  <row Id="2215" PostHistoryTypeId="2" PostId="793" RevisionGUID="74be8549-0a2b-4e3a-bf44-1135b87d32c9" CreationDate="2014-03-18T11:20:44.303" UserId="685" Text="![AA Battery][1]&#xD;&#xA;&#xD;&#xA;Above is an AA Battery voltage curve. Many people assume that 5* 1.5V AA batterys would be enough to power the Arduino. As you can see the 1.5 is the maximum voltage and it quickly drops. Different brands have different values and sometimes this can drop below the value of the voltage regulator input. I usually tend to aim between 7 and 9 Volts for  running from batteries.&#xD;&#xA;&#xD;&#xA;For wall socket charges, Buy a cheap one and hook it up to a volt meter, Many that say 5V actually have a range of values. Raspberry Pi users often have problems with power caused by manufacturers saying its 5v and it actually delivering something like 4.85 and fluctuating beacuse of the power demand of the pi &#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/DIp8P.jpg" />
  <row Id="2217" PostHistoryTypeId="5" PostId="782" RevisionGUID="3ac4b8db-bae6-4f67-a36b-eb678f0af6ca" CreationDate="2014-03-18T14:29:41.730" UserId="665" Comment="Added new findings" Text="I have an Arduino Mega 2560 with a [libelium XBee Shield][1]. If I have an XBee S2 mounted on it and set the two jumpers to the USB setting or remove them, I am able to flash a program onto my Arduino.&#xD;&#xA;&#xD;&#xA;However, when I'm mounting one of my XBee PRO S2B (I have three of them available and all behave the same) on the Arduino, no matter how I set the jumpers, it is not possible to flash anything on it. I always see `avrdude: stk500v2_getsync(): timeout communicating with programmer` in the Arduino IDE.&#xD;&#xA;&#xD;&#xA;Is the XBee PRO S2B incompatible with the Arduino or what might be the issue? I also tried to add an external power source additionally to the USB, but it didn't help either.&#xD;&#xA;&#xD;&#xA;**Update**&#xD;&#xA;&#xD;&#xA;After some more experimenting, I found out new details. I tried to disconnect each pin of the shield individually. While doing it, I discovered that disconnecting the `reset` pin from the arduino makes it possible to flash it - take a look at the [XBee shield schematic][2], it's pin 5 from the ICSP connector; Photo: ![photo of it][3]&#xD;&#xA;&#xD;&#xA;I used a multimeter and discovered that the XBee PRO S2B CTS / DCIO7 port is high, while the one from the XBee S2 is low, and so constantly resetting the arduino. I mounted the XBee PRO S2B onto the [Sparkfun XBee Explorer USB][4] and opened a serial port with PuTTY.&#xD;&#xA;In contrast to the S2, the PRO S2B provides a menu with several options:&#xD;&#xA;&#xD;&#xA;    B-Bypass Mode&#xD;&#xA;    F-Update App&#xD;&#xA;    T-Timeout&#xD;&#xA;    V-BL Version&#xD;&#xA;    A-App Version&#xD;&#xA;    R-Reset&#xD;&#xA;    &gt;&#xD;&#xA;&#xD;&#xA;![Sparkfun XBee Explorer USB, CTS port][5]&#xD;&#xA;&#xD;&#xA;As soon as I type B, the CTS port goes low, and would prevent the arduino from resetting. Also this mode is needed to detect the module via XCTU. However, with an unmodified arduino, I wouldn't have a chance to send this letter, since the XBee is constantly resetting it. What is this menu, can it be disabled somehow?&#xD;&#xA;&#xD;&#xA;(Btw, how about an xbee tag for this site?)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoXbeeShield#.UybqgHVSm4I&#xD;&#xA;  [2]: http://www.arduino.cc/en/uploads/Main/XbeeShieldSchematic.pdf&#xD;&#xA;  [3]: http://i.stack.imgur.com/wgXvG.jpg&#xD;&#xA;  [4]: https://www.sparkfun.com/products/8687&#xD;&#xA;  [5]: http://i.stack.imgur.com/ju3TV.jpg" />
  <row Id="2218" PostHistoryTypeId="6" PostId="782" RevisionGUID="3ac4b8db-bae6-4f67-a36b-eb678f0af6ca" CreationDate="2014-03-18T14:29:41.730" UserId="665" Comment="Added new findings" Text="&lt;programming&gt;&lt;serial&gt;" />
  <row Id="2219" PostHistoryTypeId="5" PostId="782" RevisionGUID="4572912e-014b-4fed-9605-f20e9598e533" CreationDate="2014-03-18T14:41:03.903" UserId="665" Comment="Typofix of port name" Text="I have an Arduino Mega 2560 with a [libelium XBee Shield][1]. If I have an XBee S2 mounted on it and set the two jumpers to the USB setting or remove them, I am able to flash a program onto my Arduino.&#xD;&#xA;&#xD;&#xA;However, when I'm mounting one of my XBee PRO S2B (I have three of them available and all behave the same) on the Arduino, no matter how I set the jumpers, it is not possible to flash anything on it. I always see `avrdude: stk500v2_getsync(): timeout communicating with programmer` in the Arduino IDE.&#xD;&#xA;&#xD;&#xA;Is the XBee PRO S2B incompatible with the Arduino or what might be the issue? I also tried to add an external power source additionally to the USB, but it didn't help either.&#xD;&#xA;&#xD;&#xA;**Update**&#xD;&#xA;&#xD;&#xA;After some more experimenting, I found out new details. I tried to disconnect each pin of the shield individually. While doing it, I discovered that disconnecting the `reset` pin from the arduino makes it possible to flash it - take a look at the [XBee shield schematic][2], it's pin 5 from the ICSP connector; Photo: ![photo of it][3]&#xD;&#xA;&#xD;&#xA;I used a multimeter and discovered that the XBee PRO S2B CTS / DIO7 port is high, while the one from the XBee S2 is low, and so constantly resetting the arduino. I mounted the XBee PRO S2B onto the [Sparkfun XBee Explorer USB][4] and opened a serial port with PuTTY.&#xD;&#xA;In contrast to the S2, the PRO S2B provides a menu with several options:&#xD;&#xA;&#xD;&#xA;    B-Bypass Mode&#xD;&#xA;    F-Update App&#xD;&#xA;    T-Timeout&#xD;&#xA;    V-BL Version&#xD;&#xA;    A-App Version&#xD;&#xA;    R-Reset&#xD;&#xA;    &gt;&#xD;&#xA;&#xD;&#xA;![Sparkfun XBee Explorer USB, CTS port][5]&#xD;&#xA;&#xD;&#xA;As soon as I type B, the CTS port goes low, and would prevent the arduino from resetting. Also this mode is needed to detect the module via XCTU. However, with an unmodified arduino, I wouldn't have a chance to send this letter, since the XBee is constantly resetting it. What is this menu, can it be disabled somehow?&#xD;&#xA;&#xD;&#xA;(Btw, how about an xbee tag for this site?)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoXbeeShield#.UybqgHVSm4I&#xD;&#xA;  [2]: http://www.arduino.cc/en/uploads/Main/XbeeShieldSchematic.pdf&#xD;&#xA;  [3]: http://i.stack.imgur.com/wgXvG.jpg&#xD;&#xA;  [4]: https://www.sparkfun.com/products/8687&#xD;&#xA;  [5]: http://i.stack.imgur.com/ju3TV.jpg" />
  <row Id="2220" PostHistoryTypeId="6" PostId="784" RevisionGUID="7f545cbd-7976-4022-997b-2d8a1c475746" CreationDate="2014-03-18T15:44:24.163" UserId="65" Comment="edited tags" Text="&lt;programming&gt;" />
  <row Id="2221" PostHistoryTypeId="2" PostId="795" RevisionGUID="29171128-7aa9-4b5c-87db-0a535577770d" CreationDate="2014-03-18T16:09:01.827" UserId="693" Text="I'm completely new with Arduino and microcontrollers in general.&#xD;&#xA;&#xD;&#xA;I have several 5V sensors, and need 3.3V because that's the max for the Due. Is it possible to use a resistor to connect it to the Arduino? Do I have to measure the current from the sensor and calculate the needed resistor like this?&#xD;&#xA;&#xD;&#xA;    $$\frac{5.0 - 3.3}{\text{Measured current}}$$&#xD;&#xA;    (5.0 - 3.3)/(Measured current)" />
  <row Id="2222" PostHistoryTypeId="1" PostId="795" RevisionGUID="29171128-7aa9-4b5c-87db-0a535577770d" CreationDate="2014-03-18T16:09:01.827" UserId="693" Text="How to connect 5V sensors to 3.3V digital input (Due)?" />
  <row Id="2223" PostHistoryTypeId="3" PostId="795" RevisionGUID="29171128-7aa9-4b5c-87db-0a535577770d" CreationDate="2014-03-18T16:09:01.827" UserId="693" Text="&lt;sensors&gt;&lt;arduino-due&gt;" />
  <row Id="2224" PostHistoryTypeId="10" PostId="784" RevisionGUID="65e0ffce-eb39-41c1-a940-66d6460e11b1" CreationDate="2014-03-18T16:13:41.433" UserId="42" Comment="102" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;}]}" />
  <row Id="2225" PostHistoryTypeId="36" PostId="796" RevisionGUID="f3195124-ee9d-47ec-8769-ac2a426939b5" CreationDate="2014-03-18T16:24:19.873" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/103199/is-there-a-transmission-protocol-library-for-spi" />
  <row Id="2226" PostHistoryTypeId="2" PostId="797" RevisionGUID="eba8e0e5-e435-4195-9c14-b0124b5861a9" CreationDate="2014-03-17T20:50:14.800" UserId="875" UserDisplayName="dwelch" Text="Each spi peripheral has its own protocol in the sense of commands and addresses if any and data.  Spi simply makes a common ground for chip select vs clocks and clocks vs data and separate miso and mosi data lines.&#xD;&#xA;&#xD;&#xA;So a general purpose library doesnt make sense.&#xD;&#xA;&#xD;&#xA;Also spi certainly is not limited to a byte, many peripherals and many spi controllers allow for long sequences of data, you are also not strictly limited to multiples of 8 bits either although that is the norm.&#xD;&#xA;&#xD;&#xA;Your arduino spi master may have its limitations but that has nothing to do with spi in general.&#xD;&#xA;&#xD;&#xA;Integrity testing is not part of the spi protocol, you get what you get.  Ideally all of the parts are soldered down on the same board or through known connectors and the margins have been designed in.  You would need to do something outside the spi protocol, for example if it is a spi flash then after you read a chunk of data you can do a checksum and compare it with a checksum you have embedded in the data (or crc).  If it is a spi ethernet part you may choose to leave the frame checksums in the frames and re-validate each frame yourself.  If you create your own peripheral (hardware design or cpld or fpga) then certainly you can add a crc or checksum to every transfer if you wish.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2227" PostHistoryTypeId="2" PostId="796" RevisionGUID="08c37693-f4da-4f55-b644-adf07bbd3174" CreationDate="2014-03-17T13:43:20.593" UserId="693" Text="When communicating over SPI, one byte is sent at a time. Is there a library (C or C++) that allows for sending strings? Essentially it would be a protocol library handling the start and the end of a message, as well as integrity checking. (I'm using an Arduino.)" />
  <row Id="2228" PostHistoryTypeId="1" PostId="796" RevisionGUID="08c37693-f4da-4f55-b644-adf07bbd3174" CreationDate="2014-03-17T13:43:20.593" UserId="693" Text="Is there a transmission protocol library for SPI?" />
  <row Id="2229" PostHistoryTypeId="3" PostId="796" RevisionGUID="08c37693-f4da-4f55-b644-adf07bbd3174" CreationDate="2014-03-17T13:43:20.593" UserId="693" Text="&lt;untagged&gt;" />
  <row Id="2230" PostHistoryTypeId="36" PostId="797" RevisionGUID="7895f0fd-7c3e-4a79-9342-026b3f6fe907" CreationDate="2014-03-18T16:24:19.873" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/103199/is-there-a-transmission-protocol-library-for-spi/103246#103246" />
  <row Id="2231" PostHistoryTypeId="6" PostId="796" RevisionGUID="4dc968fa-0557-4ebb-b685-03e957b7f8fc" CreationDate="2014-03-18T16:27:53.283" UserId="220" Comment="edited tags" Text="&lt;spi&gt;&lt;uart&gt;" />
  <row Id="2235" PostHistoryTypeId="2" PostId="798" RevisionGUID="f1e42252-9d38-4ae7-9e48-cb4fc7253a37" CreationDate="2014-03-18T18:19:29.483" UserId="84" Text="Well if you're not sure of what you're doing, you can always go with **level-converters** for your sensors (that does not apply to shields though)&#xD;&#xA;&#xD;&#xA;Level-converters (sometimes called **level-shifters**) come in different flavors:&#xD;&#xA;&#xD;&#xA;- breakout board (the easiest to work with)&#xD;&#xA;- IC&#xD;&#xA;- DIY circuits with a few components&#xD;&#xA;&#xD;&#xA;Some are &quot;one-way&quot;: they have pin-pairs with converters 3.3V -&gt; 5V, and other pin-pairs with 5V -&gt; 3.3V conversion; others are bi-directional, i.e. you can use the same pair of pins in 2 directions 3.3V &lt;-&gt; 5V.&#xD;&#xA;&#xD;&#xA;There are plenty of these converters, and they are rather cheap; here are just a few examples:&#xD;&#xA;&#xD;&#xA;- [one-way breakout][1] usable with 4 pairs of pins&#xD;&#xA;- [bi-directional breakout][2] usable with 4 pairs of pins&#xD;&#xA;- 74HC4050 IC discussed [here][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sparkfun.com/products/11978&#xD;&#xA;  [2]: https://www.sparkfun.com/products/12009&#xD;&#xA;  [3]: http://forum.arduino.cc/index.php?topic=109493.0" />
  <row Id="2236" PostHistoryTypeId="2" PostId="799" RevisionGUID="032cafe1-1fe5-483a-95d5-6b55db182f3f" CreationDate="2014-03-18T19:01:17.937" UserId="220" Text="&gt; Are there any alternatives to the Optiboot bootloader?&#xD;&#xA;&#xD;&#xA;Err... not really. There's actually **a [unofficial] [modification to Optiboot to make it faster when uploading](http://zygomorphic.com/arduino-tiny/?attachment_id=257).**&#xD;&#xA;&#xD;&#xA;&gt; To install the high baud rate variations…&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Ensure the Arduino IDE is not running&#xD;&#xA;&gt;  - Download the 7-Zip archive using the link above&#xD;&#xA;&gt;  - Extract the three files to the following directory: `{Arduino Installation Root}\hardware\arduino\bootloaders\optiboot\`&#xD;&#xA;&gt;  - Open the boards.txt file located in the following directory: `{Arduino Installation Root}\hardware\arduino\`&#xD;&#xA;&gt; &#xD;&#xA;&gt; Find This section inside it:&#xD;&#xA;&gt; &#xD;&#xA;&gt;     uno.name=Arduino Uno&#xD;&#xA;&gt;     uno.upload.protocol=arduino&#xD;&#xA;&gt;     uno.upload.maximum_size=32256&#xD;&#xA;&gt;     uno.upload.speed=115200&#xD;&#xA;&gt;     uno.bootloader.low_fuses=0xff&#xD;&#xA;&gt;     uno.bootloader.high_fuses=0xde&#xD;&#xA;&gt;     uno.bootloader.extended_fuses=0x05&#xD;&#xA;&gt;     uno.bootloader.path=optiboot&#xD;&#xA;&gt;     uno.bootloader.file=optiboot_atmega328.hex&#xD;&#xA;&gt;     uno.bootloader.unlock_bits=0x3F&#xD;&#xA;&gt;     uno.bootloader.lock_bits=0x0F&#xD;&#xA;&gt;     uno.build.mcu=atmega328p&#xD;&#xA;&gt;     uno.build.f_cpu=16000000L&#xD;&#xA;&gt;     uno.build.core=arduino&#xD;&#xA;&gt;     uno.build.variant=standard&#xD;&#xA;&gt; &#xD;&#xA;&gt; Add the following section…&#xD;&#xA;&gt; &#xD;&#xA;&gt;     uno_uf.name=Arduino Uno / Upload Fast&#xD;&#xA;&gt;     uno_uf.upload.protocol=arduino&#xD;&#xA;&gt;     uno_uf.upload.maximum_size=32256&#xD;&#xA;&gt;     uno_uf.upload.speed=250000&#xD;&#xA;&gt;     uno_uf.bootloader.low_fuses=0xff&#xD;&#xA;&gt;     uno_uf.bootloader.high_fuses=0xde&#xD;&#xA;&gt;     uno_uf.bootloader.extended_fuses=0x05&#xD;&#xA;&gt;     uno_uf.bootloader.path=optiboot&#xD;&#xA;&gt;     uno_uf.bootloader.file=optiboot_atmega328_250000.hex&#xD;&#xA;&gt;     uno_uf.bootloader.unlock_bits=0x3F&#xD;&#xA;&gt;     uno_uf.bootloader.lock_bits=0x0F&#xD;&#xA;&gt;     uno_uf.build.mcu=atmega328p&#xD;&#xA;&gt;     uno_uf.build.f_cpu=16000000L&#xD;&#xA;&gt;     uno_uf.build.core=arduino&#xD;&#xA;&gt;     uno_uf.build.variant=standard&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Change the two highlighted values to the baud rate you plan to use:    250000, 500000, or 1000000 Save and close the boards.txt file&#xD;&#xA;&gt;  - Using your favourite ISP programmer, install the new bootloader. *Don’t forget to: Ensure the Arduino Uno / Upload Fast board is selected (Tools / Board)*, *If appropriate, ensure the Serial Port of&#xD;&#xA;&gt; your programmer is selected (Tools / Serial Port)*, *Ensure the&#xD;&#xA;&gt; programmer is selected (Tools / Programmer)*, *After installing the&#xD;&#xA;&gt; bootloader, change the Serial Port to the serial port of your Arduino&#xD;&#xA;&gt; Uno*.&#xD;&#xA;&#xD;&#xA;Above text slightly modified for compatibility with site. *[Original post](http://zygomorphic.com/arduino-tiny/?page_id=249)*&#xD;&#xA;****&#xD;&#xA;Besides that, and the ATmegaboot bootloader, you can't really find any alternative. I would imagine that if Arduino loads it on all the Unos ever produced, it's pretty optimized. The above hack speeds up upload time, but it doesn't reduce the size of the bootloader. You can also [remove the wait time on the bootloader](http://learn.adafruit.com/arduino-tips-tricks-and-techniques/bootloader) so it has a faster startup.&#xD;&#xA;&#xD;&#xA;If you're that concerned about maximising flash see: *&lt;http://arduino.stackexchange.com/questions/193/how-to-really-shrink-a-sketch&gt;* and [this answer](http://arduino.stackexchange.com/a/222/220) [on on *&lt;http://arduino.stackexchange.com/questions/221/what-can-i-do-if-i-run-out-of-flash-memory-or-sram&gt;*]." />
  <row Id="2237" PostHistoryTypeId="5" PostId="721" RevisionGUID="1c9dc251-ca5a-4ea3-b354-76c871a65871" CreationDate="2014-03-18T19:13:42.283" UserId="441" Comment="Removed &quot;help me find the right site for my question, just in case I asked it on the wrong one&quot; plea." Text="I am trying to build a device that will allow me to control at least a couple hundred raising platforms. The goal of this is to create a real time editor for board games (more precisely Dungeons and Dragons). Ideally all the platforms would move simultaneously and the platforms would be transparent to allow us to place L.E.D.'s inside them to color the platform (this way we can make wood brown, water blue etc). &#xD;&#xA;&#xD;&#xA;On our current setup, we have used acrylic prism 1 inch x 1 inch x 6 inch (width, length, height) and we wanted to use a CNC motor to move around and move the platform. Obviously, this is NOT simultaneous raising at all and had (on paper) quite a long update time (calculated approximately 1 sec per platform).  CNC is the only solution we found that had a reasonable cost/quality (a CNC motor per platform also raised the power consumption very high).After a few weeks of looking around, planning and throwing stupid ideas away, we found  [this](http://www.youtube.com/watch?v=lvtfD_rJ2hE).&#xD;&#xA;&#xD;&#xA;Clearly, WAY better then our idea but I have no idea how he did this. They have 900 and they all work simultaneously; his platforms are much smaller too which could be nice to have but 1 inch ^2 is fine for our use. We also don't want the real time interactive thing. Loading from computer and staying static until we change it is good (though water movement would be really nice). So my question is. &#xD;&#xA;&#xD;&#xA;What would you guys recommend to raise simultaneously a thousand small platforms?&#xD;&#xA;&#xD;&#xA;Also this [document](http://tmg-trackr.media.mit.edu:8020/SuperContainer/RawData/Papers/527-inFORM%20Dynamic%20Physical%20Affordances/Published/PDF) that the devs made. Doing a bit more research I found that the device they used to move the platforms cost approx 30$, I don't think I need to say this, but I don't have 27000$ :(&#xD;&#xA;&#xD;&#xA;Key difference between their implementation and our goal:&#xD;&#xA;&#xD;&#xA; - No real-time interaction with the table. Controlled by and arduino and or a computer is fine.&#xD;&#xA; - Size of the platforms will be closer to 1 inch^2&#xD;&#xA; - All sides of the platform should be light up, but I believe this is mostly a question of choosing the right material&#xD;&#xA;" />
  <row Id="2238" PostHistoryTypeId="24" PostId="721" RevisionGUID="1c9dc251-ca5a-4ea3-b354-76c871a65871" CreationDate="2014-03-18T19:13:42.283" Comment="Proposed by 441 approved by 220 edit id of 241" />
  <row Id="2239" PostHistoryTypeId="5" PostId="721" RevisionGUID="210d4abc-c5b8-4aa1-8c7a-a8dbc017ea56" CreationDate="2014-03-18T19:13:45.990" UserId="220" Comment="deleted 126 characters in body" Text="I am trying to build a device that will allow me to control at least a couple hundred raising platforms. The goal of this is to create a real time editor for board games (*Dungeons and Dragons*).&#xD;&#xA;&#xD;&#xA;Ideally:&#xD;&#xA;&#xD;&#xA; - All the platforms would move simultaneously &#xD;&#xA; - The platforms would be transparent to allow us to place LEDs inside them to color the platform so we can make colors like blue for water and brown for dirt.&#xD;&#xA;&#xD;&#xA;In our current setup, we use some acrylic prisms that are 1 inch x 1 inch x 6 inch (width, length, height). We wanted to use a CNC motor like system to move something around and move a platform. Obviously, this can only raise/lower one item at a time. We calculated (on paper) quite a long update time (calculated approximately 1 sec per platform) to raise/lower a platform. A CNC linear drive type system is the only solution we found that had a reasonable cost/quality (a CNC motor for every platform also raised the power consumption very high). After a few weeks of looking around, planning and throwing stupid ideas away, we found [this](http://www.youtube.com/watch?v=lvtfD_rJ2hE).&#xD;&#xA;&#xD;&#xA;Clearly, it's way better then our idea but I have no idea how they did this. They have 900 platforms and they all work simultaneously. We also don't need real time interaction. Loading from computer and staying static until we change it is good (though water movement would be really nice).&#xD;&#xA;&#xD;&#xA;What would you guys recommend to raise simultaneously a thousand small platforms?&#xD;&#xA;****&#xD;&#xA;After looking at this [document](http://tmg-trackr.media.mit.edu:8020/SuperContainer/RawData/Papers/527-inFORM%20Dynamic%20Physical%20Affordances/Published/PDF) that the devs made, and doing a bit more research I found that the device they used to move the platforms cost approxomently $30; I don't think I need to say this, but I don't have $27,000.&#xD;&#xA;&#xD;&#xA;Key difference between their implementation and our goal:&#xD;&#xA;&#xD;&#xA; - No real-time interaction with the table. Controlled by an Arduino is fine.&#xD;&#xA; - Size of the platforms will be closer to 1 inch^2&#xD;&#xA; - All sides of the platform should be light up, but I believe this is mostly a question of choosing the right material" />
  <row Id="2240" PostHistoryTypeId="2" PostId="800" RevisionGUID="2597807e-9986-4b42-80de-ef6675c9c0c3" CreationDate="2014-03-18T19:53:03.877" UserId="220" Text="" />
  <row Id="2241" PostHistoryTypeId="2" PostId="801" RevisionGUID="ccd045e1-cb1f-4a19-99ff-94c69bfc2b88" CreationDate="2014-03-18T19:53:03.877" UserId="220" Text="Voltage level should be used for questions that are referring to using hardware together that operates on different voltages (the &quot;concentration&quot; of electricity)." />
  <row Id="2242" PostHistoryTypeId="5" PostId="372" RevisionGUID="388f6a66-0906-4ad8-86ed-a2477f0ba688" CreationDate="2014-03-18T19:54:09.993" UserId="220" Comment="added 191 characters in body" Text="LED stands for &quot;Light Emitting Diode&quot; and is a light that is most often used with Arduino. It needs to be connected with a resistor so it (and the Arduino) aren't damaged by too much current." />
  <row Id="2243" PostHistoryTypeId="2" PostId="802" RevisionGUID="416fca35-1625-4bc9-ad78-1d1cfede087a" CreationDate="2014-03-18T19:57:44.630" UserId="220" Text="" />
  <row Id="2244" PostHistoryTypeId="2" PostId="803" RevisionGUID="44f3a849-680b-4616-bf20-8c80da83412e" CreationDate="2014-03-18T19:57:44.630" UserId="220" Text="PROGMEM is a keyword used when declaring a variable that stores the data in flash instead of SRAM. It is part of the `pgmspace.h` library." />
  <row Id="2245" PostHistoryTypeId="5" PostId="16" RevisionGUID="ee9fdf11-21fd-4fcc-850c-9386e36c2dcb" CreationDate="2014-03-18T19:59:26.757" UserId="220" Comment="added 94 characters in body" Text="The Arduino Uno is the most common and one of the newest Arduinos, based on the ATmega328 microcontroller. Use this tag when asking a question specific to an Uno, not just a general Arduino question. Use the &quot;arduino-uno-smd&quot; tag when the question is specific about the SMD version of the Uno." />
  <row Id="2246" PostHistoryTypeId="5" PostId="15" RevisionGUID="4cda8e75-8aac-49df-80e6-0fac0791eac9" CreationDate="2014-03-18T20:00:52.007" UserId="220" Comment="added 355 characters in body" Text="The Arduino Uno is the most common and one of the newest Arduinos, based on the ATmega328 microcontroller. Use this tag when asking a question specific to an Uno, not just a general Arduino question. Use the &quot;arduino-uno-smd&quot; tag when the question is specific about the SMD version of the Uno.&#xD;&#xA;&#xD;&#xA;&gt; The Arduino Uno is a microcontroller board based on the ATmega328. It&#xD;&#xA;&gt; has 14 digital input/output pins (of which 6 can be used as PWM&#xD;&#xA;&gt; outputs), 6 analog inputs, a 16 MHz ceramic resonator, a USB&#xD;&#xA;&gt; connection, a power jack, an ICSP header, and a reset button. It&#xD;&#xA;&gt; contains everything needed to support the microcontroller; simply&#xD;&#xA;&gt; connect it to a computer with a USB cable or power it with a AC-to-DC&#xD;&#xA;&gt; adapter or battery to get started. The Uno differs from all preceding&#xD;&#xA;&gt; boards in that it does not use the FTDI USB-to-serial driver chip.&#xD;&#xA;&gt; Instead, it features the Atmega16U2 (Atmega8U2 up to version R2)&#xD;&#xA;&gt; programmed as a USB-to-serial converter.&#xD;&#xA;&gt; &#xD;&#xA;&gt; Specs:&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Microcontroller: ATmega328&#xD;&#xA;&gt;  - Operating Voltage: 5V&#xD;&#xA;&gt;  - Input Voltage (recommended): 7-12V&#xD;&#xA;&gt;  - Input Voltage (limits): 6-20V&#xD;&#xA;&gt;  - Digital I/O Pins: 14 (of which 6 provide PWM output)&#xD;&#xA;&gt;  - Analog Input Pins: 6&#xD;&#xA;&gt;  - DC Current per I/O Pin: 40 mA&#xD;&#xA;&gt;  - DC Current for 3.3V Pin: 50 mA&#xD;&#xA;&gt;  - Flash Memory: 32 KB (ATmega328) of which 0.5 KB used by bootloader&#xD;&#xA;&gt;  - SRAM: 2 KB (ATmega328)&#xD;&#xA;&gt;  - EEPROM: 1 KB (ATmega328)&#xD;&#xA;&gt;  - Clock Speed: 16 MHz&#xD;&#xA;&#xD;&#xA;From http://arduino.cc/en/Main/ArduinoBoardUno" />
  <row Id="2247" PostHistoryTypeId="5" PostId="381" RevisionGUID="27c05a6c-3427-4cde-a0a0-f85688b15e15" CreationDate="2014-03-18T20:54:27.457" UserId="220" Comment="added 1195 characters in body" Text="&quot;Pins&quot; are like gateways between the Arduino code running on the chip and the components attached to Arduino. It can refer either to the physical connectors on the board, or it can refer to the pins defined in the code.&#xD;&#xA;&#xD;&#xA;There are three main types of pins:&#xD;&#xA;&#xD;&#xA; - A **digital pin** is one that can detect and output a digital signal (i.e. either HIGH or LOW)&#xD;&#xA; - An **analog pin** works mostly like a digital pin, except that each one of them also includes a ADC (analogue to digital converter) which can give the Arduino values of 0 to 1024 that is proportional to the input voltage (i.e. 2.5V on a 5V board is 512).&#xD;&#xA; - A **PWM pin** (pulse width modulation) is a digital pin that can create a signals that goes on and off very fast. This can be used to create a dimming effect. For more questions related to PWM, see [tag:PWM].&#xD;&#xA;&#xD;&#xA;A pin can also refer to the physical *pin header* that you connect wires to. *Connect the wire to the GND pin*.&#xD;&#xA;&#xD;&#xA;&gt; ![Arduino Uno][1]&#xD;&#xA;&#xD;&#xA;*From http://arduino.cc/en/Main/ArduinoBoardUno*&#xD;&#xA;&#xD;&#xA;In the photo above, there are 14 digital pins (six of those are PWM), 6 analog pins, and 12 other pins (GND, 5V, 3.3V, etc.).&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/9bbhn.jpg" />
  <row Id="2248" PostHistoryTypeId="5" PostId="382" RevisionGUID="80549880-87e8-4301-82cb-fccb3bb1dcfe" CreationDate="2014-03-18T20:54:27.457" UserId="220" Comment="edited body" Text="&quot;Pins&quot; are like gateways between the Arduino code running on the chip and the components attached to Arduino. It can refer either to the physical connectors on the board, or it can refer to the pins defined in the code." />
  <row Id="2249" PostHistoryTypeId="2" PostId="804" RevisionGUID="87d810c0-86b3-45fd-b6dd-cacd8dbb8538" CreationDate="2014-03-18T21:01:57.920" UserId="639" Text="I have a [Arduino Nano (Sainsmart)][1] that I'm trying to upload a sketch to. Under the Arduino IDE, the device selected was `Arduino Nano w/ ATmega328`. &#xD;&#xA;&#xD;&#xA;However uploading the sketch gives me the error&#xD;&#xA;&#xD;&#xA;    avrdude: stk500_recv(): programmer is not responding&#xD;&#xA;&#xD;&#xA;I tried the other USB ports but the same error persist. The Arduino is connected to a Macbook Air via the USB cable, and the LED indicator lights on the Arduino are turned on. There was no problem uploading to a Arduino Uno.&#xD;&#xA;&#xD;&#xA;What could have gone wrong?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.amazon.com/SainSmart-Nano-v3-0-Compatible-Arduino/dp/B00761NDHI/" />
  <row Id="2250" PostHistoryTypeId="1" PostId="804" RevisionGUID="87d810c0-86b3-45fd-b6dd-cacd8dbb8538" CreationDate="2014-03-18T21:01:57.920" UserId="639" Text="Arduino Nano uploading gives error: avrdude: stk500_recv(): programmer is not responding" />
  <row Id="2251" PostHistoryTypeId="3" PostId="804" RevisionGUID="87d810c0-86b3-45fd-b6dd-cacd8dbb8538" CreationDate="2014-03-18T21:01:57.920" UserId="639" Text="&lt;programming&gt;&lt;serial&gt;&lt;uploading&gt;&lt;sketch&gt;&lt;arduino-nano&gt;" />
  <row Id="2252" PostHistoryTypeId="5" PostId="373" RevisionGUID="db7d2e03-22a0-4af0-a56c-87aac618b017" CreationDate="2014-03-18T21:07:05.250" UserId="220" Comment="added 2001 characters in body" Text="Serial communication is the standard USB connection between the Arduino and a computer with a standard USB A to B cable or through the TX/RX pins using a USB to serial converter. It can also refer to the serial library.&#xD;&#xA;&#xD;&#xA;&gt; [Serial is] used for communication between the Arduino board and a computer or other devices. All Arduino boards have at least one serial port (also known as a UART or USART): Serial. It communicates on digital pins 0 (RX) and 1 (TX) as well as with the computer via USB. Thus, if you use these functions, you cannot also use pins 0 and 1 for digital input or output.&#xD;&#xA;You can use the Arduino environment's built-in serial monitor to communicate with an Arduino board. Click the serial monitor button in the toolbar and select the same baud rate used in the call to begin().&#xD;&#xA;&#xD;&#xA;*Excerpt from the [Arduino Page about Serial](http://arduino.cc/en/reference/serial).*&#xD;&#xA;&#xD;&#xA;**Most boards have only one serial port.** Exceptions:&#xD;&#xA;&#xD;&#xA; - Leonardo has two: one connected to USB and the other connected to pins 0 and 1 for connection to UART items.&#xD;&#xA; - The Mega/Mega2560 has 4 serial ports, one connected to a UART to USB converter.&#xD;&#xA; - The DUE also has 4 serial ports, one connected to a UART to USB converter.&#xD;&#xA;&#xD;&#xA;The serial is outputted through *UART*. Then, for the primary serial connection on pins 0 and 1*, the data goes to a UART to serial chip** and then transferred to/from the computer.&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;*On some boards, such as the Leonardo, it doesn't use the pins 0 and 1.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;**On some boards, such as the Leonardo, there is no USB chip because it is built into the chip itself, or it has no USB connection.&lt;/sub&gt;&#xD;&#xA;****&#xD;&#xA;**The serial library:**&#xD;&#xA;&#xD;&#xA;Arduino includes [a library for inferencing with the serial ports](http://arduino.cc/en/reference/serial). Here is some example code:&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      // open the serial port at 9600 bps:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      Serial.println(&quot;Hello World!&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;    }" />
  <row Id="2253" PostHistoryTypeId="5" PostId="374" RevisionGUID="98a3f189-3be8-45a7-aadc-35ca55e1c9aa" CreationDate="2014-03-18T21:07:05.250" UserId="220" Comment="added 41 characters in body" Text="Serial communication is the standard USB connection between the Arduino and a computer with a standard USB A to B cable or through the TX/RX pins using a USB to serial converter. It can also refer to the serial library." />
  <row Id="2254" PostHistoryTypeId="5" PostId="15" RevisionGUID="d33737b1-aba3-4ba9-b47b-1635ad04b200" CreationDate="2014-03-18T21:08:34.720" UserId="220" Comment="added 74 characters in body" Text="The Arduino Uno is the most common and one of the newest Arduinos, based on the ATmega328 microcontroller. Use this tag when asking a question specific to an Uno, not just a general Arduino question. Use the &quot;arduino-uno-smd&quot; tag when the question is specific about the SMD version of the Uno.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&gt; ![Arduino Uno][1]&#xD;&#xA;&gt; The Arduino Uno is a microcontroller board based on the ATmega328. It&#xD;&#xA;&gt; has 14 digital input/output pins (of which 6 can be used as PWM&#xD;&#xA;&gt; outputs), 6 analog inputs, a 16 MHz ceramic resonator, a USB&#xD;&#xA;&gt; connection, a power jack, an ICSP header, and a reset button. It&#xD;&#xA;&gt; contains everything needed to support the microcontroller; simply&#xD;&#xA;&gt; connect it to a computer with a USB cable or power it with a AC-to-DC&#xD;&#xA;&gt; adapter or battery to get started. The Uno differs from all preceding&#xD;&#xA;&gt; boards in that it does not use the FTDI USB-to-serial driver chip.&#xD;&#xA;&gt; Instead, it features the Atmega16U2 (Atmega8U2 up to version R2)&#xD;&#xA;&gt; programmed as a USB-to-serial converter.&#xD;&#xA;&gt; &#xD;&#xA;&gt; Specs:&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Microcontroller: ATmega328&#xD;&#xA;&gt;  - Operating Voltage: 5V&#xD;&#xA;&gt;  - Input Voltage (recommended): 7-12V&#xD;&#xA;&gt;  - Input Voltage (limits): 6-20V&#xD;&#xA;&gt;  - Digital I/O Pins: 14 (of which 6 provide PWM output)&#xD;&#xA;&gt;  - Analog Input Pins: 6&#xD;&#xA;&gt;  - DC Current per I/O Pin: 40 mA&#xD;&#xA;&gt;  - DC Current for 3.3V Pin: 50 mA&#xD;&#xA;&gt;  - Flash Memory: 32 KB (ATmega328) of which 0.5 KB used by bootloader&#xD;&#xA;&gt;  - SRAM: 2 KB (ATmega328)&#xD;&#xA;&gt;  - EEPROM: 1 KB (ATmega328)&#xD;&#xA;&gt;  - Clock Speed: 16 MHz&#xD;&#xA;&#xD;&#xA;From *&lt;http://arduino.cc/en/Main/ArduinoBoardUno&gt;*&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/OuoAD.jpg" />
  <row Id="2255" PostHistoryTypeId="5" PostId="314" RevisionGUID="45f229d9-9f3f-44e5-a9ec-2d79d95cca73" CreationDate="2014-03-18T21:12:33.900" UserId="220" Comment="added 253 characters in body" Text="Use this tag for questions regarding programming (writing code) for Arduino. This can include problems with code you've written for Arduino, or questions about how/why Arduino code acts in certain ways.&#xD;&#xA;&#xD;&#xA;Where a question relates to a particular language, you can also use language-specific tags, such as [tag:c++].&#xD;&#xA;&#xD;&#xA;Programming questions which are not specific to Arduino (e.g. general questions about a programming language) should be asked on [**Stack Overflow**](http://www.stackoverflow.com) instead.&#xD;&#xA;&#xD;&#xA;For questions regarding uploading sketches to Arduino devices, please use the [tag:uploading] tag.&#xD;&#xA;&#xD;&#xA;**Note:** With this tag, [syntax highlighting](http://en.wikipedia.org/wiki/Syntax_highlighting) will be enabled. See **[the syntax highlighting help section](http://arduino.stackexchange.com/editing-help#syntax-highlighting)** for more information." />
  <row Id="2256" PostHistoryTypeId="5" PostId="315" RevisionGUID="2e81369c-3c11-4c18-a735-553221c3e01e" CreationDate="2014-03-18T21:12:33.900" UserId="220" Comment="added 46 characters in body" Text="The process of designing and writing source code as part of a program (or sketch) for Arduino. Do not use for uploading to an Arduino board." />
  <row Id="2257" PostHistoryTypeId="5" PostId="804" RevisionGUID="cc12bafa-04a6-49d9-bfbc-bf4451047a0c" CreationDate="2014-03-18T21:17:55.650" UserId="639" Comment="added 195 characters in body" Text="I have a [Arduino Nano (Sainsmart)][1] that I'm trying to upload a sketch to. Under the Arduino IDE, the device selected was `Arduino Nano w/ ATmega328`. &#xD;&#xA;&#xD;&#xA;However uploading the sketch gives me the error&#xD;&#xA;&#xD;&#xA;    avrdude: stk500_recv(): programmer is not responding&#xD;&#xA;&#xD;&#xA;I tried the other USB ports but the same error persist. The Arduino is connected to a Macbook Air via the USB cable, and the LED indicator lights on the Arduino are turned on. There was no problem uploading to a Arduino Uno.&#xD;&#xA;&#xD;&#xA;Retried after installing the latest FTDI drivers (MAC OSX, x64, v2.2.18, FTDIUSBSerialDriver_10_4_10_5_10_6_10_7.mpkg) from http://www.ftdichip.com/Drivers/VCP.htm. However that did not help.&#xD;&#xA;&#xD;&#xA;What could have gone wrong?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.amazon.com/SainSmart-Nano-v3-0-Compatible-Arduino/dp/B00761NDHI/" />
  <row Id="2258" PostHistoryTypeId="5" PostId="514" RevisionGUID="2e1e458b-b45a-40b9-b62d-a4f0dc6d7545" CreationDate="2014-03-18T21:20:48.667" UserId="220" Comment="added 646 characters in body" Text="A sensor is a converter that measures a physical quantity and converts it into an analog or digital signal which can be read by an Arduino. Use this tag for questions about selecting, connecting, using, and debugging sensors.&#xD;&#xA;&#xD;&#xA;**Some of the most common types of sensors:**&#xD;&#xA;&#xD;&#xA; - **[Temperature sensor](http://learn.adafruit.com/tmp36-temperature-sensor)**&#xD;&#xA; - **[Button](http://arduino.cc/en/tutorial/button)**&#xD;&#xA;  &lt;img src=&quot;http://arduino.cc/en/uploads/Tutorial/button.png&quot; &gt;&#xD;&#xA; - **Light sensor** (Used in *[this tutorial](http://arduino.cc/en/Tutorial/Calibration)*.)&#xD;&#xA;  &lt;img src=&quot;http://arduino.cc/en/uploads/Tutorial/calibration.png&quot; &gt;&#xD;&#xA; - **[Potentiometer](http://www.arduino.cc/en/Tutorial/Potentiometer)**&#xD;&#xA;&#xD;&#xA; &lt;img src=&quot;http://arduino.cc/en/uploads/Tutorial/potentiometer.jpg&quot; &gt;" />
  <row Id="2259" PostHistoryTypeId="5" PostId="385" RevisionGUID="41b9c2da-3aeb-4100-a89a-9682c10a0bf6" CreationDate="2014-03-18T21:25:09.593" UserId="220" Comment="added 708 characters in body" Text="The safety tag is for the well-being of the people and objects around you, and yourself.&#xD;&#xA;&#xD;&#xA;**Some general precautions for your Arduino:**&#xD;&#xA;&#xD;&#xA; - Don't under/over power your Arduino&#xD;&#xA; - Don't pull more than 40 mA on most boards from one digital pin&#xD;&#xA; - Don't apply more than 5V to any pin (except VIN)&#xD;&#xA; - Don't change a circuit while the Arduino is powered&#xD;&#xA;&#xD;&#xA;**Some general precautions for you/the people around you:**&#xD;&#xA;&#xD;&#xA; - Don't apply mains to your Arduino.&#xD;&#xA; - When powering high voltages with a relay, make sure to cover and seal any wires that might be connected to the high voltages.&#xD;&#xA; - Arduino not to be used as a flotation device. Really, don't get your Arduino or any other part of your setup wet." />
  <row Id="2260" PostHistoryTypeId="5" PostId="284" RevisionGUID="daa792e8-3976-4ce1-a6e7-7387e2f6c540" CreationDate="2014-03-18T21:29:27.993" UserId="220" Comment="added 590 characters in body" Text="This tag is for questions regarding powering and/or power consumption of Arduino systems.  &#xD;&#xA;&#xD;&#xA;**The most common ways to power an Arduino:**&#xD;&#xA;&#xD;&#xA; - **[Wall-wart](http://en.wikipedia.org/wiki/Wall_wart)**&#xD;&#xA;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/7/7f/Wall-Wart-AC-Adapter.jpg&quot; &gt;&#xD;&#xA; - **Battery** (with some sort of external circuitry for making sure the voltage is correct.) This is also used sometimes in conjunction with solar panels to act as a &quot;buffer.&quot;&#xD;&#xA; - **USB** is often used for small projects that are on the breadboard and don't require much power (no motors, etc.)." />
  <row Id="2261" PostHistoryTypeId="5" PostId="285" RevisionGUID="e338be3d-de67-481e-bdde-acfa8f9a0cde" CreationDate="2014-03-18T21:29:27.993" UserId="220" Comment="edited body" Text="This tag is for questions regarding powering and/or power consumption of Arduino systems.  " />
  <row Id="2262" PostHistoryTypeId="5" PostId="804" RevisionGUID="c117e7c2-d4a6-4d13-a65f-e02c4c50d656" CreationDate="2014-03-18T21:33:24.327" UserId="639" Comment="added 37 characters in body" Text="I have a [Arduino Nano (Sainsmart)][1] that I'm trying to upload a sketch to. Under the Arduino IDE, the device selected was `Arduino Nano w/ ATmega328`. &#xD;&#xA;&#xD;&#xA;However uploading the sketch gives me the error&#xD;&#xA;&#xD;&#xA;    avrdude: stk500_recv(): programmer is not responding&#xD;&#xA;&#xD;&#xA;I tried both USB ports (`/dev/tty.usbserial` &amp; `/dev/cu.usbserial`) but the same error persist. The Arduino is connected to a Macbook Air via the USB cable, and the `PWR` LED indicator light on the Arduino is turned on and the `L` indicator LED blinks. There was no problem uploading to a Arduino Uno.&#xD;&#xA;&#xD;&#xA;Retried after installing the latest FTDI drivers (MAC OSX, x64, v2.2.18, FTDIUSBSerialDriver_10_4_10_5_10_6_10_7.mpkg) from http://www.ftdichip.com/Drivers/VCP.htm. However that did not help.&#xD;&#xA;&#xD;&#xA;What could have gone wrong?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.amazon.com/SainSmart-Nano-v3-0-Compatible-Arduino/dp/B00761NDHI/" />
  <row Id="2263" PostHistoryTypeId="5" PostId="383" RevisionGUID="29704022-70af-4e2d-902e-7638be8147de" CreationDate="2014-03-18T21:36:49.553" UserId="220" Comment="added 5025 characters in body" Text="A library is a file that can be included into the code to add new instructions by combining many existing instructions and creating one easy to use instruction to call.&#xD;&#xA;&#xD;&#xA;**Here is the list of libraries:**&#xD;&#xA;&#xD;&#xA;*http://arduino.cc/en/Reference/Libraries*&#xD;&#xA;&gt; ## Standard Libraries:&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - EEPROM - reading and writing to &quot;permanent&quot; storage&#xD;&#xA;&gt;  - Ethernet - for connecting to the internet using the Arduino Ethernet    Shield&#xD;&#xA;&gt;  - Firmata - for communicating with applications on the computer using a    standard serial protocol.&#xD;&#xA;&gt;  - GSM - for connecting to a GSM/GRPS network with the GSM shield.&#xD;&#xA;&gt;  - LiquidCrystal - for controlling liquid crystal displays (LCDs)&#xD;&#xA;&gt;  - SD - for reading and writing SD cards&#xD;&#xA;&gt;  - Servo - for controlling servo motors&#xD;&#xA;&gt;  - SPI - for communicating with devices using the Serial Peripheral    Interface (SPI) Bus&#xD;&#xA;&gt;  - SoftwareSerial - for serial communication on any digital pins.    Version 1.0 and later of Arduino incorporate Mikal Hart's   &#xD;&#xA;&gt; NewSoftSerial library as SoftwareSerial.&#xD;&#xA;&gt;  - Stepper - for controlling stepper motors&#xD;&#xA;&gt;  - TFT - for drawing text , images, and shapes on the Arduino TFT screen&#xD;&#xA;&gt;  - WiFi - for connecting to the internet using the Arduino WiFi shield&#xD;&#xA;&gt;  - Wire - Two Wire Interface (TWI/I2C) for sending and receiving data    over a net of devices or sensors.&#xD;&#xA;&gt;  - The Matrix and Sprite libraries are no longer part of the core    distribution.&#xD;&#xA;&gt; &#xD;&#xA;&gt; ## Due Only Libraries:&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Audio - Play audio files from a SD card.&#xD;&#xA;&gt;  - Scheduler - Manage multiple non-blocking tasks.&#xD;&#xA;&gt;  - USBHost - Communicate with USB peripherals like mice and keyboards.&#xD;&#xA;&gt; &#xD;&#xA;&gt; ## Esplora Only Libraries:&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Esplora - this library enable you to easily access to various sensors    and actuators mounted on the Esplora board.&#xD;&#xA;&gt; &#xD;&#xA;&gt; ## Arduino Robot Library:&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Robot - this library enables easy access to the functions of the    Arduino Robot&#xD;&#xA;&gt; &#xD;&#xA;&gt; ## Arduino Yún Bridge Library:&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Bridge Library - Enables communication between the Linux processor    and the Arduino on the Yún.&#xD;&#xA;&gt; &#xD;&#xA;&gt; ## USB Libraries (Leonardo, Micro, Due, and Esplora)&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Keyboard - Send keystrokes to an attached computer.&#xD;&#xA;&gt;  - Mouse - Control cursor movement on a connected computer.&#xD;&#xA;&gt; &#xD;&#xA;&gt; ## Contributed Libraries&#xD;&#xA;&gt; &#xD;&#xA;&gt; If you're using one of these libraries, you need to install it first.&#xD;&#xA;&gt; See these instructions for details on installation. There's also a&#xD;&#xA;&gt; tutorial on writing your own libraries.&#xD;&#xA;&gt; &#xD;&#xA;&gt; **Communication (networking and protocols):**&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Messenger - for processing text-based messages from the computer&#xD;&#xA;&gt;  - NewSoftSerial - an improved version of the SoftwareSerial library&#xD;&#xA;&gt;  - OneWire - control devices (from Dallas Semiconductor) that use the    One Wire protocol.&#xD;&#xA;&gt;  - PS2Keyboard - read characters from a PS2 keyboard.&#xD;&#xA;&gt;  - Simple Message System - send messages between Arduino and the    computer&#xD;&#xA;&gt;  - SSerial2Mobile - send text messages or emails using a cell phone (via    AT commands over software serial)&#xD;&#xA;&gt;  - Webduino - extensible web server library (for use with the Arduino    Ethernet Shield)&#xD;&#xA;&gt;  - X10 - Sending X10 signals over AC power lines&#xD;&#xA;&gt;  - XBee - for communicating with XBees in API mode&#xD;&#xA;&gt;  - SerialControl - Remote control other Arduinos over a serial    connection&#xD;&#xA;&gt; &#xD;&#xA;&gt; **Sensing:**&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Capacitive Sensing - turn two or more pins into capacitive sensors&#xD;&#xA;&gt;  - Debounce - for reading noisy digital inputs (e.g. from buttons)&#xD;&#xA;&gt; &#xD;&#xA;&gt; **Displays and LEDs:**&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - GFX - base class with standard graphics routines (by Adafruit    Industries)&#xD;&#xA;&gt;  - GLCD - graphics routines for LCD based on the KS0108 or equivalent    chipset.&#xD;&#xA;&gt;  - Improved LCD library fixes LCD initialization bugs in official    Arduino LCD library&#xD;&#xA;&gt;  - LedControl - for controlling LED matrices or seven-segment displays    with a MAX7221 or MAX7219.&#xD;&#xA;&gt;  - LedControl - an alternative to the Matrix library for driving    multiple LEDs with Maxim chips.&#xD;&#xA;&gt;  - LedDisplay - control of a HCMS-29xx scrolling LED display.&#xD;&#xA;&gt;  - Matrix - Basic LED Matrix display manipulation library&#xD;&#xA;&gt;  - PCD8544 - for the LCD controller on Nokia 55100-like displays (by    Adafruit Industries)&#xD;&#xA;&gt;  - Sprite - Basic image sprite manipulation library for use in    animations with an LED matrix&#xD;&#xA;&gt;  - ST7735 - for the LCD controller on a 1.8&quot;, 128x160 TFT screen (by    Adafruit Industries)&#xD;&#xA;&gt; &#xD;&#xA;&gt; **Audio and Waveforms:** FFT - frequency analysis of audio or other analog signals Tone - generate audio frequency square waves in the&#xD;&#xA;&gt; background on any microcontroller pin Motors and PWM: TLC5940 - 16&#xD;&#xA;&gt; channel 12 bit PWM controller.&#xD;&#xA;&gt; &#xD;&#xA;&gt; **Timing:**&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - DateTime - a library for keeping track of the current date and time    in software.&#xD;&#xA;&gt;  - Metro - help you time actions at regular intervals&#xD;&#xA;&gt;  - MsTimer2 - uses the timer 2 interrupt to trigger an action every N    milliseconds.&#xD;&#xA;&gt; &#xD;&#xA;&gt; **Utilities:**&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - PString - a lightweight class for printing to buffers&#xD;&#xA;&gt;  - Streaming - a method to simplify print statements" />
  <row Id="2264" PostHistoryTypeId="5" PostId="111" RevisionGUID="4ebb52c1-74da-436a-b9df-bd8417d6f1c3" CreationDate="2014-03-18T21:43:31.643" UserId="220" Comment="added 1195 characters in body" Text="Uploading is the process of updating or changing the sketch on the Arduino board. It does not refer to uploading to a server or a website.&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/ArduinoUnoB.jpg/799px-ArduinoUnoB.jpg&quot; &gt;&#xD;&#xA;*http://commons.wikimedia.org/wiki/File:ArduinoUnoB.jpg*&#xD;&#xA;&#xD;&#xA;&gt; ##Upload process:&#xD;&#xA;&gt; &#xD;&#xA;&gt; Sketches are uploaded by avrdude. The upload process is also&#xD;&#xA;&gt; controlled by variables in the boards and main preferences files.&#xD;&#xA;&gt; Those in the boards file include: &lt;BOARD&gt;.upload.protocol: the&#xD;&#xA;&gt; protocol that avrdude should use to talk to the board (typically&#xD;&#xA;&gt; &quot;stk500&quot;). &lt;BOARD&gt;.upload.speed: the speed (baud rate) avrdude should&#xD;&#xA;&gt; use when uploading sketches (typically &quot;19200&quot;).&#xD;&#xA;&gt; &lt;BOARD&gt;.upload.maximum_size: the maximum size for a sketch on the&#xD;&#xA;&gt; board (dependent on the chip and the size of the bootloader). And in&#xD;&#xA;&gt; the main preferences file: upload.verbose: whether or not to dump&#xD;&#xA;&gt; debugging messages while upload a sketch to a board (defaults to&#xD;&#xA;&gt; &quot;false&quot;).&#xD;&#xA;&#xD;&#xA;*http://arduino.cc/en/Hacking/BuildProcess*&#xD;&#xA;&#xD;&#xA;Once the code is transferred to the board, then [if the board has auto-reset], the board will reset and the sketch will be ran." />
  <row Id="2265" PostHistoryTypeId="2" PostId="805" RevisionGUID="00c6f578-5ace-49cc-b3fc-f80a641b0417" CreationDate="2014-03-18T21:44:41.960" UserId="497" Text="First thing to try: &#xD;&#xA;&#xD;&#xA;Connect a 2.2k - 10k resistor from the arduino RX pin (the hc-05 tx pin) to ground.  &#xD;&#xA;&#xD;&#xA;If that didn't work, I recommend getting everything into a known state and eliminating some complexity. So, first let's remove the Android software from the equation.  And second, let's put the module into a known baud rate.&#xD;&#xA;&#xD;&#xA;To do this wire up the arduino and module like this:![schematic][1]&#xD;&#xA;&#xD;&#xA;Notice that the Key pin is connected to 3.3v.  That will ensure the module is at 38400 baud on power up.&#xD;&#xA;&#xD;&#xA;Connect the arduino to your computer with the FTDI cable.  Upload the following sketch:&#xD;&#xA;&#xD;&#xA;    /* Serial Loop */&#xD;&#xA;&#xD;&#xA;    #include &lt;SoftwareSerial.h&gt;&#xD;&#xA;&#xD;&#xA;    #define rxPin 8&#xD;&#xA;    #define txPin 9&#xD;&#xA;&#xD;&#xA;    SoftwareSerial mySerial(rxPin, txPin); // RX, TX&#xD;&#xA;    char myChar ;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);   &#xD;&#xA;      Serial.println(&quot;AT&quot;);&#xD;&#xA;&#xD;&#xA;      mySerial.begin(38400);&#xD;&#xA;      mySerial.println(&quot;AT&quot;);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      while (mySerial.available()) {&#xD;&#xA;        myChar = mySerial.read();&#xD;&#xA;        Serial.print(myChar);&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      while (Serial.available()) {&#xD;&#xA;        myChar = Serial.read();&#xD;&#xA;        Serial.print(myChar); //echo&#xD;&#xA;        mySerial.print(myChar);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;With the sketch now uploaded and running, open the Arduino serial console and enter these AT commands. The serial console baud rate should be set to 9600 and line endings should be &quot;Both NL &amp; CR&quot;&#xD;&#xA;    &#xD;&#xA;    AT+ORGL //back to factory settings&#xD;&#xA;    AT+ROLE=0 //slave role - transparent serial bridge&#xD;&#xA;    AT+UART=9600,0,0 //default baud rate&#xD;&#xA;    AT+INIT //init module&#xD;&#xA;&#xD;&#xA;You should get &quot;OK&quot; back from the module after each command. If you've gotten this far, we know the module is working fine and we know what baud rate it will default to now.  &#xD;&#xA;&#xD;&#xA;Hook the module back up the way you had it before.  Make sure 3.3v is disconnected from key pin and make sure you have added the pulldown resistor on the RX line. Cycle the power to the module. The module should start up running 9600 baud, slave mode. Delete the module from the Android pairing list and re-pair it.  The name probably will have changed.  Hopefully it works correctly now.&#xD;&#xA;&#xD;&#xA;Cheers&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/4zcck.png" />
  <row Id="2266" PostHistoryTypeId="12" PostId="805" RevisionGUID="84023c75-7a78-453f-83aa-9fc671af72c4" CreationDate="2014-03-18T21:45:11.493" UserId="497" Comment="via Vote" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:497,&quot;DisplayName&quot;:&quot;imjosh&quot;}]}" />
  <row Id="2267" PostHistoryTypeId="13" PostId="805" RevisionGUID="23ef225a-99b0-421e-b6a5-1aaaffa393e2" CreationDate="2014-03-18T21:46:13.013" UserId="497" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:497,&quot;DisplayName&quot;:&quot;imjosh&quot;}]}" />
  <row Id="2268" PostHistoryTypeId="5" PostId="257" RevisionGUID="f31f7f72-618b-4615-b35f-8f3a9c00eba1" CreationDate="2014-03-18T21:49:54.467" UserId="220" Comment="added 1732 characters in body" Text="The arduino DUE is different than most arduino cards on the marked since it runs at 3.3V. &#xD;&#xA;&#xD;&#xA;&gt; The Arduino Due is a microcontroller board based on the Atmel SAM3X8E ARM Cortex-M3 CPU. It is the first Arduino board based on a 32-bit ARM core microcontroller. It has 54 digital input/output pins (of which 12 can be used as PWM outputs), 12 analog inputs, 4 UARTs (hardware serial ports), a 84 MHz clock, an USB OTG capable connection, 2 DAC (digital to analog), 2 TWI, a power jack, an SPI header, a JTAG header, a reset button and an erase button.&#xD;&#xA;&#xD;&#xA;&gt; **Warning:** Unlike other Arduino boards, the Arduino Due board runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Providing higher voltages, like 5V to an I/O pin could damage the board.&#xD;&#xA;&#xD;&#xA;&gt;The board contains everything needed to support the microcontroller; simply connect it to a computer with a micro-USB cable or power it with a AC-to-DC adapter or battery to get started. The Due is compatible with all Arduino shields that work at 3.3V and are compliant with the 1.0 Arduino pinout.&#xD;&#xA;The Due follows the 1.0 pinout:&#xD;&#xA;TWI: SDA and SCL pins that are near to the AREF pin.&#xD;&#xA;The IOREF pin which allows an attached shield with the proper configuration to adapt to the voltage provided by the board. This enables shield compatibility with a 3.3V board like the Due and AVR-based boards which operate at 5V.&#xD;&#xA;An unconnected pin, reserved for future use.&#xD;&#xA;&lt;img src=&quot;http://arduino.cc/en/uploads/Main/ArduinoDue_Front_450px.jpg&quot; &gt;&#xD;&#xA;&#xD;&#xA;[Full specs and information](http://arduino.cc/en/Main/arduinoBoardDue#.UwFH6vbzT1o).&#xD;&#xA;****&#xD;&#xA;**Other features:**&#xD;&#xA;&#xD;&#xA; - 32 bit microcontroller: 4 byte wide instructions during one CPU cycle. When handling large amounts of data, this should&#xD;&#xA; - 84 Mhz microcontroller (Uno is 16 Mhz on a less efficient architecture.)&#xD;&#xA; - 96KB SRAM&#xD;&#xA; - 512KB flash&#xD;&#xA;&#xD;&#xA;This gives it much more power than a standard ATmega chip." />
  <row Id="2269" PostHistoryTypeId="5" PostId="389" RevisionGUID="4143f8e8-4d85-4cfc-b3dd-a5cf16d80da6" CreationDate="2014-03-18T21:54:48.253" UserId="220" Comment="added 611 characters in body" Text="Shields are attachments that &quot;snap&quot; onto the Arduino board adding functionality. They are usually the same shape as an Uno/Leonardo/Duemilanove. Some examples are: the Ethernet (includes SD port) shield, motor shields, and sensor shields.&#xD;&#xA;&#xD;&#xA;**Some of the official shields:**&#xD;&#xA;&#xD;&#xA; - **[GSM][1]** (cell connectivity)&#xD;&#xA; - **[Ethernet][2]**&#xD;&#xA;&lt;img src=&quot;http://arduino.cc/en/uploads/Main/ArduinoEthernetShield_R3_Front.jpg&quot; &gt;&#xD;&#xA; - **[Motor Shield][3]**&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoGSMShield&#xD;&#xA;  [2]: http://arduino.cc/en/Main/ArduinoEthernetShield&#xD;&#xA;  [3]: http://arduino.cc/en/Main/ArduinoMotorShieldR3" />
  <row Id="2270" PostHistoryTypeId="5" PostId="516" RevisionGUID="de8ca480-8a83-4543-aa06-29a61a84ded8" CreationDate="2014-03-18T22:04:54.080" UserId="220" Comment="added 488 characters in body" Text="This tag is for questions about the official **[Arduino IDE][1]**. This open-source IDE makes it easy to write code/sketches and upload it/them to any Arduino board. The IDE runs on Windows, Mac OS X and Linux.&#xD;&#xA;&#xD;&#xA;Virtually all beginner tutorials use the Arduino IDE. You can write the code, select the correct COM port, and then click &quot;upload.&quot; Other IDEs may require more configuration and not be as user friendly. It is available as a standalone application or installer on Windows.&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/en/d/d9/Arduino_1.0_IDE%2C_Ubuntu_11.10.png&quot; &gt;&#xD;&#xA;&#xD;&#xA;*[Arduino IDE running on Ubuntu Linux](http://en.wikipedia.org/wiki/File:Arduino_1.0_IDE,_Ubuntu_11.10.png).*&#xD;&#xA;&#xD;&#xA;For more information about &lt;b&gt;I&lt;/b&gt;ntegrated &lt;b&gt;D&lt;/b&gt;evelopment &lt;b&gt;E&lt;/b&gt;nvironments in general, see the [tag:ide] tag.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/main/software" />
  <row Id="2271" PostHistoryTypeId="2" PostId="806" RevisionGUID="c3526df3-1a68-48ef-a76f-2f44247a4556" CreationDate="2014-03-18T22:05:09.317" UserId="353" Text="This error message basically shows up for any communication problem, so by itself, it is not all that instructive. The Arduino Nano is supposed to have auto-reset, but maybe your clone does not? In that case, you'd have to press the reset key on the board just before starting an upload.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2272" PostHistoryTypeId="5" PostId="425" RevisionGUID="c4cfc749-d4e5-4a01-9134-a16babcd5bde" CreationDate="2014-03-18T22:09:09.277" UserId="220" Comment="added 724 characters in body" Text="Linux is an open source operating system (OS) that is lightweight and runs on many systems. It also runs on the Arduino Yún. There are different &quot;flavors&quot; or &quot;distros&quot; (distributions and changes made by different groups) of Linux such as Ubuntu, Debian, and Fedora. All versions of Linux use the Linux *Kernel* as the base of the OS. The kernel was released in late 1991.&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/4/40/Ubuntu_13.10_release.png/800px-Ubuntu_13.10_release.png&quot; &gt;&#xD;&#xA;*[Screenshot of Ubuntu, a popular distro](http://en.wikipedia.org/wiki/File:Ubuntu_13.10_release.png).*&#xD;&#xA;&#xD;&#xA;The Y&amp;uacute;n runs a port of Linux called *Open WRT* that is designed for routers and other networking appliances." />
  <row Id="2273" PostHistoryTypeId="5" PostId="375" RevisionGUID="e83d9da8-6b8d-4651-9860-cc8eeddba8dc" CreationDate="2014-03-18T22:15:31.890" UserId="220" Comment="added 1150 characters in body" Text="A clone is a legal, Arduino-like board developed by a third party using the original schematics for the board (with a few minor adjustments). If significant changes are made, it is called a derivative.&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://i.imgur.com/qgJGS5w.png&quot; &gt;&#xD;&#xA;&#xD;&#xA;**All Arduino clones follow the [naming guidelines](http://arduino.cc/en/Main/FAQ):**&#xD;&#xA;&#xD;&#xA;&gt; While unofficial products should not have &quot;Arduino&quot; in their name, it's okay to describe your product in relation to the Arduino project and platform. Here are a few guidelines that explain which uses we consider reasonable. Not okay:&#xD;&#xA;&#xD;&#xA;&gt;  - Arduino Xxxxxx&#xD;&#xA;&gt;  - Xxxxxx Arduino&#xD;&#xA;&gt;  - Arduino Compatible Xxxxxx - use &quot;Xxxxxx (Arduino-Compatible)&quot; instead&#xD;&#xA;&#xD;&#xA;&gt; Okay:&#xD;&#xA;&#xD;&#xA;&gt;  - Xxxxxx for Arduino - products that work with official Arduino boards (e.g. shields or kits)&#xD;&#xA;&gt;  - Xxxxxx (Arduino-Compatible) - variations and clones which are software and hardware compatible Note that while we don't attempt to&#xD;&#xA;&gt; restrict uses of the &quot;duino&quot; suffix, its use causes the Italians on&#xD;&#xA;&gt; the team to cringe (apparently it sounds terrible); you might want to&#xD;&#xA;&gt; avoid it. (It's also trademarked by a Hungarian company.)" />
  <row Id="2274" PostHistoryTypeId="5" PostId="376" RevisionGUID="06813f61-d288-4b52-8c08-df97daa21c33" CreationDate="2014-03-18T22:15:31.890" UserId="220" Comment="added 2 characters in body" Text="A clone is a legal, Arduino-like board developed by a third party using the original schematics for the board (with a few minor adjustments). If significant changes are made, it is called a derivative." />
  <row Id="2275" PostHistoryTypeId="5" PostId="379" RevisionGUID="65e267a1-7627-4044-a887-85ae07a43805" CreationDate="2014-03-18T22:19:11.420" UserId="220" Comment="added 1099 characters in body" Text="The Arduino Uno SMD is a &quot;branch&quot; of the Arduino Uno board that has a SMD (surface mount chip) that is smaller and cheaper, but not replaceable. It was developed when there was a shortage of ATMega328-PUs. It acts the same way as a &quot;standard&quot; Arduino Uno.&#xD;&#xA;&#xD;&#xA;*From the **[Arduino Uno SMD page][1]***:&#xD;&#xA;&lt;img src=&quot;http://arduino.cc/en/uploads/Main/ArduinoUnoSmd.jpg&quot; &gt;&#xD;&#xA;&#xD;&#xA;&gt; The Arduino Uno SMD is a version of the Arduino Uno, but uses an&#xD;&#xA;&gt; surface mount version of the Atmega328P instead of the through-hole&#xD;&#xA;&gt; version. This version was made in response to a shortage in supply of&#xD;&#xA;&gt; the through-hole Atmega328P. The board is based on the ATmega328&#xD;&#xA;&gt; (datasheet). It has 14 digital input/output pins (of which 6 can be&#xD;&#xA;&gt; used as PWM outputs), 6 analog inputs, a 16 MHz crystal oscillator, a&#xD;&#xA;&gt; USB connection, a power jack, an ICSP header, and a reset button. It&#xD;&#xA;&gt; contains everything needed to support the microcontroller; simply&#xD;&#xA;&gt; connect it to a computer with a USB cable or power it with a AC-to-DC&#xD;&#xA;&gt; adapter or battery to get started.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardUnoSMD" />
  <row Id="2276" PostHistoryTypeId="5" PostId="380" RevisionGUID="54dc5132-5d88-45d6-bc69-3dfe01cfe7fb" CreationDate="2014-03-18T22:19:11.420" UserId="220" Comment="added 23 characters in body" Text="The Arduino Uno SMD is a &quot;branch&quot; of the Arduino Uno board that has a SMD (surface mount chip) that is smaller and cheaper, but not replaceable. It was developed when there was a shortage of ATMega328-PUs. It acts the same way as a &quot;standard&quot; Arduino Uno." />
  <row Id="2277" PostHistoryTypeId="5" PostId="109" RevisionGUID="9575fc52-2707-4d39-acbd-e5045d2a9379" CreationDate="2014-03-18T22:25:31.173" UserId="220" Comment="added 279 characters in body" Text="Ethernet can be used for communication between an Arduino and a computer. It is defined as _a system for connecting a number of computer systems to form a local area network, with protocols to control the passing of information and to avoid simultaneous transmission by two or more systems_&#xD;&#xA;&#xD;&#xA;There is also an [Arduino Ethernet board][1], for which you should use the tag [tag:arduino-ethernet].&#xD;&#xA;&#xD;&#xA;Additionally, there is an [Arduino Ethernet Shield][2]. Use this tag for the shield.&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://arduino.cc/en/uploads/Main/ArduinoEthernetShield_R3_Front.jpg&quot; &gt; *http://arduino.cc/en/Main/ArduinoEthernetShield*&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardEthernet&#xD;&#xA;  [2]: http://arduino.cc/en/Main/ArduinoEthernetShield" />
  <row Id="2278" PostHistoryTypeId="6" PostId="790" RevisionGUID="aeea9a37-6cdb-4598-8721-f6d2ce1bd669" CreationDate="2014-03-18T22:27:46.933" UserId="220" Comment="Pro and Pro mini are two different boards." Text="&lt;arduino-pro-mini&gt;" />
  <row Id="2279" PostHistoryTypeId="6" PostId="750" RevisionGUID="48999f1b-4c95-4a30-a7ec-ea760c1e54ae" CreationDate="2014-03-18T22:28:19.150" UserId="220" Comment="Pro and Pro mini are two different boards." Text="&lt;clones&gt;&lt;voltage-level&gt;&lt;arduino-pro-mini&gt;" />
  <row Id="2280" PostHistoryTypeId="5" PostId="523" RevisionGUID="0e78b68e-2f40-4f15-9c5e-80a5c448c382" CreationDate="2014-03-18T22:39:17.040" UserId="220" Comment="added 1199 characters in body" Text="The Arduino Mega is a board based on the ATmega2560 or 1280 chip.&#xD;&#xA;&#xD;&#xA;Use this tag for questions specifically regarding the Mega, and not just general Arduino usage. This applies to both versions of this board.&#xD;&#xA;****&#xD;&#xA;## [Arduino Mega 2560][1]:&#xD;&#xA;*From official Arduino page:*&#xD;&#xA;&gt;&lt;img src=&quot;http://arduino.cc/en/uploads/Main/ArduinoMega2560_R3_Front_450px.jpg&quot; &gt;&#xD;&#xA;&#xD;&#xA;&gt; Microcontroller	ATmega2560&#xD;&#xA;&gt; &#xD;&#xA;&gt; Operating Voltage	5V&#xD;&#xA;&gt; &#xD;&#xA;&gt; Input Voltage (recommended)	7-12V&#xD;&#xA;&gt; &#xD;&#xA;&gt; Input Voltage (limits)	6-20V&#xD;&#xA;&gt; &#xD;&#xA;&gt; Digital I/O Pins	54 (of which 15 provide PWM output)&#xD;&#xA;&gt; &#xD;&#xA;&gt; Analog Input Pins	16&#xD;&#xA;&gt; &#xD;&#xA;&gt; DC Current per I/O Pin	40 mA&#xD;&#xA;&gt; &#xD;&#xA;&gt; DC Current for 3.3V Pin	50 mA&#xD;&#xA;&gt; &#xD;&#xA;&gt; Flash Memory	256 KB of which 8 KB used by bootloader&#xD;&#xA;&gt; &#xD;&#xA;&gt; SRAM	8 KB&#xD;&#xA;&gt; &#xD;&#xA;&gt; EEPROM	4 KB&#xD;&#xA;&gt; &#xD;&#xA;&gt; Clock Speed	16 MHz&#xD;&#xA;&#xD;&#xA;****&#xD;&#xA;## [Arduino Mega 1280][2]:&#xD;&#xA;*From official Arduino page:*&#xD;&#xA;&#xD;&#xA;&gt; Microcontroller	ATmega1280&#xD;&#xA;&gt; &#xD;&#xA;&gt; Operating Voltage	5V&#xD;&#xA;&gt; &#xD;&#xA;&gt; Input Voltage (recommended)	7-12V&#xD;&#xA;&gt; &#xD;&#xA;&gt; Input Voltage (limits)	6-20V&#xD;&#xA;&gt; &#xD;&#xA;&gt; Digital I/O Pins	54 (of which 15 provide PWM output)&#xD;&#xA;&gt; &#xD;&#xA;&gt; Analog Input Pins	16&#xD;&#xA;&gt; &#xD;&#xA;&gt; DC Current per I/O Pin	40 mA&#xD;&#xA;&gt; &#xD;&#xA;&gt; DC Current for 3.3V Pin	50 mA&#xD;&#xA;&gt; &#xD;&#xA;&gt; Flash Memory	128 KB of which 4 KB used by bootloader&#xD;&#xA;&gt; &#xD;&#xA;&gt; SRAM	8 KB&#xD;&#xA;&gt; &#xD;&#xA;&gt; EEPROM	4 KB&#xD;&#xA;&gt; &#xD;&#xA;&gt; Clock Speed	16 MHz&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/arduinoBoardMega2560&#xD;&#xA;  [2]: http://arduino.cc/en/Main/arduinoBoardMega" />
  <row Id="2281" PostHistoryTypeId="5" PostId="524" RevisionGUID="1d878b75-8033-459e-9511-5ef6240b8c8b" CreationDate="2014-03-18T22:39:17.040" UserId="220" Comment="added 8 characters in body" Text="A microcontroller board based on the ATmega2560 or 1280 chip. Use this tag for questions specifically regarding the Mega, and not just general Arduino usage." />
  <row Id="2282" PostHistoryTypeId="5" PostId="23" RevisionGUID="11b67e27-9409-4363-923b-e993ee5198a4" CreationDate="2014-03-18T22:42:16.700" UserId="220" Comment="deleted 17 characters in body" Text="&gt; &lt;img src=&quot;http://arduino.cc/en/uploads/Main/ArduinoYunFront_2_450px.jpg&quot; &gt;&#xD;&#xA;&#xD;&#xA;&gt; The Arduino Yún is a microcontroller board based on the ATmega32u4 and the Atheros AR9331. The Atheros processor supports a Linux distribution based on OpenWRT named Linino. The board has built-in Ethernet and WiFi support, a USB-A port, micro-SD card slot, 20 digital input/output pins (of which 7 can be used as PWM outputs and 12 as analog inputs), a 16 MHz crystal oscillator, a micro USB connection, an ICSP header, and a 3 reset buttons.&#xD;&#xA;&#xD;&#xA;*(From http://arduino.cc/en/Main/ArduinoBoardYun)*&#xD;&#xA;&#xD;&#xA;The main differences between the Yún and other Arduinos is that the Yún contains an onboard WiFi antenna used to program the board wirelessly, connect to the internet in sketches, or see various information about the board. The Yún also contains a Linux side, which is different because most boards only have one onboard processor. The Yún has two onboard processors; one for the system and one for the Linux part. One can connect to the Linux side of the Yún via [a Bridge library][1]. Python 2.7 is also included with the Yún.&#xD;&#xA;&#xD;&#xA;Consider using other related tags such as [tag:programming] or [tag:pins] more specific to your problem.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/YunBridgeLibrary#.UwpmrfkiEw8" />
  <row Id="2283" PostHistoryTypeId="2" PostId="807" RevisionGUID="b3d24707-3516-499d-94fb-bbf826ed82b8" CreationDate="2014-03-18T22:47:05.140" UserId="220" Text="The Arduino Nano is a small board based on the ATmega328 or 168. It has male headers, so it can be plugged directly into a breadboard. It is small and compact, and features a USB chip.&#xD;&#xA;&#xD;&#xA;&gt; &lt;img src=&quot;http://arduino.cc/en/uploads/Main/ArduinoNanoFront_3_lg.jpg&quot; &gt;&#xD;&#xA;&gt; The Arduino Nano is a small, complete, and breadboard-friendly board&#xD;&#xA;&gt; based on the ATmega328 (Arduino Nano 3.x) or ATmega168 (Arduino Nano&#xD;&#xA;&gt; 2.x). It has more or less the same functionality of the Arduino Duemilanove, but in a different package. It lacks only a DC power&#xD;&#xA;&gt; jack, and works with a Mini-B USB cable instead of a standard one. The&#xD;&#xA;&gt; Nano was designed and is being produced by Gravitech.&#xD;&#xA;&gt; ****&#xD;&#xA;&gt; &#xD;&#xA;&gt; Microcontroller	Atmel ATmega168 or ATmega328&#xD;&#xA;&gt; &#xD;&#xA;&gt; Operating Voltage (logic level)	5 V&#xD;&#xA;&gt; &#xD;&#xA;&gt; Input Voltage (recommended)	7-12 V&#xD;&#xA;&gt; &#xD;&#xA;&gt; Input Voltage (limits)	6-20 V&#xD;&#xA;&gt; &#xD;&#xA;&gt; Digital I/O Pins	14 (of which 6 provide PWM output)&#xD;&#xA;&gt; &#xD;&#xA;&gt; Analog Input Pins	8&#xD;&#xA;&gt; &#xD;&#xA;&gt; DC Current per I/O Pin	40 mA&#xD;&#xA;&gt; &#xD;&#xA;&gt; Flash Memory	16 KB (ATmega168) or 32 KB (ATmega328) of which 2 KB used&#xD;&#xA;&gt; by bootloader&#xD;&#xA;&gt; &#xD;&#xA;&gt; SRAM	1 KB (ATmega168) or 2 KB (ATmega328)&#xD;&#xA;&gt; &#xD;&#xA;&gt; EEPROM	512 bytes (ATmega168) or 1 KB (ATmega328)&#xD;&#xA;&gt; &#xD;&#xA;&gt; Clock Speed	16 MHz&#xD;&#xA;&gt; &#xD;&#xA;&gt; Dimensions	0.73&quot; x 1.70&quot;&#xD;&#xA;&#xD;&#xA;*(From the [Arduino Nano Page](http://arduino.cc/en/Main/arduinoBoardNano).)*" />
  <row Id="2284" PostHistoryTypeId="2" PostId="808" RevisionGUID="466f65ea-f57f-4e57-bf46-a58a426e1382" CreationDate="2014-03-18T22:47:05.140" UserId="220" Text="The Arduino Nano is a small board based on the ATmega328 or 168. It has male headers, so it can be plugged directly into a breadboard. It is small and compact, and features a USB chip." />
  <row Id="2285" PostHistoryTypeId="5" PostId="391" RevisionGUID="2d6187b9-f661-4d9c-8a09-505ccc5fd8c1" CreationDate="2014-03-18T22:53:53.367" UserId="220" Comment="added 684 characters in body" Text="C++ is the standard language used to program the Arduino IDE. Most Arduino code online is written in this language.&#xD;&#xA;&#xD;&#xA;C++ is one of the most popular coding languages available, being highly cross-platform. Transferring Arduino code to PC code (and vice versa) is very hard, even when ignoring the fact that your computer can't run a motor. For example, in C++ code, the first thing to be called is `main`. In Arduino C++, main is still called, however, **the Arduino libraries are called, not your sketch.** Those libraries *then* call `setup` and then `loop` repeatedly after finishing all of it's tasks it must do before the Arduino can run code.&#xD;&#xA;&#xD;&#xA;It is pronounced &quot;C plus plus.&quot;" />
  <row Id="2286" PostHistoryTypeId="5" PostId="392" RevisionGUID="a6354e4f-13da-471e-9a13-23cab69314eb" CreationDate="2014-03-18T22:53:53.367" UserId="220" Comment="added 135 characters in body" Text="C++ is the standard language used to program the Arduino IDE. However, the Arduino IDE does have lots of libraries built in, so functions such as &quot;main&quot; are not called directly in the sketch code. Most Arduino code online is written in this language." />
  <row Id="2287" PostHistoryTypeId="5" PostId="750" RevisionGUID="4d310153-ab8f-4a38-8f3d-f5e5b39cdaf8" CreationDate="2014-03-18T22:58:06.180" UserId="633" Comment="deleted 106 characters in body" Text="I have a few Arduino Pro Mini clones (cheap Chinese stuff) and would like to power them with 12V power supply (same as fan voltage). According to the [Arduino Pro Mini spec][1] the RAW pin can take 3.35-12V (3.3V model). In practice this means a 12V PSU cannot be used as they are almost always over 12V with low load. I read that the voltage regulator in this board is capable up to 16V input. I tried plugging in a cheap 12V power adapter that read 15.1V with no load but a component on the Arduino board actually exploded instantly. The board seems to work still when powered from usb programmer. Component that burned out is just above VCC, RST and GND pins.&#xD;&#xA;&#xD;&#xA;Why did this happen? What did I just damage and most importantly what is a safe voltage level to use? I already have a few 12V switching power supplies it would be a shame if I could not use them.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardProMini#.UyT9APl_sz0" />
  <row Id="2288" PostHistoryTypeId="6" PostId="193" RevisionGUID="181d0dac-d7a1-4fd6-8b1a-d0f78cadf0f3" CreationDate="2014-03-18T23:35:56.863" UserId="220" Comment="edited tags" Text="&lt;programming&gt;&lt;sketch&gt;&lt;arduino-leonardo&gt;" />
  <row Id="2289" PostHistoryTypeId="2" PostId="809" RevisionGUID="6517de71-f933-4c11-9882-866f67951a37" CreationDate="2014-03-18T23:43:09.380" UserId="220" Text="Although it depends on your sketch, you can somewhat decrease the size by **reusing code with methods.**&#xD;&#xA;&#xD;&#xA;Take this code:&#xD;&#xA;&#xD;&#xA;    int led = 13;&#xD;&#xA;    int val;&#xD;&#xA;    &#xD;&#xA;    void setup() {                &#xD;&#xA;      pinMode(led, OUTPUT);     &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      &#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      &#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      &#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      &#xD;&#xA;      val = digitalRead(10);&#xD;&#xA;    }&#xD;&#xA;1,396 bytes on Arduino Uno. Now let's shrink it a bit:&#xD;&#xA;&#xD;&#xA;    int led = 13;&#xD;&#xA;    int val;&#xD;&#xA;    &#xD;&#xA;    void setup() {                &#xD;&#xA;      pinMode(led, OUTPUT);     &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      blink();&#xD;&#xA;      val = digitalRead(10);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void blink() {&#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;    }&#xD;&#xA;1,270 bytes. A 10% decrease! Could still be shrinked... Code Golf Stack Exchange! Just joking.&#xD;&#xA;&#xD;&#xA;Anyway, although it doesn't *greatly* shrink a sketch, it sometimes can be the easiest route when you are two bytes over the limit, or just want to make a more compact sketch to begin with without loosing any functionality. It's not for every situation, but I find it useful sometimes." />
  <row Id="2290" PostHistoryTypeId="2" PostId="810" RevisionGUID="59f7dcde-02d6-4e0e-b3c9-f4755373c82b" CreationDate="2014-03-19T00:15:29.617" UserId="220" Text="There has been a lot of talk about shrinking sketches recently, but if you don't need the room, should it be done? Will it speed up my program?&#xD;&#xA;&#xD;&#xA;Take this code:&#xD;&#xA;&#xD;&#xA;    int led = 13;&#xD;&#xA;    int val;&#xD;&#xA;    &#xD;&#xA;    void setup() {                &#xD;&#xA;      pinMode(led, OUTPUT);     &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      &#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      &#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      &#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      &#xD;&#xA;      val = digitalRead(10);&#xD;&#xA;    }&#xD;&#xA;1,396 bytes on Arduino Uno. Now let's shrink it a bit:&#xD;&#xA;&#xD;&#xA;    int led = 13;&#xD;&#xA;    int val;&#xD;&#xA;    &#xD;&#xA;    void setup() {                &#xD;&#xA;      pinMode(led, OUTPUT);     &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      blink();&#xD;&#xA;      val = digitalRead(10);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void blink() {&#xD;&#xA;      digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;      digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW&#xD;&#xA;      delay(1000);               // wait for a second&#xD;&#xA;    }&#xD;&#xA;1,270 bytes. A 10% decrease! It could be shrunk even more. **I have the space... is it more efficient (as far as speed) to make it the most compact I can or leave it &quot;uncompressed?&quot;** I would imagine that it would be a little more work (not much) calling `blink();`, therefore slowing down my code. Is this true? Are there other advantages/disadvantages of making it as small as possible (besides storage/distribution of C++ files)?" />
  <row Id="2291" PostHistoryTypeId="1" PostId="810" RevisionGUID="59f7dcde-02d6-4e0e-b3c9-f4755373c82b" CreationDate="2014-03-19T00:15:29.617" UserId="220" Text="Should I try to make my sketches as small as possible, even when I have enough room?" />
  <row Id="2292" PostHistoryTypeId="3" PostId="810" RevisionGUID="59f7dcde-02d6-4e0e-b3c9-f4755373c82b" CreationDate="2014-03-19T00:15:29.617" UserId="220" Text="&lt;programming&gt;&lt;sketch&gt;&lt;sketch-size&gt;" />
  <row Id="2293" PostHistoryTypeId="2" PostId="811" RevisionGUID="17aaf5cf-36af-40db-88e6-dcf2e7043921" CreationDate="2014-03-19T02:02:13.733" UserId="701" Text="Generally speaking, smaller is better. However, there is a point where too small actually makes the program run slower.&#xD;&#xA;&#xD;&#xA;My suggestion is if you are working on a sketch and it is blatantly obvious that you are repeating code over and over again, I would rip that out and put it into a function, not only does it make the program smaller, it makes it easier to read. &#xD;&#xA;&#xD;&#xA;There is also some optimization going on behind the scenes as well during compilation, so even though the C/C++ code looks to be large, chances are the compiler/linker are determining that something are repeats and consolidating them... Or at least the AVR compiler I used previously did, cannot remember if Arduino does this." />
  <row Id="2297" PostHistoryTypeId="2" PostId="812" RevisionGUID="31f952ca-ec3d-4d52-8c8e-ad7f3062b281" CreationDate="2014-03-19T04:22:10.897" UserId="381" Text="I have the below portable electric heater, but I would love to control it's start AND stop time using an Arduino. As-is, it does not come with a stop feature. SO, I have a burning question. How can I get an Arduino to start and stop this heater at specific times of the day?&#xD;&#xA;&#xD;&#xA;As you can see, it does have a start time, but it does not have a stop time.&#xD;&#xA;The power button is a simple push button. I suspect I would need to 'interject' into that and the board by using a switch? Apologies if the terminology is off, but I'm very green.&#xD;&#xA;Where would a noob begin?&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/ybUjr.jpg" />
  <row Id="2298" PostHistoryTypeId="1" PostId="812" RevisionGUID="31f952ca-ec3d-4d52-8c8e-ad7f3062b281" CreationDate="2014-03-19T04:22:10.897" UserId="381" Text="What are some steps to attach an Arduino to an electric heater?" />
  <row Id="2299" PostHistoryTypeId="3" PostId="812" RevisionGUID="31f952ca-ec3d-4d52-8c8e-ad7f3062b281" CreationDate="2014-03-19T04:22:10.897" UserId="381" Text="&lt;arduino-uno&gt;" />
  <row Id="2300" PostHistoryTypeId="2" PostId="813" RevisionGUID="ffd5e595-435b-4e05-90cd-720e73c51068" CreationDate="2014-03-19T06:19:04.083" UserId="83" Text="Would or should? Don't fiddle with the internals of the heater. Set its switch to the always on position and control switching on and off with an external relay. Make a box that has a power cord, a mains adapter for your Arduino and a mains outlet in which you can plug your heater.&#xD;&#xA;&#xD;&#xA;Use&#xD;&#xA;- an RTC (real time clock) breakout to keep accurate time&#xD;&#xA;- optionally a quad 7 segment display to display date/time&#xD;&#xA;- couple push buttons to configure the device&#xD;&#xA;- a relay breakout rated for the maximum power of the heater to turn it on/off." />
  <row Id="2301" PostHistoryTypeId="5" PostId="813" RevisionGUID="0c81455e-82b4-440a-96bc-11374cc0b7cd" CreationDate="2014-03-19T06:24:56.057" UserId="83" Comment="added 590 characters in body" Text="Would or should begin? Don't fiddle with the internals of the heater. &#xD;&#xA;&#xD;&#xA;Set its switch to the always on position and control switching on and off with an external relay. Make a box that has plenty of room (you can reduce size at a later moment), a power cord, a mains adapter for your Arduino and a mains outlet in which you can plug your heater.&#xD;&#xA;&#xD;&#xA;Use:&#xD;&#xA;&#xD;&#xA;- an [RTC (real time clock) breakout](http://www.amazon.co.uk/s/?tag=duc08-21&amp;url=search-alias%3Daps&amp;field-keywords=rtc%20breakout) to keep accurate time&#xD;&#xA;- optionally a [7 segment display](http://www.amazon.co.uk/Seven-Segment-Displays-Module-Arduino-Driver/dp/B00IWP2W4C/ref=sr_1_5?ie=UTF8&amp;qid=1395210069&amp;sr=8-5&amp;keywords=7+segment+display+driver) to display date/time. Just make sure it has a driver chip on it so you don't need your Arduino to multiplex the individual LEDs&#xD;&#xA;- couple push buttons to configure the device&#xD;&#xA;- a [relay](http://www.amazon.co.uk/s/ref=nb_sb_noss_1?url=search-alias%3Daps&amp;field-keywords=relay+5V&amp;rh=i%3Aaps%2Ck%3Arelay+5V) rated for the maximum power of the heater to turn it on/off, that can be driven from 5V. Possibly needs a transistor and flyback diode to be controlled from an Arduino GPIO line.&#xD;&#xA;&#xD;&#xA;And be **very** careful when experimenting with mains power, it can be leathal." />
  <row Id="2302" PostHistoryTypeId="5" PostId="813" RevisionGUID="045e867c-ac91-4ded-a366-dabadab614ba" CreationDate="2014-03-19T06:58:06.987" UserId="83" Comment="deleted 12 characters in body" Text="Would or should begin? Don't fiddle with the internals of the heater. &#xD;&#xA;&#xD;&#xA;Set its switch to the always on position and control switching on and off with an external relay. Make a box that has plenty of room (you can reduce size at a later moment), a power cord, a mains adapter for your Arduino and a mains outlet in which you can plug your heater.&#xD;&#xA;&#xD;&#xA;Use:&#xD;&#xA;&#xD;&#xA;- an [RTC (real time clock) breakout](http://www.amazon.co.uk/s/?tag=duc08-21&amp;url=search-alias%3Daps&amp;field-keywords=rtc%20breakout) to keep accurate time&#xD;&#xA;- optionally a [7 segment display](http://www.amazon.co.uk/MAX7219-8-Digit-Display-Segment-Digital/dp/B00IHSE6V6/ref=sr_1_6?ie=UTF8&amp;qid=1395212225&amp;sr=8-6&amp;keywords=7+segment+display) to display date/time. Just make sure it has a driver chip on it so you don't need your Arduino to multiplex the individual LEDs&#xD;&#xA;- couple push buttons to configure the device&#xD;&#xA;- a [relay](http://www.amazon.co.uk/s/ref=nb_sb_noss_1?url=search-alias%3Daps&amp;field-keywords=relay+5V&amp;rh=i%3Aaps%2Ck%3Arelay+5V) rated for the maximum power of the heater to turn it on/off, that can be driven from 5V. Possibly needs a transistor and flyback diode to be controlled from an Arduino GPIO line.&#xD;&#xA;&#xD;&#xA;And be **very** careful when experimenting with mains power, it can be leathal." />
  <row Id="2303" PostHistoryTypeId="2" PostId="814" RevisionGUID="1ba13510-15e3-48be-8a2f-e8044b2843bb" CreationDate="2014-03-19T08:30:20.267" UserId="470" Text="You second code may be smaller in size but due to the function call overhead the max execution speed is reduced.  &#xD;&#xA;Does this matter in your case? No, because you have huge delays anyway, but if the code was an actual series of repeated calculations that should be executed as fast as possible then it would make a difference.&#xD;&#xA;&#xD;&#xA;As a general rule, smaller code is not necessarily faster too.&#xD;&#xA;&#xD;&#xA;For code optimization (either size or speed) you can refer to this application note from Atmel [AVR4027: Tips and Tricks to Optimize Your C Code for 8-bit AVR Microcontrollers](http://www.atmel.com/images/doc8453.pdf)&#xD;&#xA;&#xD;&#xA;I could repeat everything it says here but I don't think there a point, you can read the original article directly." />
  <row Id="2304" PostHistoryTypeId="5" PostId="814" RevisionGUID="e92e7219-7ed4-468e-a69a-fc859ca79602" CreationDate="2014-03-19T08:39:24.590" UserId="470" Comment="added 3 characters in body" Text="You second code may be smaller in size but due to the function call overhead the max execution speed is reduced.  &#xD;&#xA;Does this matter in your case? No, because you have huge delays anyway, but if the code was an actual series of repeated calculations that should be executed as fast as possible then it would make a difference.&#xD;&#xA;&#xD;&#xA;As a general rule, smaller code is not necessarily faster too.&#xD;&#xA;&#xD;&#xA;For code optimization (either size or speed) you can refer to this application note from Atmel [AVR4027: Tips and Tricks to Optimize Your C Code for 8-bit AVR Microcontrollers](http://www.atmel.com/images/doc8453.pdf)&#xD;&#xA;&#xD;&#xA;I could repeat everything it says here but I don't think there is a point, you can read the original article directly." />
  <row Id="2305" PostHistoryTypeId="5" PostId="814" RevisionGUID="9e279fb4-749b-4715-bc8f-ffb5d658bc08" CreationDate="2014-03-19T09:43:12.373" UserId="470" Comment="added 2561 characters in body" Text="You second code may be smaller in size but due to the function call overhead the max execution speed is reduced.  &#xD;&#xA;Does this matter in your case? No, because you have huge delays anyway, but if the code was an actual series of repeated calculations that should be executed as fast as possible then it would make a difference.&#xD;&#xA;&#xD;&#xA;As a general rule, smaller code is not necessarily faster too.&#xD;&#xA;&#xD;&#xA;For code optimization (either size or speed) you can refer to this application note from Atmel [AVR4027: Tips and Tricks to Optimize Your C Code for 8-bit AVR Microcontrollers](http://www.atmel.com/images/doc8453.pdf)&#xD;&#xA;&#xD;&#xA;I could repeat everything it says here but I don't think there is a point, you can read the original article directly.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Regarding the compiler optimization level. Arduino IDE uses the avr-gcc compiler with a setting for **Os** optimization.  &#xD;&#xA;The avr-gcc available optimization levels are ([source1](http://www.network-theory.co.uk/docs/gccintro/gccintro_49.html) [source2](http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Optimize-Options.html#Optimize-Options))  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA; - **O0 or no -O option**  &#xD;&#xA;    At this optimization level GCC does not perform any optimization and compiles the source code in the most straightforward way possible. Each command in the source code is converted directly to the corresponding instructions in the executable file, without rearrangement. This is the best option to use when debugging a program and is the default if no optimization level option is specified.&#xD;&#xA; &#xD;&#xA; - **O1 or -O**  &#xD;&#xA;    This level turns on the most common forms of optimization that do not require any speed-space tradeoffs. With this option the resulting executables should be smaller and faster than with -O0. The more expensive optimizations, such as instruction scheduling, are not used at this level. Compiling with the option -O1 can often take less time than compiling with -O0, due to the reduced amounts of data that need to be processed after simple optimizations. &#xD;&#xA;&#xD;&#xA; - **O2**  &#xD;&#xA;    This option turns on further optimizations, in addition to those used by -O1. These additional optimizations include instruction scheduling. Only optimizations that do not require any speed-space tradeoffs are used, so the executable should not increase in size. The compiler will take longer to compile programs and require more memory than with -O1. This option is generally the best choice for deployment of a program, because it provides maximum optimization without increasing the executable size. It is the default optimization level for releases of GNU packages. &#xD;&#xA;&#xD;&#xA; - **O3**  &#xD;&#xA;    This option turns on more expensive optimizations, such as function inlining, in addition to all the optimizations of the lower levels -O2 and -O1. The -O3 optimization level may increase the speed of the resulting executable, but can also increase its size. Under some circumstances where these optimizations are not favorable, this option might actually make a program slower. &#xD;&#xA;&#xD;&#xA; - **Os**  &#xD;&#xA;    This option selects optimizations which reduce the size of an executable. The aim of this option is to produce the smallest possible executable, for systems constrained by memory or disk space. In some cases a smaller executable will also run faster, due to better cache usage." />
  <row Id="2306" PostHistoryTypeId="5" PostId="812" RevisionGUID="e3b596c6-aee7-4e3d-b35d-eb9cbb51a716" CreationDate="2014-03-19T11:05:37.593" UserId="381" Comment="added 120 characters in body" Text="I have the below portable electric heater, but I would love to control it's start AND stop time using an Arduino. As-is, it does not come with a stop feature. SO, I have a burning question. How can I get an Arduino to start and stop this heater at specific times of the day?&#xD;&#xA;&#xD;&#xA;As you can see, it does have a start time, but it does not have a stop time.&#xD;&#xA;The power button is a simple push button. I suspect I would need to 'interject' into that and the board by using a switch? Apologies if the terminology is off, but I'm very green.&#xD;&#xA;Where would a noob begin?&#xD;&#xA;&#xD;&#xA;-EDIT-&#xD;&#xA;The unit is always off when it's plugged back in. That likely means I cannot put a timer on the power cord. &#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/ybUjr.jpg" />
  <row Id="2307" PostHistoryTypeId="4" PostId="750" RevisionGUID="de44e058-3913-4da0-be8f-055c9d8449d2" CreationDate="2014-03-19T13:25:02.790" UserId="633" Comment="edited title" Text="Arduino Pro Mini (3.3V version) input voltage range / tolerance" />
  <row Id="2309" PostHistoryTypeId="2" PostId="815" RevisionGUID="115cdd93-4485-4e96-9496-5dd5b7e61d24" CreationDate="2014-03-19T14:26:44.540" UserId="709" Text="There are a lot of methods to power an arduino from a large range of voltages&#xD;&#xA;&#xD;&#xA;- usb cable from pc or from a phone charger or an usb hub&#xD;&#xA;- step down convertors&#xD;&#xA;- step up converters&#xD;&#xA;- switching power supply&#xD;&#xA;- batteries (connected to the power jack or usb or to Vin)&#xD;&#xA;&#xD;&#xA;What I can't seem to find is a small 220v-5v converter. I'd like to put an arduino in the wall, under a light switch, so size matters. &#xD;&#xA;&#xD;&#xA;The last resort option is to open a 5v phone charger and replace the metal prongs that go in a socket with two wires, and replace the usb socket with anoter pair of wires that go the arduino board, but still, an Arduino Pro Mini or an Arduino Nano is smaller than the phone charger. &#xD;&#xA;&#xD;&#xA;Thank you for your time" />
  <row Id="2310" PostHistoryTypeId="1" PostId="815" RevisionGUID="115cdd93-4485-4e96-9496-5dd5b7e61d24" CreationDate="2014-03-19T14:26:44.540" UserId="709" Text="What is the smallest method of connecting an arduino to 110v / 220v?" />
  <row Id="2311" PostHistoryTypeId="3" PostId="815" RevisionGUID="115cdd93-4485-4e96-9496-5dd5b7e61d24" CreationDate="2014-03-19T14:26:44.540" UserId="709" Text="&lt;arduino-uno&gt;&lt;power&gt;&lt;arduino-nano&gt;&lt;arduino-pro-mini&gt;&lt;electricity&gt;" />
  <row Id="2312" PostHistoryTypeId="2" PostId="816" RevisionGUID="135081f6-e2c2-4b46-bde6-8848fb627e3f" CreationDate="2014-03-19T14:34:30.793" UserId="693" Text="What are the advantages of each language when using the Arduino?&#xD;&#xA;&#xD;&#xA;I'm thinking this is a good general question, but I'll add a bit about why I'm asking if anyone wants to give me a tip.&#xD;&#xA;&#xD;&#xA;I'm experienced in preprocessed languages like JavaScript, PHP, and have fiddled with languages like Java and Visual Basic. In other words I know programming techniques and both classical and prototypal object orientation, but nothing about communicating directly with hardware.&#xD;&#xA;&#xD;&#xA;I'm making an octocopter, and am thinking that an object oriented approach will be the easiest. (The software will have very many features...) However I have never written in C++.&#xD;&#xA;&#xD;&#xA;Since this is a Q&amp;A site that's supposed to help others, only the general question presented at the beginning is of much importance, but I'd appreciate any comments on my situation." />
  <row Id="2313" PostHistoryTypeId="1" PostId="816" RevisionGUID="135081f6-e2c2-4b46-bde6-8848fb627e3f" CreationDate="2014-03-19T14:34:30.793" UserId="693" Text="C++ vs. The Arduino Language?" />
  <row Id="2314" PostHistoryTypeId="3" PostId="816" RevisionGUID="135081f6-e2c2-4b46-bde6-8848fb627e3f" CreationDate="2014-03-19T14:34:30.793" UserId="693" Text="&lt;c++&gt;&lt;arduino-ide&gt;" />
  <row Id="2315" PostHistoryTypeId="2" PostId="817" RevisionGUID="7ff40042-9e71-444a-a671-56142a53d3fb" CreationDate="2014-03-19T14:51:57.067" UserId="666" Text="My personal experience as professor (programming, mechatronics) is that if you have previous programming experience and you are aware of concepts as OOP, it is better to go for C/C++. The arduino language is really great for beginners, but have some limitations (e.g. you must have all your files in the same folder). And it is basically a simplification of C/C++ (you can practically copy&amp;paste arduino code to a C/C++ file, and it will work). Also it makes sense that you can go and use a full well known IDE as eclipse:&#xD;&#xA;&#xD;&#xA;http://playground.arduino.cc/Code/Eclipse&#xD;&#xA;&#xD;&#xA;Initially it is required a bit more of setup and configuration of your dev environment, but IMHO it is worth it for programmers with experience in any other language.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2316" PostHistoryTypeId="2" PostId="818" RevisionGUID="4f8c6213-a601-4a31-af16-fb0ff8d7cd1e" CreationDate="2014-03-19T14:52:47.250" UserId="8" Text="The Arduino language *is* C++, but it is very different from most C++ varieties. The Arduino language has a lot of abstraction built in, especially in the hardware interfaces, which makes it very simple to use. If you have a background in Java, C and C++ should be very similar.&#xD;&#xA;&#xD;&#xA;The main differences between Arduino and C++ are in the memory storage. Usually a modern computer has more than 2GB of RAM, while the Arduino Uno has 2kB (1 million times less). The Arduino also uses 8-bit instructions in stead of the 32 bit ones a computer uses. This will mainly affect the amount of information you can store in a variable.&#xD;&#xA;&#xD;&#xA;If you are very new to the Arduino world, you should look up a tutorial, as there are many good ones out there.&#xD;&#xA;" />
  <row Id="2317" PostHistoryTypeId="5" PostId="817" RevisionGUID="db81dcb7-5bfe-4183-87f4-cc3694f44c49" CreationDate="2014-03-19T14:57:18.857" UserId="666" Comment="added 219 characters in body" Text="My personal experience as professor (programming, mechatronics) is that if you have previous programming experience and you are aware of concepts as OOP, it is better to go for C/C++. The arduino language is really great for beginners, but have some limitations (e.g. you must have all your files in the same folder). And it is basically a simplification of C/C++ (you can practically copy&amp;paste arduino code to a C/C++ file, and it will work). Also it makes sense that you can go and use a full well known IDE as eclipse:&#xD;&#xA;&#xD;&#xA;http://playground.arduino.cc/Code/Eclipse&#xD;&#xA;&#xD;&#xA;Initially it is required a bit more of setup and configuration of your dev environment, but IMHO it is worth it for programmers with experience in any other language.&#xD;&#xA;&#xD;&#xA;In any case, it won't harm you to start using the arduino language and the arduino IDE for a few days to get familiar with the arduino hardware and then move to C/C++ with Eclipse for really developing your project.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2318" PostHistoryTypeId="2" PostId="819" RevisionGUID="16208ae7-5cbd-47c4-9740-b6d8fdad5271" CreationDate="2014-03-19T14:59:26.963" UserId="42" Text="**In theory...**  &#xD;&#xA;There isn't really an Arduino language as such. It's really just C++ with some domain-specific libraries. These add on various features, such as functions you can call to control the hardware. If you didn't have those functions, you'd need to fiddle directly with special registers to control everything. That's how embedded programming is usually done. It's fast, but it can be quite hard to learn and understand.&#xD;&#xA;&#xD;&#xA;In addition to the functions, the libraries add alternative names for some types. For example, `boolean` and `byte` are not in the C++ standard. However, they are directly equivalent to `bool` and `unsigned char`.&#xD;&#xA;&#xD;&#xA;All of these things mean you can probably port general C++ code directly to Arduino without difficulty. However, going back the other way may require some minor editing.&#xD;&#xA;&#xD;&#xA;**In practice...**  &#xD;&#xA;Having said all of that, programming for Arduino isn't exactly the same as general C++ programming. A lot of the differences are common to all embedded programming though (such as limited memory and processing power).&#xD;&#xA;&#xD;&#xA;It's also worth noting that if you're using the official Arduino IDE then there are all sorts of annoying quirks and limitations on how you setup your code. There are workarounds in all cases (as far as I'm aware), but they are sometimes quite frustrating.&#xD;&#xA;&#xD;&#xA;For full flexibility, use a third-party IDE (such as Eclipse) with a plug-in to support Arduino. That should give you all the advantages of C++, along with the Arduino libraries." />
  <row Id="2319" PostHistoryTypeId="2" PostId="820" RevisionGUID="ed7f8543-46ea-4865-a34e-d9f2b86a7d15" CreationDate="2014-03-19T15:16:04.090" UserId="353" Text="What if you replace the nearest outlet with some kind of [USB Wall Socket](http://www.alibaba.com/product-detail/Nice-Dual-USB-Wall-socket-For_1518461365.html) and attach to that (either through a standard USB plug, or inside the wall) ?" />
  <row Id="2320" PostHistoryTypeId="2" PostId="821" RevisionGUID="1654c2ef-dfb1-458c-aced-31a1bc866d8c" CreationDate="2014-03-19T15:27:47.403" UserId="639" Text="An XBee Series 2 is set to `Coordinator API` whose `TX` and `RX` pins are connected to an Arduino Nano's `Rx` and `Tx` pins respectively. The arduino is connected to a Mac OSX via USB.&#xD;&#xA;&#xD;&#xA;A second XBee Series 2 is connected to a Windows system via USB. It is set to `Router AT` mode.&#xD;&#xA;&#xD;&#xA;Using the sketch below on the Arduino, a packet is sent from the `Router AT` Xbee to the `Coordinator API` Xbee, which is seen by `XCTU` as a Explicit RX frame. However the Arduino LED should blink once if it received a reply packet (should it?)&#xD;&#xA;&#xD;&#xA;On another test, I wrote a script to send a frame for the `Coordinator API` Xbee to send to the `Router AT` Xbee. Once again the Arduino LED does not blink, and nothing is seen using Arduino's Serial Monitor.&#xD;&#xA;&#xD;&#xA;**Testing the `Coordinator API` XBee**&#xD;&#xA;&#xD;&#xA;Using the same script to send a packet from `Coordinator API` Xbee to itself, the packet was received as well as a delivery confirmation packet. This shows that both the `Coordinator API` Xbee and the script are working.&#xD;&#xA;&#xD;&#xA;	// Delivery confirmation &#xD;&#xA;	received:  { type: 144,&#xD;&#xA;	  remote64: '0013a20040a74613',&#xD;&#xA;	  remote16: '0000',&#xD;&#xA;	  receiveOptions: 1,&#xD;&#xA;	  data: [ 116 ] }&#xD;&#xA;&#xD;&#xA;	// Received the packet sent to itself	  &#xD;&#xA;	received:  { type: 139,&#xD;&#xA;	  id: 1,&#xD;&#xA;	  remote16: '0000',&#xD;&#xA;	  transmitRetryCount: 0,&#xD;&#xA;	  deliveryStatus: 0,&#xD;&#xA;	  discoveryStatus: 0 }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Testing the Arduno Sketch Code**&#xD;&#xA;&#xD;&#xA;Using the same Arduino sketch which continuously sends API frames to the `Coordinator`, I connected the `Router AT` XBee's `RX` pin to Arduino's `RX` pin, so the frames the arduino are sending out are going back into its `RX` pin.&#xD;&#xA;&#xD;&#xA;This causes the Arduino's LED to light up! So there is nothing wrong with the code.&#xD;&#xA;&#xD;&#xA;**Problem:** Does this mean the `Router AT` XBee is not configured properly? I do not think its `TX` pin is damaged because `XCTU` can still read the settings off this XBee. Any ideas on how we can troubleshoot this? Thanks!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Arduino Sketch (Connected to Coordinator Xbee)**&#xD;&#xA;&#xD;&#xA;    #include &lt;XBee.h&gt;&#xD;&#xA;&#xD;&#xA;    XBee xbee = XBee();&#xD;&#xA;    uint8_t payload[] = { 0, 0 };&#xD;&#xA;&#xD;&#xA;    // SH + SL Address of receiving XBee&#xD;&#xA;    XBeeAddress64 addr64 = XBeeAddress64(0x0013a200, 0x40a74613);&#xD;&#xA;    ZBTxRequest zbTx = ZBTxRequest(addr64, payload, sizeof(payload));&#xD;&#xA;    ZBTxStatusResponse txStatus = ZBTxStatusResponse();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;        &#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;        xbee.setSerial(Serial);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;&#xD;&#xA;        xbee.send(zbTx);&#xD;&#xA;        delay(1000);&#xD;&#xA;        &#xD;&#xA;        xbee.readPacket();&#xD;&#xA;        if (xbee.getResponse().isAvailable()) {&#xD;&#xA;&#xD;&#xA;            // Response received, blink LED once&#xD;&#xA;            Serial.println('resposne!');&#xD;&#xA;            digitalWrite(13, HIGH);&#xD;&#xA;            delay(1000);&#xD;&#xA;            digitalWrite(13, LOW);&#xD;&#xA;            delay(1000);&#xD;&#xA;        }&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2321" PostHistoryTypeId="1" PostId="821" RevisionGUID="1654c2ef-dfb1-458c-aced-31a1bc866d8c" CreationDate="2014-03-19T15:27:47.403" UserId="639" Text="Arduino unable to read from XBee Series 2" />
  <row Id="2322" PostHistoryTypeId="3" PostId="821" RevisionGUID="1654c2ef-dfb1-458c-aced-31a1bc866d8c" CreationDate="2014-03-19T15:27:47.403" UserId="639" Text="&lt;programming&gt;&lt;serial&gt;&lt;pins&gt;&lt;sketch&gt;&lt;arduno-nano&gt;" />
  <row Id="2323" PostHistoryTypeId="2" PostId="822" RevisionGUID="3a51eec3-7e0d-4a8e-9389-3ba0131d195c" CreationDate="2014-03-19T15:55:13.463" UserId="220" Text="&gt; The last resort option is to open a 5v phone charger and replace the metal prongs that go in a socket with two wires, and replace the usb socket with another pair of wires that go the arduino board, but still, an Arduino Pro Mini or an Arduino Nano is smaller than the phone charger.&#xD;&#xA;&#xD;&#xA;You will probably have to do something like that.&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/Wall_wart_opened.JPG/800px-Wall_wart_opened.JPG&quot; &gt;&#xD;&#xA;&#xD;&#xA;**Because of the nature of conversion between AC and DC, there has to be some large parts.** I'm not going to go into the specifics because that is what EE is for. There is usually a diode bridge (because AC waveforms reverse the current ~60 times a second) and a transformer (to lower the voltage for the diode bridge). They almost always include a regulator and a capacitor to make sure voltage is exact and it outputs a &quot;clean&quot; power supply.&#xD;&#xA;&#xD;&#xA;[This adapter](http://www.amazon.co.uk/Xcessor-Compact-European-Wall-Charger/dp/B00DVLHZOE/ref=sr_1_1?s=electronics&amp;ie=UTF8&amp;qid=1395244016&amp;sr=1-1&amp;keywords=220v+usb+adapter) seems to be the most compact adapter I can find. You'll never get something *near* the size you are desiring. I don't know the size of the Amazon adapter I gave a link for, but in the US (120V), iPhone chargers are very small and they should fit in a standard depth outlet box (with a little room left over for relays and such). If you *really* need to get smaller, I recommend using a ATtiny chip." />
  <row Id="2327" PostHistoryTypeId="2" PostId="824" RevisionGUID="3e99e334-40ba-42b9-868b-ad3eb986dc83" CreationDate="2014-03-19T17:09:02.170" UserId="313" Text="C++, if those are your two choices:&#xD;&#xA;&#xD;&#xA; - C++ is a standardized language. It is widely deployed in many environments including embedded systems and therefore is more thoroughly tested than the very-like-C++ language that is &quot;Arduino&quot;. This is especially important for mission-critical / safety-critical applications such as you are planning. Crashed code means a crashed 'copter and even if it doesn't hurt someone, it **will** break your expensive machine.&#xD;&#xA;&#xD;&#xA; - Being standard, C++ is portable. Need to upgrade your processor? Everything but silicon-specific code will port to the new one. Need to change your toolset, development system, host OS? C++ will be supported everywhere. Though Arduino IDE will run anywhere Java is supported, it is the only tool that uses Arduino C++ and it is a very limited tool. If you want to use Eclipse, the AVR tools, go barefoot on the command-line, develop within Emacs, or whatever other environment you prefer, standard C++ will be supported.&#xD;&#xA;&#xD;&#xA; - The Arduino IDE does things behind your back - specifically, it #includes .h files when it thinks you need them. Even if it is correct, you really want to write, or at least see and understand, everything the compiler is going to see. Programming languages aren't made for computers (computers eat bits for breakfast); they're made for people, specifically the people who follow you on the project, the most important of whom is ... you!, when 6 months after you wrote a module, you have to come back to enhance it, or more likely, fix it. You really want to be able to see everything the compiler sees.&#xD;&#xA;&#xD;&#xA;Do limit your use of C++ language features to those whose implementation you fully understand. There are some features that compile to more resource-intensive code than is obvious from reading the source code. The optionally generated .lss (merged source and assembly) listing can give you some good insight into what the C++ compiler did when you weren't looking.&#xD;&#xA;&#xD;&#xA;To your question about memory: C++ does not garbage-collect. Stack-based languages like C and C++ do allocate temporary storage on the stack for automatic variables at function entry, which then gets released when the function returns, but this is not true garbage-collection. Objects created in heap- or global memory live until you explicitly delete them. Make sure you know where, when, and for how long different kinds of objects will be created. You really don't want your code `new`-ing and `delete`-ing objects willy-nilly. They will be built in heap memory, fragmenting it and causing it to grow up into the stack. That's when your code - and your nice 'copter - will crash.&#xD;&#xA;&#xD;&#xA;C does less for you so it can do less **to** you. It's not a bad choice. C with a few of C++'s features can be an even better choice, given you choose the extra features judiciously." />
  <row Id="2328" PostHistoryTypeId="2" PostId="825" RevisionGUID="980d66b7-4440-4343-9aab-726ec578ea19" CreationDate="2014-03-19T17:10:02.733" UserId="575" Text="Has anyone seen or know of a method of preloading (using a computer or whatever) a firmware as data onto one arduino set up to operate as an isp and then using that arduino plug the isp interface into another and upload the firmware.&#xD;&#xA;&#xD;&#xA;To be clear - i'm looking for a way to make uploading arduino sketches possible without a direct connection to a full blown computer.&#xD;&#xA;&#xD;&#xA;Ideally the steps involved would be:&#xD;&#xA;&#xD;&#xA;1. Write new sketch/firmware&#xD;&#xA;2. Compile firmware&#xD;&#xA;3. Write a copy firmware onto Arduino A as data (Arduino A is set up to work as ISP)&#xD;&#xA;4. Detach Arduino A from the computer&#xD;&#xA;5. In a seperate location attach Arduino A to Arduino B using ISP headers&#xD;&#xA;6. Using some method (maybe a pushbutton) trigger Arduino A to upload the preloaded firmware onto Arduino B.&#xD;&#xA;&#xD;&#xA;I'm assuming that theoretically it could work because uploading firmware is just an exchange of bytes across the SPI interface but i'm not sure about the reality.&#xD;&#xA;&#xD;&#xA;The scenario for which I'm considering is if I were to install an arduino (permanently) in a location that is remote from my computer (I don't have a laptop nor do I want to get one) it would be troublesome to reprogram it.&#xD;&#xA;&#xD;&#xA;The other method I have considered is using the DIL packaged ATMEGA which I can then remove from the board and program at the computer and return to the board - however I would much prefer not to risk bending of pins and the hassle of having to remove the chip each time I want to reprogram." />
  <row Id="2329" PostHistoryTypeId="1" PostId="825" RevisionGUID="980d66b7-4440-4343-9aab-726ec578ea19" CreationDate="2014-03-19T17:10:02.733" UserId="575" Text="Arduino as ISP without a computer" />
  <row Id="2330" PostHistoryTypeId="3" PostId="825" RevisionGUID="980d66b7-4440-4343-9aab-726ec578ea19" CreationDate="2014-03-19T17:10:02.733" UserId="575" Text="&lt;programming&gt;&lt;uploading&gt;&lt;isp&gt;" />
  <row Id="2331" PostHistoryTypeId="2" PostId="826" RevisionGUID="8680a574-1f29-493b-9de9-f000c3efbbee" CreationDate="2014-03-19T17:15:06.997" UserId="313" Text="The smallest is probably a plug-in USB charger such as Apple's tiny cube. The cheapest is bound to be a ~9v (output) wall-wart scrounged from the lost and found in a tourist's/traveller's hotel." />
  <row Id="2332" PostHistoryTypeId="2" PostId="827" RevisionGUID="3bb6a763-6d51-414d-8c7c-4bb2bf5fc223" CreationDate="2014-03-19T17:27:00.953" UserId="349" Text="&gt; What are the advantages of C++ vs the Arduino language when using Arduino? I'm experienced in preprocessed languages like JavaScript, PHP, and have fiddled with languages like Java and Visual Basic.&#xD;&#xA;&#xD;&#xA;First, the Arduino compiler/IDE accepts C and C++ as-is.  In fact many of the libraries are written in C++.  Much of the underlying system is not object oriented, but it could be.&#xD;&#xA;&#xD;&#xA;Thus, &quot;The arduino language&quot; is C++ or C.&#xD;&#xA;&#xD;&#xA;C++ is not garbage collected.  It does manage variables in scope - if you write:&#xD;&#xA;&#xD;&#xA;    int led = 13;&#xD;&#xA;&#xD;&#xA;    void blinkTimes(int value)&#xD;&#xA;    {&#xD;&#xA;       int i;&#xD;&#xA;&#xD;&#xA;       for(i=0;i&lt;value;i++)&#xD;&#xA;       {&#xD;&#xA;          digitalWrite(led, HIGH);&#xD;&#xA;          delay(1000);&#xD;&#xA;          digitalWrite(led, LOW);&#xD;&#xA;          delay(1000);&#xD;&#xA;       }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Then you'll find that `led` and `i` don't grow or leak, no matter how many times you call `blinkTimes`.&#xD;&#xA;&#xD;&#xA;If `i` were a class, it would similarly be disposed of once the function ended.  So as long as you aren't using `new` or similar memory allocation functions to create new objects, then you won't have to worry about leaks.&#xD;&#xA;&#xD;&#xA;You may still run out of memory, if you create huge classes and use a lot of them in deeply nested functions, but in general you aren't going to run into trouble until you start dealing with `new` and `free` functions.&#xD;&#xA;&#xD;&#xA;If you are using `new`, then you'll have to call `free` at appropriate times.  C++, and by extension Arduino, has no automatic garbage collection, you have to explicitly manage your own memory." />
  <row Id="2333" PostHistoryTypeId="2" PostId="828" RevisionGUID="9b23e0d4-7dc8-475a-9768-919751a73dec" CreationDate="2014-03-19T17:52:23.080" UserId="717" Text="I can suggest you to try this : [AC DC Step Down Converter][1]&#xD;&#xA;&#xD;&#xA;It is as small as the Apple's tiny cube, and it can be placed inside of a wall easily. (I'm personally using this with an arduino micro)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.aliexpress.com/item/220V-to-5V-AC-DC-Step-Down-Converter-5V-800mA-Switching-Power-Supply-Module-AC-85/1488428284.html" />
  <row Id="2334" PostHistoryTypeId="2" PostId="829" RevisionGUID="4ebedc72-1ce9-4cf0-84a3-7f20f9017a1a" CreationDate="2014-03-19T18:16:06.883" UserId="379" Text="I have no direct solution for what you want, but yes it is possible to do it. You can hack a bootloader firmware so that it reads the firmware flash code and upload it over ISP. &#xD;&#xA;&#xD;&#xA;Though you obviously can't upload 32k of firmware on the target AVR if both arduinos have only 32k of total flash in their MCUs, you'll need to have the flasher have more flash than the target if you want to do so (a 1284p or 2560 Mega will be far enough, or a 328/32u4 will be cood to flash a 168 or an attiny).&#xD;&#xA;The only exception would be to have the firmware to be flashed way smaller than the total memory (like for a blink sketch).&#xD;&#xA;&#xD;&#xA;In the end, that won't be easy, it's 100% pure AVR code, but you can do it. Have a look at:&#xD;&#xA;&#xD;&#xA; - [The bootloader FAQ](http://blog.schicks.net/wp-content/uploads/2009/09/bootloader_faq.pdf) ;&#xD;&#xA; - [The Optiboot Project](http://code.google.com/p/optiboot/) which goal is to make the smallest bootloader possible and&#xD;&#xA; - [AVRISP](http://code.google.com/p/micropendous/wiki/AVRISP) source code&#xD;&#xA;&#xD;&#xA;The way I'd implement that would be to either make everything fit in the bootloader of the flasher device, so it reads the firmware (everything from 0x00 to the bootloader start address) and flashes it through ISP by merging AVRISP with Optiboot.&#xD;&#xA;&#xD;&#xA;Anyway, that's an interesting project for a workshop about bootloaders and AVRs I may suggest at my local hackerspace! ;-)&#xD;&#xA;&#xD;&#xA;HTH" />
  <row Id="2336" PostHistoryTypeId="5" PostId="821" RevisionGUID="f99220e8-6817-485f-838d-dd3f7aca6b86" CreationDate="2014-03-19T19:02:56.617" UserId="639" Comment="deleted 5 characters in body" Text="An XBee Series 2 is set to `Coordinator API` whose `TX` and `RX` pins are connected to an Arduino Nano's `Rx` and `Tx` pins respectively. The arduino is connected to a Mac OSX via USB.&#xD;&#xA;&#xD;&#xA;A second XBee Series 2 is connected to a Windows system via USB. It is set to `Router AT` mode.&#xD;&#xA;&#xD;&#xA;Using the sketch below on the Arduino, a packet is sent from the `Router AT` Xbee to the `Coordinator API` Xbee, which is seen by `XCTU` as a Explicit RX frame. However the Arduino LED should blink once if it received a reply packet (should it?)&#xD;&#xA;&#xD;&#xA;On another test, I wrote a script to send a frame for the `Coordinator API` Xbee to send to the `Router AT` Xbee. Once again the Arduino LED does not blink, and nothing is seen using Arduino's Serial Monitor.&#xD;&#xA;&#xD;&#xA;**Testing the `Coordinator API` XBee**&#xD;&#xA;&#xD;&#xA;Using the same script to send a packet from `Coordinator API` Xbee to itself, the packet was received as well as a delivery confirmation packet. This shows that both the `Coordinator API` Xbee and the script are working.&#xD;&#xA;&#xD;&#xA;	// Delivery confirmation &#xD;&#xA;	received:  { type: 144,&#xD;&#xA;	  remote64: '0013a20040a74613',&#xD;&#xA;	  remote16: '0000',&#xD;&#xA;	  receiveOptions: 1,&#xD;&#xA;	  data: [ 116 ] }&#xD;&#xA;&#xD;&#xA;	// Received the packet sent to itself	  &#xD;&#xA;	received:  { type: 139,&#xD;&#xA;	  id: 1,&#xD;&#xA;	  remote16: '0000',&#xD;&#xA;	  transmitRetryCount: 0,&#xD;&#xA;	  deliveryStatus: 0,&#xD;&#xA;	  discoveryStatus: 0 }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Testing the Arduno Sketch Code**&#xD;&#xA;&#xD;&#xA;Using the same Arduino sketch which continuously sends API frames to the `Coordinator`, I connected the `Router AT` XBee's `RX` pin to Arduino's `RX` pin, so the frames the arduino are sending out are going back into its `RX` pin.&#xD;&#xA;&#xD;&#xA;This causes the Arduino's LED to light up! So there is nothing wrong with the code.&#xD;&#xA;&#xD;&#xA;**Problem:** Does this mean the `Router AT` XBee is not configured properly? I do not think its `TX` pin is damaged because `XCTU` can still read the settings off this XBee. Any ideas on how we can troubleshoot this? Thanks!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Arduino Sketch (Connected to Router Xbee)**&#xD;&#xA;&#xD;&#xA;    #include &lt;XBee.h&gt;&#xD;&#xA;&#xD;&#xA;    XBee xbee = XBee();&#xD;&#xA;    uint8_t payload[] = { 0, 0 };&#xD;&#xA;&#xD;&#xA;    // SH + SL Address of receiving XBee&#xD;&#xA;    XBeeAddress64 addr64 = XBeeAddress64(0x0013a200, 0x40a74613);&#xD;&#xA;    ZBTxRequest zbTx = ZBTxRequest(addr64, payload, sizeof(payload));&#xD;&#xA;    ZBTxStatusResponse txStatus = ZBTxStatusResponse();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;        &#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;        xbee.setSerial(Serial);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;&#xD;&#xA;        xbee.send(zbTx);&#xD;&#xA;        delay(1000);&#xD;&#xA;        &#xD;&#xA;        xbee.readPacket();&#xD;&#xA;        if (xbee.getResponse().isAvailable()) {&#xD;&#xA;&#xD;&#xA;            // Response received, blink LED once&#xD;&#xA;            Serial.println('resposne!');&#xD;&#xA;            digitalWrite(13, HIGH);&#xD;&#xA;            delay(1000);&#xD;&#xA;            digitalWrite(13, LOW);&#xD;&#xA;            delay(1000);&#xD;&#xA;        }&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2337" PostHistoryTypeId="5" PostId="822" RevisionGUID="7dd902f1-891a-464c-a56a-6560a8dc40be" CreationDate="2014-03-19T19:12:36.813" UserId="220" Comment="added 1133 characters in body" Text="&gt; The last resort option is to open a 5v phone charger and replace the metal prongs that go in a socket with two wires, and replace the usb socket with another pair of wires that go the arduino board, but still, an Arduino Pro Mini or an Arduino Nano is smaller than the phone charger.&#xD;&#xA;&#xD;&#xA;You will probably have to do something like that.&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/7/7c/Wall_wart_opened.JPG/800px-Wall_wart_opened.JPG&quot; &gt;&#xD;&#xA;&#xD;&#xA;**Because of the nature of conversion between AC and DC, there has to be some large parts.** I'm not going to go into the specifics because that is what EE is for. There is usually a diode bridge (because AC waveforms reverse the current ~60 times a second) and a transformer (to lower the voltage for the diode bridge). They almost always include a regulator and a capacitor to make sure voltage is exact and it outputs a &quot;clean&quot; power supply.&#xD;&#xA;&#xD;&#xA;[This adapter](http://www.amazon.co.uk/Xcessor-Compact-European-Wall-Charger/dp/B00DVLHZOE/ref=sr_1_1?s=electronics&amp;ie=UTF8&amp;qid=1395244016&amp;sr=1-1&amp;keywords=220v+usb+adapter) seems to be the most compact adapter I can find. You'll never get something *near* the size you are desiring. I don't know the size of the Amazon adapter I gave a link for, but in the US (120V), iPhone chargers are very small and they should fit in a standard depth outlet box (with a little room left over for relays and such). If you *really* need to get smaller, I recommend using a ATtiny chip.&#xD;&#xA;####&#xD;&#xA;## How I recommend connecting this:&#xD;&#xA;I would avoid ripping this apart *at all costs*. If you *absolutely have to*, you might want to coat it with some clear non-conductive epoxy. Note: this may act as a thermal insulator, therefore reducing the lifespan of the part. You should just coil some wire around the prongs, and then melt a little solder onto each of the terminals. Then, cover that with electrical tape and pigtail (with a wire nut) into a source power line. Note: you probably are doing wiring that could be illegal in your area. Check your local building codes before attempting this.&#xD;&#xA;&#xD;&#xA;After that, attach a USB cord to the socket and to the Arduino or the ATtiny/ATmega328 chip 5V/GND input (of coarse, after cutting and stripping one end of the USB cord). I would also, after finalizing all the code and circuitry, seal that with some epoxy or somehow add it to an enclosure to make sure you don't fry your Arduino if a loose wire touches the Arduino circuitry.&#xD;&#xA;&#xD;&#xA;## If you don't feel safe doing any of the above, *don't do it*. You can live without a Arduino light switch.&#xD;&#xA;That being said, happy hacking! :P" />
  <row Id="2338" PostHistoryTypeId="2" PostId="830" RevisionGUID="351a9ed6-cadc-49bb-8e22-db0658a7ea18" CreationDate="2014-03-19T20:33:20.310" UserId="84" Text="I am currently playing with Arduino timers (on UNO currently) and I am building a library that  has a function that must be called every millisecond.&#xD;&#xA;&#xD;&#xA;There is plenty of code samples on Internet so I went with something that seemed perfect for my needs. I have then updated it to make it a reusable C++ class. &#xD;&#xA;&#xD;&#xA;Here is my code:&#xD;&#xA;&#xD;&#xA;    #define BIT(x) (0x01 &lt;&lt; (x))&#xD;&#xA;    &#xD;&#xA;    static volatile uint32_t milliseconds = 0;&#xD;&#xA;    &#xD;&#xA;    class Timer&#xD;&#xA;    {&#xD;&#xA;        public:&#xD;&#xA;        Timer()&#xD;&#xA;        {&#xD;&#xA;            // Disable interrupts&#xD;&#xA;            uint8_t savedStatus = SREG;&#xD;&#xA;            cli();&#xD;&#xA;            // Use Timer2 with 1 ms interrupts&#xD;&#xA;            // OC2A &amp; OC2B disconnected, mode 2 (CTC, Clear Timer on Compare match)&#xD;&#xA;            TCCR2A = BIT(WGM21);&#xD;&#xA;            // Don't force output compare (FOCA &amp; FOCB), mode 2, Clock Select clk/128 (CS = 5)&#xD;&#xA;            TCCR2B = BIT(CS22) | BIT(CS20);&#xD;&#xA;            // Set timer counter compare match (when value reached, 1ms has elapsed)&#xD;&#xA;            OCR2A = 125 - 1;&#xD;&#xA;            // Reset Timer2 counter&#xD;&#xA;            TCNT2 = 0;&#xD;&#xA;            // Set Timer2 interrupt mode (Set interrupt on OCR2A compare match)&#xD;&#xA;            TIMSK2 = BIT(OCIE2A);&#xD;&#xA;    &#xD;&#xA;            // Restore interrupt enabling state&#xD;&#xA;            SREG = savedStatus;&#xD;&#xA;        }&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    static void callEveryMillisecond(uint32_t ms)&#xD;&#xA;    {&#xD;&#xA;        // Do something here&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // Attach interrupt routine to the Timer Compare Interrupt&#xD;&#xA;    ISR(TIMER2_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;        milliseconds++;&#xD;&#xA;        callEveryMillisecond(millisecond);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;After checking [ATmega328 datasheet][1] (section 17) several times, I came to the conclusion that what I do in `Timer` class constructor above is correct, and for Arduino UNO, the values used must lead to one call of the ISR every ms:&#xD;&#xA;&#xD;&#xA; - CPU frequency = **16MHz**&#xD;&#xA; - Prescaler = **128**&#xD;&#xA; - -&gt; timer frequency = **16MHz/128 = 125KHz**&#xD;&#xA; - -&gt; max counter value = **125**&#xD;&#xA;&#xD;&#xA;I decided to use the **CTC** (Clear Timer on Compare match) mode, which means that when the timer `TCNT2` (which is incremented at 125KHz frequency), reaches `OCR2A` value, then it will trigger the ISR, and then will be reset on next tick; the additional tick to reset the counter explains why we use `125 - 1` for `OCR2A` and not just `125`.&#xD;&#xA;&#xD;&#xA;Now comes the weird stuff. In order to check that my code worked, I decided to blink the LED on pin 13 every 10 seconds, hence I have added the following code to my program:&#xD;&#xA;&#xD;&#xA;    static void callEveryMillisecond(uint32_t ms)&#xD;&#xA;    {&#xD;&#xA;        if (ms % 10000 == 0)&#xD;&#xA;            digitalWrite(13, digitalRead(13) ^ 1);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    static Timer timer;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Then I measured the time during which pin 13 LED is lit on (or off, both measures are the same). Measures are not very accurate (I just used my wristwatch) but good enough for my check.&#xD;&#xA;&#xD;&#xA;I was surprised to see the measured time to be about **20 seconds instead of 10s**.&#xD;&#xA;&#xD;&#xA;Initially I thought about a mismatch in CPU frequency, but after performing a lot of small changes, here is what I found which worked perfectly:&#xD;&#xA;&#xD;&#xA;    //static Timer timer;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        static Timer timer;&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;Just moving the `Timer` instance into `setup()` did the trick: my measures rightly indicated **10 seconds** between 2 states of the pin 13 LED.&#xD;&#xA;&#xD;&#xA;**Now my questions are:**&#xD;&#xA;&#xD;&#xA;1. Why the second code sample works perfectly, whereas the first does not?&#xD;&#xA;&#xD;&#xA;2. Is there, in standard Arduino included code, some code that would overwrite some of the settings I perform for Timer2 in `Timer::Timer()`?&#xD;&#xA;&#xD;&#xA;3. Is there a way to make the first code sample work? Note that I don't like the second sample because it does not seem natural coding, also, I will need access to `Timer` `timer` instance in several locations of my future program, hence it can't be possible if it is declared in the scope of `setup()`.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/Images/doc8161.pdf&#xD;&#xA;" />
  <row Id="2339" PostHistoryTypeId="1" PostId="830" RevisionGUID="351a9ed6-cadc-49bb-8e22-db0658a7ea18" CreationDate="2014-03-19T20:33:20.310" UserId="84" Text="Timer2 does not work as it should" />
  <row Id="2340" PostHistoryTypeId="3" PostId="830" RevisionGUID="351a9ed6-cadc-49bb-8e22-db0658a7ea18" CreationDate="2014-03-19T20:33:20.310" UserId="84" Text="&lt;arduino-uno&gt;&lt;c++&gt;&lt;timers&gt;" />
  <row Id="2341" PostHistoryTypeId="2" PostId="831" RevisionGUID="0ebeec2b-20d6-46f0-a96b-102ec4a5eb09" CreationDate="2014-03-19T21:04:16.180" UserId="84" Text="Nowadays, most smartphones come with a charger that is linked to the USB plug of the phone.&#xD;&#xA;&#xD;&#xA;The charger for my HTC says: **5V**, **1A**, I guess this voltage must be regulated (but I haven't checked it has the charger is sealed).&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;The charger itself has a female USB socket on which you can plug any USB cord to link to your Arduino.&#xD;&#xA;&#xD;&#xA;**IMPORTANT!** I have never tried it myself! I would not bet my life on it! It would be wise to check the output voltage is well regulated.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/NYLJn.png" />
  <row Id="2342" PostHistoryTypeId="2" PostId="832" RevisionGUID="226a6b85-d5d6-4bff-9365-054f7536e9d5" CreationDate="2014-03-19T21:20:24.353" UserId="722" Text="Note that&#xD;&#xA;&#xD;&#xA;    typedef struct { ... } Foo;&#xD;&#xA;&#xD;&#xA;is obsolete in C++ and you should just use&#xD;&#xA;&#xD;&#xA;    struct Foo { ... };&#xD;&#xA;&#xD;&#xA;It's not very clear in the answers but the other effect of structs is public inheritance by default vs private inheritance by default with classes.&#xD;&#xA;&#xD;&#xA;As mentioned by others, using struct is generally a convention for POD types.&#xD;&#xA;&#xD;&#xA;Also technically 'struct vs object' should be 'struct vs class' (as instantiating a struct or a class still gives an object)." />
  <row Id="2343" PostHistoryTypeId="2" PostId="833" RevisionGUID="709beab6-43b6-4a98-8ea3-ab46d8da3e82" CreationDate="2014-03-19T21:35:17.490" UserId="723" Text="&gt; In terms of memory, what difference will this make?&#xD;&#xA;&#xD;&#xA;None. Structs and classes are the same thing, differing only in protection levels, and instantiating either creates an 'object'.&#xD;&#xA;&#xD;&#xA;&gt; still see the struct technique being used heavily - why is this?&#xD;&#xA;&#xD;&#xA;Less typing if you're not trying to hide data members." />
  <row Id="2344" PostHistoryTypeId="2" PostId="834" RevisionGUID="4c8f5977-e70e-436b-bd85-4f7b5a0b1fa8" CreationDate="2014-03-19T21:38:42.387" UserId="723" Text="Your factor should be done simply because it's better code, not because it's smaller. The advantage is that it's easier to modify.&#xD;&#xA;&#xD;&#xA;If making the code size smaller results in a loss of clarity (not so in your case), then you should probably view it as a [premature optimization](http://c2.com/cgi/wiki?PrematureOptimization).&#xD;&#xA;" />
  <row Id="2345" PostHistoryTypeId="5" PostId="821" RevisionGUID="7547511d-3063-47a5-a034-5bf04f14dad4" CreationDate="2014-03-19T21:45:00.530" UserId="639" Comment="edited body" Text="An XBee Series 2 is set to `Router AT` whose `TX` and `RX` pins are connected to an Arduino Nano's `Rx` and `Tx` pins respectively. The arduino is connected to a Mac OSX via USB.&#xD;&#xA;&#xD;&#xA;A second XBee Series 2 is connected to a Windows system via USB. It is set to `Coordinator API` mode.&#xD;&#xA;&#xD;&#xA;Using the sketch below on the Arduino, a packet is sent from the `Router AT` Xbee to the `Coordinator API` Xbee, which is seen by `XCTU` as a Explicit RX frame. However the Arduino LED should blink once if it received a reply packet (should it?)&#xD;&#xA;&#xD;&#xA;On another test, I wrote a script to send a frame for the `Coordinator API` Xbee to send to the `Router AT` Xbee. Once again the Arduino LED does not blink, and nothing is seen using Arduino's Serial Monitor.&#xD;&#xA;&#xD;&#xA;**Testing the `Coordinator API` XBee**&#xD;&#xA;&#xD;&#xA;Using the same script to send a packet from `Coordinator API` Xbee to itself, the packet was received as well as a delivery confirmation packet. This shows that both the `Coordinator API` Xbee and the script are working.&#xD;&#xA;&#xD;&#xA;	// Delivery confirmation &#xD;&#xA;	received:  { type: 144,&#xD;&#xA;	  remote64: '0013a20040a74613',&#xD;&#xA;	  remote16: '0000',&#xD;&#xA;	  receiveOptions: 1,&#xD;&#xA;	  data: [ 116 ] }&#xD;&#xA;&#xD;&#xA;	// Received the packet sent to itself	  &#xD;&#xA;	received:  { type: 139,&#xD;&#xA;	  id: 1,&#xD;&#xA;	  remote16: '0000',&#xD;&#xA;	  transmitRetryCount: 0,&#xD;&#xA;	  deliveryStatus: 0,&#xD;&#xA;	  discoveryStatus: 0 }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Testing the Arduno Sketch Code**&#xD;&#xA;&#xD;&#xA;Using the same Arduino sketch which continuously sends API frames to the `Coordinator`, I connected the `Router AT` XBee's `RX` pin to Arduino's `RX` pin, so the frames the arduino are sending out are going back into its `RX` pin.&#xD;&#xA;&#xD;&#xA;This causes the Arduino's LED to light up! So there is nothing wrong with the code.&#xD;&#xA;&#xD;&#xA;**Problem:** Does this mean the `Router AT` XBee is not configured properly? I do not think its `TX` pin is damaged because `XCTU` can still read the settings off this XBee. Any ideas on how we can troubleshoot this? Thanks!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Arduino Sketch (Connected to Router Xbee)**&#xD;&#xA;&#xD;&#xA;    #include &lt;XBee.h&gt;&#xD;&#xA;&#xD;&#xA;    XBee xbee = XBee();&#xD;&#xA;    uint8_t payload[] = { 0, 0 };&#xD;&#xA;&#xD;&#xA;    // SH + SL Address of receiving XBee&#xD;&#xA;    XBeeAddress64 addr64 = XBeeAddress64(0x0013a200, 0x40a74613);&#xD;&#xA;    ZBTxRequest zbTx = ZBTxRequest(addr64, payload, sizeof(payload));&#xD;&#xA;    ZBTxStatusResponse txStatus = ZBTxStatusResponse();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;        &#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;        xbee.setSerial(Serial);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;&#xD;&#xA;        xbee.send(zbTx);&#xD;&#xA;        delay(1000);&#xD;&#xA;        &#xD;&#xA;        xbee.readPacket();&#xD;&#xA;        if (xbee.getResponse().isAvailable()) {&#xD;&#xA;&#xD;&#xA;            // Response received, blink LED once&#xD;&#xA;            Serial.println('resposne!');&#xD;&#xA;            digitalWrite(13, HIGH);&#xD;&#xA;            delay(1000);&#xD;&#xA;            digitalWrite(13, LOW);&#xD;&#xA;            delay(1000);&#xD;&#xA;        }&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2346" PostHistoryTypeId="5" PostId="827" RevisionGUID="f54a7ed8-1aae-4c05-aba2-53590249a012" CreationDate="2014-03-19T21:51:26.480" UserId="84" Comment="fixed small problem with C++ keyword (delete is opposite of new in C++; free the opposite of malloc in C)" Text="&gt; What are the advantages of C++ vs the Arduino language when using Arduino? I'm experienced in preprocessed languages like JavaScript, PHP, and have fiddled with languages like Java and Visual Basic.&#xD;&#xA;&#xD;&#xA;First, the Arduino compiler/IDE accepts C and C++ as-is.  In fact many of the libraries are written in C++.  Much of the underlying system is not object oriented, but it could be.&#xD;&#xA;&#xD;&#xA;Thus, &quot;The arduino language&quot; is C++ or C.&#xD;&#xA;&#xD;&#xA;C++ is not garbage collected.  It does manage variables in scope - if you write:&#xD;&#xA;&#xD;&#xA;    int led = 13;&#xD;&#xA;&#xD;&#xA;    void blinkTimes(int value)&#xD;&#xA;    {&#xD;&#xA;       int i;&#xD;&#xA;&#xD;&#xA;       for(i=0;i&lt;value;i++)&#xD;&#xA;       {&#xD;&#xA;          digitalWrite(led, HIGH);&#xD;&#xA;          delay(1000);&#xD;&#xA;          digitalWrite(led, LOW);&#xD;&#xA;          delay(1000);&#xD;&#xA;       }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Then you'll find that `led` and `i` don't grow or leak, no matter how many times you call `blinkTimes`.&#xD;&#xA;&#xD;&#xA;If `i` were a class, it would similarly be disposed of once the function ended.  So as long as you aren't using `new` or similar memory allocation functions to create new objects, then you won't have to worry about leaks.&#xD;&#xA;&#xD;&#xA;You may still run out of memory, if you create huge classes and use a lot of them in deeply nested functions, but in general you aren't going to run into trouble until you start dealing with `new` and `free` functions.&#xD;&#xA;&#xD;&#xA;If you are using `new`, then you'll have to call `delete` at appropriate times.  C++, and by extension Arduino, has no automatic garbage collection, you have to explicitly manage your own memory." />
  <row Id="2347" PostHistoryTypeId="24" PostId="827" RevisionGUID="f54a7ed8-1aae-4c05-aba2-53590249a012" CreationDate="2014-03-19T21:51:26.480" Comment="Proposed by 84 approved by 8, 136 edit id of 242" />
  <row Id="2348" PostHistoryTypeId="5" PostId="658" RevisionGUID="9c33f5ff-6204-4635-a43d-9ffc68814d76" CreationDate="2014-03-19T21:52:48.000" UserId="136" Comment="Object -&gt; Class" Text="C on embedded systems has traditionally use structs to hold structured data.&#xD;&#xA;&#xD;&#xA;Arduino brings C++ to the table, so we can use classes instead.&#xD;&#xA;&#xD;&#xA;Lets say we have two different data structures which could be considered very similar:&#xD;&#xA;&#xD;&#xA;    typedef struct &#xD;&#xA;    {&#xD;&#xA;    	int valueOne;&#xD;&#xA;    	int valueTwo;&#xD;&#xA;    	int valueThree;&#xD;&#xA;    } value_t;&#xD;&#xA;&#xD;&#xA;and:&#xD;&#xA;&#xD;&#xA;    class Value&#xD;&#xA;    {&#xD;&#xA;    	public:&#xD;&#xA;    		int valueOne;&#xD;&#xA;    		int valueTwo;&#xD;&#xA;    		int valueThree;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;In terms of memory, what difference will this make? &#xD;&#xA;&#xD;&#xA;I still see the struct technique being used heavily - why is this?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2349" PostHistoryTypeId="4" PostId="658" RevisionGUID="9c33f5ff-6204-4635-a43d-9ffc68814d76" CreationDate="2014-03-19T21:52:48.000" UserId="136" Comment="Object -&gt; Class" Text="What overheads and other considerations are there when using a struct vs a class?" />
  <row Id="2350" PostHistoryTypeId="2" PostId="835" RevisionGUID="c5491f4c-d81e-4c66-9961-993d7b29dc05" CreationDate="2014-03-19T22:41:58.290" UserId="220" Text="**I don't know if that heater will work for sure with this approach because the buttons are weird.** However, I am 99% sure this will work.&#xD;&#xA;&#xD;&#xA;&gt;![][1]&#xD;&#xA;&#xD;&#xA;*(From http://keshavsaharia.com/2012/12/01/coffeeduino/)*&#xD;&#xA;&#xD;&#xA;Basically here's what you do:&#xD;&#xA;&#xD;&#xA; 1. Disassemble the control panel to find the PCB where the buttons are mounted. Find which button you want to simulate a press of.&#xD;&#xA; 2. Find the solder joint where the button meets the PCB.&#xD;&#xA; 3. Solder a wire to the two terminals that are connected. Some buttons have three or four terminals: look at the traces on the PCB to see which buttons are connected.&#xD;&#xA; 4. Wire the relay with the two wires connected so the relay acts as a switch.&#xD;&#xA; 5. Make the proper connections to the Arduino board to control the relay.&#xD;&#xA;&#xD;&#xA;In code, you can just turn the relay on for a quarter of a second or so. Then, the IC on the heater will react like you pushed the button.&#xD;&#xA;&#xD;&#xA;Make sure to seal all of this up and make sure you don't accidentally short out any of the wires. I would say to also isolate the Arduino and relay to make sure that you don't electrocute yourself at all if something goes wrong.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/qx3F5.png" />
  <row Id="2351" PostHistoryTypeId="2" PostId="836" RevisionGUID="7862c704-b662-4b3d-90cf-3f0f90496b29" CreationDate="2014-03-19T23:04:27.167" UserId="304" Text="As I mentioned in my comments to your question, if you are using [this][1] library&#xD;&#xA;then it doesn't actually support AT mode. In fact, AT mode (otherwise known as Transparent Mode) is simply attached to the `Serial` port and accessed directly through the `Serial` object.&#xD;&#xA;&#xD;&#xA;Example: put this into your Arduino attached to the AT Router.&#xD;&#xA;&#xD;&#xA;    #define LED 13&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;        pinMode(LED, OUTPUT);&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;        Serial.println(&quot;\nXBee AT communications test&quot;);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      static unsigned long previous = millis()/1000;&#xD;&#xA;      if(previous != millis()/1000){&#xD;&#xA;        previous = millis()/1000;&#xD;&#xA;        char buffer[5];    &#xD;&#xA;        sprintf(buffer,&quot;%04i&quot;,previous);&#xD;&#xA;        Serial.println(buffer);&#xD;&#xA;       digitalWrite(LED, !digitalRead(LED)); &#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Then open the console on the XCTU software on the API Coordinator watch the packets.&#xD;&#xA;&#xD;&#xA; ![look at packet 0102][2] &#xD;&#xA;&#xD;&#xA;You will see above the received packets from the router. Because the coordinator is in `API` mode, you see it like this. (In `AT` mode, you will see the raw packets.&#xD;&#xA;&#xD;&#xA;Ichose numbers to send because they are easy to read in this form. Packet `0102` appears in the packets data as `30 31 30 32 0D 0A`&#xD;&#xA;&#xD;&#xA;In `AT` mode there is no packet confirmation, validations, status or anything. They are all handled &quot;transparently&quot;. &#xD;&#xA;&#xD;&#xA;As a side note, I've seen many references that both XBees need to be in the same mode. That is, in fact, incorrect. If we modify our source to include `Serial.read` you would see data the other way as well.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://code.google.com/p/xbee-arduino/&#xD;&#xA;  [2]: http://i.stack.imgur.com/dEu73.png" />
  <row Id="2352" PostHistoryTypeId="2" PostId="837" RevisionGUID="0cba222b-cef1-4c7f-9386-8eca9824b083" CreationDate="2014-03-19T23:18:25.310" UserId="730" Text="what I'm trying to do is : if any of the values stored in the elements of the array are larger than 2 , set the value of that element in the array to zero&#xD;&#xA;&#xD;&#xA;    int  colom[] = {&#xD;&#xA;    0-var1,1-var3,2-var2,3-var6,4-var7};&#xD;&#xA;    if (colom[]&gt;2){&#xD;&#xA;    colom[] = 0;&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;but obviously it cant run the code because I didn't specify which index but this is the point I dont want it to check one element only , I want it to check the whole array" />
  <row Id="2353" PostHistoryTypeId="1" PostId="837" RevisionGUID="0cba222b-cef1-4c7f-9386-8eca9824b083" CreationDate="2014-03-19T23:18:25.310" UserId="730" Text="Check to see if all the values in an array are larger than x and set them to zero" />
  <row Id="2354" PostHistoryTypeId="3" PostId="837" RevisionGUID="0cba222b-cef1-4c7f-9386-8eca9824b083" CreationDate="2014-03-19T23:18:25.310" UserId="730" Text="&lt;arduino-uno&gt;" />
  <row Id="2355" PostHistoryTypeId="10" PostId="837" RevisionGUID="39b23e23-4b19-4e92-835e-2a98ca387b0e" CreationDate="2014-03-19T23:25:15.110" UserId="42" Comment="102" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;}]}" />
  <row Id="2356" PostHistoryTypeId="2" PostId="838" RevisionGUID="bf7c8f71-a530-4f2c-bdda-316f84a71247" CreationDate="2014-03-19T23:51:35.850" UserId="8" Text="I think the problem is very simple. In `TIMER2_COMPA_vect`, you have this code:&#xD;&#xA;&#xD;&#xA;    ISR(TIMER2_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;        milliseconds++;&#xD;&#xA;        callEveryMillisecond(millisecond);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You have the variable `milliseconds`, which you increment, and then you call the `callEveryMillisecond` function and pass the variable `millisecond` (without the `s`)&#xD;&#xA;" />
  <row Id="2357" PostHistoryTypeId="5" PostId="830" RevisionGUID="187c1e6d-01b8-4911-9bb8-1984e5b60232" CreationDate="2014-03-19T23:53:39.783" UserId="84" Comment="fixed typo in sample code that let people think the code cannot compile" Text="I am currently playing with Arduino timers (on UNO currently) and I am building a library that  has a function that must be called every millisecond.&#xD;&#xA;&#xD;&#xA;There is plenty of code samples on Internet so I went with something that seemed perfect for my needs. I have then updated it to make it a reusable C++ class. &#xD;&#xA;&#xD;&#xA;Here is my code:&#xD;&#xA;&#xD;&#xA;    #define BIT(x) (0x01 &lt;&lt; (x))&#xD;&#xA;    &#xD;&#xA;    static volatile uint32_t milliseconds = 0;&#xD;&#xA;    &#xD;&#xA;    class Timer&#xD;&#xA;    {&#xD;&#xA;        public:&#xD;&#xA;        Timer()&#xD;&#xA;        {&#xD;&#xA;            // Disable interrupts&#xD;&#xA;            uint8_t savedStatus = SREG;&#xD;&#xA;            cli();&#xD;&#xA;            // Use Timer2 with 1 ms interrupts&#xD;&#xA;            // OC2A &amp; OC2B disconnected, mode 2 (CTC, Clear Timer on Compare match)&#xD;&#xA;            TCCR2A = BIT(WGM21);&#xD;&#xA;            // Don't force output compare (FOCA &amp; FOCB), mode 2, Clock Select clk/128 (CS = 5)&#xD;&#xA;            TCCR2B = BIT(CS22) | BIT(CS20);&#xD;&#xA;            // Set timer counter compare match (when value reached, 1ms has elapsed)&#xD;&#xA;            OCR2A = 125 - 1;&#xD;&#xA;            // Reset Timer2 counter&#xD;&#xA;            TCNT2 = 0;&#xD;&#xA;            // Set Timer2 interrupt mode (Set interrupt on OCR2A compare match)&#xD;&#xA;            TIMSK2 = BIT(OCIE2A);&#xD;&#xA;    &#xD;&#xA;            // Restore interrupt enabling state&#xD;&#xA;            SREG = savedStatus;&#xD;&#xA;        }&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    static void callEveryMillisecond(uint32_t ms)&#xD;&#xA;    {&#xD;&#xA;        // Do something here&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // Attach interrupt routine to the Timer Compare Interrupt&#xD;&#xA;    ISR(TIMER2_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;        milliseconds++;&#xD;&#xA;        callEveryMillisecond(milliseconds);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;After checking [ATmega328 datasheet][1] (section 17) several times, I came to the conclusion that what I do in `Timer` class constructor above is correct, and for Arduino UNO, the values used must lead to one call of the ISR every ms:&#xD;&#xA;&#xD;&#xA; - CPU frequency = **16MHz**&#xD;&#xA; - Prescaler = **128**&#xD;&#xA; - -&gt; timer frequency = **16MHz/128 = 125KHz**&#xD;&#xA; - -&gt; max counter value = **125**&#xD;&#xA;&#xD;&#xA;I decided to use the **CTC** (Clear Timer on Compare match) mode, which means that when the timer `TCNT2` (which is incremented at 125KHz frequency), reaches `OCR2A` value, then it will trigger the ISR, and then will be reset on next tick; the additional tick to reset the counter explains why we use `125 - 1` for `OCR2A` and not just `125`.&#xD;&#xA;&#xD;&#xA;Now comes the weird stuff. In order to check that my code worked, I decided to blink the LED on pin 13 every 10 seconds, hence I have added the following code to my program:&#xD;&#xA;&#xD;&#xA;    static void callEveryMillisecond(uint32_t ms)&#xD;&#xA;    {&#xD;&#xA;        if (ms % 10000 == 0)&#xD;&#xA;            digitalWrite(13, digitalRead(13) ^ 1);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    static Timer timer;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Then I measured the time during which pin 13 LED is lit on (or off, both measures are the same). Measures are not very accurate (I just used my wristwatch) but good enough for my check.&#xD;&#xA;&#xD;&#xA;I was surprised to see the measured time to be about **20 seconds instead of 10s**.&#xD;&#xA;&#xD;&#xA;Initially I thought about a mismatch in CPU frequency, but after performing a lot of small changes, here is what I found which worked perfectly:&#xD;&#xA;&#xD;&#xA;    //static Timer timer;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        static Timer timer;&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;Just moving the `Timer` instance into `setup()` did the trick: my measures rightly indicated **10 seconds** between 2 states of the pin 13 LED.&#xD;&#xA;&#xD;&#xA;**Now my questions are:**&#xD;&#xA;&#xD;&#xA;1. Why the second code sample works perfectly, whereas the first does not?&#xD;&#xA;&#xD;&#xA;2. Is there, in standard Arduino included code, some code that would overwrite some of the settings I perform for Timer2 in `Timer::Timer()`?&#xD;&#xA;&#xD;&#xA;3. Is there a way to make the first code sample work? Note that I don't like the second sample because it does not seem natural coding, also, I will need access to `Timer` `timer` instance in several locations of my future program, hence it can't be possible if it is declared in the scope of `setup()`.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/Images/doc8161.pdf&#xD;&#xA;" />
  <row Id="2358" PostHistoryTypeId="2" PostId="839" RevisionGUID="0c60a425-8898-4cb4-8814-5cab384cd778" CreationDate="2014-03-19T23:54:27.277" UserId="730" Text="I have a list of set-ups and I only have 2 rows in the lcd , I'm trying to scroll down for the moment and Im doing this by changing the row in the setcurseor function  to either 0 or 1 .&#xD;&#xA;&#xD;&#xA;However since that Ill be having about 10 set-ups I used an equation that will change the rows to 0 and one for the ones I want to display and a negative number for those that I dont want to appear .&#xD;&#xA;The problem is when setting the cursor's row to -1 or  2 it will ignore the one with row one (which is the 2nd row  )&#xD;&#xA;&#xD;&#xA;is there a way that I can overcome this problem ? by setting it to a row that will not appear on my lcd ?&#xD;&#xA;&#xD;&#xA;          int  colom[5] = {&#xD;&#xA;        0-goDown,1-goDown,2-goDown,3-goDown,4-goDown  };&#xD;&#xA;    for (int i = 0; i &lt; 4; i++) {&#xD;&#xA;        if (colom[i] &gt; 1) colom[i] = -1;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;      lcd.setCursor(0, colom[0]);&#xD;&#xA;      lcd.print(&quot;choise 1 &quot;);&#xD;&#xA;      lcd.setCursor(0, colom[1]);&#xD;&#xA;      lcd.print(&quot;choise 2 &quot;);&#xD;&#xA;      lcd.setCursor(0, colom[2]);&#xD;&#xA;      lcd.print(&quot;choise 3 &quot;);&#xD;&#xA;      lcd.setCursor(0, colom[3]);&#xD;&#xA;      lcd.print(&quot;choise 4 &quot;);&#xD;&#xA;      lcd.setCursor(0, colom[4]);&#xD;&#xA;      lcd.print(&quot;choise 5 &quot;);&#xD;&#xA;&#xD;&#xA;so here goDown is 0 so choice 1 and 2 should appear , but Im only getting choice 1 and in the second row its changing quickly between 2 and 5 , its not constant &#xD;&#xA;&#xD;&#xA;I thought about doing an if condition for each choice but that will be a lot of code to write and it wont be efficient for my application " />
  <row Id="2359" PostHistoryTypeId="1" PostId="839" RevisionGUID="0c60a425-8898-4cb4-8814-5cab384cd778" CreationDate="2014-03-19T23:54:27.277" UserId="730" Text="LCD scrolling down problem" />
  <row Id="2360" PostHistoryTypeId="3" PostId="839" RevisionGUID="0c60a425-8898-4cb4-8814-5cab384cd778" CreationDate="2014-03-19T23:54:27.277" UserId="730" Text="&lt;arduino-uno&gt;&lt;lcd&gt;" />
  <row Id="2361" PostHistoryTypeId="5" PostId="838" RevisionGUID="2dc12c2e-4d8f-4dd8-b9ca-692811efaaab" CreationDate="2014-03-19T23:59:32.450" UserId="8" Comment="new ideas..." Text="In your setup function, you need to instantiate your timer, like this:&#xD;&#xA;&#xD;&#xA;    static Timer timer;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        timer = new Timer();                       &lt;&lt;&lt;--- here&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    }" />
  <row Id="2362" PostHistoryTypeId="2" PostId="840" RevisionGUID="c8740d1b-6881-4968-9320-388c31674e2b" CreationDate="2014-03-20T00:36:16.610" UserId="723" Text="This is a bad strategy in general. You should not be issuing print calls for things you *don't* want to print and relying on the lcd library to filter for you because they're out of bounds.&#xD;&#xA;&#xD;&#xA;Call print for only the choices you want to display.&#xD;&#xA;&#xD;&#xA;    char* menu[] = {&#xD;&#xA;        &quot;choice 1&quot;,&#xD;&#xA;        &quot;choice 2&quot;,&#xD;&#xA;        &quot;choice 3&quot;,&#xD;&#xA;        &quot;choice 4&quot;,&#xD;&#xA;        &quot;choice 5&quot;,&#xD;&#xA;    };&#xD;&#xA;    const int numMenuItems = sizeof menu / sizeof *menu;&#xD;&#xA;    const int numLcdRows = 2;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // start out at the top of the menu&#xD;&#xA;    int scrollPos = 0;&#xD;&#xA;&#xD;&#xA;    void drawMenu() {&#xD;&#xA;        for (int i=0; i &lt; numLcdRows; ++i) {&#xD;&#xA;            lcd.setCursor(0, i); &#xD;&#xA;            lcd.print(menu[i + scrollPos]);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;To scroll up or down, just adjust the scroll offset:&#xD;&#xA;&#xD;&#xA;    inline void scrollUp() {&#xD;&#xA;        if (scrollPos &gt; 0)&#xD;&#xA;            scrollPos--;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    inline void scrollDown() {&#xD;&#xA;        if (scrollPos &lt; numMenuItems - numLcdRows - 1)&#xD;&#xA;            scrollPos++;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Note this is untested code written for a library I've never seen (just inferring how it works from your post); it's for illustration purposes only.&#xD;&#xA;" />
  <row Id="2363" PostHistoryTypeId="5" PostId="839" RevisionGUID="4779283e-bcb1-45e1-872d-980bdec77c95" CreationDate="2014-03-20T00:39:35.633" UserId="730" Comment="added 77 characters in body" Text="I have a list of set-ups and I only have 2 rows in the lcd , I'm trying to scroll down for the moment and Im doing this by changing the row in the setcurseor function  to either 0 or 1 .&#xD;&#xA;&#xD;&#xA;However since that Ill be having about 10 set-ups I used an equation that will change the rows to 0 and one for the ones I want to display and a negative number for those that I dont want to appear .&#xD;&#xA;The problem is when setting the cursor's row to -1 or  2 it will ignore the one with row one (which is the 2nd row  )&#xD;&#xA;&#xD;&#xA;is there a way that I can overcome this problem ? by setting it to a row that will not appear on my lcd ?&#xD;&#xA;im using the #include &lt;LiquidCrystal.h&gt;&#xD;&#xA;and I already set  lcd.begin(16, 2);&#xD;&#xA;&#xD;&#xA;          int  colom[5] = {&#xD;&#xA;        0-goDown,1-goDown,2-goDown,3-goDown,4-goDown  };&#xD;&#xA;    for (int i = 0; i &lt; 4; i++) {&#xD;&#xA;        if (colom[i] &gt; 1) colom[i] = -1;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;      lcd.setCursor(0, colom[0]);&#xD;&#xA;      lcd.print(&quot;choise 1 &quot;);&#xD;&#xA;      lcd.setCursor(0, colom[1]);&#xD;&#xA;      lcd.print(&quot;choise 2 &quot;);&#xD;&#xA;      lcd.setCursor(0, colom[2]);&#xD;&#xA;      lcd.print(&quot;choise 3 &quot;);&#xD;&#xA;      lcd.setCursor(0, colom[3]);&#xD;&#xA;      lcd.print(&quot;choise 4 &quot;);&#xD;&#xA;      lcd.setCursor(0, colom[4]);&#xD;&#xA;      lcd.print(&quot;choise 5 &quot;);&#xD;&#xA;&#xD;&#xA;so here goDown is 0 so choice 1 and 2 should appear , but Im only getting choice 1 and in the second row its changing quickly between 2 and 5 , its not constant &#xD;&#xA;&#xD;&#xA;I thought about doing an if condition for each choice but that will be a lot of code to write and it wont be efficient for my application " />
  <row Id="2364" PostHistoryTypeId="5" PostId="840" RevisionGUID="63380492-7c17-44dd-9f7b-5033e1c90067" CreationDate="2014-03-20T00:56:46.543" UserId="723" Comment="fix off-by-one error" Text="This is a bad strategy in general. You should not be issuing print calls for things you *don't* want to print and relying on the lcd library to filter for you because they're out of bounds.&#xD;&#xA;&#xD;&#xA;Call print for only the choices you want to display.&#xD;&#xA;&#xD;&#xA;    char* menu[] = {&#xD;&#xA;        &quot;choice 1&quot;,&#xD;&#xA;        &quot;choice 2&quot;,&#xD;&#xA;        &quot;choice 3&quot;,&#xD;&#xA;        &quot;choice 4&quot;,&#xD;&#xA;        &quot;choice 5&quot;,&#xD;&#xA;    };&#xD;&#xA;    const int numMenuItems = sizeof menu / sizeof *menu;&#xD;&#xA;    const int numLcdRows = 2;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // start out at the top of the menu&#xD;&#xA;    int scrollPos = 0;&#xD;&#xA;&#xD;&#xA;    void drawMenu() {&#xD;&#xA;        for (int i=0; i &lt; numLcdRows; ++i) {&#xD;&#xA;            lcd.setCursor(0, i); &#xD;&#xA;            lcd.print(menu[i + scrollPos]);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;To scroll up or down, just adjust the scroll offset:&#xD;&#xA;&#xD;&#xA;    inline void scrollUp() {&#xD;&#xA;        if (scrollPos &gt; 0)&#xD;&#xA;            scrollPos--;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    inline void scrollDown() {&#xD;&#xA;        if (scrollPos &lt; numMenuItems - numLcdRows)&#xD;&#xA;            scrollPos++;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Note this is untested code written for a library I've never seen (just inferring how it works from your post); it's for illustration purposes only.&#xD;&#xA;" />
  <row Id="2365" PostHistoryTypeId="5" PostId="836" RevisionGUID="414c6d84-9d7d-4171-a593-833fa0d8499c" CreationDate="2014-03-20T01:21:13.243" UserId="304" Comment="added reverse communication" Text="As I mentioned in my comments to your question, if you are using [this][1] library&#xD;&#xA;then it doesn't actually support AT mode. In fact, AT mode (otherwise known as Transparent Mode) is simply attached to the `Serial` port and accessed directly through the `Serial` object.&#xD;&#xA;&#xD;&#xA;Example: put this into your Arduino attached to the AT Router.&#xD;&#xA;&#xD;&#xA;    #define LED 13&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;        pinMode(LED, OUTPUT);&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;        Serial.println(&quot;\nXBee AT communications test&quot;);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      static unsigned long previous = millis()/1000;&#xD;&#xA;      if(previous != millis()/1000){&#xD;&#xA;        previous = millis()/1000;&#xD;&#xA;        char buffer[5];    &#xD;&#xA;        sprintf(buffer,&quot;%04i&quot;,previous);&#xD;&#xA;        Serial.println(buffer);&#xD;&#xA;       digitalWrite(LED, !digitalRead(LED)); &#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Then open the console on the XCTU software on the API Coordinator watch the packets.&#xD;&#xA;&#xD;&#xA; ![look at packet 0102][2] &#xD;&#xA;&#xD;&#xA;You will see above the received packets from the router. Because the coordinator is in `API` mode, you see it like this. (In `AT` mode, you will see the raw packets.&#xD;&#xA;&#xD;&#xA;Ichose numbers to send because they are easy to read in this form. Packet `0102` appears in the packets data as `30 31 30 32 0D 0A`&#xD;&#xA;&#xD;&#xA;In `AT` mode there is no packet confirmation, validations, status or anything. They are all handled &quot;transparently&quot;. &#xD;&#xA;&#xD;&#xA;As a side note, I've seen many references that both XBees need to be in the same mode. That is, in fact, incorrect. If we modify our source to include `Serial.read` you would see data the other way as well.&#xD;&#xA;&#xD;&#xA;**edit:** I thought I would add communications between `AT Router` and `API Coordinator`. I have modified the code in the `Router` to receive a constructed packet from the `Coordinator` via the XCTU software. &#xD;&#xA;&#xD;&#xA;    #define LED 13&#xD;&#xA;    &#xD;&#xA;    boolean serialComplete = false;&#xD;&#xA;    char bufferIn[64];&#xD;&#xA;    char bufferOut[5];&#xD;&#xA;    int count=0;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;        Serial.println(&quot;\nXBee AT communications test&quot;);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      static unsigned long previous = millis()/1000;&#xD;&#xA;      if(serialComplete) {&#xD;&#xA;        Serial.println(bufferIn);&#xD;&#xA;        serialComplete=false;&#xD;&#xA;        count = 0;&#xD;&#xA;        memset(bufferIn,0,sizeof(bufferIn));&#xD;&#xA;        digitalWrite(LED,!digitalRead(LED)); &#xD;&#xA;      }&#xD;&#xA;      if(previous != millis()/1000){&#xD;&#xA;        previous = millis()/1000;&#xD;&#xA;        sprintf(bufferOut,&quot;%04u&quot;,(uint16_t)previous);&#xD;&#xA;        Serial.println(bufferOut);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void serialEvent() {&#xD;&#xA;      while (Serial.available()) {&#xD;&#xA;        char inChar = (char)Serial.read(); &#xD;&#xA;        if (inChar == '\n' || inChar == '\0') {&#xD;&#xA;          bufferIn[count++]=0;&#xD;&#xA;          serialComplete = true;&#xD;&#xA;        } else {&#xD;&#xA;          bufferIn[count++] = inChar;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Then in XCTU construct a packet for the `Coordinator`. I'm using version 6.1.0. &#xD;&#xA;&#xD;&#xA;![add API frame][3] &#xD;&#xA;&#xD;&#xA;and click &quot;the create frame using form generator tool&quot;&#xD;&#xA;&#xD;&#xA;![form generator tool][4]&#xD;&#xA;&#xD;&#xA;here is the packet being received by the router. I am only sending `9999` `nul` terminated.&#xD;&#xA;&#xD;&#xA;![result][5]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Then once the pair are running, you can send the constructed packet from the XCTU software and it will be received by the router.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://code.google.com/p/xbee-arduino/&#xD;&#xA;  [2]: http://i.stack.imgur.com/dEu73.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/C2tmh.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/QtGD0.png&#xD;&#xA;  [5]: http://i.stack.imgur.com/db0eF.png" />
  <row Id="2366" PostHistoryTypeId="2" PostId="841" RevisionGUID="40be5d0f-4387-41cf-acbb-e170f62b823e" CreationDate="2014-03-20T01:30:18.720" UserId="8" Text="I have written some abstraction code for handling LCD menus, located here: https://github.com/red-green/Arduino_Mobile_OS&#xD;&#xA;&#xD;&#xA;Here is the main snippet:&#xD;&#xA;&#xD;&#xA;    byte menu(String title,const String* strings,byte length) {&#xD;&#xA;      boolean select, esc; static byte item, selection;&#xD;&#xA;      select = false;&#xD;&#xA;      esc = false;&#xD;&#xA;      item = 1;&#xD;&#xA;      lcd.clear();&#xD;&#xA;        lcd.setCursor(0,0);&#xD;&#xA;        lcd.print(title);&#xD;&#xA;        lcd.print(&quot;: &quot;);&#xD;&#xA;        lcd.print(item);&#xD;&#xA;        lcd.setCursor(0,1);&#xD;&#xA;        lcd.print(strings[item]);&#xD;&#xA;        delay(100);&#xD;&#xA;        &#xD;&#xA;      while (!select) {&#xD;&#xA;        uint8_t buttons = lcd.readButtons();&#xD;&#xA;        if (buttons) {&#xD;&#xA;        if (buttons &amp; BUTTON_UP) {&#xD;&#xA;          item--; &#xD;&#xA;        }&#xD;&#xA;        if (buttons &amp; BUTTON_DOWN) {&#xD;&#xA;          item++;&#xD;&#xA;        }&#xD;&#xA;        if (buttons &amp; BUTTON_LEFT) {&#xD;&#xA;          esc = true;&#xD;&#xA;        }  &#xD;&#xA;        if (buttons &amp; BUTTON_SELECT) {&#xD;&#xA;          selection = item;&#xD;&#xA;          select = true;&#xD;&#xA;        }&#xD;&#xA;      &#xD;&#xA;        item = constrain(item,1,length - 1);&#xD;&#xA;        lcd.clear();&#xD;&#xA;        lcd.setCursor(0,0);&#xD;&#xA;        lcd.print(title);&#xD;&#xA;        lcd.print(&quot;: &quot;);&#xD;&#xA;        lcd.print(item);&#xD;&#xA;        lcd.setCursor(0,1);&#xD;&#xA;        lcd.print(strings[item]);&#xD;&#xA;        if (esc) {&#xD;&#xA;          select = true;&#xD;&#xA;          selection = 0;&#xD;&#xA;        }&#xD;&#xA;        delay(100);&#xD;&#xA;      &#xD;&#xA;      }&#xD;&#xA;      } &#xD;&#xA;      return(selection);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You may need to change the button handling to work with your setup. To call, have an array of items before setup, like this:&#xD;&#xA;&#xD;&#xA;    const String utilmenuitems[6] = {&quot;back&quot;,&quot;Random Numbers&quot;,&quot;Uptime&quot;,&quot;Device Info&quot;};&#xD;&#xA;&#xD;&#xA;You can then call it like:&#xD;&#xA;&#xD;&#xA;    byte return = menu(&quot;Utilities&quot;,utilmenuitems,4);" />
  <row Id="2367" PostHistoryTypeId="2" PostId="842" RevisionGUID="18f82760-a8a4-4468-9c42-133e9f508d91" CreationDate="2014-03-20T01:42:15.390" UserId="304" Text="I don't have a PRO to play with, but I just looked at the [datasheet][1] and it appears that it SHOULD timeout after 60 seconds &#xD;&#xA;&#xD;&#xA;&gt; If no serial transaction is initiated within a 60 second timeout period, the bootloader times out and returns to &#xD;&#xA;the menu. If the upload is interrupted with a power cycle or reset event, the EM250 will detect an invalid &#xD;&#xA;application image and enter bootloader mode.  (page 139)&#xD;&#xA;&#xD;&#xA;Also, it seems that it takes a particular set of conditions to get to the bootloader, obviously these conditions are being met:&#xD;&#xA;&#xD;&#xA;&gt; XBee modules use a modified version of Ember’s bootloader. This bootloader version supports a custom entry &#xD;&#xA;mechanism that uses module pins DIN (pin 3), DTR / SLEEP_RQ (pin 9), and RTS (pin 16). To invoke the bootloader, &#xD;&#xA;do the following:&#xD;&#xA;&#xD;&#xA;&gt; 1. Set DTR / SLEEP_RQ low (TTL 0V) and RTS high.&#xD;&#xA;2. Send a serial break to the DIN pin and power cycle or reset the module.&#xD;&#xA;3. When the module powers up, DTR / SLEEP_RQ and DIN should be low (TTL 0V) and RTS should be high.&#xD;&#xA;4. Terminate the serial break and send a carriage return at 115200bps to the module.&#xD;&#xA;5. If successful, the module will send the Ember bootloader menu out the DOUT pin at 115200bps.&#xD;&#xA;6. Commands can be sent to the bootloader at 115200bps.&#xD;&#xA;&#xD;&#xA;&gt; **Note:** Hardware flow control should be disabled when entering and communicating with the EM250 bootloader.&#xD;&#xA;&#xD;&#xA;Perhaps check pins 3, 9 and 16 on boot and see if you can modify their behaviour.&#xD;&#xA;&#xD;&#xA;  [1]: ftp://ftp1.digi.com/support/documentation/90000976_F.pdf" />
  <row Id="2369" PostHistoryTypeId="2" PostId="843" RevisionGUID="91f095ec-60e9-4092-9711-4567b45fc846" CreationDate="2014-03-20T04:36:24.680" UserId="734" Text="I tried testing the system and I’m not sure if the problem is with the xbee’s, the transmitting code, or the recieveing code.  Before I post my code I will explain what we are doing with the signals.  We have three analog signals that will be sent serially through one xbee using an arduino and xbee shield.  We want to send these signals to the receiving xbee where the arduino will output these signals to be connected to a third arduino through wires to be used in a Simulink program.  We are using an arduino mega for the transmitting side and an arduino uno for the receiving side. I was told I need to do serial streaming but I’m not sure how that’s done.  I understand the xbee and arduinos both digitize signals but we are hoping to get a signal very similar to the analog signals we are transmitting.  Any amount of help is greatly appreciated!!  &lt;br/&gt;&#xD;&#xA;This is how I have my xbees configured (series 1) both in AT mode:  &lt;br/&gt;&#xD;&#xA;Transmitting Xbee:  &lt;br/&gt;&#xD;&#xA;Channel:10  &lt;br/&gt;&#xD;&#xA;Pan id: 1234  &lt;br/&gt;&#xD;&#xA;MY: 10  &lt;br/&gt;&#xD;&#xA;DL: 11  &lt;br/&gt;&#xD;&#xA;Receiving  Xbee:  &lt;br/&gt;&#xD;&#xA;Channel:10  &lt;br/&gt;&#xD;&#xA;Pan ID: 1234  &lt;br/&gt;&#xD;&#xA;MY: 11  &lt;br/&gt;&#xD;&#xA;DL: 10  &lt;br/&gt;&#xD;&#xA;  &lt;br/&gt;&#xD;&#xA;transmitting Arduino code:    &lt;br/&gt;                      &#xD;&#xA;void setup() {  &lt;br/&gt;&#xD;&#xA;  Serial.begin(9600);  &lt;br/&gt;&#xD;&#xA;}  &lt;br/&gt;&#xD;&#xA;void loop() {  &lt;br/&gt;&#xD;&#xA;  // read the input on analog pins  &lt;br/&gt;&#xD;&#xA;  int sensorValue1 = analogRead(A0);  &lt;br/&gt;&#xD;&#xA;  int sensorValue2 = analogRead(A1);  &lt;br/&gt;&#xD;&#xA;  int sensorValue3 = analogRead(A2);  &lt;br/&gt;&#xD;&#xA;  // print out the value you read:  &lt;br/&gt;&#xD;&#xA;  Serial.println(sensorValue1);  &lt;br/&gt;&#xD;&#xA;  Serial.println(sensorValue2);  &lt;br/&gt;&#xD;&#xA;  Serial.println(sensorValue3);  &lt;br/&gt;&#xD;&#xA;  delay(1);   &lt;br/&gt;       &#xD;&#xA;}  &lt;br/&gt;&#xD;&#xA;Receiving Arduino code:  &lt;br/&gt;&#xD;&#xA;int received1=8;  &lt;br/&gt;&#xD;&#xA; int received2=9;  &lt;br/&gt;&#xD;&#xA; int received3=10;  &lt;br/&gt;&#xD;&#xA;void setup(){  &lt;br/&gt;&#xD;&#xA;pinMode(received1, OUTPUT);  &lt;br/&gt;&#xD;&#xA;pinMode(received2, OUTPUT);  &lt;br/&gt;&#xD;&#xA;pinMode(received3, OUTPUT);  &lt;br/&gt;&#xD;&#xA; Serial.begin(9600);  &lt;br/&gt;&#xD;&#xA;}  &lt;br/&gt;&#xD;&#xA;void loop(){  &lt;br/&gt;&#xD;&#xA; if(Serial.available() )  &lt;br/&gt;&#xD;&#xA; {  &lt;br/&gt;&#xD;&#xA; byte output1 = Serial.read();  &lt;br/&gt;&#xD;&#xA; byte output2 = Serial.read();  &lt;br/&gt;&#xD;&#xA; byte output3 = Serial.read();  &lt;br/&gt;&#xD;&#xA;digitalWrite(received1, HIGH);  &lt;br/&gt;&#xD;&#xA;digitalWrite(received2, HIGH);  &lt;br/&gt;&#xD;&#xA;digitalWrite(received3, HIGH);  &lt;br/&gt;&#xD;&#xA;}  &lt;br/&gt;&#xD;&#xA;}&#xD;&#xA;" />
  <row Id="2370" PostHistoryTypeId="1" PostId="843" RevisionGUID="91f095ec-60e9-4092-9711-4567b45fc846" CreationDate="2014-03-20T04:36:24.680" UserId="734" Text="xbee+arduino communication problem" />
  <row Id="2371" PostHistoryTypeId="3" PostId="843" RevisionGUID="91f095ec-60e9-4092-9711-4567b45fc846" CreationDate="2014-03-20T04:36:24.680" UserId="734" Text="&lt;programming&gt;&lt;serial&gt;" />
  <row Id="2372" PostHistoryTypeId="2" PostId="844" RevisionGUID="3cd4b4b8-116b-46ab-a6af-725a14e80b49" CreationDate="2014-03-20T05:54:42.600" UserId="304" Text="There are several things here:&#xD;&#xA;&#xD;&#xA;1. Increase your delay, you don't want to be sending the data that often, even if you only increase it to 100-200ms, although I'd recommend making it in the order of 1-30 seconds.&#xD;&#xA;&#xD;&#xA;2. You're reading in analog inputs which will be in the range of `0-1023` but your serial reads are in byte format (which will actually be reading the first three bytes (or the first three DIGITS of the first reading). More about this below.&#xD;&#xA;&#xD;&#xA;3. You're reading in three arbitrary bytes, you're not identifying them at all, you have no idea what you're reading (other than by testing for a 1ms delay--which over XBee is not practical).&#xD;&#xA;&#xD;&#xA;You have two options, transmit the data as ASCII (not a good idea IMHO), pre-pending some identifier such that:&#xD;&#xA;&#xD;&#xA;    1:259&#xD;&#xA;    2:0&#xD;&#xA;    3:1019&#xD;&#xA;&#xD;&#xA;or even some other delimiter:&#xD;&#xA;&#xD;&#xA;    259:0:1019&#xD;&#xA;&#xD;&#xA;But I would probably lean towards byte encoding:&#xD;&#xA;&#xD;&#xA;    byte0 :0xEA    // just some custom header for yourself&#xD;&#xA;    byte1H:0x01&#xD;&#xA;    byte1L:0x03&#xD;&#xA;    byte2H:0x00&#xD;&#xA;    byte2L:0x00&#xD;&#xA;    byte3H:0x03&#xD;&#xA;    byte3L:0xFB&#xD;&#xA;    byte4 :0xXX    // checksum&#xD;&#xA;&#xD;&#xA;Or you could `map` the inputs down to a range of `0-255` for single byte transmission. &#xD;&#xA;&#xD;&#xA;Next you'll need to work on receiving the data, how you do that is going to depend on how you encode the stream. With ASCII you can look for the new line, with byte encoding, you are in control and can set the header and length, knowing this is fixed, you'll have no problem (I'm pseudo-coding here):&#xD;&#xA;&#xD;&#xA;    #define HEADER        0xEA&#xD;&#xA;    #define PACKETLENGTH  7&#xD;&#xA;    boolean processData = false;&#xD;&#xA;&#xD;&#xA;    void SerialEvent(){&#xD;&#xA;      byte inChar   =0;&#xD;&#xA;      byte count    =0;&#xD;&#xA;      byte checksum =0;&#xD;&#xA;      char buffer[PACKETLENGTH];&#xD;&#xA;       &#xD;&#xA;      if(Serial.available()){&#xD;&#xA;        byte = Serial.read()&#xD;&#xA;        if(byte==HEADER){&#xD;&#xA;          for(int i = 0; i &lt; PACKETLENGTH; i++){&#xD;&#xA;            buffer[i] = Serial.read();&#xD;&#xA;            if(i!=PACKETLENGTH-1) checksum+=buffer[i];&#xD;&#xA;          }&#xD;&#xA;          if(checksum==buffer[PACKETLENGTH-1]) processData=true;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This isn't perfect, and the checksum could be better implemented. &#xD;&#xA;&#xD;&#xA;I hope this is enough to get you started." />
  <row Id="2373" PostHistoryTypeId="5" PostId="843" RevisionGUID="1fb2fbf4-5102-4412-acab-f34958fe2445" CreationDate="2014-03-20T06:11:24.180" UserId="304" Comment="formatted the code" Text="I tried testing the system and I’m not sure if the problem is with the xbee’s, the transmitting code, or the recieveing code.  Before I post my code I will explain what we are doing with the signals.  &#xD;&#xA;&#xD;&#xA;We have three analog signals that will be sent serially through one xbee using an arduino and xbee shield.  We want to send these signals to the receiving xbee where the arduino will output these signals to be connected to a third arduino through wires to be used in a Simulink program.  &#xD;&#xA;&#xD;&#xA;We are using an arduino mega for the transmitting side and an arduino uno for the receiving side. I was told I need to do serial streaming but I’m not sure how that’s done.  I understand the xbee and arduinos both digitize signals but we are hoping to get a signal very similar to the analog signals we are transmitting.  Any amount of help is greatly appreciated!!  &#xD;&#xA;&#xD;&#xA;This is how I have my xbees configured (series 1) both in AT mode:  &lt;br/&gt;&#xD;&#xA;&#xD;&#xA;&gt;    Transmitting Xbee:  &#xD;&#xA;    Channel:10  &#xD;&#xA;    Pan id: 1234  &#xD;&#xA;    MY: 10  &#xD;&#xA;    DL: 11  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&gt;    Receiving  Xbee:  &#xD;&#xA;    Channel:10  &#xD;&#xA;    Pan ID: 1234 &#xD;&#xA;    MY: 11  &#xD;&#xA;    DL: 10  &#xD;&#xA;&#xD;&#xA;transmitting Arduino code:                   &#xD;&#xA;&#xD;&#xA;    void setup() {  &#xD;&#xA;      Serial.begin(9600);  &#xD;&#xA;    }  &#xD;&#xA;    void loop() {  &#xD;&#xA;      // read the input on analog pins &#xD;&#xA;      int sensorValue1 = analogRead(A0);  &#xD;&#xA;      int sensorValue2 = analogRead(A1);  &#xD;&#xA;      int sensorValue3 = analogRead(A2);  &#xD;&#xA;      // print out the value you read: &#xD;&#xA;      Serial.println(sensorValue1);  &#xD;&#xA;      Serial.println(sensorValue2);  &#xD;&#xA;      Serial.println(sensorValue3);  &#xD;&#xA;      delay(1);   &#xD;&#xA;    }  &#xD;&#xA;    &#xD;&#xA;Receiving Arduino code:  &#xD;&#xA;&#xD;&#xA;    int received1=8;  &#xD;&#xA;    int received2=9;  &#xD;&#xA;    int received3=10;  &#xD;&#xA;    void setup(){  &#xD;&#xA;      pinMode(received1, OUTPUT);  &#xD;&#xA;      pinMode(received2, OUTPUT);  &#xD;&#xA;      pinMode(received3, OUTPUT);  &#xD;&#xA;      Serial.begin(9600);  &#xD;&#xA;    }  &#xD;&#xA;    void loop(){  &#xD;&#xA;      if(Serial.available() )  &#xD;&#xA;      {  &#xD;&#xA;        byte output1 = Serial.read();  &#xD;&#xA;        byte output2 = Serial.read();  &#xD;&#xA;        byte output3 = Serial.read();  &#xD;&#xA;        digitalWrite(received1, HIGH);  &#xD;&#xA;        digitalWrite(received2, HIGH);  &#xD;&#xA;        digitalWrite(received3, HIGH);  &#xD;&#xA;      }  &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    " />
  <row Id="2374" PostHistoryTypeId="24" PostId="843" RevisionGUID="1fb2fbf4-5102-4412-acab-f34958fe2445" CreationDate="2014-03-20T06:11:24.180" Comment="Proposed by 304 approved by 83, -1 edit id of 243" />
  <row Id="2375" PostHistoryTypeId="5" PostId="843" RevisionGUID="fe99c034-7138-4535-97ed-c620d2f67945" CreationDate="2014-03-20T06:11:24.180" UserId="84" Comment="formatted the code" Text="I tried testing the system and I’m not sure if the problem is with the XBee’s, the transmitting code, or the receiving code. Before I post my code, I will explain what we are doing with the signals.&#xD;&#xA;&#xD;&#xA;We have three analog signals that will be sent serially through one XBee using an Arduino and XBee shield.  We want to send these signals to the receiving xbee where the Arduino will output these signals to be connected to a third Arduino through wires to be used in a Simulink program.  &#xD;&#xA;&#xD;&#xA;We are using an Arduino mega for the transmitting side and an Arduino uno for the receiving side. I was told I need to do serial streaming but I’m not sure how that’s done. I understand the XBee and Arduinos both digitize signals but we are hoping to get a signal very similar to the analog signals we are transmitting. Any amount of help is greatly appreciated!!&#xD;&#xA;&#xD;&#xA;This is how I have my XBees configured (series 1) both in AT mode:  &lt;br/&gt;&#xD;&#xA;&#xD;&#xA;&gt;    **Transmitting XBee**:  &#xD;&#xA;    Channel:10  &#xD;&#xA;    Pan id: 1234  &#xD;&#xA;    MY: 10  &#xD;&#xA;    DL: 11  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&gt;    **Receiving XBee**:  &#xD;&#xA;    Channel:10  &#xD;&#xA;    Pan ID: 1234 &#xD;&#xA;    MY: 11  &#xD;&#xA;    DL: 10  &#xD;&#xA;&#xD;&#xA;Transmitting Arduino code:                   &#xD;&#xA;&#xD;&#xA;    void setup() {  &#xD;&#xA;      Serial.begin(9600);  &#xD;&#xA;    }  &#xD;&#xA;    void loop() {  &#xD;&#xA;      // read the input on analog pins &#xD;&#xA;      int sensorValue1 = analogRead(A0);  &#xD;&#xA;      int sensorValue2 = analogRead(A1);  &#xD;&#xA;      int sensorValue3 = analogRead(A2);  &#xD;&#xA;      // print out the value you read: &#xD;&#xA;      Serial.println(sensorValue1);  &#xD;&#xA;      Serial.println(sensorValue2);  &#xD;&#xA;      Serial.println(sensorValue3);  &#xD;&#xA;      delay(1);   &#xD;&#xA;    }  &#xD;&#xA;    &#xD;&#xA;Receiving Arduino code:  &#xD;&#xA;&#xD;&#xA;    int received1=8;  &#xD;&#xA;    int received2=9;  &#xD;&#xA;    int received3=10;  &#xD;&#xA;    void setup(){  &#xD;&#xA;      pinMode(received1, OUTPUT);  &#xD;&#xA;      pinMode(received2, OUTPUT);  &#xD;&#xA;      pinMode(received3, OUTPUT);  &#xD;&#xA;      Serial.begin(9600);  &#xD;&#xA;    }  &#xD;&#xA;    void loop(){  &#xD;&#xA;      if(Serial.available() )  &#xD;&#xA;      {  &#xD;&#xA;        byte output1 = Serial.read();  &#xD;&#xA;        byte output2 = Serial.read();  &#xD;&#xA;        byte output3 = Serial.read();  &#xD;&#xA;        digitalWrite(received1, HIGH);  &#xD;&#xA;        digitalWrite(received2, HIGH);  &#xD;&#xA;        digitalWrite(received3, HIGH);  &#xD;&#xA;      }  &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    " />
  <row Id="2376" PostHistoryTypeId="4" PostId="843" RevisionGUID="fe99c034-7138-4535-97ed-c620d2f67945" CreationDate="2014-03-20T06:11:24.180" UserId="84" Comment="formatted the code" Text="XBee+Arduino communication problem" />
  <row Id="2377" PostHistoryTypeId="6" PostId="843" RevisionGUID="fe99c034-7138-4535-97ed-c620d2f67945" CreationDate="2014-03-20T06:11:24.180" UserId="84" Comment="formatted the code" Text="&lt;programming&gt;&lt;serial&gt;&lt;xbee&gt;" />
  <row Id="2378" PostHistoryTypeId="5" PostId="830" RevisionGUID="d7a1e4bf-b1d9-4a30-bb5e-547fff5ff98c" CreationDate="2014-03-20T06:15:27.507" UserId="84" Comment="Write that the code sample is simplified" Text="I am currently playing with Arduino timers (on UNO currently) and I am building a library that  has a function that must be called every millisecond.&#xD;&#xA;&#xD;&#xA;There is plenty of code samples on Internet so I went with something that seemed perfect for my needs. I have then updated it to make it a reusable C++ class. &#xD;&#xA;&#xD;&#xA;Here is my code (simplified to just isolate the issue):&#xD;&#xA;&#xD;&#xA;    #define BIT(x) (0x01 &lt;&lt; (x))&#xD;&#xA;    &#xD;&#xA;    static volatile uint32_t milliseconds = 0;&#xD;&#xA;    &#xD;&#xA;    class Timer&#xD;&#xA;    {&#xD;&#xA;        public:&#xD;&#xA;        Timer()&#xD;&#xA;        {&#xD;&#xA;            // Disable interrupts&#xD;&#xA;            uint8_t savedStatus = SREG;&#xD;&#xA;            cli();&#xD;&#xA;            // Use Timer2 with 1 ms interrupts&#xD;&#xA;            // OC2A &amp; OC2B disconnected, mode 2 (CTC, Clear Timer on Compare match)&#xD;&#xA;            TCCR2A = BIT(WGM21);&#xD;&#xA;            // Don't force output compare (FOCA &amp; FOCB), mode 2, Clock Select clk/128 (CS = 5)&#xD;&#xA;            TCCR2B = BIT(CS22) | BIT(CS20);&#xD;&#xA;            // Set timer counter compare match (when value reached, 1ms has elapsed)&#xD;&#xA;            OCR2A = 125 - 1;&#xD;&#xA;            // Reset Timer2 counter&#xD;&#xA;            TCNT2 = 0;&#xD;&#xA;            // Set Timer2 interrupt mode (Set interrupt on OCR2A compare match)&#xD;&#xA;            TIMSK2 = BIT(OCIE2A);&#xD;&#xA;    &#xD;&#xA;            // Restore interrupt enabling state&#xD;&#xA;            SREG = savedStatus;&#xD;&#xA;        }&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    static void callEveryMillisecond(uint32_t ms)&#xD;&#xA;    {&#xD;&#xA;        // Do something here&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // Attach interrupt routine to the Timer Compare Interrupt&#xD;&#xA;    ISR(TIMER2_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;        milliseconds++;&#xD;&#xA;        callEveryMillisecond(milliseconds);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;After checking [ATmega328 datasheet][1] (section 17) several times, I came to the conclusion that what I do in `Timer` class constructor above is correct, and for Arduino UNO, the values used must lead to one call of the ISR every ms:&#xD;&#xA;&#xD;&#xA; - CPU frequency = **16MHz**&#xD;&#xA; - Prescaler = **128**&#xD;&#xA; - -&gt; timer frequency = **16MHz/128 = 125KHz**&#xD;&#xA; - -&gt; max counter value = **125**&#xD;&#xA;&#xD;&#xA;I decided to use the **CTC** (Clear Timer on Compare match) mode, which means that when the timer `TCNT2` (which is incremented at 125KHz frequency), reaches `OCR2A` value, then it will trigger the ISR, and then will be reset on next tick; the additional tick to reset the counter explains why we use `125 - 1` for `OCR2A` and not just `125`.&#xD;&#xA;&#xD;&#xA;Now comes the weird stuff. In order to check that my code worked, I decided to blink the LED on pin 13 every 10 seconds, hence I have added the following code to my program:&#xD;&#xA;&#xD;&#xA;    static void callEveryMillisecond(uint32_t ms)&#xD;&#xA;    {&#xD;&#xA;        if (ms % 10000 == 0)&#xD;&#xA;            digitalWrite(13, digitalRead(13) ^ 1);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    static Timer timer;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Then I measured the time during which pin 13 LED is lit on (or off, both measures are the same). Measures are not very accurate (I just used my wristwatch) but good enough for my check.&#xD;&#xA;&#xD;&#xA;I was surprised to see the measured time to be about **20 seconds instead of 10s**.&#xD;&#xA;&#xD;&#xA;Initially I thought about a mismatch in CPU frequency, but after performing a lot of small changes, here is what I found which worked perfectly:&#xD;&#xA;&#xD;&#xA;    //static Timer timer;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        static Timer timer;&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;Just moving the `Timer` instance into `setup()` did the trick: my measures rightly indicated **10 seconds** between 2 states of the pin 13 LED.&#xD;&#xA;&#xD;&#xA;**Now my questions are:**&#xD;&#xA;&#xD;&#xA;1. Why the second code sample works perfectly, whereas the first does not?&#xD;&#xA;&#xD;&#xA;2. Is there, in standard Arduino included code, some code that would overwrite some of the settings I perform for Timer2 in `Timer::Timer()`?&#xD;&#xA;&#xD;&#xA;3. Is there a way to make the first code sample work? Note that I don't like the second sample because it does not seem natural coding, also, I will need access to `Timer` `timer` instance in several locations of my future program, hence it can't be possible if it is declared in the scope of `setup()`.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/Images/doc8161.pdf&#xD;&#xA;" />
  <row Id="2379" PostHistoryTypeId="2" PostId="845" RevisionGUID="d2aef7d4-68a9-45f6-ad21-ac191f0131ef" CreationDate="2014-03-20T09:33:58.700" UserId="470" Text="I have located the source of the problem.&#xD;&#xA;&#xD;&#xA;In file wiring.c (arduino-1.5.6-r2\hardware\arduino\avr\cores\arduino) which gets called before setup(), there is the following part that tries to changes the timer 2 prescaller to 64 by setting the `CS22` bit.  &#xD;&#xA;&#xD;&#xA;    // set timer 2 prescale factor to 64&#xD;&#xA;    #if defined(TCCR2) &amp;&amp; defined(CS22)&#xD;&#xA;    	sbi(TCCR2, CS22);&#xD;&#xA;    #elif defined(TCCR2B) &amp;&amp; defined(CS22)&#xD;&#xA;    	sbi(TCCR2B, CS22);&#xD;&#xA;    #else&#xD;&#xA;    	#warning Timer 2 not finished (may not be present on this CPU)&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;You already set `CS20` and  `CS22` so this doesn't affect you. What does affect you is the following part which sets bit `WGM20` &#xD;&#xA;&#xD;&#xA;    	// configure timer 2 for phase correct pwm (8-bit)&#xD;&#xA;    #if defined(TCCR2) &amp;&amp; defined(WGM20)&#xD;&#xA;    	sbi(TCCR2, WGM20);&#xD;&#xA;    #elif defined(TCCR2A) &amp;&amp; defined(WGM20)&#xD;&#xA;    	sbi(TCCR2A, WGM20);&#xD;&#xA;    #else&#xD;&#xA;    	#warning Timer 2 not finished (may not be present on this CPU)&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;and you have already set `WGM21` so `WGM21` and `WGM20` set changes the timer mode to fast PWM , top=0xFF which gives almost double delay that the mode you were trying to use (CTC top=124)" />
  <row Id="2388" PostHistoryTypeId="2" PostId="847" RevisionGUID="df8bc9bf-f292-49e0-ac68-cbb5aec8e522" CreationDate="2014-03-20T11:14:42.673" UserId="744" Text="I am a new user of Arduino microcontroller (I have a Arduino Due) and also I am a new user of BLE112 (bluegiga modul 112)&#xD;&#xA;So my mentor for the practice told me to mak BLE112 advertisable and furthermore he told me to lok for information about UART@115K; &#xD;&#xA;And i have to mention that he gaved me a ble112 with already solder wires to the selected pins ( so my concludes are that i have only to use those)&#xD;&#xA;&#xD;&#xA;PIN NUMBER [PIN NAME] for BLE112&#xD;&#xA;2 AVDD   (Supply voltage 2-3.6V)&#xD;&#xA;3 AVDD   (Supply voltage 2-3.6V)&#xD;&#xA;4 [P2_2]   DC –Debug clock	(DIGITAL I/O)&#xD;&#xA;5 [P2_1]   DD- Debug data	(DIGITAL I/O)&#xD;&#xA;9 VDD_USB   (Supply voltage 2-3.6V)&#xD;&#xA;20 DVDD (Supply voltage 2-3.6V)&#xD;&#xA;23 [P0_5]  RXD(Rx)		(DIGITAL I/O)&#xD;&#xA;24 [P0_4]  TXD(TX)		(DIGITAL I/O)&#xD;&#xA;25 [P0_3]  RTS		(DIGITAL I/O)&#xD;&#xA;26 [P0_2]  CTS		(DIGITAL I/O)&#xD;&#xA;29 RESET&#xD;&#xA;30 GND&#xD;&#xA;&#xD;&#xA;So what i did, was I Connected pins betwen devices like this:&#xD;&#xA;&#xD;&#xA;On pin of Arduino 3.3V i putt [2,3,9,20]BLE112&#xD;&#xA;On pin of Arduino GDN i putt [30]BLE112&#xD;&#xA;&#xD;&#xA;And than I found the picture I attached, there is discribed that I shoud put CTS of BLE on RTS of ardunio and conversely.&#xD;&#xA;But i dont know where is that on arduno bord?&#xD;&#xA;So I think I have to program one of the Digital pins? (adn i decided to make a connection like this)&#xD;&#xA;&#xD;&#xA;Than i put BLE  pin 26(CTS) on Arduino rendom digital pin 32 &#xD;&#xA;and BLE pin 25(RTS) on Arduino rendom digital pin 34&#xD;&#xA;&#xD;&#xA;BLE pin 24(TX) on Arduino RX pin 0&#xD;&#xA;BLE pin 23(RX) on Arduino TX pin 1&#xD;&#xA;&#xD;&#xA;And i dind't use(conect) DC(Debug clock), DD(Debug data) and Reset from BLE112&#xD;&#xA;&#xD;&#xA;So and than i found some more info. on  the web that if i use USART than i shoud use a wake up pin whic is by the defaul P0_0 more abaut&#xD;&#xA;that in attached pdf. (search by wake_up)&#xD;&#xA;&#xD;&#xA;And now i should mention sleep mode Ble112 (there are three kinds of it) and i belive that my is in MODE 3 (that means that it&#xD;&#xA;consumeminimum of them all) &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Well i found some example named UART@115K&#xD;&#xA;» UART@115k &#xD;&#xA;This example configures the BLE112 or BLE113 Bluetooth Smart module to expose the BGAPI protocol over &#xD;&#xA;UART interface with the following settings: 115200 bps, 8n1 and hardware flow control enabled. The power &#xD;&#xA;mode 3 is enabled in this example and the wake-up pin is configured to P0_0 pin (P0_0 button on DKBLE112 &#xD;&#xA;and DKBLE113). When the power mode 3 is enabled the device will not be able to receive commands or data &#xD;&#xA;over UART unless the wake-up pin is asserted. &#xD;&#xA;The example uses UART in the pin configuration channel 1 and alternate 1, which is the configuration used &#xD;&#xA;in the DKBLE112 and DKBLE113 development kits. &#xD;&#xA;If you try this example with DKBLE112 or DKBLE113 make sure the UART interface is enabled and the device &#xD;&#xA;is NOT powered with a CR2032 battery as it’s not able to power up the level shifter or UART to USB &#xD;&#xA;converter. &#xD;&#xA;This is also the factory default configuration for BLE112 and BLE113 Bluetooth Smart Modules.« &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![Connection shown][1]&#xD;&#xA;&#xD;&#xA;and the link where i found this: [https://bluegiga.zendesk.com/entries/22412436][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/OwjIi.jpg&#xD;&#xA;  [2]: https://bluegiga.zendesk.com/entries/22412436" />
  <row Id="2389" PostHistoryTypeId="1" PostId="847" RevisionGUID="df8bc9bf-f292-49e0-ac68-cbb5aec8e522" CreationDate="2014-03-20T11:14:42.673" UserId="744" Text="How to connect arduino to bluegiga112" />
  <row Id="2390" PostHistoryTypeId="3" PostId="847" RevisionGUID="df8bc9bf-f292-49e0-ac68-cbb5aec8e522" CreationDate="2014-03-20T11:14:42.673" UserId="744" Text="&lt;pins&gt;&lt;arduino-due&gt;&lt;connectivity&gt;" />
  <row Id="2391" PostHistoryTypeId="5" PostId="847" RevisionGUID="be9dcca8-2783-47f0-8e34-9f6f16913f24" CreationDate="2014-03-20T11:19:56.417" UserId="744" Comment="improved formating" Text="I am a new user of Arduino microcontroller (I have a Arduino Due) and also I am a new user of BLE112 (bluegiga modul 112)&lt;br /&gt;&#xD;&#xA;So my mentor for the practice told me to mak BLE112 advertisable and furthermore he told me to lok for information about UART@115K;&lt;br /&gt; &#xD;&#xA;And i have to mention that he gaved me a ble112 with already solder wires to the selected pins ( so my concludes are that i have only to use those)&#xD;&#xA;&#xD;&#xA;PIN NUMBER [PIN NAME] for BLE112&#xD;&#xA;&#xD;&#xA;2 AVDD   (Supply voltage 2-3.6V)&lt;br /&gt;&#xD;&#xA;3 AVDD   (Supply voltage 2-3.6V)&lt;br /&gt;&#xD;&#xA;4 [P2_2]   DC –Debug clock	(DIGITAL I/O)&lt;br /&gt;&#xD;&#xA;5 [P2_1]   DD- Debug data	(DIGITAL I/O)&lt;br /&gt;&#xD;&#xA;9 VDD_USB   (Supply voltage 2-3.6V)&lt;br /&gt;&#xD;&#xA;20 DVDD (Supply voltage 2-3.6V)&lt;br /&gt;&#xD;&#xA;23 [P0_5]  RXD(Rx)		(DIGITAL I/O)&lt;br /&gt;&#xD;&#xA;24 [P0_4]  TXD(TX)		(DIGITAL I/O)&lt;br /&gt;&#xD;&#xA;25 [P0_3]  RTS		(DIGITAL I/O)&lt;br /&gt;&#xD;&#xA;26 [P0_2]  CTS		(DIGITAL I/O)&lt;br /&gt;&#xD;&#xA;29 RESET&lt;br /&gt;&#xD;&#xA;30 GND&lt;br /&gt;&#xD;&#xA;&#xD;&#xA;So what i did, was I Connected pins betwen devices like this:&#xD;&#xA;&#xD;&#xA;On pin of Arduino 3.3V i putt [2,3,9,20]BLE112&lt;br /&gt;&#xD;&#xA;On pin of Arduino GDN i putt [30]BLE112&lt;br /&gt;&#xD;&#xA;&#xD;&#xA;And than I found the picture I attached, there is discribed that I shoud put CTS of BLE on RTS of ardunio and conversely.&#xD;&#xA;But i dont know where is that on arduno bord?&#xD;&#xA;So I think I have to program one of the Digital pins? (adn i decided to make a connection like this)&#xD;&#xA;&#xD;&#xA;Than i put BLE  pin 26(CTS) on Arduino rendom digital pin 32 &lt;br /&gt;&#xD;&#xA;and BLE pin 25(RTS) on Arduino rendom digital pin 34&lt;br /&gt;&#xD;&#xA;&#xD;&#xA;BLE pin 24(TX) on Arduino RX pin 0&lt;br /&gt;&#xD;&#xA;BLE pin 23(RX) on Arduino TX pin 1&lt;br /&gt;&#xD;&#xA;&#xD;&#xA;And i dind't use(conect) DC(Debug clock), DD(Debug data) and Reset from BLE112&#xD;&#xA;&#xD;&#xA;So and than i found some more info. on  the web that if i use USART than i shoud use a wake up pin whic is by the defaul P0_0 more abaut&#xD;&#xA;that in attached pdf. (search by wake_up)&#xD;&#xA;&#xD;&#xA;And now i should mention sleep mode Ble112 (there are three kinds of it) and i belive that my is in MODE 3 (that means that it&#xD;&#xA;consumeminimum of them all) &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Well i found some example named UART@115K&#xD;&#xA;» UART@115k &#xD;&#xA;This example configures the BLE112 or BLE113 Bluetooth Smart module to expose the BGAPI protocol over &#xD;&#xA;UART interface with the following settings: 115200 bps, 8n1 and hardware flow control enabled. The power &#xD;&#xA;mode 3 is enabled in this example and the wake-up pin is configured to P0_0 pin (P0_0 button on DKBLE112 &#xD;&#xA;and DKBLE113). When the power mode 3 is enabled the device will not be able to receive commands or data &#xD;&#xA;over UART unless the wake-up pin is asserted. &#xD;&#xA;The example uses UART in the pin configuration channel 1 and alternate 1, which is the configuration used &#xD;&#xA;in the DKBLE112 and DKBLE113 development kits. &#xD;&#xA;If you try this example with DKBLE112 or DKBLE113 make sure the UART interface is enabled and the device &#xD;&#xA;is NOT powered with a CR2032 battery as it’s not able to power up the level shifter or UART to USB &#xD;&#xA;converter. &#xD;&#xA;This is also the factory default configuration for BLE112 and BLE113 Bluetooth Smart Modules.« &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![Connection shown][1]&#xD;&#xA;&#xD;&#xA;and the link where i found this: [https://bluegiga.zendesk.com/entries/22412436][2]&#xD;&#xA;&#xD;&#xA; [&#xD;&#xA;and the pdf i mention to se for star_up][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/OwjIi.jpg&#xD;&#xA;  [2]: https://bluegiga.zendesk.com/entries/22412436&#xD;&#xA;  [3]: https://www.bluegiga.com/protectedstore/8pHYFByrRbCfvauWLt5CMQ/lnlU2gAsQ0xNiol858gOLw/_JR5_qFqBNLIfHoFIFcdq0y9048xjcuyJMYmCVLj-j3xRFlc8VYw/Bluetooth_Smart_Configuration_Guide_v33.pdf" />
  <row Id="2392" PostHistoryTypeId="5" PostId="844" RevisionGUID="b0a9a461-1313-46f8-8d84-3460d7c4e60b" CreationDate="2014-03-20T11:27:03.943" UserId="304" Comment="added real code to demonstrate what the OP is after" Text="There are several things here:&#xD;&#xA;&#xD;&#xA;1. Increase your delay, you don't want to be sending the data that often, even if you only increase it to 100-200ms, although I'd recommend making it in the order of 1-30 seconds.&#xD;&#xA;&#xD;&#xA;2. You're reading in analog inputs which will be in the range of `0-1023` but your serial reads are in byte format (which will actually be reading the first three bytes (or the first three DIGITS of the first reading). More about this below.&#xD;&#xA;&#xD;&#xA;3. You're reading in three arbitrary bytes, you're not identifying them at all, you have no idea what you're reading (other than by testing for a 1ms delay--which over XBee is not practical).&#xD;&#xA;&#xD;&#xA;You have two options, transmit the data as ASCII (not a good idea IMHO), pre-pending some identifier such that:&#xD;&#xA;&#xD;&#xA;    1:259&#xD;&#xA;    2:0&#xD;&#xA;    3:1019&#xD;&#xA;&#xD;&#xA;or even some other delimiter:&#xD;&#xA;&#xD;&#xA;    259:0:1019&#xD;&#xA;&#xD;&#xA;But I would probably lean towards byte encoding:&#xD;&#xA;&#xD;&#xA;    byte0 :0xEA    // just some custom header for yourself&#xD;&#xA;    byte1H:0x01&#xD;&#xA;    byte1L:0x03&#xD;&#xA;    byte2H:0x00&#xD;&#xA;    byte2L:0x00&#xD;&#xA;    byte3H:0x03&#xD;&#xA;    byte3L:0xFB&#xD;&#xA;    byte4 :0xXX    // checksum&#xD;&#xA;&#xD;&#xA;Or you could `map` the inputs down to a range of `0-255` for single byte transmission. &#xD;&#xA;&#xD;&#xA;Next you'll need to work on receiving the data, how you do that is going to depend on how you encode the stream. &#xD;&#xA;&#xD;&#xA;_**edit:** I've removed the code sample that was here and replaced it with two working sketches below._&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;I have two XBees, running in AT mode, mine are Series 2, but programatically _I THINK_ they are the same. If not, you'll have to tweak these, but I'm pretty sure you'll be right. &#xD;&#xA;&#xD;&#xA;What we have are two apps, the first is the &quot;SENDING&quot; app, it takes three arbitrary values, they are: minutes (0-60) the micro has been running, seconds (0-60) the micro has been running, and 100 (it was random, and you can put that back if you want). Also, if you comment out the `#define TESTAPP` instead of using these values, it can pull three analog values from `A0`-`A2` instead. (If you change it in the receiving app, you could have three LEDS on Pulse Width channels and vary the brightness). &#xD;&#xA;&#xD;&#xA;    /* * * * * * * */&#xD;&#xA;&#xD;&#xA;    XBEE SENDER (131) &#xD;&#xA;&#xD;&#xA;    #define TESTAPP        // Just serial data based on time&#xD;&#xA;    &#xD;&#xA;    #define PACKETLENGTH   7&#xD;&#xA;    #define LED            13&#xD;&#xA;    &#xD;&#xA;    /* * * * * * * */&#xD;&#xA;    &#xD;&#xA;    void setup(){&#xD;&#xA;        Serial.begin(9600);  &#xD;&#xA;        Serial.println(&quot;\nSender&quot;);&#xD;&#xA;        randomSeed(analogRead(0));   &#xD;&#xA;        pinMode(LED,OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    unsigned long m1 = 0;&#xD;&#xA;    unsigned long m2 = 0;&#xD;&#xA;    &#xD;&#xA;    void loop(){&#xD;&#xA;        m1 = millis()/1000;&#xD;&#xA;        if(m2 != m1){&#xD;&#xA;            m2 = m1;&#xD;&#xA;            &#xD;&#xA;    #ifdef TESTAPP        &#xD;&#xA;            uint8_t  s = m1 % 60;           // how many seconds on millis()&#xD;&#xA;            m1 /= 60;                       // now we're working with minutes&#xD;&#xA;            uint8_t  m = m1 % 60;           // how manu minutes on millis()&#xD;&#xA;            uint8_t  r = 100; //random(256);&#xD;&#xA;            Serial.print(&quot;x.x&quot;);            // this is just pre-pended data for testing&#xD;&#xA;            Serial.print('&lt;');  &#xD;&#xA;            Serial.write(m);  &#xD;&#xA;            Serial.print('-');  &#xD;&#xA;            Serial.write(s);  &#xD;&#xA;            Serial.print('-');  &#xD;&#xA;            Serial.write(r);  &#xD;&#xA;            Serial.print(&quot;&gt;  x-x&quot;);        // we want to ignore these chars&#xD;&#xA;    #else&#xD;&#xA;            Serial.print('&lt;');  &#xD;&#xA;            Serial.write(map(analogRead(A0),0,1023,0,255));  &#xD;&#xA;            Serial.print('-');  &#xD;&#xA;            Serial.write(map(analogRead(A1),0,1023,0,255));  &#xD;&#xA;            Serial.print('-');  &#xD;&#xA;            Serial.write(map(analogRead(A2),0,1023,0,255));  &#xD;&#xA;            Serial.print('&gt;');        &#xD;&#xA;    #endif&#xD;&#xA;            digitalWrite(LED,!digitalRead(LED));  // toggle the LED everytime we're here&#xD;&#xA;        }&#xD;&#xA;        // do other stuff here...&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;You'll notice garbage characters around the data we are transporting, this is to demonstrate cycling through all serial communications to arrive at the 7 particular characters we need. That's done in the next app, the receiver:&#xD;&#xA;&#xD;&#xA;    /* * * * * * * * */&#xD;&#xA;&#xD;&#xA;    XBEE RECEIVER (121) &#xD;&#xA;        &#xD;&#xA;    #define TESTAPP  // if you attach 3 LEDS to 9, 10 and 11, the remove this line.&#xD;&#xA;    &#xD;&#xA;    //#define DEBUG  // uncomment this line to see all the data stream coming in&#xD;&#xA;    &#xD;&#xA;    #define PACKETLENGTH  7&#xD;&#xA;    &#xD;&#xA;    /* * * * * * * * */&#xD;&#xA;    &#xD;&#xA;    int LED[3]={9, 10, 11};&#xD;&#xA;    &#xD;&#xA;    void setup(){&#xD;&#xA;      Serial.begin(9600);  &#xD;&#xA;      Serial.println(&quot;\nReceiver&quot;);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    byte  buffer[PACKETLENGTH]; // what holds our serial data&#xD;&#xA;    byte  idx         = 0;      // the index for the buffer character being written&#xD;&#xA;    byte  validBuffer = 0;      // flag to tell us if we're ready to go&#xD;&#xA;    &#xD;&#xA;    void loop(){&#xD;&#xA;      if(validBuffer){&#xD;&#xA;          #ifdef TESTAPP&#xD;&#xA;              // we're just going to print it out in a different format&#xD;&#xA;              validBuffer=0;&#xD;&#xA;              #ifdef DEBUG&#xD;&#xA;                  Serial.print('\n');&#xD;&#xA;              #endif&#xD;&#xA;              Serial.print(&quot;Data: (&quot;);&#xD;&#xA;              if (buffer[1]&lt;10) Serial.print(&quot;0&quot;);&#xD;&#xA;              Serial.print(buffer[1]);&#xD;&#xA;              Serial.print(&quot;:&quot;);&#xD;&#xA;              if (buffer[3]&lt;10) Serial.print(&quot;0&quot;);&#xD;&#xA;              Serial.print(buffer[3]);&#xD;&#xA;              Serial.print(&quot;) (&quot;);&#xD;&#xA;              Serial.print(buffer[5]);&#xD;&#xA;              Serial.println(&quot;)&quot;);&#xD;&#xA;          #else&#xD;&#xA;              // this is the more practical side of things&#xD;&#xA;              // instead of serial.printing, change the brightness &#xD;&#xA;              // on three attached LEDs via PWM Pins (9, 10, 11)&#xD;&#xA;              analogWrite(LED[0],buffer[1]); &#xD;&#xA;              analogWrite(LED[1],buffer[3]);&#xD;&#xA;              analogWrite(LED[2],buffer[5]);&#xD;&#xA;          #endif&#xD;&#xA;          memset(buffer, 0, PACKETLENGTH);  // we've used the data, clear it out&#xD;&#xA;          idx = 0;                          // and reset the index marker&#xD;&#xA;      }  &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // This is where the real magic is done. We have a buffer of&#xD;&#xA;    // PACKETLENGTH that takes in all Serial data and waits until&#xD;&#xA;    // it finds PACKETLENGTH characters in the format we're after&#xD;&#xA;    // Probably not the best method, but it would be unlikely to&#xD;&#xA;    // stumble across this pattern, although not impossible :) &#xD;&#xA;    // use at your own risk &#xD;&#xA;&#xD;&#xA;    void serialEvent(){&#xD;&#xA;        if(validBuffer) return; //we don't want to process new Serial&#xD;&#xA;                                //until we've processed the buffer&#xD;&#xA;        buffer[idx] = Serial.read();&#xD;&#xA;            #ifdef DEBUG&#xD;&#xA;            Serial.write(buffer[idx]);&#xD;&#xA;            #endif&#xD;&#xA;     &#xD;&#xA;        if (++idx==PACKETLENGTH){&#xD;&#xA;            // we have enough bytes for testing, this next part could be handled better&#xD;&#xA;            if(  buffer[0]=='&lt;' &amp;&amp; &#xD;&#xA;                 buffer[2]=='-' &amp;&amp;     &#xD;&#xA;                 buffer[4]=='-' &amp;&amp;     &#xD;&#xA;                 buffer[6]=='&gt;' ) { // we have a valid data packet     &#xD;&#xA;                   validBuffer=1;&#xD;&#xA;            } else {    // we don't have valid data yet, but keep&#xD;&#xA;                        // what we have, shift it all over one byte and&#xD;&#xA;                        // we'll check again once the next byte is received&#xD;&#xA;                memmove(buffer, buffer + 1, PACKETLENGTH-1);&#xD;&#xA;            }  &#xD;&#xA;            idx--;&#xD;&#xA;        }&#xD;&#xA;    }" />
  <row Id="2394" PostHistoryTypeId="6" PostId="432" RevisionGUID="2765b686-3aac-42bc-8688-6a29b90a01d9" CreationDate="2014-03-20T11:47:16.523" UserId="304" Comment="added newly created &quot;xbee&quot; tag (I didn't create the tag) and there are some answers referencing xbees" Text="&lt;arduino-uno&gt;&lt;wifi&gt;&lt;xbee&gt;" />
  <row Id="2395" PostHistoryTypeId="24" PostId="432" RevisionGUID="2765b686-3aac-42bc-8688-6a29b90a01d9" CreationDate="2014-03-20T11:47:16.523" Comment="Proposed by 304 approved by 84, 136 edit id of 248" />
  <row Id="2396" PostHistoryTypeId="6" PostId="708" RevisionGUID="4de619aa-9687-4c3a-8dbc-c33087225d8a" CreationDate="2014-03-20T11:48:09.027" UserId="304" Comment="added newly created &quot;xbee&quot; tag" Text="&lt;arduino-uno&gt;&lt;sensors&gt;&lt;shields&gt;&lt;proximity&gt;&lt;xbee&gt;" />
  <row Id="2397" PostHistoryTypeId="24" PostId="708" RevisionGUID="4de619aa-9687-4c3a-8dbc-c33087225d8a" CreationDate="2014-03-20T11:48:09.027" Comment="Proposed by 304 approved by 136, 84 edit id of 244" />
  <row Id="2398" PostHistoryTypeId="6" PostId="782" RevisionGUID="0e077764-39bb-4d6c-bab3-ee43ef3aa901" CreationDate="2014-03-20T11:48:48.687" UserId="304" Comment="added newly created &quot;xbee&quot; tag" Text="&lt;programming&gt;&lt;serial&gt;&lt;xbee&gt;" />
  <row Id="2399" PostHistoryTypeId="24" PostId="782" RevisionGUID="0e077764-39bb-4d6c-bab3-ee43ef3aa901" CreationDate="2014-03-20T11:48:48.687" Comment="Proposed by 304 approved by 136, 84 edit id of 247" />
  <row Id="2400" PostHistoryTypeId="6" PostId="821" RevisionGUID="c5520093-621b-448f-b29f-246cc65f0946" CreationDate="2014-03-20T11:50:42.517" UserId="304" Comment="added newly created &quot;xbee&quot; tag" Text="&lt;programming&gt;&lt;serial&gt;&lt;sketch&gt;&lt;arduno-nano&gt;&lt;xbee&gt;" />
  <row Id="2401" PostHistoryTypeId="24" PostId="821" RevisionGUID="c5520093-621b-448f-b29f-246cc65f0946" CreationDate="2014-03-20T11:50:42.517" Comment="Proposed by 304 approved by 136, 84 edit id of 246" />
  <row Id="2402" PostHistoryTypeId="5" PostId="782" RevisionGUID="7e816ab0-3564-4f9c-8ac9-c33b80ac9093" CreationDate="2014-03-20T11:56:44.990" UserId="665" Comment="Removed my question regarding the xbee tag since it has been added, thanks!" Text="I have an Arduino Mega 2560 with a [libelium XBee Shield][1]. If I have an XBee S2 mounted on it and set the two jumpers to the USB setting or remove them, I am able to flash a program onto my Arduino.&#xD;&#xA;&#xD;&#xA;However, when I'm mounting one of my XBee PRO S2B (I have three of them available and all behave the same) on the Arduino, no matter how I set the jumpers, it is not possible to flash anything on it. I always see `avrdude: stk500v2_getsync(): timeout communicating with programmer` in the Arduino IDE.&#xD;&#xA;&#xD;&#xA;Is the XBee PRO S2B incompatible with the Arduino or what might be the issue? I also tried to add an external power source additionally to the USB, but it didn't help either.&#xD;&#xA;&#xD;&#xA;**Update**&#xD;&#xA;&#xD;&#xA;After some more experimenting, I found out new details. I tried to disconnect each pin of the shield individually. While doing it, I discovered that disconnecting the `reset` pin from the arduino makes it possible to flash it - take a look at the [XBee shield schematic][2], it's pin 5 from the ICSP connector; Photo: ![photo of it][3]&#xD;&#xA;&#xD;&#xA;I used a multimeter and discovered that the XBee PRO S2B CTS / DIO7 port is high, while the one from the XBee S2 is low, and so constantly resetting the arduino. I mounted the XBee PRO S2B onto the [Sparkfun XBee Explorer USB][4] and opened a serial port with PuTTY.&#xD;&#xA;In contrast to the S2, the PRO S2B provides a menu with several options:&#xD;&#xA;&#xD;&#xA;    B-Bypass Mode&#xD;&#xA;    F-Update App&#xD;&#xA;    T-Timeout&#xD;&#xA;    V-BL Version&#xD;&#xA;    A-App Version&#xD;&#xA;    R-Reset&#xD;&#xA;    &gt;&#xD;&#xA;&#xD;&#xA;![Sparkfun XBee Explorer USB, CTS port][5]&#xD;&#xA;&#xD;&#xA;As soon as I type B, the CTS port goes low, and would prevent the arduino from resetting. Also this mode is needed to detect the module via XCTU. However, with an unmodified arduino, I wouldn't have a chance to send this letter, since the XBee is constantly resetting it. What is this menu, can it be disabled somehow?&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoXbeeShield#.UybqgHVSm4I&#xD;&#xA;  [2]: http://www.arduino.cc/en/uploads/Main/XbeeShieldSchematic.pdf&#xD;&#xA;  [3]: http://i.stack.imgur.com/wgXvG.jpg&#xD;&#xA;  [4]: https://www.sparkfun.com/products/8687&#xD;&#xA;  [5]: http://i.stack.imgur.com/ju3TV.jpg" />
  <row Id="2403" PostHistoryTypeId="5" PostId="719" RevisionGUID="29478b91-67fd-45d4-8366-c56697fc314a" CreationDate="2014-03-20T12:39:19.997" UserId="304" Comment="wasn't clear about the fact it is the series twos that need flashing" Text="Adding to Ron's answer, the Series 1 is a lot easier to use, because you have to flash firmware onto Series 2s and do all kinds of setup. The S1s work out of the box.&#xD;&#xA;&#xD;&#xA;Another thing to keep in mind is that Xbees use 3.3v I/O pins, while the Arduino uses 5v. Most Xbee shields have a Logic Level Converter to handle this, but there are some that don't, and those could damage your Xbee." />
  <row Id="2404" PostHistoryTypeId="24" PostId="719" RevisionGUID="29478b91-67fd-45d4-8366-c56697fc314a" CreationDate="2014-03-20T12:39:19.997" Comment="Proposed by 304 approved by 136, 220 edit id of 245" />
  <row Id="2405" PostHistoryTypeId="5" PostId="602" RevisionGUID="67ed6394-e5f4-4676-879a-319dbffb0fe6" CreationDate="2014-03-20T15:00:53.120" UserId="453" Comment="Adding the output of verbose mode !" Text="I have a problem with my Arduino. I can't upload any sketches to it (it gives me the error `avrdude: verification error; content mismatch`), but the LEDS are still blinking. Do you think that the whole Arduino is dead or is it just the chip ?&#xD;&#xA;&#xD;&#xA;EDIT :I tried an other USB cable but It changed nothing.&#xD;&#xA;&#xD;&#xA;EDIT : Here is the output of verbose mode while uploading :  &#xD;&#xA;Taille binaire du croquis : 1 084 octets (d'un max de 32 256 octets)&#xD;&#xA;/Applications/Arduino.app/Contents/Resources/Java/hardware/tools/avr/bin/avrdude -C/Applications/Arduino.app/Contents/Resources/Java/hardware/tools/avr/etc/avrdude.conf -v -v -v -v -patmega328p -carduino -P/dev/cu.usbmodem641 -b115200 -D -Uflash:w:/var/folders/56/7b6d3xm14n31kjrw8609ywjw0000gn/T/build1168987322216849272.tmp/Blink.cpp.hex:i &#xD;&#xA;&#xD;&#xA;avrdude: Version 5.11, compiled on Sep  2 2011 at 18:52:52&#xD;&#xA;         Copyright (c) 2000-2005 Brian Dean, http://www.bdmicro.com/&#xD;&#xA;         Copyright (c) 2007-2009 Joerg Wunsch&#xD;&#xA;&#xD;&#xA;         System wide configuration file is &quot;/Applications/Arduino.app/Contents/Resources/Java/hardware/tools/avr/etc/avrdude.conf&quot;&#xD;&#xA;         User configuration file is &quot;/Users/trevorannedenise/.avrduderc&quot;&#xD;&#xA;         User configuration file does not exist or is not a regular file, skipping&#xD;&#xA;&#xD;&#xA;         Using Port                    : /dev/cu.usbmodem641&#xD;&#xA;         Using Programmer              : arduino&#xD;&#xA;         Overriding Baud Rate          : 115200&#xD;&#xA;avrdude: Send: 0 [30]   [20] &#xD;&#xA;avrdude: Send: 0 [30]   [20] &#xD;&#xA;avrdude: Send: 0 [30]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;         AVR Part                      : ATMEGA328P&#xD;&#xA;         Chip Erase delay              : 9000 us&#xD;&#xA;         PAGEL                         : PD7&#xD;&#xA;         BS2                           : PC2&#xD;&#xA;         RESET disposition             : dedicated&#xD;&#xA;         RETRY pulse                   : SCK&#xD;&#xA;         serial program mode           : yes&#xD;&#xA;         parallel program mode         : yes&#xD;&#xA;         Timeout                       : 200&#xD;&#xA;         StabDelay                     : 100&#xD;&#xA;         CmdexeDelay                   : 25&#xD;&#xA;         SyncLoops                     : 32&#xD;&#xA;         ByteDelay                     : 0&#xD;&#xA;         PollIndex                     : 3&#xD;&#xA;         PollValue                     : 0x53&#xD;&#xA;         Memory Detail                 :&#xD;&#xA;&#xD;&#xA;                                  Block Poll               Page                       Polled&#xD;&#xA;           Memory Type Mode Delay Size  Indx Paged  Size   Size #Pages MinW  MaxW   ReadBack&#xD;&#xA;           ----------- ---- ----- ----- ---- ------ ------ ---- ------ ----- ----- ---------&#xD;&#xA;           eeprom        65    20     4    0 no       1024    4      0  3600  3600 0xff 0xff&#xD;&#xA;                                  Block Poll               Page                       Polled&#xD;&#xA;           Memory Type Mode Delay Size  Indx Paged  Size   Size #Pages MinW  MaxW   ReadBack&#xD;&#xA;           ----------- ---- ----- ----- ---- ------ ------ ---- ------ ----- ----- ---------&#xD;&#xA;           flash         65     6   128    0 yes     32768  128    256  4500  4500 0xff 0xff&#xD;&#xA;                                  Block Poll               Page                       Polled&#xD;&#xA;           Memory Type Mode Delay Size  Indx Paged  Size   Size #Pages MinW  MaxW   ReadBack&#xD;&#xA;           ----------- ---- ----- ----- ---- ------ ------ ---- ------ ----- ----- ---------&#xD;&#xA;           lfuse          0     0     0    0 no          1    0      0  4500  4500 0x00 0x00&#xD;&#xA;                                  Block Poll               Page                       Polled&#xD;&#xA;           Memory Type Mode Delay Size  Indx Paged  Size   Size #Pages MinW  MaxW   ReadBack&#xD;&#xA;           ----------- ---- ----- ----- ---- ------ ------ ---- ------ ----- ----- ---------&#xD;&#xA;           hfuse          0     0     0    0 no          1    0      0  4500  4500 0x00 0x00&#xD;&#xA;                                  Block Poll               Page                       Polled&#xD;&#xA;           Memory Type Mode Delay Size  Indx Paged  Size   Size #Pages MinW  MaxW   ReadBack&#xD;&#xA;           ----------- ---- ----- ----- ---- ------ ------ ---- ------ ----- ----- ---------&#xD;&#xA;           efuse          0     0     0    0 no          1    0      0  4500  4500 0x00 0x00&#xD;&#xA;                                  Block Poll               Page                       Polled&#xD;&#xA;           Memory Type Mode Delay Size  Indx Paged  Size   Size #Pages MinW  MaxW   ReadBack&#xD;&#xA;           ----------- ---- ----- ----- ---- ------ ------ ---- ------ ----- ----- ---------&#xD;&#xA;           lock           0     0     0    0 no          1    0      0  4500  4500 0x00 0x00&#xD;&#xA;                                  Block Poll               Page                       Polled&#xD;&#xA;           Memory Type Mode Delay Size  Indx Paged  Size   Size #Pages MinW  MaxW   ReadBack&#xD;&#xA;           ----------- ---- ----- ----- ---- ------ ------ ---- ------ ----- ----- ---------&#xD;&#xA;           calibration    0     0     0    0 no          1    0      0     0     0 0x00 0x00&#xD;&#xA;                                  Block Poll               Page                       Polled&#xD;&#xA;           Memory Type Mode Delay Size  Indx Paged  Size   Size #Pages MinW  MaxW   ReadBack&#xD;&#xA;           ----------- ---- ----- ----- ---- ------ ------ ---- ------ ----- ----- ---------&#xD;&#xA;           signature      0     0     0    0 no          3    0      0     0     0 0x00 0x00&#xD;&#xA;&#xD;&#xA;         Programmer Type : Arduino&#xD;&#xA;         Description     : Arduino&#xD;&#xA;avrdude: Send: A [41] . [80]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [03] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: A [41] . [81]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [04] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: A [41] . [82]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [04] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: A [41] . [98]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [03] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;         Hardware Version: 3&#xD;&#xA;         Firmware Version: 4.4&#xD;&#xA;avrdude: Send: A [41] . [84]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [03] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: A [41] . [85]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [03] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: A [41] . [86]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [03] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: A [41] . [87]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [03] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: A [41] . [89]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [03] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;         Vtarget         : 0.3 V&#xD;&#xA;         Varef           : 0.3 V&#xD;&#xA;         Oscillator      : 28.800 kHz&#xD;&#xA;         SCK period      : 3.3 us&#xD;&#xA;&#xD;&#xA;avrdude: Send: A [41] . [81]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [04] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: A [41] . [82]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [04] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: B [42] . [86] . [00] . [00] . [01] . [01] . [01] . [01] . [03] . [ff] . [ff] . [ff] . [ff] . [00] . [80] . [04] . [00] . [00] . [00] . [80] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: E [45] . [05] . [04] . [d7] . [c2] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: P [50]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: AVR device initialized and ready to accept instructions&#xD;&#xA;&#xD;&#xA;Reading | avrdude: Send: u [75]   [20] &#xD;&#xA;avrdude: Recv: . [14] . [1e] . [95] . [0f] . [10] &#xD;&#xA;################################################## | 100% 0.00s&#xD;&#xA;&#xD;&#xA;avrdude: Device signature = 0x1e950f&#xD;&#xA;avrdude: Send: V [56] . [a0] . [03] . [fc] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [00] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: V [56] . [a0] . [03] . [fd] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [00] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: V [56] . [a0] . [03] . [fe] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [00] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: V [56] . [a0] . [03] . [ff] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [00] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: reading input file &quot;/var/folders/56/7b6d3xm14n31kjrw8609ywjw0000gn/T/build1168987322216849272.tmp/Blink.cpp.hex&quot;&#xD;&#xA;avrdude: writing flash (1084 bytes):&#xD;&#xA;&#xD;&#xA;Writing | avrdude: Send: U [55] . [00] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: d [64] . [00] . [80] F [46] . [0c] . [94] a [61] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] . [9d] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [0c] . [94] ~ [7e] . [00] . [00] . [00] . [00] . [00] $ [24] . [00] ' [27] . [00] * [2a] . [00] . [00] . [00] . [00] . [00] % [25] . [00] ( [28] . [00] + [2b] . [00] . [00] . [00] . [00] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;#####avrdude: Send: U [55] @ [40] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: d [64] . [00] . [80] F [46] # [23] . [00] &amp; [26] . [00] ) [29] . [00] . [04] . [04] . [04] . [04] . [04] . [04] . [04] . [04] . [02] . [02] . [02] . [02] . [02] . [02] . [03] . [03] . [03] . [03] . [03] . [03] . [01] . [02] . [04] . [08] . [10]   [20] @ [40] . [80] . [01] . [02] . [04] . [08] . [10]   [20] . [01] . [02] . [04] . [08] . [10]   [20] . [00] . [00] . [00] . [07] . [00] . [02] . [01] . [00] . [00] . [03] . [04] . [06] . [00] . [00] . [00] . [00] . [00] . [00] . [00] . [00] . [11] $ [24] . [1f] . [be] . [cf] . [ef] . [d8] . [e0] . [de] . [bf] . [cd] . [bf] . [11] . [e0] . [a0] . [e0] . [b1] . [e0] . [ea] . [e3] . [f4] . [e0] . [02] . [c0] . [05] . [90] . [0d] . [92] . [a2] 0 [30] . [b1] . [07] . [d9] . [f7] . [11] . [e0] . [a2] . [e0] . [b1] . [e0] . [01] . [c0] . [1d] . [92] . [ab] 0 [30] . [b1] . [07] . [e1] . [f7] . [0e] . [94] . [0c] . [02] . [0c] . [94] . [1b] . [02] . [0c] . [94] . [00] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] . [80] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: d [64] . [00] . [80] F [46] . [80] . [91] . [00] . [01] a [61] . [e0] . [0e] . [94] . [b8] . [01] h [68] . [ee] s [73] . [e0] . [80] . [e0] . [90] . [e0] . [0e] . [94] . [e5] . [00] . [80] . [91] . [00] . [01] ` [60] . [e0] . [0e] . [94] . [b8] . [01] h [68] . [ee] s [73] . [e0] . [80] . [e0] . [90] . [e0] . [0e] . [94] . [e5] . [00] . [08] . [95] . [80] . [91] . [00] . [01] a [61] . [e0] . [0e] . [94] y [79] . [01] . [08] . [95] . [1f] . [92] . [0f] . [92] . [0f] . [b6] . [0f] . [92] . [11] $ [24] / [2f] . [93] ? [3f] . [93] . [8f] . [93] . [9f] . [93] . [af] . [93] . [bf] . [93] . [80] . [91] . [06] . [01] . [90] . [91] . [07] . [01] . [a0] . [91] . [08] . [01] . [b0] . [91] . [09] . [01] 0 [30] . [91] . [0a] . [01] . [01] . [96] . [a1] . [1d] . [b1] . [1d] # [23] / [2f] - [2d] _ [5f] - [2d] 7 [37]   [20] . [f0] - [2d] W [57] . [01] . [96] . [a1] . [1d] . [b1] . [1d]   [20] . [93] . [0a] . [01] . [80] . [93]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] . [c0] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: d [64] . [00] . [80] F [46] . [06] . [01] . [90] . [93] . [07] . [01] . [a0] . [93] . [08] . [01] . [b0] . [93] . [09] . [01] . [80] . [91] . [02] . [01] . [90] . [91] . [03] . [01] . [a0] . [91] . [04] . [01] . [b0] . [91] . [05] . [01] . [01] . [96] . [a1] . [1d] . [b1] . [1d] . [80] . [93] . [02] . [01] . [90] . [93] . [03] . [01] . [a0] . [93] . [04] . [01] . [b0] . [93] . [05] . [01] . [bf] . [91] . [af] . [91] . [9f] . [91] . [8f] . [91] ? [3f] . [91] / [2f] . [91] . [0f] . [90] . [0f] . [be] . [0f] . [90] . [1f] . [90] . [18] . [95] . [9b] . [01] . [ac] . [01] . [7f] . [b7] . [f8] . [94] . [80] . [91] . [02] . [01] . [90] . [91] . [03] . [01] . [a0] . [91] . [04] . [01] . [b0] . [91] . [05] . [01] f [66] . [b5] . [a8] . [9b] . [05] . [c0] o [6f] ? [3f] . [19] . [f0] . [01] . [96] . [a1] . [1d] . [b1] . [1d] . [7f] . [bf] . [ba] / [2f] . [a9] / [2f] . [98] / [2f] . [88] ' [27] . [86] . [0f] . [91] . [1d]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] . [00] . [01]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: d [64] . [00] . [80] F [46] . [a1] . [1d] . [b1] . [1d] b [62] . [e0] . [88] . [0f] . [99] . [1f] . [aa] . [1f] . [bb] . [1f] j [6a] . [95] . [d1] . [f7] . [bc] . [01] - [2d] . [c0] . [ff] . [b7] . [f8] . [94] . [80] . [91] . [02] . [01] . [90] . [91] . [03] . [01] . [a0] . [91] . [04] . [01] . [b0] . [91] . [05] . [01] . [e6] . [b5] . [a8] . [9b] . [05] . [c0] . [ef] ? [3f] . [19] . [f0] . [01] . [96] . [a1] . [1d] . [b1] . [1d] . [ff] . [bf] . [ba] / [2f] . [a9] / [2f] . [98] / [2f] . [88] ' [27] . [8e] . [0f] . [91] . [1d] . [a1] . [1d] . [b1] . [1d] . [e2] . [e0] . [88] . [0f] . [99] . [1f] . [aa] . [1f] . [bb] . [1f] . [ea] . [95] . [d1] . [f7] . [86] . [1b] . [97] . [0b] . [88] ^ [5e] . [93] @ [40] . [c8] . [f2] ! [21] P [50] 0 [30] @ [40] @ [40] @ [40] P [50] @ [40] h [68] Q [51] | [7c] O [4f] ! [21] . [15] 1 [31] . [05] A [41] . [05] Q [51] . [05] q [71] . [f6] . [08] . [95] x [78] . [94] . [84] . [b5]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] @ [40] . [01]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: d [64] . [00] . [80] F [46] . [82] ` [60] . [84] . [bd] . [84] . [b5] . [81] ` [60] . [84] . [bd] . [85] . [b5] . [82] ` [60] . [85] . [bd] . [85] . [b5] . [81] ` [60] . [85] . [bd] . [ee] . [e6] . [f0] . [e0] . [80] . [81] . [81] ` [60] . [80] . [83] . [e1] . [e8] . [f0] . [e0] . [10] . [82] . [80] . [81] . [82] ` [60] . [80] . [83] . [80] . [81] . [81] ` [60] . [80] . [83] . [e0] . [e8] . [f0] . [e0] . [80] . [81] . [81] ` [60] . [80] . [83] . [e1] . [eb] . [f0] . [e0] . [80] . [81] . [84] ` [60] . [80] . [83] . [e0] . [eb] . [f0] . [e0] . [80] . [81] . [81] ` [60] . [80] . [83] . [ea] . [e7] . [f0] . [e0] . [80] . [81] . [84] ` [60] . [80] . [83] . [80] . [81] . [82] ` [60] . [80] . [83] . [80] . [81] . [81] ` [60] . [80] . [83] . [80] . [81] . [80] h [68] . [80] . [83] . [10] . [92] . [c1] . [00] . [08] . [95] . [cf] . [93] . [df] . [93] H [48] / [2f] P [50] . [e0] . [ca] . [01] . [86] V [56] . [9f] O [4f]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] . [80] . [01]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: d [64] . [00] . [80] F [46] . [fc] . [01] 4 [34] . [91] J [4a] W [57] _ [5f] O [4f] . [fa] . [01] . [84] . [91] . [88] # [23] i [69] . [f1] . [90] . [e0] . [88] . [0f] . [99] . [1f] . [fc] . [01] . [e8] Y [59] . [ff] O [4f] . [a5] . [91] . [b4] . [91] . [fc] . [01] . [ee] X [58] . [ff] O [4f] . [c5] . [91] . [d4] . [91] f [66] # [23] Q [51] . [f4] / [2f] . [b7] . [f8] . [94] . [8c] . [91] . [93] / [2f] . [90] . [95] . [89] # [23] . [8c] . [93] . [88] . [81] . [89] # [23] . [0b] . [c0] b [62] 0 [30] a [61] . [f4] / [2f] . [b7] . [f8] . [94] . [8c] . [91] . [93] / [2f] . [90] . [95] . [89] # [23] . [8c] . [93] . [88] . [81] . [83] + [2b] . [88] . [83] / [2f] . [bf] . [06] . [c0] . [9f] . [b7] . [f8] . [94] . [8c] . [91] . [83] + [2b] . [8c] . [93] . [9f] . [bf] . [df] . [91] . [cf] . [91] . [08] . [95] H [48] / [2f] P [50] . [e0] . [ca] . [01] . [82] U [55] . [9f] O [4f] . [fc] . [01] $ [24] . [91] . [ca] . [01]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] . [c0] . [01]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: d [64] . [00] . [80] F [46] . [86] V [56] . [9f] O [4f] . [fc] . [01] . [94] . [91] J [4a] W [57] _ [5f] O [4f] . [fa] . [01] 4 [34] . [91] 3 [33] # [23] . [09] . [f4] @ [40] . [c0] &quot; [22] # [23] Q [51] . [f1] # [23] 0 [30] q [71] . [f0] $ [24] 0 [30] ( [28] . [f4] ! [21] 0 [30] . [a1] . [f0] &quot; [22] 0 [30] . [11] . [f5] . [14] . [c0] &amp; [26] 0 [30] . [b1] . [f0] ' [27] 0 [30] . [c1] . [f0] $ [24] 0 [30] . [d9] . [f4] . [04] . [c0] . [80] . [91] . [80] . [00] . [8f] w [77] . [03] . [c0] . [80] . [91] . [80] . [00] . [8f] } [7d] . [80] . [93] . [80] . [00] . [10] . [c0] . [84] . [b5] . [8f] w [77] . [02] . [c0] . [84] . [b5] . [8f] } [7d] . [84] . [bd] . [09] . [c0] . [80] . [91] . [b0] . [00] . [8f] w [77] . [03] . [c0] . [80] . [91] . [b0] . [00] . [8f] } [7d] . [80] . [93] . [b0] . [00] . [e3] / [2f] . [f0] . [e0] . [ee] . [0f] . [ff] . [1f] . [ee] X [58] . [ff] O [4f] . [a5] . [91] . [b4] . [91] / [2f] . [b7]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] . [00] . [02]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: d [64] . [00] &lt; [3c] F [46] . [f8] . [94] f [66] # [23] ! [21] . [f4] . [8c] . [91] . [90] . [95] . [89] # [23] . [02] . [c0] . [8c] . [91] . [89] + [2b] . [8c] . [93] / [2f] . [bf] . [08] . [95] . [cf] . [93] . [df] . [93] . [0e] . [94] &gt; [3e] . [01] . [0e] . [94] . [97] . [00] . [c0] . [e0] . [d0] . [e0] . [0e] . [94] . [80] . [00]   [20] . [97] . [e1] . [f3] . [0e] . [94] . [00] . [00] . [f9] . [cf] . [f8] . [94] . [ff] . [cf] . [0d] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;### | 100% 0.21s&#xD;&#xA;&#xD;&#xA;avrdude: 1084 bytes of flash written&#xD;&#xA;avrdude: verifying flash memory against /var/folders/56/7b6d3xm14n31kjrw8609ywjw0000gn/T/build1168987322216849272.tmp/Blink.cpp.hex:&#xD;&#xA;avrdude: load data flash data from input file /var/folders/56/7b6d3xm14n31kjrw8609ywjw0000gn/T/build1168987322216849272.tmp/Blink.cpp.hex:&#xD;&#xA;avrdude: input file /var/folders/56/7b6d3xm14n31kjrw8609ywjw0000gn/T/build1168987322216849272.tmp/Blink.cpp.hex contains 1084 bytes&#xD;&#xA;avrdude: reading on-chip flash data:&#xD;&#xA;&#xD;&#xA;Reading | avrdude: Send: U [55] . [00] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: t [74] . [00] . [80] F [46]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;#####avrdude: Send: U [55] @ [40] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: t [74] . [00] . [80] F [46]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] . [80] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: t [74] . [00] . [80] F [46]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] . [c0] . [00]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: t [74] . [00] . [80] F [46]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] . [00] . [01]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: t [74] . [00] . [80] F [46]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] @ [40] . [01]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: t [74] . [00] . [80] F [46]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] . [80] . [01]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: t [74] . [00] . [80] F [46]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] . [c0] . [01]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: t [74] . [00] . [80] F [46]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;######avrdude: Send: U [55] . [00] . [02]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;avrdude: Send: t [74] . [00] &lt; [3c] F [46]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] . [ff] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;### | 100% 0.16s&#xD;&#xA;&#xD;&#xA;avrdude: verifying ...&#xD;&#xA;avrdude: verification error, first mismatch at byte 0x0000&#xD;&#xA;         0x0c != 0xff&#xD;&#xA;avrdude: verification error; content mismatch&#xD;&#xA;avrdude: Send: Q [51]   [20] &#xD;&#xA;avrdude: Recv: . [14] &#xD;&#xA;avrdude: Recv: . [10] &#xD;&#xA;&#xD;&#xA;avrdude done.  Thank you.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2406" PostHistoryTypeId="5" PostId="847" RevisionGUID="785ce818-18e5-4666-bd59-3aa16c27b7a2" CreationDate="2014-03-20T15:20:08.150" UserId="304" Comment="cleaned it up as best I could" Text="I am a new user of Arduino microcontroller (I have a Arduino Due) and also I am a new user of BLE112 (bluegiga module 112)&#xD;&#xA;&#xD;&#xA;My teacher told me to make the BLE112 advertisable and furthermore he told me to look for information about UART@115K And I have to mention that he gave me a ble112 with wires already soldered to the selected pins ( so I conclude that I have to only use those)&#xD;&#xA;&#xD;&#xA;    PIN NUMBER [PIN NAME] for BLE112&#xD;&#xA;&#xD;&#xA;        2         AVDD                    (Supply voltage 2-3.6V)&#xD;&#xA;        3         AVDD                    (Supply voltage 2-3.6V)&#xD;&#xA;        4        [P2_2]  DC- Debug clock  (DIGITAL I/O)&#xD;&#xA;        5        [P2_1]  DD- Debug data	  (DIGITAL I/O)&#xD;&#xA;        9        VDD_USB                  (Supply voltage 2-3.6V)&#xD;&#xA;        20        DVDD                    (Supply voltage 2-3.6V)&#xD;&#xA;        23       [P0_5]  RXD(Rx)          (DIGITAL I/O)&#xD;&#xA;        24       [P0_4]  TXD(TX)          (DIGITAL I/O)&#xD;&#xA;        25       [P0_3]  RTS              (DIGITAL I/O)&#xD;&#xA;        26       [P0_2]  CTS              (DIGITAL I/O)&#xD;&#xA;        29        RESET&#xD;&#xA;        30         GND&#xD;&#xA;&#xD;&#xA;So what I did, was I Connected pins betwen devices like this:&#xD;&#xA;&#xD;&#xA;I put:&#xD;&#xA;&#xD;&#xA;    BLE pins [2,3,9,20]    to     3.3v pin of Arduino &#xD;&#xA;    BLE pin  [30]          to     GND pin of Arduino &#xD;&#xA;&#xD;&#xA;Then I found the picture (attached), there it describes that I should put CTS of BLE on RTS of ardunio and vice versa.&#xD;&#xA;&#xD;&#xA;But I don't know where is that on arduino board?&#xD;&#xA;&#xD;&#xA;So I think I have to program one of the Digital pins? (and I decided to make a connection like this)&#xD;&#xA;&#xD;&#xA;I put:&#xD;&#xA;&#xD;&#xA;    BLE pin 26(CTS)   to    Arduino random digital pin 32, and &#xD;&#xA;    BLE pin 25(RTS)         Arduino random digital pin 34.&#xD;&#xA;&#xD;&#xA;    BLE pin 24(TX)          Arduino RX pin 0&#xD;&#xA;    BLE pin 23(RX)          Arduino TX pin 1&#xD;&#xA;&#xD;&#xA;I didn't connect `DC(Debug clock)`, `DD(Debug data)` and `Reset` from BLE112.&#xD;&#xA;&#xD;&#xA;So then I found some more info on the web that if I use USART than I should use a wake up pin which is by the default `P0_0`(??) more about that in the attached pdf. (search by wake_up)&#xD;&#xA;&#xD;&#xA;Now I should mention sleep mode Ble112 (there are three kinds of it) and I believe that the one I am after is MODE 3 (that means that it consumes the minimum (power) of them all) &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I found some example named UART@115K&#xD;&#xA;&#xD;&#xA;&gt; UART@115k &#xD;&#xA;This example configures the BLE112 or BLE113 Bluetooth Smart module to expose the BGAPI protocol over UART interface with the following settings: 115200 bps, 8n1 and hardware flow control enabled. The power mode 3 is enabled in this example and the wake-up pin is configured to P0_0 pin (P0_0 button on DKBLE112 &#xD;&#xA;and DKBLE113). When the power mode 3 is enabled the device will not be able to receive commands or data over UART unless the wake-up pin is asserted.&#xD;&#xA;&#xD;&#xA;&gt; The example uses UART in the pin configuration channel 1 and alternate 1, which is the configuration used in the DKBLE112 and DKBLE113 development kits. &#xD;&#xA;If you try this example with DKBLE112 or DKBLE113 make sure the UART interface is enabled and the device is NOT powered with a CR2032 battery as it’s not able to power up the level shifter or UART to USB converter. &#xD;&#xA;&#xD;&#xA;&gt; This is also the factory default configuration for BLE112 and BLE113 Bluetooth Smart Modules.&#xD;&#xA;&#xD;&#xA;![Connection shown][1] &#xD;&#xA;&#xD;&#xA;and the link where i found this: [https://bluegiga.zendesk.com/entries/22412436][2] and the pdf I mentioned before for start_up ([pdf])[3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/OwjIi.jpg&#xD;&#xA;  [2]: https://bluegiga.zendesk.com/entries/22412436&#xD;&#xA;  [3]: https://www.bluegiga.com/protectedstore/8pHYFByrRbCfvauWLt5CMQ/lnlU2gAsQ0xNiol858gOLw/_JR5_qFqBNLIfHoFIFcdq0y9048xjcuyJMYmCVLj-j3xRFlc8VYw/Bluetooth_Smart_Configuration_Guide_v33.pdf" />
  <row Id="2407" PostHistoryTypeId="24" PostId="847" RevisionGUID="785ce818-18e5-4666-bd59-3aa16c27b7a2" CreationDate="2014-03-20T15:20:08.150" Comment="Proposed by 304 approved by 220 edit id of 250" />
  <row Id="2408" PostHistoryTypeId="6" PostId="403" RevisionGUID="d605cbc0-6d37-41fa-b5e2-9ea7375e99f2" CreationDate="2014-03-20T15:21:28.933" UserId="220" Comment="edited tags" Text="&lt;pins&gt;&lt;voltage-level&gt;" />
  <row Id="2409" PostHistoryTypeId="5" PostId="847" RevisionGUID="77a525e3-c287-4665-8158-21c4ef32fc4f" CreationDate="2014-03-20T15:28:51.163" UserId="220" Comment="deleted 201 characters in body; edited tags; edited title" Text="I am a new user of Arduino (I have a Arduino Due) and also I am a new user of BLE112 (Bluegiga module 112)&#xD;&#xA;&#xD;&#xA;My teacher told me to make the BLE112 advertisable and furthermore he told me to look for information about UART@115K. (The Ble112 he gave me came with wires already soldered to the selected pins: I'm assuming I only need to use those.)&#xD;&#xA;&#xD;&#xA;    PIN NUMBER [PIN NAME] for BLE112&#xD;&#xA;&#xD;&#xA;        2         AVDD                    (Supply voltage 2-3.6V)&#xD;&#xA;        3         AVDD                    (Supply voltage 2-3.6V)&#xD;&#xA;        4        [P2_2]  DC- Debug clock  (DIGITAL I/O)&#xD;&#xA;        5        [P2_1]  DD- Debug data	  (DIGITAL I/O)&#xD;&#xA;        9        VDD_USB                  (Supply voltage 2-3.6V)&#xD;&#xA;        20        DVDD                    (Supply voltage 2-3.6V)&#xD;&#xA;        23       [P0_5]  RXD(Rx)          (DIGITAL I/O)&#xD;&#xA;        24       [P0_4]  TXD(TX)          (DIGITAL I/O)&#xD;&#xA;        25       [P0_3]  RTS              (DIGITAL I/O)&#xD;&#xA;        26       [P0_2]  CTS              (DIGITAL I/O)&#xD;&#xA;        29        RESET&#xD;&#xA;        30         GND&#xD;&#xA;&#xD;&#xA;I put:&#xD;&#xA;&#xD;&#xA;    BLE pins [2,3,9,20]    to     3.3v pin of Arduino &#xD;&#xA;    BLE pin  [30]          to     GND pin of Arduino &#xD;&#xA;&#xD;&#xA;Then I found a picture (attached at the bottom of this post) that describes that I should put CTS of BLE on RTS of Arduino and vice versa. Where is the CTS on an Arduino board? I think I have to program one of the Digital pins.&#xD;&#xA;&#xD;&#xA;I tried some other connections. I put:&#xD;&#xA;&#xD;&#xA;    BLE pin 26(CTS)   to    Arduino random digital pin 32, and &#xD;&#xA;    BLE pin 25(RTS)         Arduino random digital pin 34.&#xD;&#xA;&#xD;&#xA;    BLE pin 24(TX)          Arduino RX pin 0&#xD;&#xA;    BLE pin 23(RX)          Arduino TX pin 1&#xD;&#xA;&#xD;&#xA;I didn't connect `DC(Debug clock)`, `DD(Debug data)` and `Reset` on the BLE112.&#xD;&#xA;&#xD;&#xA;So then I found some more info on the web that if I use USART than I should use a wake up pin which is by the default `P0_0`(??) more about that in [this PDF][3]. (Search `wake_up`)&#xD;&#xA;&#xD;&#xA;Now I should mention sleep mode Ble112 (there are three kinds of it) and I believe that the one I am after is MODE 3 (that means that it consumes the minimum (power) of them all) &#xD;&#xA;&#xD;&#xA;I found some example named UART@115K&#xD;&#xA;&#xD;&#xA;&gt; UART@115k &#xD;&#xA;This example configures the BLE112 or BLE113 Bluetooth Smart module to expose the BGAPI protocol over UART interface with the following settings: 115200 bps, 8n1 and hardware flow control enabled. The power mode 3 is enabled in this example and the wake-up pin is configured to P0_0 pin (P0_0 button on DKBLE112 &#xD;&#xA;and DKBLE113). When the power mode 3 is enabled the device will not be able to receive commands or data over UART unless the wake-up pin is asserted.&#xD;&#xA;&#xD;&#xA;&gt; The example uses UART in the pin configuration channel 1 and alternate 1, which is the configuration used in the DKBLE112 and DKBLE113 development kits. &#xD;&#xA;If you try this example with DKBLE112 or DKBLE113 make sure the UART interface is enabled and the device is NOT powered with a CR2032 battery as it’s not able to power up the level shifter or UART to USB converter. &#xD;&#xA;&#xD;&#xA;&gt; This is also the factory default configuration for BLE112 and BLE113 Bluetooth Smart Modules.&#xD;&#xA;&#xD;&#xA;&gt;![Connection shown][1] &#xD;&#xA;&#xD;&#xA;*Source: [https://bluegiga.zendesk.com/entries/22412436][2]*&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/OwjIi.jpg&#xD;&#xA;  [2]: https://bluegiga.zendesk.com/entries/22412436&#xD;&#xA;  [3]: https://www.bluegiga.com/protectedstore/8pHYFByrRbCfvauWLt5CMQ/lnlU2gAsQ0xNiol858gOLw/_JR5_qFqBNLIfHoFIFcdq0y9048xjcuyJMYmCVLj-j3xRFlc8VYw/Bluetooth_Smart_Configuration_Guide_v33.pdf" />
  <row Id="2410" PostHistoryTypeId="4" PostId="847" RevisionGUID="77a525e3-c287-4665-8158-21c4ef32fc4f" CreationDate="2014-03-20T15:28:51.163" UserId="220" Comment="deleted 201 characters in body; edited tags; edited title" Text="How do I connect Arduino to a Bluegiga112?" />
  <row Id="2411" PostHistoryTypeId="6" PostId="847" RevisionGUID="77a525e3-c287-4665-8158-21c4ef32fc4f" CreationDate="2014-03-20T15:28:51.163" UserId="220" Comment="deleted 201 characters in body; edited tags; edited title" Text="&lt;pins&gt;&lt;arduino-due&gt;&lt;bluetooth&gt;" />
  <row Id="2412" PostHistoryTypeId="5" PostId="15" RevisionGUID="e49cc226-3935-4977-91f0-885ebc146274" CreationDate="2014-03-20T15:31:55.707" UserId="220" Comment="added 183 characters in body" Text="The Arduino Uno is the most common and one of the newest Arduinos, based on the ATmega328 microcontroller. Use this tag when asking a question specific to an Uno, not just a general Arduino question. Use the &quot;arduino-uno-smd&quot; tag when the question is specific about the SMD version of the Uno.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&gt; ![Arduino Uno][1]&#xD;&#xA;&gt; The Arduino Uno is a microcontroller board based on the ATmega328. It&#xD;&#xA;&gt; has 14 digital input/output pins (of which 6 can be used as PWM&#xD;&#xA;&gt; outputs), 6 analog inputs, a 16 MHz ceramic resonator, a USB&#xD;&#xA;&gt; connection, a power jack, an ICSP header, and a reset button. It&#xD;&#xA;&gt; contains everything needed to support the microcontroller; simply&#xD;&#xA;&gt; connect it to a computer with a USB cable or power it with a AC-to-DC&#xD;&#xA;&gt; adapter or battery to get started. The Uno differs from all preceding&#xD;&#xA;&gt; boards in that it does not use the FTDI USB-to-serial driver chip.&#xD;&#xA;&gt; Instead, it features the Atmega16U2 (Atmega8U2 up to version R2)&#xD;&#xA;&gt; programmed as a USB-to-serial converter.&#xD;&#xA;&gt; &#xD;&#xA;&gt; Specs:&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - Microcontroller: ATmega328&#xD;&#xA;&gt;  - Operating Voltage: 5V&#xD;&#xA;&gt;  - Input Voltage (recommended): 7-12V&#xD;&#xA;&gt;  - Input Voltage (limits): 6-20V&#xD;&#xA;&gt;  - Digital I/O Pins: 14 (of which 6 provide PWM output)&#xD;&#xA;&gt;  - Analog Input Pins: 6&#xD;&#xA;&gt;  - DC Current per I/O Pin: 40 mA&#xD;&#xA;&gt;  - DC Current for 3.3V Pin: 50 mA&#xD;&#xA;&gt;  - Flash Memory: 32 KB (ATmega328) of which 0.5 KB used by bootloader&#xD;&#xA;&gt;  - SRAM: 2 KB (ATmega328)&#xD;&#xA;&gt;  - EEPROM: 1 KB (ATmega328)&#xD;&#xA;&gt;  - Clock Speed: 16 MHz&#xD;&#xA;&#xD;&#xA;From *&lt;http://arduino.cc/en/Main/ArduinoBoardUno&gt;*&#xD;&#xA;&#xD;&#xA;The main limitation with the Uno is the Uno's lack of SRAM or flash memory. However, the Uno is the most commonly used Arduino board. It is $30, and is compatible with many shields.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/OuoAD.jpg" />
  <row Id="2415" PostHistoryTypeId="2" PostId="850" RevisionGUID="fb3b1b53-3423-4677-961a-15e369925d5b" CreationDate="2014-03-20T17:39:06.713" UserId="470" Text="I think [µProg – tiny, fast, portable AVR programmer with SD](http://mdiy.pl/uprog-maly-szybki-przenosny-programator-avr-z-sd/?lang=en) does what you want. You can store multiple files in the SD card (hex, eep etc) and select from the device menu which one to write to the target MCU without any need for a PC.  &#xD;&#xA;The best part is that it's available for free (PCB, schematic, firmware etc).&#xD;&#xA;&#xD;&#xA;&gt; One of a kind, portable AVR programmer! Helps wherever you need to&#xD;&#xA;&gt; update the device firmware, where target device is in a hard-to-reach&#xD;&#xA;&gt; location and you can’t (or don’t want to) bring your laptop with a&#xD;&#xA;&gt; bunch of wires with you. Trivially easy to use, super cheap to make,&#xD;&#xA;&gt; super small, super fast, uses SD cards…&#xD;&#xA;&gt; &#xD;&#xA;&gt; Features:&#xD;&#xA;&#xD;&#xA;&gt; - super small – dimensions 44 x 39 x 5,5 mm  &#xD;&#xA;&gt; - super fast – write up to 12,5kB/s, read up to 14,5kB/s  &#xD;&#xA;&gt; - uses cheap storage medium – small MICRO SD cards&#xD;&#xA;&gt; - supports FAT16 and FAT32 file systems&#xD;&#xA;&gt; - can read, write, verify flash and eeprom memory&#xD;&#xA;&gt; - can read, write, verify fusebits and lockbits&#xD;&#xA;&gt; - write and read to BIN, HEX, and TXT files&#xD;&#xA;&gt; - can set default values of fusebits, erase memories&#xD;&#xA;&gt; - cheap, easy to obtain, LPH7779 graphic display&#xD;&#xA;&gt; - shows funny animations after every operation&#xD;&#xA;&gt; - standard programming header – Atmel 6-PIN ISP&#xD;&#xA;&gt; - has a function of auto-update its own firmware (from SD)&#xD;&#xA;&gt; - very simple to use, 4 buttons navigation&#xD;&#xA;&gt; - user-setting menu&#xD;&#xA;&gt; - programming speed auto-selection (up to 4MHz)&#xD;&#xA;&gt; - Operates at 3V, programs chips supplied from 3V to 5V&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Supported chip list&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/XZRUr.jpg" />
  <row Id="2417" PostHistoryTypeId="2" PostId="851" RevisionGUID="16510525-0c10-4ea8-ba73-3a100d4a5f17" CreationDate="2014-03-20T18:03:24.497" UserId="497" Text="Exactly what is happening and why cannot be determined based on the amount of info provided. However, I see at least one potential problem which would at least partially explain the symptoms described. &#xD;&#xA;&#xD;&#xA;You said that you are using diodes to select the voltage supply, and one supply is a 3V battery. If you are using standard diodes that drop ~0.6V then the supply voltage to the MCU is only ~2.4V. If you are using Schottky diodes with a voltage drop between 0.15-0.45, the supply voltage is potentially as low as 2.5V. You have the BOD voltage set to 2.7 volts, so in theory the MCU will never boot with the battery. &#xD;&#xA;&#xD;&#xA;As for why you can start it at 5v, drop to 3v, and bring it back up again- I'm not sure. You could be disabling the BOD in code...maybe… Not sure why it works, but it's likely not guaranteed to work.&#xD;&#xA;&#xD;&#xA;I setup a diode switch circuit with 5v and 3.3v to see what it looks like on my oscilloscope when the voltages switch. When at 3.3v switching up to 5v, the voltage oscillates quite a bit initially. This may potentially cause some problems when the MCU tries to come out of sleep. Putting a cap between VCC and GND smoothed the signal very nicely. When switching from 5v to 3.3v, there really wasn't any oscillating, just a clean drop.&#xD;&#xA;&#xD;&#xA;From this information, it seems that you should lower the BOD threshold or turn of the BOD, and put a decoupling cap between VCC and GND. You probably also should make sure you have a pull-down resistor on INT0, and read the MCU datasheet sections explaining the various sleep modes all the considerations for sleeping and waking – it’s pretty involved. Cheers&#xD;&#xA;" />
  <row Id="2420" PostHistoryTypeId="2" PostId="852" RevisionGUID="0b05af7b-78bb-491f-b56f-d86cca229edf" CreationDate="2014-03-20T18:57:59.170" UserId="600" Text="So... turned out what was happening was all in code. Turns out that I was initializing an interrupt on INT0, when it was low, at the very beginning of my code. Problem was that when it started up on 3V backup power, INT0 was always low because INT0 is tied to the 5V line (it's how it knows to go to sleep). Because INT0 was low and the interrupt was triggering on low it was causing a constant interrupt to occur, never giving the rest of the program any time to run. Switched to enabling that interrupt only once I've entered full waking mode and it works fine now." />
  <row Id="2421" PostHistoryTypeId="5" PostId="851" RevisionGUID="fb6f4442-50fa-48a0-a0af-f13ff83f8ec0" CreationDate="2014-03-20T19:20:50.480" UserId="497" Comment="fixed spelling" Text="Exactly what is happening and why cannot be determined based on the amount of info provided. However, I see at least one potential problem which would at least partially explain the symptoms described. &#xD;&#xA;&#xD;&#xA;You said that you are using diodes to select the voltage supply, and one supply is a 3V battery. If you are using standard diodes that drop ~0.6V then the supply voltage to the MCU is only ~2.4V. If you are using Schottky diodes with a voltage drop between 0.15-0.45, the supply voltage is potentially as low as 2.5V. You have the BOD voltage set to 2.7 volts, so in theory the MCU will never boot with the battery. &#xD;&#xA;&#xD;&#xA;As for why you can start it at 5v, drop to 3v, and bring it back up again- I'm not sure. You could be disabling the BOD in code...maybe… Not sure why it works, but it's likely not guaranteed to work.&#xD;&#xA;&#xD;&#xA;I setup a diode switch circuit with 5v and 3.3v to see what it looks like on my oscilloscope when the voltages switch. When at 3.3v switching up to 5v, the voltage oscillates quite a bit initially. This may potentially cause some problems when the MCU tries to come out of sleep. Putting a cap between VCC and GND smoothed the signal very nicely. When switching from 5v to 3.3v, there really wasn't any oscillating, just a clean drop.&#xD;&#xA;&#xD;&#xA;From this information, it seems that you should lower the BOD threshold or turn off the BOD, and put a decoupling cap between VCC and GND. You probably also should make sure you have a pull-down resistor on INT0, and read the MCU datasheet sections explaining the various sleep modes all the considerations for sleeping and waking – it’s pretty involved. Cheers&#xD;&#xA;" />
  <row Id="2422" PostHistoryTypeId="5" PostId="845" RevisionGUID="28eac3ea-485c-4280-ad12-94df89a228db" CreationDate="2014-03-20T19:25:03.440" UserId="84" Comment="Injected information relevant to the answer, from the current comments." Text="I have located the source of the problem.&#xD;&#xA;&#xD;&#xA;In file wiring.c (arduino-1.5.6-r2\hardware\arduino\avr\cores\arduino) which gets called before setup(), there is the following part that tries to changes the timer 2 prescaller to 64 by setting the `CS22` bit.  &#xD;&#xA;&#xD;&#xA;    // set timer 2 prescale factor to 64&#xD;&#xA;    #if defined(TCCR2) &amp;&amp; defined(CS22)&#xD;&#xA;    	sbi(TCCR2, CS22);&#xD;&#xA;    #elif defined(TCCR2B) &amp;&amp; defined(CS22)&#xD;&#xA;    	sbi(TCCR2B, CS22);&#xD;&#xA;    #else&#xD;&#xA;    	#warning Timer 2 not finished (may not be present on this CPU)&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;You already set `CS20` and  `CS22` so this doesn't affect you. What does affect you is the following part which sets bit `WGM20` &#xD;&#xA;&#xD;&#xA;    	// configure timer 2 for phase correct pwm (8-bit)&#xD;&#xA;    #if defined(TCCR2) &amp;&amp; defined(WGM20)&#xD;&#xA;    	sbi(TCCR2, WGM20);&#xD;&#xA;    #elif defined(TCCR2A) &amp;&amp; defined(WGM20)&#xD;&#xA;    	sbi(TCCR2A, WGM20);&#xD;&#xA;    #else&#xD;&#xA;    	#warning Timer 2 not finished (may not be present on this CPU)&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;and you have already set `WGM21` so `WGM21` and `WGM20` set changes the timer mode to fast PWM , top=0xFF which gives almost double delay that the mode you were trying to use (CTC top=124).&#xD;&#xA;&#xD;&#xA;**How to workaround this issue?**&#xD;&#xA;&#xD;&#xA;Timer2 is used when its associated PWM pins are used with an `analogWrite()` call, so the Arduino setup code sets all prescalers to well-defined values just in case the timers might get used later.&#xD;&#xA;&#xD;&#xA;I would not try to fight that code; instead, I would just make sure that my setup code runs later, e.g. by moving it to a separate `setup()` method in your `Timer` class and calling that from the global `setup()` routine." />
  <row Id="2423" PostHistoryTypeId="24" PostId="845" RevisionGUID="28eac3ea-485c-4280-ad12-94df89a228db" CreationDate="2014-03-20T19:25:03.440" Comment="Proposed by 84 approved by 11 edit id of 251" />
  <row Id="2424" PostHistoryTypeId="2" PostId="853" RevisionGUID="d1d8f549-04a3-40b0-bb4d-7785bd715c6c" CreationDate="2014-03-20T19:34:40.437" UserId="84" Text="As a follow-up up to @alexan_e answer, here is what I finally did to ensure that my Timer2 settings are not overwritten by the `init()` method in Arduino `wiring.c`.&#xD;&#xA;&#xD;&#xA;    #define BIT(x) (0x01 &lt;&lt; (x))&#xD;&#xA;    &#xD;&#xA;    static volatile uint32_t milliseconds = 0;&#xD;&#xA;    &#xD;&#xA;    class Timer&#xD;&#xA;    {&#xD;&#xA;        public:&#xD;&#xA;        // Don't use the constructor anymore&#xD;&#xA;        void init()&#xD;&#xA;        {&#xD;&#xA;            // Disable interrupts&#xD;&#xA;            uint8_t savedStatus = SREG;&#xD;&#xA;            cli();&#xD;&#xA;            // Use Timer2 with 1 ms interrupts&#xD;&#xA;            // OC2A &amp; OC2B disconnected, mode 2 (CTC, Clear Timer on Compare match)&#xD;&#xA;            TCCR2A = BIT(WGM21);&#xD;&#xA;            // Don't force output compare (FOCA &amp; FOCB), mode 2, Clock Select clk/128 (CS = 5)&#xD;&#xA;            TCCR2B = BIT(CS22) | BIT(CS20);&#xD;&#xA;            // Set timer counter compare match (when value reached, 1ms has elapsed)&#xD;&#xA;            OCR2A = 125 - 1;&#xD;&#xA;            // Reset Timer2 counter&#xD;&#xA;            TCNT2 = 0;&#xD;&#xA;            // Set Timer2 interrupt mode (Set interrupt on OCR2A compare match)&#xD;&#xA;            TIMSK2 = BIT(OCIE2A);&#xD;&#xA;    &#xD;&#xA;            // Restore interrupt enabling state&#xD;&#xA;            SREG = savedStatus;&#xD;&#xA;        }&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;    static void callEveryMillisecond(uint32_t ms)&#xD;&#xA;    {&#xD;&#xA;        if (ms % 10000 == 0)&#xD;&#xA;            digitalWrite(13, digitalRead(13) ^ 1);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    // Attach interrupt routine to the Timer Compare Interrupt&#xD;&#xA;    ISR(TIMER2_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;        milliseconds++;&#xD;&#xA;        callEveryMillisecond(milliseconds);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    static Timer timer;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        // Explicit call to Timer initialization; this occurs AFTER &#xD;&#xA;        // Arduino wiring.c init() has been called&#xD;&#xA;        timer.init();&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2425" PostHistoryTypeId="2" PostId="854" RevisionGUID="8f0c3ac1-1f73-4165-b0e2-8b6863dc1421" CreationDate="2014-03-20T20:17:25.960" UserId="755" Text="I would like to be able to use a USB port at the same time as an RS-232 port with my Arduino Uno board. I unwittingly bought a shield that (I think?) overrides the USB port when it is mounted to the Arduino board:&#xD;&#xA;&#xD;&#xA;http://www.dfrobot.com/wiki/index.php/RS232_Shield&#xD;&#xA;&#xD;&#xA;Would anyone be able to give me any advice on how to connect the hardware so that I can have two serial ports accessible from my Arduino Uno? The format I was thinking was (Arduino =&gt; RS-232 Sheild):&#xD;&#xA;&#xD;&#xA;GND =&gt; GND&#xD;&#xA;5V =&gt; 5V&#xD;&#xA;Digital Pin 2 =&gt; 232RXD&#xD;&#xA;Digital Pin 3 =&gt; 232TXD&#xD;&#xA;&#xD;&#xA;The accompanying code for initializing the serial port which I've written:&#xD;&#xA;&#xD;&#xA;    const int rxpin = 2; // pin used to receive&#xD;&#xA;    const int txpin = 3; // pin used to send&#xD;&#xA;    SoftwareSerial Serial_rs232(rxpin, txpin); // new serial port&#xD;&#xA;&#xD;&#xA;Any ideas as to why this may or may not be a good method of using the hardware I have available for the purpose I had in mind?" />
  <row Id="2426" PostHistoryTypeId="1" PostId="854" RevisionGUID="8f0c3ac1-1f73-4165-b0e2-8b6863dc1421" CreationDate="2014-03-20T20:17:25.960" UserId="755" Text="How to use RS-232 sheild as software serial port?" />
  <row Id="2427" PostHistoryTypeId="3" PostId="854" RevisionGUID="8f0c3ac1-1f73-4165-b0e2-8b6863dc1421" CreationDate="2014-03-20T20:17:25.960" UserId="755" Text="&lt;arduino-uno&gt;&lt;serial&gt;&lt;software&gt;" />
  <row Id="2428" PostHistoryTypeId="2" PostId="855" RevisionGUID="0db19dc6-fce9-4b32-889d-720d50fa91ee" CreationDate="2014-03-20T20:45:08.857" UserId="220" Text="&gt; GND =&gt; GND 5V =&gt; 5V Digital Pin 2 =&gt; 232RXD Digital Pin 3 =&gt; 232TXD&#xD;&#xA;&#xD;&#xA;A better choice of board would be the Leonardo, since you could connect such a shield *and* use the USB port right out of the box. However, since you have the Uno, there is a solution.&#xD;&#xA;&#xD;&#xA;*From [Arduino](http://arduino.cc/en/Reference/SoftwareSerial):*&#xD;&#xA;&#xD;&#xA;&gt; The SoftwareSerial library has been developed to allow serial communication on other digital pins of the Arduino, using software to replicate the functionality (hence the name &quot;SoftwareSerial&quot;). It is possible to have multiple software serial ports with speeds up to 115200 bps. A parameter enables inverted signaling for devices which require that protocol.&#xD;&#xA;&#xD;&#xA;It then goes on to reccomend the library [AltSoftSerial](http://www.pjrc.com/teensy/td_libs_AltSoftSerial.html).&#xD;&#xA;&#xD;&#xA;Here is some example code from the link above:&#xD;&#xA;&#xD;&#xA;    #include &lt;AltSoftSerial.h&gt;&#xD;&#xA;    &#xD;&#xA;    AltSoftSerial altSerial;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      Serial.println(&quot;AltSoftSerial Test Begin&quot;);&#xD;&#xA;      altSerial.begin(9600);&#xD;&#xA;      altSerial.println(&quot;Hello World&quot;);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      char c;&#xD;&#xA;    &#xD;&#xA;      if (Serial.available()) {&#xD;&#xA;        c = Serial.read();&#xD;&#xA;        altSerial.print(c);&#xD;&#xA;      }&#xD;&#xA;      if (altSerial.available()) {&#xD;&#xA;        c = altSerial.read();&#xD;&#xA;        Serial.print(c);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;It acts like a standard serial port, only you declare the connection as a variable first. This code is written for a board with an additional serial port, like you have.&#xD;&#xA;&#xD;&#xA;## All is good, except for one problem:&#xD;&#xA;&#xD;&#xA;The problem is the shield is wired to connect to pins 0 and 1: the ones used by the USB adapter. The AltSoftSerial library uses pins 8 for TX and 9 for RX. (Note: You cannot use PWM on pin 10 on the Uno... it should still work as a digital pin.) In that case you would **not attach the shield by plugging it into the Arduino**, and you would wire it like this:&#xD;&#xA;&#xD;&#xA;&gt; GND =&gt; GND | 5V =&gt; 5V | Digital Pin 8 =&gt; 232RXD pin 0 on the shield headers | Digital Pin 9 =&gt; 232TXD 1 on the shield headers&#xD;&#xA;&#xD;&#xA;So then, you would be manually wiring the shield to the Arduino with jumpers. As long as it doesn't connect to any other Arduino pins I'm not aware of (it shouldn't besides maybe 13 for a LED or something like that), it should function like it would stacked and using pins 0 and 1.&#xD;&#xA;&#xD;&#xA;Note: (Obviously) You cannot connect anything to the headers on the shield (You cannot connect to pin 5 and get a signal)." />
  <row Id="2429" PostHistoryTypeId="2" PostId="856" RevisionGUID="bce285c3-6351-4245-856b-19639d1e77b5" CreationDate="2014-03-20T21:55:14.047" UserId="497" Text="I tried those Tiny cores you are using and had a lot of problems. I switched to http://code.google.com/p/arduino-tiny/ and it seems much better. Create a second Arduino installation folder and add the arduino-tiny cores.  The pin name constants are like PIN_A0, PIN_A1,...,PIN_B1, etc. So, try that out.&#xD;&#xA;&#xD;&#xA;I looked briefly at the VirtualWire code and there are ifdefs specifically for the Attiny85, so it should work.  Here is a derivative project with working ATTINY85 examples: http://cosa-arduino.blogspot.de/2013/03/news-virtual-wire-interface.html" />
  <row Id="2430" PostHistoryTypeId="2" PostId="857" RevisionGUID="ca345dd3-a4ac-44b9-af17-6c6a3d21b242" CreationDate="2014-03-20T22:39:51.870" UserId="756" Text="new to arduino I'm struggling with what sounds like fairly n00b problem...&#xD;&#xA;I've wired up a adafruit GPS-board to my Arduino and it is working as it spits out GPS data to the serial port with `Serial.print(GPS.latitude, DEC)`&#xD;&#xA;&#xD;&#xA;I Now want to concat a string which I can process (read: I want to sent it via an ethernet client.)&#xD;&#xA;This is what I got already:&#xD;&#xA;&#xD;&#xA;    ......&#xD;&#xA;    String vnnt = &quot;$VNNT,&quot;;&#xD;&#xA;    &#xD;&#xA;    if (GPS.fix) {&#xD;&#xA;       vnnt += &quot;GPS,&quot;;&#xD;&#xA;&#xD;&#xA;       //this works:&#xD;&#xA;       vannut.concat(GPS.fix);&#xD;&#xA;      &#xD;&#xA;       //but this not:&#xD;&#xA;       vnnt.concat(GPS.latitude)&#xD;&#xA;&#xD;&#xA;    }else{&#xD;&#xA;       vnnt += &quot;INFO,Acquiring Sats&quot;;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Serial.println(vnnt);&#xD;&#xA;&#xD;&#xA;The error message is: `Call of overloaded 'concat(float&amp;)' is ambiguous`&#xD;&#xA;When I `Serial.print(GPS.latitude, DEC)` it results in: `4418.5937996050`&#xD;&#xA;&#xD;&#xA;So it is probably to big or something... &#xD;&#xA;&#xD;&#xA;**How can I concat the vars and create the long string?**&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2431" PostHistoryTypeId="1" PostId="857" RevisionGUID="ca345dd3-a4ac-44b9-af17-6c6a3d21b242" CreationDate="2014-03-20T22:39:51.870" UserId="756" Text="How to build (concat) a string with big numbers" />
  <row Id="2432" PostHistoryTypeId="3" PostId="857" RevisionGUID="ca345dd3-a4ac-44b9-af17-6c6a3d21b242" CreationDate="2014-03-20T22:39:51.870" UserId="756" Text="&lt;arduino-uno&gt;&lt;programming&gt;&lt;software&gt;" />
  <row Id="2433" PostHistoryTypeId="5" PostId="857" RevisionGUID="77223857-b2fd-4d1f-b847-2e9a6624b164" CreationDate="2014-03-20T22:45:58.590" UserId="756" Comment="Typo's" Text="new to arduino I'm struggling with what sounds like fairly n00b problem...&#xD;&#xA;I've wired up a adafruit GPS-board to my Arduino and it is working as it spits out GPS data to the serial port with `Serial.print(GPS.latitude, DEC)`&#xD;&#xA;&#xD;&#xA;I Now want to concat a string which I can process (read: I want to sent it via an ethernet client.)&#xD;&#xA;This is what I got already:&#xD;&#xA;&#xD;&#xA;    ......&#xD;&#xA;    String vnnt = &quot;$VNNT,&quot;;&#xD;&#xA;    &#xD;&#xA;    if (GPS.fix) {&#xD;&#xA;       vnnt += &quot;GPS,&quot;;&#xD;&#xA;&#xD;&#xA;       //this works:&#xD;&#xA;       vnnt.concat(GPS.fix);&#xD;&#xA;      &#xD;&#xA;       //but this not:&#xD;&#xA;       vnnt.concat(GPS.latitude);&#xD;&#xA;&#xD;&#xA;    }else{&#xD;&#xA;       vnnt += &quot;INFO,Acquiring Sats&quot;;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    Serial.println(vnnt);&#xD;&#xA;&#xD;&#xA;The error message is: `Call of overloaded 'concat(float&amp;)' is ambiguous`&#xD;&#xA;When I `Serial.print(GPS.latitude, DEC)` it results in: `4418.5937996050`&#xD;&#xA;&#xD;&#xA;So it is probably to big or something... &#xD;&#xA;&#xD;&#xA;**How can I concat the vars and create the long string?**&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2434" PostHistoryTypeId="2" PostId="858" RevisionGUID="c9ee18cf-aa10-49e9-8a93-178faf5aaa85" CreationDate="2014-03-20T22:52:25.423" UserId="666" Text="The concat function does not implement a float version, but some of char, int, unsigneds... so the compiler does not know how to cast (truncating probably the float) to integer. &#xD;&#xA;&#xD;&#xA;You have to convert first your float to string, use dtostrf(), then concat to your string." />
  <row Id="2435" PostHistoryTypeId="5" PostId="858" RevisionGUID="96b8f6c6-c1d8-4228-b883-7fae8a60d98c" CreationDate="2014-03-20T22:59:11.010" UserId="666" Comment="added 413 characters in body" Text="The concat function does not implement a float version, but some of char, int, unsigneds...&#xD;&#xA;&#xD;&#xA;    unsigned char String::concat(long unsigned int)&#xD;&#xA;    unsigned char String::concat(unsigned int)&#xD;&#xA;    unsigned char String::concat(int)&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA; so the compiler does not know how to cast (truncating probably the float) to integer, as there are several options. &#xD;&#xA;&#xD;&#xA;You have to convert first your float to string, use dtostrf() or sprintf() then concat to your string.&#xD;&#xA;&#xD;&#xA;    char outstr[25];&#xD;&#xA;    sprintf(outstr, &quot;%f&quot;, GPS.latitude);&#xD;&#xA;or&#xD;&#xA;&#xD;&#xA;    dtostrf(GPS.latitude, 6, 2, outstr);  //check docs for 6, 2 values, and set them for your needs&#xD;&#xA;&#xD;&#xA;And then: &#xD;&#xA;&#xD;&#xA;    vnnt.concat(outstr)&#xD;&#xA;&#xD;&#xA;Also note that sprintf is very handy for compact creation of a (char) string:&#xD;&#xA;&#xD;&#xA;    char msg[80];&#xD;&#xA;    sprintf(msg, &quot;$VNNT,GPS, %s %f&quot;, GPS.fix, GPS.latitude);&#xD;&#xA;" />
  <row Id="2436" PostHistoryTypeId="2" PostId="859" RevisionGUID="dbdc104f-790d-43d9-a832-0fe143ae53ca" CreationDate="2014-03-21T16:33:37.700" UserId="726" Text="Try re-bootloading your arduino by going to Tools &gt; Burn Bootloader" />
  <row Id="2437" PostHistoryTypeId="2" PostId="860" RevisionGUID="51f11982-2864-44d8-9dec-1ae2df7fb592" CreationDate="2014-03-21T17:48:44.647" UserId="220" Text="I've been looking for a while inside Arduino's files to find the core library. However, I haven't found them yet. **Where on my hard drive can I obtain the core library files (.cpp and .h) necessary for all Arduino code?**&#xD;&#xA;&#xD;&#xA;Looking around on Google, I couldn't find a way to find the above files. I did see something about getting an .a file while Arduino is compiling, however, that isn't what I want. I want to browse the code and look at functions such as delay to see how they would react when given the values not expected. (i.e. Will my code stall if I use `delay(-200);` by not being to exit the loop, or will it create a black hole and disrupt the space-time continuum?)" />
  <row Id="2438" PostHistoryTypeId="1" PostId="860" RevisionGUID="51f11982-2864-44d8-9dec-1ae2df7fb592" CreationDate="2014-03-21T17:48:44.647" UserId="220" Text="How can I get the source files for Arduino libraries?" />
  <row Id="2439" PostHistoryTypeId="3" PostId="860" RevisionGUID="51f11982-2864-44d8-9dec-1ae2df7fb592" CreationDate="2014-03-21T17:48:44.647" UserId="220" Text="&lt;library&gt;&lt;core-libraries&gt;" />
  <row Id="2440" PostHistoryTypeId="2" PostId="861" RevisionGUID="f947d8ed-7599-4264-8349-8e593b08bd36" CreationDate="2014-03-21T18:00:33.390" UserId="368" Text="The base Arduino source files are in the Arduino installation, under `hardware/*/cores/`. Source for additional libraries included are in `libraries/`. Additional files may be found in the sketchbook under its `hardware/*/cores/` and `libraries/` directories." />
  <row Id="2441" PostHistoryTypeId="2" PostId="862" RevisionGUID="98381d94-4f08-43db-9711-8178e07deccc" CreationDate="2014-03-21T18:53:33.323" UserId="313" Text="On a Mac, the path to the source code folder is:&lt;br&gt;&#xD;&#xA;`Arduino.app/Contents/Resources/Java/Hardware/Arduino/Cores/Arduino`. I'd expect it would be the same from `/Java/` on down in other OSes.&#xD;&#xA;&#xD;&#xA;![Path to library sources (Arduino-Mac)][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/pY7yE.png" />
  <row Id="2442" PostHistoryTypeId="5" PostId="633" RevisionGUID="16375e79-4e4f-45a6-af2a-7290e4d79811" CreationDate="2014-03-21T19:29:56.110" UserId="510" Comment="Copy edited." Text="[The Arduino Uno Page](http://arduino.cc/en/Main/arduinoBoardUno) doesn't say the temperatures that it can operate in. I'm thinking about placing it outdoors. How can I make sure my Arduino Uno is safe in weather that can reach -20 to 105 degrees Fahrenheit? (-26 to 40 degrees Celsius).&#xD;&#xA;" />
  <row Id="2443" PostHistoryTypeId="24" PostId="633" RevisionGUID="16375e79-4e4f-45a6-af2a-7290e4d79811" CreationDate="2014-03-21T19:29:56.110" Comment="Proposed by 510 approved by 11 edit id of 252" />
  <row Id="2444" PostHistoryTypeId="2" PostId="863" RevisionGUID="9b545dbe-2bab-4326-a926-fda562b7e89e" CreationDate="2014-03-21T19:46:40.930" UserId="765" Text="I am using the arduinconnector ANE to connect to an arduino baord in an AIR application. https://code.google.com/p/as3-arduino-connector/&#xD;&#xA;&#xD;&#xA;Can anyone tell me if its possible to connect to more than 1 board, simply by instantiating additional instances of the ANE and passing in unique port #'s?&#xD;&#xA;&#xD;&#xA;Or is there some reason why this isn't possible and a unique AIR application is required for every arduino you connect to?" />
  <row Id="2445" PostHistoryTypeId="1" PostId="863" RevisionGUID="9b545dbe-2bab-4326-a926-fda562b7e89e" CreationDate="2014-03-21T19:46:40.930" UserId="765" Text="AIR- connect to more than 1 arduino" />
  <row Id="2446" PostHistoryTypeId="3" PostId="863" RevisionGUID="9b545dbe-2bab-4326-a926-fda562b7e89e" CreationDate="2014-03-21T19:46:40.930" UserId="765" Text="&lt;arduino-uno&gt;" />
  <row Id="2447" PostHistoryTypeId="2" PostId="864" RevisionGUID="7feb500c-85b7-4add-b893-5c9d2038a026" CreationDate="2014-03-21T20:46:13.690" UserId="454" Text="I have an Arduino Mega 2560 and it was working fine until about lunch time when I started getting this error:&#xD;&#xA;&#xD;&#xA;    avrdude: stk500v2_ReceiveMessage(): timeout&#xD;&#xA;    avrdude: stk500v2_getsync(): timeout communicating with programmer&#xD;&#xA;&#xD;&#xA;I know it isn't the code I'm running as I tried to load it onto an UNO and it seemed to load without issue. I need to use the Mega as it has more ports, though.&#xD;&#xA;&#xD;&#xA;From what I have read this is potentially an issue with the bootloader and is possibly related to the current version of Arduino. I know virtually nothing about the bootloader; all I know is that it is used to upload code to the Arduino (I think...), therefore I have a fear of just messing around with related files unknowingly. &#xD;&#xA;&#xD;&#xA;These pages are the ones I've been looking at, but like I said, I don't really know enough to feel comfortable with just messing around with the files.&#xD;&#xA;&#xD;&#xA;http://forum.arduino.cc/index.php?topic=135451.0&#xD;&#xA;http://forum.arduino.cc/index.php/topic,83079.msg659993.html#msg659993&#xD;&#xA;&#xD;&#xA;I tried uninstalling my Mega totally, then reinstalling it. I also downloaded an older version of Arduino (0022) and neither option seemed to work. &#xD;&#xA;&#xD;&#xA;I don't know what to do, or how to change the `avr` files if necessary.&#xD;&#xA;&#xD;&#xA;I'd really appreciate any help!" />
  <row Id="2448" PostHistoryTypeId="1" PostId="864" RevisionGUID="7feb500c-85b7-4add-b893-5c9d2038a026" CreationDate="2014-03-21T20:46:13.690" UserId="454" Text="Arduino Mega timeout communication with programmer error" />
  <row Id="2449" PostHistoryTypeId="3" PostId="864" RevisionGUID="7feb500c-85b7-4add-b893-5c9d2038a026" CreationDate="2014-03-21T20:46:13.690" UserId="454" Text="&lt;bootloader&gt;&lt;arduino-mega&gt;&lt;avrdude&gt;" />
  <row Id="2450" PostHistoryTypeId="5" PostId="766" RevisionGUID="614a0262-b9b4-4efb-80a1-0f251c6f938b" CreationDate="2014-03-22T01:25:40.820" UserId="220" Comment="added 2868 characters in body" Text="I got an Arduino Uno to play around with, and started to actually dive in. During a program that I am writing for a friend, it suddenly stopped outputting to the serial monitor. When I comment out the part I added (the for loop for changing the names), it still doesn't respond. &#xD;&#xA;&#xD;&#xA;    #include &lt;TrueRandom.h&gt;&#xD;&#xA;    #include &lt;EEPROM.h&gt;&#xD;&#xA;    #define numPokemon 151&#xD;&#xA;    String nameArray[] = {&quot;MISSINGNO&quot;,&quot;Bulbasaur&quot;,&quot;Ivysaur&quot;,&quot;Venusaur&quot;,&quot;Charmander&quot;,&quot;Charmeleon&quot;,&quot;Charizard&quot;,&quot;Squirtle&quot;,&#xD;&#xA;    &quot;Wartortle&quot;,&quot;Blastoise&quot;,&quot;Caterpie&quot;,&quot;Metapod&quot;,&quot;Butterfree&quot;,&quot;Weedle&quot;,&quot;Kakuna&quot;,&quot;Beedrill&quot;,&quot;Pidgey&quot;,&quot;Pidgeotto&quot;,&#xD;&#xA;    &quot;Pidgeot&quot;,&quot;Rattata&quot;,&quot;Raticate&quot;,&quot;Spearow&quot;,&quot;Fearow&quot;,&quot;Ekans&quot;,&quot;Arbok&quot;,&quot;Pikachu&quot;,&quot;Raichu&quot;,&quot;Sandshrew&quot;,&quot;Sandslash&quot;,&#xD;&#xA;    &quot;Nidoran♀&quot;,&quot;Nidorina&quot;,&quot;Nidoqueen&quot;,&quot;Nidoran♂&quot;,&quot;Nidorino&quot;,&quot;Nidoking&quot;,&quot;Clefairy&quot;,&quot;Clefable&quot;,&quot;Vulpix&quot;,&quot;Ninetales&quot;,&quot;Jigglypuff&quot;,&#xD;&#xA;    &quot;Wigglytuff&quot;,&quot;Zubat&quot;,&quot;Golbat&quot;,&quot;Oddish&quot;,&quot;Gloom&quot;,&quot;Vileplume&quot;,&quot;Paras&quot;,&quot;Parasect&quot;,&quot;Venonat&quot;,&quot;Venomoth&quot;,&quot;Diglett&quot;,&quot;Dugtrio&quot;,&quot;Meowth&quot;,&#xD;&#xA;    &quot;Persian&quot;,&quot;Psyduck&quot;,&quot;Golduck&quot;,&quot;Mankey&quot;,&quot;Primeape&quot;,&quot;Growlithe&quot;,&quot;Arcanine&quot;,&quot;Poliwag&quot;,&quot;Poliwhirl&quot;,&quot;Poliwrath&quot;,&quot;Abra&quot;,&quot;Kadabra&quot;,&quot;Alakazam&quot;,&#xD;&#xA;    &quot;Machop&quot;,&quot;Machoke&quot;,&quot;Machamp&quot;,&quot;Bellsprout&quot;,&quot;Weepinbell&quot;,&quot;Victreebel&quot;,&quot;Tentacool&quot;,&quot;Tentacruel&quot;,&quot;Geodude&quot;,&quot;Graveler&quot;,&quot;Golem&quot;,&quot;Ponyta&quot;,&quot;Rapidash&quot;,&#xD;&#xA;    &quot;Slowpoke&quot;,&quot;Slowbro&quot;,&quot;Magnemite&quot;,&quot;Magneton&quot;,&quot;Farfetch`d&quot;,&quot;Doduo&quot;,&quot;Dodrio&quot;,&quot;Seel&quot;,&quot;Dewgong&quot;,&quot;Grimer&quot;,&quot;Muk&quot;,&quot;Shellder&quot;,&quot;Cloyster&quot;,&quot;Gastly&quot;,&quot;Haunter&quot;,&#xD;&#xA;    &quot;Gengar&quot;,&quot;Onix&quot;,&quot;Drowzee&quot;,&quot;Hypno&quot;,&quot;Krabby&quot;,&quot;Kingler&quot;,&quot;Voltorb&quot;,&quot;Electrode&quot;,&quot;Exeggcute&quot;,&quot;Exeggutor&quot;,&quot;Cubone&quot;,&quot;Marowak&quot;,&quot;Hitmonlee&quot;,&quot;Hitmonchan&quot;,&quot;Lickitung&quot;,&#xD;&#xA;    &quot;Koffing&quot;,&quot;Weezing&quot;,&quot;Rhyhorn&quot;,&quot;Rhydon&quot;,&quot;Chansey&quot;,&quot;Tangela&quot;,&quot;Kangaskhan&quot;,&quot;Horsea&quot;,&quot;Seadra&quot;,&quot;Goldeen&quot;,&quot;Seaking&quot;,&quot;Staryu&quot;,&quot;Starmie&quot;,&quot;Mr. Mime&quot;,&quot;Scyther&quot;,&quot;Jynx&quot;,&#xD;&#xA;    &quot;Electabuzz&quot;,&quot;Magmar&quot;,&quot;Pinsir&quot;,&quot;Tauros&quot;,&quot;Magikarp&quot;,&quot;Gyarados&quot;,&quot;Lapras&quot;,&quot;Ditto&quot;,&quot;Eevee&quot;,&quot;Vaporeon&quot;,&quot;Jolteon&quot;,&quot;Flareon&quot;,&quot;Porygon&quot;,&quot;Omanyte&quot;,&quot;Omastar&quot;,&quot;Kabuto&quot;,&quot;Kabutops&quot;,&#xD;&#xA;    &quot;Aerodactyl&quot;,&quot;Snorlax&quot;,&quot;Articuno&quot;,&quot;Zapdos&quot;,&quot;Moltres&quot;,&quot;Dratini&quot;,&quot;Dragonair&quot;,&quot;Dragonite&quot;,&quot;Mewtwo&quot;,&quot;Mew&quot;,&#xD;&#xA;    };&#xD;&#xA;    int a = 0;&#xD;&#xA;    int b = 0;&#xD;&#xA;    int value;&#xD;&#xA;    String pokemonName;&#xD;&#xA;    int currentID = TrueRandom.random(1,numPokemon+1);&#xD;&#xA;    // a = CurrentID&#xD;&#xA;    void setup(){&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      if (EEPROM.read(a)!=0){&#xD;&#xA;        currentID = EEPROM.read(a);&#xD;&#xA;        Serial.print(&quot;The Stored ID is &quot;);&#xD;&#xA;        Serial.println(EEPROM.read(a));&#xD;&#xA;        Serial.println(&quot;Stored = true&quot;);&#xD;&#xA;      }else{&#xD;&#xA;        value = EEPROM.read(a);&#xD;&#xA;        Serial.println(value);&#xD;&#xA;        EEPROM.write(a,currentID);&#xD;&#xA;        value = EEPROM.read(a);&#xD;&#xA;        Serial.println(value);&#xD;&#xA;        Serial.println(&quot;Stored = false&quot;);&#xD;&#xA;      }&#xD;&#xA;      for (int i = 0 ; i &lt; 152 ; i++){&#xD;&#xA;          if (currentID = i){&#xD;&#xA;            pokemonName = nameArray[i];&#xD;&#xA;            Serial.print(pokemonName);&#xD;&#xA;            break;&#xD;&#xA;          }&#xD;&#xA;       }&#xD;&#xA;      //nameChange(currentID);&#xD;&#xA;      //Serial.println(pokemonName);&#xD;&#xA;    }&#xD;&#xA;    void loop(){&#xD;&#xA;     &#xD;&#xA;    }&#xD;&#xA;    void nameChange(int currentID){&#xD;&#xA;       for (int i = 0 ; i &lt; 152 ; i++){&#xD;&#xA;          if (currentID = i){&#xD;&#xA;            pokemonName = nameArray[i];&#xD;&#xA;            break;&#xD;&#xA;          }&#xD;&#xA;       }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;What is the problem with this code?" />
  <row Id="2451" PostHistoryTypeId="2" PostId="865" RevisionGUID="0728a24f-6a42-429f-a267-0327098c0602" CreationDate="2014-03-22T01:32:16.627" UserId="220" Text="When messing around with code and uploading a sketch to my Arduino board, I almost accidentally pulled out the USB cord. Everything is fine, but then I started thinking what would've happened if I had pulled it out.&#xD;&#xA;&#xD;&#xA;How safe is avrdude? Could it damage or brick the board? I'd imagine that you would just have to upload code to it again... but what would happen before you upload the new code? I've seen something about how you can always upload new code if the bootloader is intact, but I would imagine that there would be some problems. If this were to happen, should I unplug everything connected in case Arduino writes a HIGH to an input (or similar) that would damage the component?" />
  <row Id="2452" PostHistoryTypeId="1" PostId="865" RevisionGUID="0728a24f-6a42-429f-a267-0327098c0602" CreationDate="2014-03-22T01:32:16.627" UserId="220" Text="Can I corrupt my Arduino if it's unplugged during an upload?" />
  <row Id="2453" PostHistoryTypeId="3" PostId="865" RevisionGUID="0728a24f-6a42-429f-a267-0327098c0602" CreationDate="2014-03-22T01:32:16.627" UserId="220" Text="&lt;uploading&gt;&lt;safety&gt;&lt;avrdude&gt;" />
  <row Id="2454" PostHistoryTypeId="2" PostId="866" RevisionGUID="929d2536-0af9-482f-be55-df49963b8147" CreationDate="2014-03-22T01:48:10.177" UserId="65" Text="This seems to be possible with `as3Glue` as per the [docs][1]:&#xD;&#xA;&#xD;&#xA;&gt; as3Glue is an ActionScript 3 library that enables communication between Flash/Flex/AIR applications and Arduino boards. **It can together with one or several Arduino boards** be used to monitor sensors (such as rotary encoders and motion detectors), control actuators (such as LEDs and motors) and interface other electronics (such as RFID readers) from Flash, Flex and AIR applications.&#xD;&#xA;&#xD;&#xA;`as3Glue` can be used with `as3-arduino-connector` as mentioned in the [docs][2]:&#xD;&#xA;&#xD;&#xA;&gt;Using with as3Glue&#xD;&#xA;&#xD;&#xA;&gt;Download either the SWC or Source Code from the Downloads section of this project for a patched version of as3Glue. This patched version has the exact same interfaces as v20, with a notable exception of the constructor. When you instantiate a new &quot;Arduino&quot; object, replace the IP address and port with the COM port and baud rate. For example :&#xD;&#xA;&#xD;&#xA;&gt;    public var myArduino:Arduino = new Arduino(&quot;COM10&quot;, 57600);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://code.google.com/p/as3glue/&#xD;&#xA;  [2]: https://code.google.com/p/as3-arduino-connector/" />
  <row Id="2457" PostHistoryTypeId="2" PostId="867" RevisionGUID="4b8789d5-9174-4771-987c-2fc034ed2308" CreationDate="2014-03-22T03:22:07.477" UserId="8" Text="It should be fine.&#xD;&#xA;&#xD;&#xA;Most boards don't require you to reupload the bootloader every time you upload a sketch, so your program will be corrupted but your bootloader won't. I assume the bootloader is similar to the bootloader on other chips I have seen&lt;sup&gt;*&lt;/sup&gt;, it will stop execution if the code doesn't work properly. I would also think that the micro would not accept a transmission if it's checksum is missing.&#xD;&#xA;&#xD;&#xA;I wouldn't try it if I were you, but you can be a little less cautious about this sort of thing.&#xD;&#xA;&#xD;&#xA;&lt;sup&gt;\*&lt;/sup&gt;: the Propellor chip, among others" />
  <row Id="2458" PostHistoryTypeId="2" PostId="868" RevisionGUID="894734ee-c620-4d70-88c2-617cbb926ff5" CreationDate="2014-03-22T03:28:17.777" UserId="368" Text="AVRDUDE does not actually *perform* the write, it merely *directs* it. The actual writes are performed either by the bootloader or by the ISP firmware/hardware within the MCU itself.&#xD;&#xA;&#xD;&#xA;With the bootloader it depends on how itself is coded, but at worst it would finish off the flash byte or page or EEPROM page zero- or one-filled and then fail to communicate further with AVRDUDE, aborting programming.&#xD;&#xA;&#xD;&#xA;With ISP, the page write command would never be received and the programming would be aborted at the last full page. Fuse bytes are done singly and so programming a single fuse can be viewed as an atomic operation.&#xD;&#xA;&#xD;&#xA;In either case, a chip erase operation should reset the MCU to a known working state, fuse changes excepted." />
  <row Id="2459" PostHistoryTypeId="2" PostId="869" RevisionGUID="9c26121e-9962-4102-b552-0fef12a6056d" CreationDate="2014-03-22T07:19:33.490" UserId="136" Text="The code is also available online for those times you don't have the IDE installed:&#xD;&#xA;&#xD;&#xA;https://github.com/arduino/Arduino" />
  <row Id="2460" PostHistoryTypeId="2" PostId="870" RevisionGUID="c8b8f8ba-ec27-4026-b384-a7030e4b2293" CreationDate="2014-03-22T10:59:45.887" UserId="562" Text="I've been browsing Aliexpress and eBay for decent Arduino enclusures, but I've found out they are even pricier then boards themselves. &#xD;&#xA;&#xD;&#xA;Then I've realized that there are multiple firms that offer cheap laser cutting - I can buy 1 sq.m acrylic sheet and order lots of boxes at once.&#xD;&#xA;&#xD;&#xA;Obviously I am not the first one who came up with this idea. Has anyone seen downloadable vector layouts I can use as something to start from? Thanks. " />
  <row Id="2461" PostHistoryTypeId="1" PostId="870" RevisionGUID="c8b8f8ba-ec27-4026-b384-a7030e4b2293" CreationDate="2014-03-22T10:59:45.887" UserId="562" Text="Acrylic enclosure for Arduino" />
  <row Id="2462" PostHistoryTypeId="3" PostId="870" RevisionGUID="c8b8f8ba-ec27-4026-b384-a7030e4b2293" CreationDate="2014-03-22T10:59:45.887" UserId="562" Text="&lt;enclosure&gt;" />
  <row Id="2463" PostHistoryTypeId="5" PostId="870" RevisionGUID="b597faf3-96fe-4f7b-a457-4ffddee8c72f" CreationDate="2014-03-22T14:23:42.953" UserId="562" Comment="Clarified one phrase" Text="I've been browsing Aliexpress and eBay for decent Arduino enclusures, but I've found out they are even pricier then boards themselves. &#xD;&#xA;&#xD;&#xA;Then I've realized that there are multiple firms that offer cheap laser cutting - I can buy 1 sq.m acrylic sheet and order cutting multiple parts of boxes at once.&#xD;&#xA;&#xD;&#xA;Obviously I am not the first one who came up with this idea. Has anyone seen downloadable vector layouts I can use as something to start from? Thanks. " />
  <row Id="2464" PostHistoryTypeId="2" PostId="871" RevisionGUID="e4acb4ee-f6c0-48fb-9ad0-18b866139864" CreationDate="2014-03-22T15:59:45.930" UserId="65" Text="The Arduino boards provide an analog input range of 0V to 5V which translates to 0 to 1023 integer values. The range is determined by the on-board ADC, which in the case of the Uno is a 10 bit ADC (2^10 = 1024). &#xD;&#xA;&#xD;&#xA;Do any of the official boards have a larger (&gt;10 bits) ADC? Do any boards provide a wider range of analog input values?" />
  <row Id="2465" PostHistoryTypeId="1" PostId="871" RevisionGUID="e4acb4ee-f6c0-48fb-9ad0-18b866139864" CreationDate="2014-03-22T15:59:45.930" UserId="65" Text="Does any board provide more than 1024 analog input values?" />
  <row Id="2466" PostHistoryTypeId="3" PostId="871" RevisionGUID="e4acb4ee-f6c0-48fb-9ad0-18b866139864" CreationDate="2014-03-22T15:59:45.930" UserId="65" Text="&lt;analogread&gt;" />
  <row Id="2467" PostHistoryTypeId="2" PostId="872" RevisionGUID="37ee45f5-603c-499f-b0b4-a89c0424aebb" CreationDate="2014-03-22T16:05:20.307" UserId="368" Text="AVR-based Arduinos only have 10-bit ADCs, but the ATSAM3X in the Due has &lt;a href=&quot;http://arduino.cc/en/Reference/AnalogReadResolution&quot;&gt;12-bit ADCs&lt;/a&gt;. Additionally, it is possible to interface to higher-resolution external ADCs via I&lt;sup&gt;2&lt;/sup&gt;C or SPI." />
  <row Id="2468" PostHistoryTypeId="2" PostId="873" RevisionGUID="9df2e54b-c291-4eac-8ea3-ba891f8c4fe3" CreationDate="2014-03-22T17:53:52.213" UserId="639" Text="Using Arduino Nano and a current transformer (CT), I'm trying to sense the current flowing through a 120V 60Hz line.&#xD;&#xA;&#xD;&#xA;**Circuit**&#xD;&#xA;&#xD;&#xA;CT outputs `0-1V` according to its specs. This output is biased `AREF/2` = 2.5V.&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;**`analogRead` Values**&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Question:** Is this waveform what you would expect from the CT? Why are there regions where the values are flat, rather than varying continuously?&#xD;&#xA;&#xD;&#xA;Furthermore if we look at the curve part of the plot, why is Arduino reading values both above `512` and below `512` at the same time? &#xD;&#xA;&#xD;&#xA;Are these analogRead values suitable to be used to calculate the RMS voltage, and hence the RMS current passing through the wire being sensed? The final goal of this is to calculate the power usage after determining the RMS current flowing through the wire.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/tgpsQ.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/2Gdcc.png" />
  <row Id="2469" PostHistoryTypeId="1" PostId="873" RevisionGUID="9df2e54b-c291-4eac-8ea3-ba891f8c4fe3" CreationDate="2014-03-22T17:53:52.213" UserId="639" Text="Reading a varying voltage into Arduino" />
  <row Id="2470" PostHistoryTypeId="3" PostId="873" RevisionGUID="9df2e54b-c291-4eac-8ea3-ba891f8c4fe3" CreationDate="2014-03-22T17:53:52.213" UserId="639" Text="&lt;programming&gt;&lt;sensors&gt;&lt;power&gt;&lt;voltage-level&gt;&lt;arduino-nano&gt;" />
  <row Id="2471" PostHistoryTypeId="5" PostId="873" RevisionGUID="81a243cb-285f-4fc2-9109-37d4579b91c3" CreationDate="2014-03-22T18:20:42.367" UserId="639" Comment="added 95 characters in body" Text="Using Arduino Nano and a [current transformer (CT)][1], I'm trying to sense the current flowing through a 120V 60Hz line.&#xD;&#xA;&#xD;&#xA;**Circuit**&#xD;&#xA;&#xD;&#xA;CT outputs `0-1V` according to its specs. This output is biased `AREF/2` = 2.5V.&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;**`analogRead` Values**&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Question:** Is this waveform what you would expect from the CT? Why are there regions where the values are flat, rather than varying continuously?&#xD;&#xA;&#xD;&#xA;Furthermore if we look at the curve part of the plot, why is Arduino reading values both above `512` and below `512` alternately? It reads a value above `512`, then a value below `512`, then a value above `512` and so on.&#xD;&#xA;&#xD;&#xA;Are these analogRead values suitable to be used to calculate the RMS voltage, and hence the RMS current passing through the wire being sensed? The final goal of this is to calculate the power usage after determining the RMS current flowing through the wire.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.seeedstudio.com/depot/Noninvasive-AC-Current-Sensor-30A-max-p-519.html&#xD;&#xA;  [2]: http://i.stack.imgur.com/tgpsQ.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/2Gdcc.png" />
  <row Id="2472" PostHistoryTypeId="5" PostId="873" RevisionGUID="3b43c03d-3bf3-4fa7-8e03-579045307141" CreationDate="2014-03-22T18:29:11.210" UserId="639" Comment="added 363 characters in body" Text="Using Arduino Nano and a [current transformer (CT)][1], I'm trying to sense the current flowing through a 120V 60Hz line.&#xD;&#xA;&#xD;&#xA;**Circuit**&#xD;&#xA;&#xD;&#xA;CT outputs `0-1V` according to its specs. This output is biased `AREF/2` = 2.5V.&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;**`analogRead` Values**&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Question:** Is this waveform what you would expect from the CT? Why are there regions where the values are flat, rather than varying continuously?&#xD;&#xA;&#xD;&#xA;Furthermore if we look at the curve part of the plot, why is Arduino reading values both above `512` and below `512` alternately? It reads a value above `512`, then a value below `512`, then a value above `512` and so on.&#xD;&#xA;&#xD;&#xA;Assuming that 100 ms passes between `analogRead` samples, based on the plot of `analogRead` values below, there are 1026 samples between the waveform peaks, which turns out to be 102.6 millisec between peaks. That means there will be about 10 peaks in 1 second, although I would expect 60 peaks since we are sensing a 60 Hz line. What do you make out of this?&#xD;&#xA;&#xD;&#xA;Are these analogRead values suitable to be used to calculate the RMS voltage, and hence the RMS current passing through the wire being sensed? The final goal of this is to calculate the power usage after determining the RMS current flowing through the wire.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.seeedstudio.com/depot/Noninvasive-AC-Current-Sensor-30A-max-p-519.html&#xD;&#xA;  [2]: http://i.stack.imgur.com/tgpsQ.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/2Gdcc.png" />
  <row Id="2473" PostHistoryTypeId="2" PostId="874" RevisionGUID="032671d3-d895-4894-9cc8-f13beb106762" CreationDate="2014-03-22T19:50:02.973" UserId="633" Text="I have a relatively cheap 0-15psi pressure transducer. It has 3 pins - ground 5V and signal. The signal outputs a voltage of 0.5V to 4.5V based on pressure from 0psi to 15psi. I can verify it does respond to significant pressure increases so it works at least to a point.&#xD;&#xA;&#xD;&#xA;The issue is that the reading from arduino can differ by over 50% when at ambient atmospheric pressure (resting on a table). It should be significantly more accurate if the sensor data are to be trusted. The code is basic:&#xD;&#xA;&#xD;&#xA;    void setup(){&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void measurePressure(){&#xD;&#xA;      int rawReading = analogRead(A0);   // Range : 0..1024&#xD;&#xA;      //float rawVoltage = (rawReading * (4.5 / 1023.0)) + 0.5;&#xD;&#xA;      &#xD;&#xA;      Serial.print(&quot;Raw reading: &quot;);&#xD;&#xA;      Serial.println(rawReading);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      measurePressure();&#xD;&#xA;      delay(1000);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The output variations are not entirely random, it seems that the reading goes down and up in intervals of roughly 5-15 seconds. Below is a sample output:&#xD;&#xA;&#xD;&#xA;    Raw reading: 61&#xD;&#xA;    Raw reading: 67&#xD;&#xA;    Raw reading: 70&#xD;&#xA;    Raw reading: 73&#xD;&#xA;    Raw reading: 74&#xD;&#xA;    Raw reading: 78&#xD;&#xA;    Raw reading: 75&#xD;&#xA;    Raw reading: 82&#xD;&#xA;    Raw reading: 85&#xD;&#xA;    Raw reading: 90&#xD;&#xA;    Raw reading: 89&#xD;&#xA;    Raw reading: 97&#xD;&#xA;    Raw reading: 103&#xD;&#xA;    Raw reading: 119&#xD;&#xA;    Raw reading: 146&#xD;&#xA;    Raw reading: 165&#xD;&#xA;    Raw reading: 171&#xD;&#xA;    Raw reading: 168&#xD;&#xA;    Raw reading: 163&#xD;&#xA;    Raw reading: 150&#xD;&#xA;    Raw reading: 143&#xD;&#xA;    Raw reading: 118&#xD;&#xA;    Raw reading: 88&#xD;&#xA;    Raw reading: 70&#xD;&#xA;    Raw reading: 62&#xD;&#xA;    Raw reading: 64&#xD;&#xA;    Raw reading: 72&#xD;&#xA;    Raw reading: 78&#xD;&#xA;    Raw reading: 80&#xD;&#xA;    Raw reading: 82&#xD;&#xA;    Raw reading: 88&#xD;&#xA;    Raw reading: 92&#xD;&#xA;    Raw reading: 102&#xD;&#xA;    Raw reading: 134&#xD;&#xA;    Raw reading: 160&#xD;&#xA;    Raw reading: 170&#xD;&#xA;    Raw reading: 172&#xD;&#xA;    Raw reading: 166&#xD;&#xA;    Raw reading: 158&#xD;&#xA;    Raw reading: 149&#xD;&#xA;    Raw reading: 132&#xD;&#xA;    Raw reading: 100&#xD;&#xA;    Raw reading: 73&#xD;&#xA;    Raw reading: 63&#xD;&#xA;    Raw reading: 61&#xD;&#xA;    Raw reading: 71&#xD;&#xA;    Raw reading: 77&#xD;&#xA;    Raw reading: 79&#xD;&#xA;    Raw reading: 84&#xD;&#xA;    Raw reading: 90&#xD;&#xA;    Raw reading: 90&#xD;&#xA;    Raw reading: 99&#xD;&#xA;    Raw reading: 134&#xD;&#xA;    Raw reading: 161&#xD;&#xA;    Raw reading: 170&#xD;&#xA;    Raw reading: 166&#xD;&#xA;    Raw reading: 161&#xD;&#xA;    Raw reading: 151&#xD;&#xA;    Raw reading: 133&#xD;&#xA;    Raw reading: 103&#xD;&#xA;    Raw reading: 81&#xD;&#xA;    Raw reading: 68&#xD;&#xA;    Raw reading: 63&#xD;&#xA;    Raw reading: 63&#xD;&#xA;    Raw reading: 71&#xD;&#xA;    Raw reading: 73&#xD;&#xA;    Raw reading: 81&#xD;&#xA;    Raw reading: 83&#xD;&#xA;    Raw reading: 85&#xD;&#xA;    Raw reading: 89&#xD;&#xA;    Raw reading: 98&#xD;&#xA;    Raw reading: 128&#xD;&#xA;    Raw reading: 161&#xD;&#xA;    Raw reading: 171&#xD;&#xA;    Raw reading: 166&#xD;&#xA;    Raw reading: 159&#xD;&#xA;    Raw reading: 145&#xD;&#xA;    Raw reading: 120&#xD;&#xA;    Raw reading: 85&#xD;&#xA;    Raw reading: 67&#xD;&#xA;    Raw reading: 57&#xD;&#xA;    Raw reading: 63&#xD;&#xA;    Raw reading: 72&#xD;&#xA;    Raw reading: 75&#xD;&#xA;    Raw reading: 83&#xD;&#xA;    Raw reading: 85&#xD;&#xA;    Raw reading: 89&#xD;&#xA;    Raw reading: 97&#xD;&#xA;    Raw reading: 130&#xD;&#xA;    Raw reading: 164&#xD;&#xA;    Raw reading: 172&#xD;&#xA;    Raw reading: 163&#xD;&#xA;    Raw reading: 155&#xD;&#xA;    Raw reading: 135&#xD;&#xA;    Raw reading: 101&#xD;&#xA;    Raw reading: 69&#xD;&#xA;    Raw reading: 60&#xD;&#xA;    Raw reading: 62&#xD;&#xA;    Raw reading: 72&#xD;&#xA;    Raw reading: 78&#xD;&#xA;&#xD;&#xA;I tried adding 4.7k pull down resistor with no change but that was just a blind try. I have a multimeter connected as well and the reading seems to be more stable ranging from about 0.495V to 0.535V (variations do not seem to match arduino output).&#xD;&#xA;&#xD;&#xA;What could be causing the issue?" />
  <row Id="2474" PostHistoryTypeId="1" PostId="874" RevisionGUID="032671d3-d895-4894-9cc8-f13beb106762" CreationDate="2014-03-22T19:50:02.973" UserId="633" Text="Pressure transducer / sensor (0.5 - 4.5V) innacurate analog pin readings" />
  <row Id="2475" PostHistoryTypeId="3" PostId="874" RevisionGUID="032671d3-d895-4894-9cc8-f13beb106762" CreationDate="2014-03-22T19:50:02.973" UserId="633" Text="&lt;voltage-level&gt;" />
  <row Id="2476" PostHistoryTypeId="5" PostId="873" RevisionGUID="b94b8cff-7be0-4ecc-8d10-70ae39b4a388" CreationDate="2014-03-22T21:22:48.463" UserId="639" Comment="added 390 characters in body" Text="Using Arduino Nano and a [current transformer (CT)][1], I'm trying to sense the current flowing through a 120V 60Hz line.&#xD;&#xA;&#xD;&#xA;**Circuit**&#xD;&#xA;&#xD;&#xA;CT outputs `0-1V` according to its specs. This output is biased `AREF/2` = 2.5V.&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;**`analogRead` Values**&#xD;&#xA;&#xD;&#xA;The x-axis represents the index number of the ADC sample, while the y-axis represent the ADC value (0-1024). Sampling rate is about 9 kHz. Peak-to-peak difference is about 1026 samples.&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Question:** Is this waveform what you would expect from the CT? Why are there regions where the values are flat, rather than varying continuously?&#xD;&#xA;&#xD;&#xA;Furthermore if we look at the curve part of the plot, why is Arduino reading values both above `512` and below `512` alternately? It reads a value above `512`, then a value below `512`, then a value above `512` and so on.&#xD;&#xA;&#xD;&#xA;Time taken for an `analogRead` was measured to be 110 microseconds for my setup and there are 1026 samples between the waveform peaks. That means there will be about 9 peaks in 1 second, although I would expect 60 peaks since we are sensing a 60 Hz line. What do you make out of this? Theres a capacitor `C1` in the circuit, would it have anything to do with this?&#xD;&#xA;&#xD;&#xA;Are these analogRead values suitable to be used to calculate the RMS voltage, and hence the RMS current passing through the wire being sensed? The final goal of this is to calculate the power usage after determining the RMS current flowing through the wire.&#xD;&#xA;&#xD;&#xA;**Sketch used to get values for plot**&#xD;&#xA;&#xD;&#xA;	void setup() {&#xD;&#xA;	    Serial.begin(9600);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;	void loop() {&#xD;&#xA;	  &#xD;&#xA;	   double sensorValue = analogRead(1);&#xD;&#xA;	   Serial.println(sensorValue)&#xD;&#xA;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Actual `analogRead` data points in the bump regions**&#xD;&#xA;&#xD;&#xA;	487&#xD;&#xA;	534&#xD;&#xA;	487&#xD;&#xA;	535&#xD;&#xA;	488&#xD;&#xA;	537&#xD;&#xA;	484&#xD;&#xA;	536&#xD;&#xA;	487&#xD;&#xA;	538&#xD;&#xA;	486&#xD;&#xA;	536&#xD;&#xA;	484&#xD;&#xA;	540&#xD;&#xA;	484&#xD;&#xA;	539&#xD;&#xA;	485&#xD;&#xA;	540&#xD;&#xA;	483&#xD;&#xA;	540&#xD;&#xA;	484&#xD;&#xA;	541&#xD;&#xA;	481&#xD;&#xA;	539&#xD;&#xA;	481&#xD;&#xA;	540&#xD;&#xA;	484&#xD;&#xA;	540&#xD;&#xA;	480&#xD;&#xA;	543&#xD;&#xA;	484&#xD;&#xA;	539&#xD;&#xA;	481&#xD;&#xA;	540&#xD;&#xA;	484&#xD;&#xA;	541&#xD;&#xA;	486&#xD;&#xA;	542&#xD;&#xA;	485&#xD;&#xA;	538&#xD;&#xA;	485&#xD;&#xA;	538&#xD;&#xA;	488&#xD;&#xA;	535&#xD;&#xA;	489&#xD;&#xA;	534&#xD;&#xA;	491&#xD;&#xA;	530&#xD;&#xA;	491&#xD;&#xA;	529&#xD;&#xA;	493&#xD;&#xA;	531&#xD;&#xA;	492&#xD;&#xA;	526&#xD;&#xA;	498&#xD;&#xA;	526&#xD;&#xA;	499&#xD;&#xA;	524&#xD;&#xA;	499&#xD;&#xA;	520&#xD;&#xA;	503&#xD;&#xA;	518&#xD;&#xA;	502&#xD;&#xA;	518&#xD;&#xA;	507&#xD;&#xA;&#xD;&#xA;  [1]: http://www.seeedstudio.com/depot/Noninvasive-AC-Current-Sensor-30A-max-p-519.html&#xD;&#xA;  [2]: http://i.stack.imgur.com/tgpsQ.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/2Gdcc.png" />
  <row Id="2477" PostHistoryTypeId="5" PostId="873" RevisionGUID="4f6ab203-2ac4-41c1-93b6-a2a3a215ed99" CreationDate="2014-03-22T22:23:48.407" UserId="639" Comment="added 220 characters in body" Text="Using Arduino Nano and a [current transformer (CT)][1], I'm trying to sense the current flowing through a 120V 60Hz line.&#xD;&#xA;&#xD;&#xA;**Circuit**&#xD;&#xA;&#xD;&#xA;CT outputs `0-1V` according to its specs. This output is biased `AREF/2` = 2.5V.&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;**`analogRead` Values**&#xD;&#xA;&#xD;&#xA;The x-axis represents the index number of the ADC sample, while the y-axis represent the ADC value (0-1024). Sampling rate is about 9 kHz. Peak-to-peak difference is about 1026 samples.&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Question:** Is this waveform what you would expect from the CT? Why are there regions where the values are flat, rather than varying continuously?&#xD;&#xA;&#xD;&#xA;Furthermore if we look at the curve part of the plot, why is Arduino reading values both above `512` and below `512` alternately? It reads a value above `512`, then a value below `512`, then a value above `512` and so on.&#xD;&#xA;&#xD;&#xA;Time taken for an `analogRead` was measured to be 110 microseconds for my setup and there are 1026 samples between the waveform peaks. That means there will be about 9 peaks in 1 second, although I would expect 60 peaks since we are sensing a 60 Hz line. What do you make out of this? Theres a capacitor `C1` in the circuit, would it have anything to do with this?&#xD;&#xA;&#xD;&#xA;Are these analogRead values suitable to be used to calculate the RMS voltage, and hence the RMS current passing through the wire being sensed? The final goal of this is to calculate the power usage after determining the RMS current flowing through the wire.&#xD;&#xA;&#xD;&#xA;**Sketch used to get values for plot**&#xD;&#xA;&#xD;&#xA;	void setup() {&#xD;&#xA;	    Serial.begin(9600);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;	void loop() {&#xD;&#xA;	  &#xD;&#xA;	   double sensorValue = analogRead(1);&#xD;&#xA;	   Serial.println(sensorValue)&#xD;&#xA;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Actual `analogRead` data points in the bump regions**&#xD;&#xA;&#xD;&#xA;	487&#xD;&#xA;	534&#xD;&#xA;	487&#xD;&#xA;	535&#xD;&#xA;	488&#xD;&#xA;	537&#xD;&#xA;	484&#xD;&#xA;	536&#xD;&#xA;	487&#xD;&#xA;	538&#xD;&#xA;	486&#xD;&#xA;	536&#xD;&#xA;	484&#xD;&#xA;	540&#xD;&#xA;	484&#xD;&#xA;	539&#xD;&#xA;	485&#xD;&#xA;	540&#xD;&#xA;	483&#xD;&#xA;	540&#xD;&#xA;	484&#xD;&#xA;	541&#xD;&#xA;	481&#xD;&#xA;	539&#xD;&#xA;	481&#xD;&#xA;	540&#xD;&#xA;	484&#xD;&#xA;	540&#xD;&#xA;	480&#xD;&#xA;	543&#xD;&#xA;	484&#xD;&#xA;	539&#xD;&#xA;	481&#xD;&#xA;	540&#xD;&#xA;	484&#xD;&#xA;	541&#xD;&#xA;	486&#xD;&#xA;	542&#xD;&#xA;	485&#xD;&#xA;	538&#xD;&#xA;	485&#xD;&#xA;	538&#xD;&#xA;	488&#xD;&#xA;	535&#xD;&#xA;	489&#xD;&#xA;	534&#xD;&#xA;	491&#xD;&#xA;	530&#xD;&#xA;	491&#xD;&#xA;	529&#xD;&#xA;	493&#xD;&#xA;	531&#xD;&#xA;	492&#xD;&#xA;	526&#xD;&#xA;	498&#xD;&#xA;	526&#xD;&#xA;	499&#xD;&#xA;	524&#xD;&#xA;	499&#xD;&#xA;	520&#xD;&#xA;	503&#xD;&#xA;	518&#xD;&#xA;	502&#xD;&#xA;	518&#xD;&#xA;	507&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;**Plot of analogRead values**&#xD;&#xA;&#xD;&#xA;The analogRead values are now stored on buffer before being transmitted over Serial.&#xD;&#xA;&#xD;&#xA;![enter image description here][4]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.seeedstudio.com/depot/Noninvasive-AC-Current-Sensor-30A-max-p-519.html&#xD;&#xA;  [2]: http://i.stack.imgur.com/tgpsQ.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/2Gdcc.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/Wjw7T.png" />
  <row Id="2478" PostHistoryTypeId="5" PostId="873" RevisionGUID="a9a431ca-b9d5-433d-9a11-93c91090f0e1" CreationDate="2014-03-22T22:30:50.240" UserId="639" Comment="added 220 characters in body" Text="Using Arduino Nano and a [current transformer (CT)][1], I'm trying to sense the current flowing through a 120V 60Hz line.&#xD;&#xA;&#xD;&#xA;**Circuit**&#xD;&#xA;&#xD;&#xA;CT outputs `0-1V` according to its specs. This output is biased `AREF/2` = 2.5V.&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;**`analogRead` Values**&#xD;&#xA;&#xD;&#xA;The x-axis represents the index number of the ADC sample, while the y-axis represent the ADC value (0-1024). Sampling rate is about 9 kHz. Peak-to-peak difference is about 1026 samples.&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Question:** Is this waveform what you would expect from the CT? Why are there regions where the values are flat, rather than varying continuously?&#xD;&#xA;&#xD;&#xA;Furthermore if we look at the curve part of the plot, why is Arduino reading values both above `512` and below `512` alternately? It reads a value above `512`, then a value below `512`, then a value above `512` and so on.&#xD;&#xA;&#xD;&#xA;Time taken for an `analogRead` was measured to be 110 microseconds for my setup and there are 1026 samples between the waveform peaks. That means there will be about 9 peaks in 1 second, although I would expect 60 peaks since we are sensing a 60 Hz line. What do you make out of this? Theres a capacitor `C1` in the circuit, would it have anything to do with this?&#xD;&#xA;&#xD;&#xA;Are these analogRead values suitable to be used to calculate the RMS voltage, and hence the RMS current passing through the wire being sensed? The final goal of this is to calculate the power usage after determining the RMS current flowing through the wire.&#xD;&#xA;&#xD;&#xA;**Sketch used to get values for plot**&#xD;&#xA;&#xD;&#xA;	void setup() {&#xD;&#xA;	    Serial.begin(9600);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;	void loop() {&#xD;&#xA;	  &#xD;&#xA;	   double sensorValue = analogRead(1);&#xD;&#xA;	   Serial.println(sensorValue)&#xD;&#xA;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Actual `analogRead` data points in the bump regions**&#xD;&#xA;&#xD;&#xA;	487&#xD;&#xA;	534&#xD;&#xA;	487&#xD;&#xA;	535&#xD;&#xA;	488&#xD;&#xA;	537&#xD;&#xA;	484&#xD;&#xA;	536&#xD;&#xA;	487&#xD;&#xA;	538&#xD;&#xA;	486&#xD;&#xA;	536&#xD;&#xA;	484&#xD;&#xA;	540&#xD;&#xA;	484&#xD;&#xA;	539&#xD;&#xA;	485&#xD;&#xA;	540&#xD;&#xA;	483&#xD;&#xA;	540&#xD;&#xA;	484&#xD;&#xA;	541&#xD;&#xA;	481&#xD;&#xA;	539&#xD;&#xA;	481&#xD;&#xA;	540&#xD;&#xA;	484&#xD;&#xA;	540&#xD;&#xA;	480&#xD;&#xA;	543&#xD;&#xA;	484&#xD;&#xA;	539&#xD;&#xA;	481&#xD;&#xA;	540&#xD;&#xA;	484&#xD;&#xA;	541&#xD;&#xA;	486&#xD;&#xA;	542&#xD;&#xA;	485&#xD;&#xA;	538&#xD;&#xA;	485&#xD;&#xA;	538&#xD;&#xA;	488&#xD;&#xA;	535&#xD;&#xA;	489&#xD;&#xA;	534&#xD;&#xA;	491&#xD;&#xA;	530&#xD;&#xA;	491&#xD;&#xA;	529&#xD;&#xA;	493&#xD;&#xA;	531&#xD;&#xA;	492&#xD;&#xA;	526&#xD;&#xA;	498&#xD;&#xA;	526&#xD;&#xA;	499&#xD;&#xA;	524&#xD;&#xA;	499&#xD;&#xA;	520&#xD;&#xA;	503&#xD;&#xA;	518&#xD;&#xA;	502&#xD;&#xA;	518&#xD;&#xA;	507&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;**Plot of analogRead values**&#xD;&#xA;&#xD;&#xA;The analogRead values are now stored on buffer before being transmitted over Serial. There are now 55 ADC datapoints making up 1 period. Considering the analogRead time is 110us, each cycle takes 6.05ms, giving us a frequency of 165Hz! What may have gone wrong?&#xD;&#xA;&#xD;&#xA;![enter image description here][4]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      &#xD;&#xA;       double sensorValue = analogRead(1);&#xD;&#xA;       char buf[32]; &#xD;&#xA;       &#xD;&#xA;       dtostrf(sensorValue,8, 2, buf);  &#xD;&#xA;       value = buf;&#xD;&#xA;       &#xD;&#xA;      &#xD;&#xA;       if(stop == 0) {&#xD;&#xA;         &#xD;&#xA;           if(i&lt;10000) {&#xD;&#xA;               message += ',';&#xD;&#xA;               message += value;&#xD;&#xA;               i++;&#xD;&#xA;           } else {&#xD;&#xA;             stop = 1;&#xD;&#xA;             Serial.println(message);&#xD;&#xA;           }&#xD;&#xA;           &#xD;&#xA;       }&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.seeedstudio.com/depot/Noninvasive-AC-Current-Sensor-30A-max-p-519.html&#xD;&#xA;  [2]: http://i.stack.imgur.com/tgpsQ.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/2Gdcc.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/Wjw7T.png" />
  <row Id="2479" PostHistoryTypeId="2" PostId="875" RevisionGUID="531d474d-64af-41d8-9927-6ec20b1c7de7" CreationDate="2014-03-22T23:10:32.617" UserId="353" Text="One safety feature that hasn't been mentioned so far is that the ATmega328 has a set of lock bits that prevent read/write access to certain areas. To the best of my knowledge, the way Arduinos are set up, those bits are always set to prevent writing to the boot loader area unless the &quot;Burn Bootloader&quot; command is currently active, and since you can only use that command with an external programmer, you can always write a new bootloader if something goes wrong.&#xD;&#xA;&#xD;&#xA;I think the only way of bricking the board (in the sense of leaving the MCU in a state that is functional, yet almost irrepairably unresponsive) is writing bad fuse settings. " />
  <row Id="2480" PostHistoryTypeId="2" PostId="876" RevisionGUID="c8f107e9-9482-40ce-a73f-99b22e12ca48" CreationDate="2014-03-23T03:14:19.210" UserId="11" Text="&gt; &lt;img src=&quot;http://i.stack.imgur.com/hYRnU.png&quot; width=&quot;450&quot; height=&quot;200&quot; &gt; &#xD;&#xA;&lt;sub&gt;The logo is a derivative of the [Arduino Community Logo][1] licensed under [Creative Commons license CC-SA-BY-NC 3.0][2]&lt;/sub&gt; &#xD;&#xA;&#xD;&#xA;To celebrate [10 years of Arduino][3], we are proud to announce the *first event ever* on Arduino Stack Exchange.&#xD;&#xA;&#xD;&#xA;&gt; Get your boards and soldering equipment out, dig out the ICs and&#xD;&#xA;&gt; resistors. The first Arduino Stack Exchange contest is just round the&#xD;&#xA;&gt; corner. We will be looking for interesting projects that are built&#xD;&#xA;&gt; using Arduinos. The contest is aimed towards sharing, discussing and&#xD;&#xA;&gt; providing feedback on projects that you and other members are working&#xD;&#xA;&gt; on. &lt;sub&gt;[Project Showcase Announcement Post][4]&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;# Details: &#xD;&#xA;&#xD;&#xA; - The prize is an **official Stack Exchange t-shirt** (Provided by Pops) &#xD;&#xA; - Limit two entries per person. If more than two are provided, only the first two will be considered. &#xD;&#xA; - Clones *are* allowed.&#xD;&#xA; - Projects for consideration will be accepted through **March 29th, 2014 at 4:00 UTC.** The question will still remain open in case someone wants to show off their project they made on Arduino Day 2014.&#xD;&#xA;&#xD;&#xA;Visit the [Meta post][5] for discussion about this project.&#xD;&#xA;&#xD;&#xA;# Answer Format&#xD;&#xA;&#xD;&#xA;You may post up to two projects (as two separate answers) as entries for the contest. All extra entries will be deleted. Consider following the following template for entries:&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;&gt; # Project Title&#xD;&#xA;&gt; &#xD;&#xA;&gt; **Very Brief Description**&#xD;&#xA;&gt; &#xD;&#xA;&gt; # Description&#xD;&#xA;&gt; &#xD;&#xA;&gt; What is your project? What does it do? What problem does it solve?&#xD;&#xA;&gt; &#xD;&#xA;&gt; # Design&#xD;&#xA;&gt; &#xD;&#xA;&gt; Things to include in this section:&#xD;&#xA;&gt; &#xD;&#xA;&gt; - Schematics and other design documentation. [Fritzing][6] is a good tool for drawing breadboard schematics like the one shown in the&#xD;&#xA;&gt; project logo above.&#xD;&#xA;&gt; - Components used to build the project&#xD;&#xA;&gt; - Pictures or video&#xD;&#xA;&gt; &#xD;&#xA;&gt; # Conclusion&#xD;&#xA;&gt; &#xD;&#xA;&gt; Final thoughts. What did you learn from doing this project? What would&#xD;&#xA;&gt; you do differently if you had to start over?&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;You can copy/paste the text if you want to use this templtae.&#xD;&#xA;&#xD;&#xA;    # Project Title&#xD;&#xA;    **Very Brief Description**&#xD;&#xA;    &#xD;&#xA;    # Description&#xD;&#xA;    What is your project? What does it do? What problem does it solve?&#xD;&#xA;    &#xD;&#xA;    # Design&#xD;&#xA;    Things to include in this section:&#xD;&#xA;    &#xD;&#xA;    - Schematics and other design documentation. [Fritzing][7] is a good tool for drawing breadboard schematics like the one shown in the project logo above.&#xD;&#xA;    - Components used to build the project&#xD;&#xA;    - Pictures or video&#xD;&#xA;    &#xD;&#xA;    # Conclusion&#xD;&#xA;    Final thoughts. What did you learn from doing this project? What would you do differently if you had to start over?&#xD;&#xA;&#xD;&#xA;# Prizes&#xD;&#xA;&#xD;&#xA;There are two prizes! The winner will be the submission getting the maximum number of upvotes (downvotes do not count) and will get a Stack Exchange T-shirt*! There will be something for the runner-up as well. The runner-up will be decided at the discretion of the event organizers.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;*Certain restrictions may apply. International shipping may take a few weeks. &lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;# Where do I submit my projects?&#xD;&#xA;Post your projects as answers to this post.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Trademark/HomePage?from=Main.Trademark&#xD;&#xA;  [2]: http://creativecommons.org/licenses/&#xD;&#xA;  [3]: http://day.arduino.cc/&#xD;&#xA;  [4]: http://meta.arduino.stackexchange.com/questions/153/project-showcase-14-is-coming-to-arduino-stack-exchange-updated-3-19-14&#xD;&#xA;  [5]: http://meta.arduino.stackexchange.com/questions/171/project-showcase-14-detailed-information&#xD;&#xA;  [6]: http://fritzing.org/home/&#xD;&#xA;  [7]: http://fritzing.org/home/" />
  <row Id="2481" PostHistoryTypeId="1" PostId="876" RevisionGUID="c8f107e9-9482-40ce-a73f-99b22e12ca48" CreationDate="2014-03-23T03:14:19.210" UserId="11" Text="Project Showcase '14" />
  <row Id="2482" PostHistoryTypeId="3" PostId="876" RevisionGUID="c8f107e9-9482-40ce-a73f-99b22e12ca48" CreationDate="2014-03-23T03:14:19.210" UserId="11" Text="&lt;events&gt;&lt;project-showcase&gt;" />
  <row Id="2483" PostHistoryTypeId="2" PostId="877" RevisionGUID="72687813-253e-4054-bcf8-0c7643cf3929" CreationDate="2014-03-23T03:19:02.423" UserId="774" Text="I'm doing my first electronics project where a signal that varies between -1 to 1 V is going into an analog pin on the Arduino. The amplified signal has to be read as fast as possible by Arduino. The source signal is at 60 Hz.&#xD;&#xA;&#xD;&#xA;Will [this LM324][1] be a suitable 4-channel opamp for my needs? How concerned should I be about the 2 mV input offset and 20 nA input current bias?&#xD;&#xA;&#xD;&#xA;I notice that it is a surface mount chip, can it be connected to my breadboard?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.digikey.com/product-detail/en/LM324APT/497-7329-6-ND/1884378" />
  <row Id="2484" PostHistoryTypeId="1" PostId="877" RevisionGUID="72687813-253e-4054-bcf8-0c7643cf3929" CreationDate="2014-03-23T03:19:02.423" UserId="774" Text="Opamp for amplifying 1V signal voltage to 2V" />
  <row Id="2485" PostHistoryTypeId="3" PostId="877" RevisionGUID="72687813-253e-4054-bcf8-0c7643cf3929" CreationDate="2014-03-23T03:19:02.423" UserId="774" Text="&lt;pins&gt;&lt;sensors&gt;&lt;arduino-nano&gt;" />
  <row Id="2486" PostHistoryTypeId="5" PostId="876" RevisionGUID="34227653-6e9a-4513-9e33-ee124694cf48" CreationDate="2014-03-23T03:22:15.897" UserId="65" Comment="added 26 characters in body" Text="&gt; &lt;img src=&quot;http://i.stack.imgur.com/hYRnU.png&quot; width=&quot;450&quot; height=&quot;200&quot; &gt; &#xD;&#xA;&#xD;&#xA;&gt; &lt;sub&gt;The logo is a derivative of the [Arduino Community Logo][1] licensed under [Creative Commons license CC-SA-BY-NC 3.0][2]&lt;/sub&gt; &#xD;&#xA;&#xD;&#xA;To celebrate [10 years of Arduino][3], we are proud to announce the *first event ever* on Arduino Stack Exchange.&#xD;&#xA;&#xD;&#xA;&gt; Get your boards and soldering equipment out, dig out the ICs and&#xD;&#xA;&gt; resistors. The first Arduino Stack Exchange contest is just round the&#xD;&#xA;&gt; corner. We will be looking for interesting projects that are built&#xD;&#xA;&gt; using Arduinos. The contest is aimed towards sharing, discussing and&#xD;&#xA;&gt; providing feedback on projects that you and other members are working&#xD;&#xA;&gt; on. &lt;sub&gt;[Project Showcase Announcement Post][4]&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;# Details: &#xD;&#xA;&#xD;&#xA; - The prize is an **official Stack Exchange t-shirt** (Provided by Pops) &#xD;&#xA; - Limit two entries per person. If more than two are provided, only the first two will be considered. &#xD;&#xA; - Clones *are* allowed.&#xD;&#xA; - Projects for consideration will be accepted through **March 29th, 2014 at 4:00 UTC.** The question will still remain open in case someone wants to show off their project they made on Arduino Day 2014.&#xD;&#xA;&#xD;&#xA;Visit the [Meta post][5] for discussion about this event and further information.&#xD;&#xA;&#xD;&#xA;# Answer Format&#xD;&#xA;&#xD;&#xA;You may post up to two projects (as two separate answers) as entries for the contest. All extra entries will be deleted. Consider following the following template for entries:&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;&gt; # Project Title&#xD;&#xA;&gt; &#xD;&#xA;&gt; **Very Brief Description**&#xD;&#xA;&gt; &#xD;&#xA;&gt; # Description&#xD;&#xA;&gt; &#xD;&#xA;&gt; What is your project? What does it do? What problem does it solve?&#xD;&#xA;&gt; &#xD;&#xA;&gt; # Design&#xD;&#xA;&gt; &#xD;&#xA;&gt; Things to include in this section:&#xD;&#xA;&gt; &#xD;&#xA;&gt; - Schematics and other design documentation. [Fritzing][6] is a good tool for drawing breadboard schematics like the one shown in the&#xD;&#xA;&gt; project logo above.&#xD;&#xA;&gt; - Components used to build the project&#xD;&#xA;&gt; - Pictures or video&#xD;&#xA;&gt; &#xD;&#xA;&gt; # Conclusion&#xD;&#xA;&gt; &#xD;&#xA;&gt; Final thoughts. What did you learn from doing this project? What would&#xD;&#xA;&gt; you do differently if you had to start over?&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;You can copy/paste the text if you want to use this templtae.&#xD;&#xA;&#xD;&#xA;    # Project Title&#xD;&#xA;    **Very Brief Description**&#xD;&#xA;    &#xD;&#xA;    # Description&#xD;&#xA;    What is your project? What does it do? What problem does it solve?&#xD;&#xA;    &#xD;&#xA;    # Design&#xD;&#xA;    Things to include in this section:&#xD;&#xA;    &#xD;&#xA;    - Schematics and other design documentation. [Fritzing][7] is a good tool for drawing breadboard schematics like the one shown in the project logo above.&#xD;&#xA;    - Components used to build the project&#xD;&#xA;    - Pictures or video&#xD;&#xA;    &#xD;&#xA;    # Conclusion&#xD;&#xA;    Final thoughts. What did you learn from doing this project? What would you do differently if you had to start over?&#xD;&#xA;&#xD;&#xA;# Prizes&#xD;&#xA;&#xD;&#xA;There are two prizes! The winner will be the submission getting the maximum number of upvotes (downvotes do not count) and will get a Stack Exchange T-shirt*! There will be something for the runner-up as well. The runner-up will be decided at the discretion of the event organizers.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;*Certain restrictions may apply. International shipping may take a few weeks. &lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;# Where do I submit my projects?&#xD;&#xA;Post your projects as answers to this post.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Trademark/HomePage?from=Main.Trademark&#xD;&#xA;  [2]: http://creativecommons.org/licenses/&#xD;&#xA;  [3]: http://day.arduino.cc/&#xD;&#xA;  [4]: http://meta.arduino.stackexchange.com/questions/153/project-showcase-14-is-coming-to-arduino-stack-exchange-updated-3-19-14&#xD;&#xA;  [5]: http://meta.arduino.stackexchange.com/questions/171/project-showcase-14-detailed-information&#xD;&#xA;  [6]: http://fritzing.org/home/&#xD;&#xA;  [7]: http://fritzing.org/home/" />
  <row Id="2487" PostHistoryTypeId="5" PostId="877" RevisionGUID="78c47dfe-ef38-4295-b56e-5977428588c9" CreationDate="2014-03-23T03:26:05.970" UserId="774" Comment="added 288 characters in body" Text="I'm doing my first electronics project where a signal that varies between -1 to 1 V is going into an analog pin on the Arduino. The amplified signal has to be read as fast as possible by Arduino. The source signal is at 60 Hz.&#xD;&#xA;&#xD;&#xA;Will [this LM324][1] be a suitable 4-channel opamp for my needs? How concerned should I be about the 2 mV input offset and 20 nA input current bias?&#xD;&#xA;&#xD;&#xA;I notice that it is a surface mount chip, can it be connected to my breadboard using [this 14 TSSOP to DIP converter][2]?&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.digikey.com/product-detail/en/LM324APT/497-7329-6-ND/1884378&#xD;&#xA;  [2]: http://www.ebay.com/itm/SOP14-SSOP14-TSSOP14-to-DIP14-PCB-SMD-to-DIP-Adapter-plate-Pitch-0-65-1-27mm-/231183888806?pt=LH_DefaultDomain_0&amp;hash=item35d3a231a6&#xD;&#xA;  [3]: http://i.stack.imgur.com/uYkYh.png" />
  <row Id="2488" PostHistoryTypeId="2" PostId="878" RevisionGUID="ddcfea6c-3566-4900-aa81-c6cf7b14c172" CreationDate="2014-03-23T03:26:38.100" UserId="368" Text="A 2mV offset voltage will become a 4mV error after amplification. You haven't shown the schematic for your amplification, but the current bias will also become error after amplification.&#xD;&#xA;&#xD;&#xA;*That* LM324 variant is surface mount, but there are other LM324 variants in a DIP package, which will work fine in a breadboard." />
  <row Id="2489" PostHistoryTypeId="2" PostId="879" RevisionGUID="ee96d95f-bccf-4eb4-bc79-e8fc7959cc5e" CreationDate="2014-03-23T05:04:51.437" UserId="10" Text="# ShiftLCD&#xD;&#xA;**AVR based, Arduino compatible, board that mounts to the back of an 8x1 up to 20x4 Character LCD Screen.**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;I just designed this board and the custom library to make it easier to use and LCD. Though they are pretty easy to use at the moment. It cuts down the number of output pins used from 6 to 3. It also has the option to expand the I/O by adding more shift registers on to the one that drives the display. The processor used is an ATTiny45 or ATTiny85 which has an available analog pin and digital pin, that has PWM available, to be used for input or output.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;[OSH Park permalink which has parts listed][1]&#xD;&#xA;[Arduino Library][2]&#xD;&#xA;![Schematic][3]&#xD;&#xA;![OSH Park render][4]&#xD;&#xA;![Unsoldered Board][5]&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;Granted this may not be the coolest product or idea, it still has its uses. The answer the question directly, &quot;What did you learn from doing this project&quot; I learned how to design from start to finish a PCB board. If I could do anything differently it would have been to use surface mount parts instead of through hole, then again it is just a prototype, one-off board. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://oshpark.com/shared_projects/LKBJyhOP&#xD;&#xA;&lt;br&gt;&#xD;&#xA;  [2]: https://github.com/jamolnng/Arduino/tree/master/libraries/ShiftLCD&#xD;&#xA;  [3]: http://i.stack.imgur.com/3nETo.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/aXSfc.png&#xD;&#xA;  [5]: http://i.stack.imgur.com/DqIuw.jpg" />
  <row Id="2490" PostHistoryTypeId="5" PostId="879" RevisionGUID="7d2fe168-1486-44d6-90c3-ec55815dffa0" CreationDate="2014-03-23T05:10:22.687" UserId="10" Comment="Formatting" Text="# ShiftLCD&#xD;&#xA;**AVR based, Arduino compatible, board that mounts to the back of an 8x1 up to 20x4 Character LCD Screen.**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;I just designed this board and the custom library to make it easier to use and LCD. Though they are pretty easy to use at the moment. It cuts down the number of output pins used from 6 to 3. It also has the option to expand the I/O by adding more shift registers on to the one that drives the display. The processor used is an ATTiny45 or ATTiny85 which has an available analog pin and digital pin, that has PWM available, to be used for input or output.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;* [OSH Park permalink which has parts listed][1]&lt;br&gt;&#xD;&#xA;* [Arduino Library][2]&#xD;&#xA;&#xD;&#xA;![Schematic][3]&#xD;&#xA;![OSH Park render][4]&#xD;&#xA;![Unsoldered Board][5]&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;Granted this may not be the coolest product or idea, it still has its uses. The answer the question directly, &quot;What did you learn from doing this project&quot; I learned how to design from start to finish a PCB board. If I could do anything differently it would have been to use surface mount parts instead of through hole, then again it is just a prototype, one-off board. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://oshpark.com/shared_projects/LKBJyhOP&#xD;&#xA;  [2]: https://github.com/jamolnng/Arduino/tree/master/libraries/ShiftLCD&#xD;&#xA;  [3]: http://i.stack.imgur.com/3nETo.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/aXSfc.png&#xD;&#xA;  [5]: http://i.stack.imgur.com/DqIuw.jpg" />
  <row Id="2491" PostHistoryTypeId="2" PostId="880" RevisionGUID="89a06b0b-1df2-45b1-a1ec-cb25d0ba1498" CreationDate="2014-03-23T07:41:06.620" UserId="83" Text="# Energy saver for the absent minded PC user&#xD;&#xA;**This device switches on/off my desk lights when it is dark(ish) and in sync with my PC screensaver.**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;The project is little more than an combination of a light sensitive sensor, a relay and some smart code that monitors the screensaver on my PC. When it is dusk and when screen saver is not active, it switches on the lights over my desk. When I subsequently leave my desk the screensaver will activate, which will in turn trigger the desk light to be turned off. When there is enough light during day time, the lights are not switched on at all. The problem solved is to reduce the waste of energy due to the lighting in my office being switched on when I have left the room.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;Because the power of microcontrollers / Arduino only little extra hardware is required to create useful project. The same goes for this project where the hardware is little more than:&#xD;&#xA;&#xD;&#xA;- an Arduino&#xD;&#xA;- a couple of screw shields to connect the external components&#xD;&#xA;- an LDR in series with a resistor to measure ambient light&#xD;&#xA;- a relay card to switch on and off the mains powered lights&#xD;&#xA;&#xD;&#xA;&lt;!-- Begin schematic: In order to preserve an editable schematic, please&#xD;&#xA;     don't edit this section directly.&#xD;&#xA;     Click the &quot;edit&quot; link below the image in the preview instead. --&gt;&#xD;&#xA;&#xD;&#xA;![schematic](http://i.stack.imgur.com/cQlSi.png)&#xD;&#xA;&#xD;&#xA;&lt;!-- End schematic --&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;I learned how to interface the PC over the USB serial link with Arduino and how to read current state of the screensaver on my PC. If I would start over, I'd use a much smaller controller as I really only need a single digital output and a single analog input. Probably base the project on [V-USB](http://www.obdev.at/products/vusb/index.html). Arduino however is excellent for the quick and easy Proof of Concept. (The PoC is on my desk for at least 2 years already)." />
  <row Id="2492" PostHistoryTypeId="5" PostId="876" RevisionGUID="64cee106-b112-48d4-8a12-669c166a0bae" CreationDate="2014-03-23T08:10:53.953" UserId="65" Comment="Spelling corrected; Minor edits" Text="&gt; &lt;img src=&quot;http://i.stack.imgur.com/hYRnU.png&quot; width=&quot;450&quot; height=&quot;200&quot; &gt; &#xD;&#xA;&#xD;&#xA;&gt; &lt;sub&gt;The logo is a derivative of the [Arduino Community Logo][1] licensed under [Creative Commons license CC-SA-BY-NC 3.0][2]&lt;/sub&gt; &#xD;&#xA;&#xD;&#xA;To celebrate [10 years of Arduino][3], we are proud to announce the *first event ever* on Arduino Stack Exchange.&#xD;&#xA;&#xD;&#xA;&gt; Get your boards and soldering equipment out, dig out the ICs and&#xD;&#xA;&gt; resistors. The first Arduino Stack Exchange contest is just round the&#xD;&#xA;&gt; corner. We will be looking for interesting projects that are built&#xD;&#xA;&gt; using Arduinos. The contest is aimed towards sharing, discussing and&#xD;&#xA;&gt; providing feedback on projects that you and other members are working&#xD;&#xA;&gt; on. &lt;sub&gt;[See announcement post][4]&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;# Details: &#xD;&#xA;&#xD;&#xA; - The prize is an official **Stack Exchange t-shirt**&#xD;&#xA; - Limit two entries per person. If more than two are provided, only the first two will be considered. &#xD;&#xA; - Clones *are* allowed.&#xD;&#xA; - Projects for consideration will be accepted through **March 29th, 2014 at 4:00 UTC.** The question will still remain open in case someone wants to show off their project they made on Arduino Day 2014.&#xD;&#xA;&#xD;&#xA;Visit the [Meta post][5] for discussion about this event and further information.&#xD;&#xA;&#xD;&#xA;# Answer Format&#xD;&#xA;&#xD;&#xA;You may post up to two projects (as two separate answers) as entries for the contest. All extra entries will be deleted. Consider following the following template for entries:&#xD;&#xA;&#xD;&#xA;&gt; # Project Title&#xD;&#xA;&gt; &#xD;&#xA;&gt; **Very Brief Description**&#xD;&#xA;&gt; &#xD;&#xA;&gt; # Description&#xD;&#xA;&gt; &#xD;&#xA;&gt; What is your project? What does it do? What problem does it solve?&#xD;&#xA;&gt; &#xD;&#xA;&gt; # Design&#xD;&#xA;&gt; &#xD;&#xA;&gt; Things to include in this section:&#xD;&#xA;&gt; &#xD;&#xA;&gt; - Schematics and other design documentation. [Fritzing][6] is a good tool for drawing breadboard schematics like the one shown in the&#xD;&#xA;&gt; project logo above.&#xD;&#xA;&gt; - Components used to build the project&#xD;&#xA;&gt; - Pictures or video&#xD;&#xA;&gt; &#xD;&#xA;&gt; # Conclusion&#xD;&#xA;&gt; &#xD;&#xA;&gt; Final thoughts. What did you learn from doing this project? What would&#xD;&#xA;&gt; you do differently if you had to start over?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;You can copy/paste the following text if you want to use this template.&#xD;&#xA;&#xD;&#xA;    # Project Title&#xD;&#xA;    **Very Brief Description**&#xD;&#xA;    &#xD;&#xA;    # Description&#xD;&#xA;    What is your project? What does it do? What problem does it solve?&#xD;&#xA;    &#xD;&#xA;    # Design&#xD;&#xA;    Things to include in this section:&#xD;&#xA;    &#xD;&#xA;    - Schematics and other design documentation. [Fritzing][7] is a good tool for drawing breadboard schematics like the one shown in the project logo above.&#xD;&#xA;    - Components used to build the project&#xD;&#xA;    - Pictures or video&#xD;&#xA;    &#xD;&#xA;    # Conclusion&#xD;&#xA;    Final thoughts. What did you learn from doing this project? What would you do differently if you had to start over?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Prizes&#xD;&#xA;&#xD;&#xA;There are two prizes! The winner will be the submission getting the maximum number of upvotes (downvotes do not count) and will get a Stack Exchange T-shirt*! There will be something for the runner-up as well. The runner-up will be decided at the discretion of the event organizers.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;*Certain restrictions may apply. International shipping may take a few weeks. &lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;# Where do I submit my projects?&#xD;&#xA;Post your projects as answers to this post.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Trademark/HomePage?from=Main.Trademark&#xD;&#xA;  [2]: http://creativecommons.org/licenses/&#xD;&#xA;  [3]: http://day.arduino.cc/&#xD;&#xA;  [4]: http://meta.arduino.stackexchange.com/questions/153/project-showcase-14-is-coming-to-arduino-stack-exchange-updated-3-19-14&#xD;&#xA;  [5]: http://meta.arduino.stackexchange.com/questions/171/project-showcase-14-detailed-information&#xD;&#xA;  [6]: http://fritzing.org/home/&#xD;&#xA;  [7]: http://fritzing.org/home/" />
  <row Id="2493" PostHistoryTypeId="2" PostId="881" RevisionGUID="66c5a3c8-76af-489a-8eb1-9a01edfd58ea" CreationDate="2014-03-23T10:52:46.530" UserId="168" Text="Just an alternate idea I saw: If you dont need high accuracy, you can use a voltage divider to bias -1 to +1 into 0 to 1, and set the analog reference to 1.2, and get almost the same result but skip the op amp.&#xD;&#xA;&#xD;&#xA;A voltage divider with 2 equal resistors will give you the voltage halfway between its two inputs. If the bottom of the voltage divider is at 1v, and the top input is at -1, you get 0 out.&#xD;&#xA;&#xD;&#xA;If the bottom is at +1, you get 1 out.&#xD;&#xA;&#xD;&#xA;I saw a really clever design using 2 1 megaohm resistors, and actually using the aref pin as an output to provide the bias for the divider, setting the reference to the 1.2v setting, putting the signal in the top of the divider and ground and connecting the adc to the output of the divider.&#xD;&#xA;&#xD;&#xA;Aref wasnt meant as a current source, but they use 1meg resistors so the current draw will be at most a few microamps.&#xD;&#xA;&#xD;&#xA;A filter cap on aref probably draws more than that if vcc is noisy(if there wasnt current to filter we wouldnt need the cap!) So a few uA should be fine.&#xD;&#xA;&#xD;&#xA;They put a 1nf capacitor betcan the input and ground to fix the issues with the ADC input current causing voltage drop. It worked up to 100hz. They never tested accuracy because it wasnt needed though. I'd guess that the adc internal reference was the major error source, probably a few percent." />
  <row Id="2494" PostHistoryTypeId="2" PostId="882" RevisionGUID="e8b8e346-f4b0-4fb4-af89-ec647b35c8f8" CreationDate="2014-03-23T12:11:25.067" UserId="113" Text="Regarding your measurements, I would completely disregard the first set with Serial.println() in the loop. I would exepect the timing of this to be unreliable.&#xD;&#xA;&#xD;&#xA;Your second set of data that you captured in a buffer looks correct, but your Frequency Estimation / timing may be wrong. I would invert a Digital Output at each loop iteration. You can measure the frequency of that with a Multimeter and your ADC sample rate would be twice that value.&#xD;&#xA;&#xD;&#xA;For a PC or laptop power supply that's quite a common current waveform.&#xD;&#xA;&#xD;&#xA;Without effective Power Factor Correction the current signal shown below would be quite typical (source: [http://www.nlvocables.com/blog/?p=300][1])&#xD;&#xA;&#xD;&#xA;![http://www.nlvocables.com/blog/?p=300][2]&#xD;&#xA;&#xD;&#xA;You will need to calculate RMS values and it would be wise to filter the signal.&#xD;&#xA;&#xD;&#xA;[Here's an instructable][3] I wrote on how to build and code an Arduino Yun based Electricity Monitor with Cloud Support / Temboo and Google Drive. It should be of some help to you.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.nlvocables.com/blog/?p=300&#xD;&#xA;  [2]: http://i.stack.imgur.com/oAAF2.gif&#xD;&#xA;  [3]: http://www.instructables.com/id/Yun-based-Electricity-Monitor-with-Cloud-Support-T/" />
  <row Id="2495" PostHistoryTypeId="6" PostId="874" RevisionGUID="17e726cc-28d6-4504-b27c-4cef2a09c83e" CreationDate="2014-03-23T12:43:29.950" UserId="65" Comment="edited tags" Text="&lt;sensors&gt;&lt;arduino-pro-micro&gt;" />
  <row Id="2496" PostHistoryTypeId="2" PostId="883" RevisionGUID="66fd1842-7dc2-4708-b9b4-544ec573e8de" CreationDate="2014-03-23T15:41:51.263" UserId="333" Text="I am using an HC-SRO4 ultrasonic sensor for a wall-avoidance, maze-solving robot. However, I have recently run into an issue where I am getting a whirring noise from the sensor because it is taking measurements way too often.&#xD;&#xA;&#xD;&#xA;This is the code I have right now:&#xD;&#xA;&#xD;&#xA;    const int serialPeriod = 250;       // only print to the serial console every 1/4 second&#xD;&#xA;    unsigned long timeSerialDelay = 0;&#xD;&#xA;    &#xD;&#xA;    const int loopPeriod = 20;          // a period of 20ms = a frequency of 50Hz&#xD;&#xA;    unsigned long timeLoopDelay   = 0;&#xD;&#xA;    &#xD;&#xA;    // specify the trig &amp; echo pins used for the ultrasonic sensors&#xD;&#xA;    const int ultrasonic2TrigPin = 8;&#xD;&#xA;    const int ultrasonic2EchoPin = 9;&#xD;&#xA;    &#xD;&#xA;    int ultrasonic2Distance;&#xD;&#xA;    int ultrasonic2Duration;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;      &#xD;&#xA;        // ultrasonic sensor pin configurations&#xD;&#xA;        pinMode(ultrasonic2TrigPin, OUTPUT);&#xD;&#xA;        pinMode(ultrasonic2EchoPin, INPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        debugOutput(); // prints debugging messages to the serial console&#xD;&#xA;        &#xD;&#xA;        if(millis() - timeLoopDelay &gt;= loopPeriod)&#xD;&#xA;        {&#xD;&#xA;            readUltrasonicSensors(); // read and store the measured distances&#xD;&#xA;            &#xD;&#xA;            timeLoopDelay = millis();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void readUltrasonicSensors()&#xD;&#xA;    {&#xD;&#xA;        // ultrasonic 2&#xD;&#xA;        digitalWrite(ultrasonic2TrigPin, HIGH);&#xD;&#xA;        delayMicroseconds(10);                  // must keep the trig pin high for at least 10us&#xD;&#xA;        digitalWrite(ultrasonic2TrigPin, LOW);&#xD;&#xA;        &#xD;&#xA;        ultrasonic2Duration = pulseIn(ultrasonic2EchoPin, HIGH);&#xD;&#xA;        ultrasonic2Distance = (ultrasonic2Duration/2)/29;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void debugOutput()&#xD;&#xA;    {&#xD;&#xA;        Serial.print(&quot;timeSerialDelay: &quot;);&#xD;&#xA;        Serial.print(timeSerialDelay);&#xD;&#xA;        Serial.println();&#xD;&#xA;        &#xD;&#xA;        if((millis() - timeSerialDelay) &gt; serialPeriod)&#xD;&#xA;        {&#xD;&#xA;            Serial.print(&quot;ultrasonic2Distance: &quot;);&#xD;&#xA;            Serial.print(ultrasonic2Distance);&#xD;&#xA;            Serial.print(&quot;cm: &quot;);&#xD;&#xA;            Serial.println();&#xD;&#xA;            &#xD;&#xA;            timeSerialDelay = millis();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;and my wiring:&#xD;&#xA;&#xD;&#xA;![breadboard wiring][1]&#xD;&#xA;&#xD;&#xA;[Link to product](https://www.foxytronics.com/products/181-4-pin-female-to-female-cable)&#xD;&#xA;&#xD;&#xA;Does anyone know why the scanning is happening constantly? It should only be happening every 1/4 of a second, not constantly. The weird thing is that this wasn't happening earlier before I started using the cable. &#xD;&#xA;&#xD;&#xA;I believe it has something to do with the 8.5&quot; extension cable I have (needed because I can't mount three sensors, one facing to each side and one in front, on a single breadboard). This is because when I mounted the sensor directly onto the breadboard, the delay was correct and the whirring was not present. However, as I just mentioned, I *need* the extension cable to be able to have the three sensors.&#xD;&#xA;&#xD;&#xA;Does anyone have a solution for this?&#xD;&#xA;&#xD;&#xA;Thanks!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/yzG9F.jpg" />
  <row Id="2497" PostHistoryTypeId="1" PostId="883" RevisionGUID="66fd1842-7dc2-4708-b9b4-544ec573e8de" CreationDate="2014-03-23T15:41:51.263" UserId="333" Text="Ultrasonic Sensor scanning too often resulting in a whirring noise" />
  <row Id="2498" PostHistoryTypeId="3" PostId="883" RevisionGUID="66fd1842-7dc2-4708-b9b4-544ec573e8de" CreationDate="2014-03-23T15:41:51.263" UserId="333" Text="&lt;arduino-uno&gt;&lt;sensors&gt;" />
  <row Id="2499" PostHistoryTypeId="2" PostId="884" RevisionGUID="f958bccf-7f70-416d-8f7f-bc258a527fac" CreationDate="2014-03-23T15:55:02.290" UserId="8" Text="If you want to sample at 4Hz (4 times per second), you need to change your headers accordingly:&#xD;&#xA;&#xD;&#xA;    const int serialPeriod = 250;       // only print to the serial console every 1/4 second&#xD;&#xA;    unsigned long timeSerialDelay = 0;&#xD;&#xA;    &#xD;&#xA;    const int loopPeriod = 250;          // a period of 250ms = a frequency of 4Hz&#xD;&#xA;    unsigned long timeLoopDelay   = 0;" />
  <row Id="2500" PostHistoryTypeId="5" PostId="540" RevisionGUID="855bb926-e2f6-4cb3-a403-594726322068" CreationDate="2014-03-23T16:12:32.387" UserId="510" Comment="Copy edited. The question changed." Text="&gt; So... I want to debug the WaterMote sketch, but I do not see an option in my Arduino IDE on Mac OS X. Is there a way to debug sketches using Macs? Searching online shows various and preferred options, but mostly on Windows (of which I don't have any at home).&#xD;&#xA;&#xD;&#xA;It's definitely possible to debug a sketch with OS&amp;nbsp;X. But it's definitely an advanced AVR topic, and if you're not experienced enough with embedded programming you should first try to avoid it, except if it is really necessary.&#xD;&#xA;&#xD;&#xA;Debugging a sketch for an [ATmega328][1] implies:&#xD;&#xA;&#xD;&#xA; - Running a flasher such as the AVR Dragon, the JTAG ICE 3, the STK500 or the AVR ONE; no cheap flasher implements the `DebugWire` protocol;&#xD;&#xA; - Setting up the debug fuse, which is an operation that can brick your [MCU][2].&#xD;&#xA;&#xD;&#xA;If you're using an [ATmega32U4][3] (or alike), you won't be able to do it out of the box, as the 32U4 needs a [JTAG][4] connection for on-chip debugging.&#xD;&#xA;&#xD;&#xA;Finally, once you got through that, you can bind a `gdb` to the AVR using [AVaRICE][5]. I'm not getting you through all that, because I really, really, strongly advise you not to do it until you're experienced enough to know what you're doing.&#xD;&#xA;&#xD;&#xA;&gt;    Moteino with WaterMote sketch loaded&#xD;&#xA;&gt;        connected via USB to the MacBook Pro&#xD;&#xA;&gt;        Arduino IDE running, but I see strange &quot;[][][]&quot; square output in the Serial connection.&#xD;&#xA;&gt;        I do not know what to make of this since that text is not in the WaterMote sketch.&#xD;&#xA;&gt; Is there a way to debug sketches loaded on Arduino clones using Arduino IDE on Macs?&#xD;&#xA;&#xD;&#xA;It is very likely you did not setup the correct baudrate for the serial outputs. Arduino IDE defaults to 9600&amp;nbsp;bits/s connections, whereas the [WaterMote source code][6] defines a 115,200&amp;nbsp;bits/s connection. When you open the `Serial Monitor` change the setting at the right of the status bar.&#xD;&#xA;&#xD;&#xA;And finally, be sure to uncomment the [`#define SERIAL_EN` line][7] to enable the serial communication and debug outputs.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.atmel.com/devices/atmega328.aspx&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Microcontroller&#xD;&#xA;  [3]: http://www.atmel.com/devices/atmega32u4.aspx&#xD;&#xA;  [4]: http://en.wikipedia.org/wiki/Joint_Test_Action_Group&#xD;&#xA;  [5]: http://avarice.sf.net&#xD;&#xA;  [6]: https://github.com/LowPowerLab/WaterMote/blob/master/WaterMote.ino#L31&#xD;&#xA;  [7]: https://github.com/LowPowerLab/WaterMote/blob/master/WaterMote.ino#L30&#xD;&#xA;" />
  <row Id="2501" PostHistoryTypeId="24" PostId="540" RevisionGUID="855bb926-e2f6-4cb3-a403-594726322068" CreationDate="2014-03-23T16:12:32.387" Comment="Proposed by 510 approved by 8, 220 edit id of 253" />
  <row Id="2502" PostHistoryTypeId="5" PostId="879" RevisionGUID="81a5e13d-b636-40d9-8ee5-f5934bf3c88a" CreationDate="2014-03-23T16:12:55.507" UserId="10" Comment="Reworded part of the description." Text="# ShiftLCD&#xD;&#xA;**AVR based, Arduino compatible, board that mounts to the back of an 8x1 up to 20x4 Character LCD Screen.**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;I just designed this board and the custom library to make it easier to use and LCD. Though they are pretty easy to use at the moment. It cuts down the number of output pins used from 6 to 3. It also has the option to expand the I/O by adding more shift registers on to the one that drives the display. The processor used is an ATTiny45 or ATTiny85 which has, after using the shift register, digital pins 1 (PWM) and 4 available and analog pin 2 (same pin as digital pin 4) available.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;* [OSH Park permalink which has parts listed][1]&lt;br&gt;&#xD;&#xA;* [Arduino Library][2]&#xD;&#xA;&#xD;&#xA;![Schematic][3]&#xD;&#xA;![OSH Park render][4]&#xD;&#xA;![Unsoldered Board][5]&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;Granted this may not be the coolest product or idea, it still has its uses. The answer the question directly, &quot;What did you learn from doing this project&quot; I learned how to design from start to finish a PCB board. If I could do anything differently it would have been to use surface mount parts instead of through hole, then again it is just a prototype, one-off board. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://oshpark.com/shared_projects/LKBJyhOP&#xD;&#xA;  [2]: https://github.com/jamolnng/Arduino/tree/master/libraries/ShiftLCD&#xD;&#xA;  [3]: http://i.stack.imgur.com/3nETo.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/aXSfc.png&#xD;&#xA;  [5]: http://i.stack.imgur.com/DqIuw.jpg" />
  <row Id="2503" PostHistoryTypeId="5" PostId="879" RevisionGUID="1de56165-a0e4-4feb-b0cc-14b0f3f37ee3" CreationDate="2014-03-23T16:19:55.237" UserId="10" Comment="Added challenges" Text="# ShiftLCD&#xD;&#xA;**AVR based, Arduino compatible, board that mounts to the back of an 8x1 up to 20x4 Character LCD Screen.**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;I just designed this board and the custom library to make it easier to use and LCD. Though they are pretty easy to use at the moment. It cuts down the number of output pins used from 6 to 3. It also has the option to expand the I/O by adding more shift registers on to the one that drives the display. The processor used is an ATTiny45 or ATTiny85 which has, after using the shift register, digital pins 1 (PWM) and 4 available and analog pin 2 (same pin as digital pin 4) available.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;* [OSH Park permalink which has parts listed][1]&lt;br&gt;&#xD;&#xA;* [Arduino Library][2]&#xD;&#xA;&#xD;&#xA;![Schematic][3]&#xD;&#xA;![OSH Park render][4]&#xD;&#xA;![Unsoldered Board][5]&#xD;&#xA;&#xD;&#xA;#Challenges&#xD;&#xA;One unforeseen challenge I faced was when I started I was using digital pins 0-2 to run the shift register, these also happened to be the programming pins (MISO, MOSI, SCK). So every time I reprogrammed the device the LCD would get sent a whole bunch of gibberish messages where the power would have to be turned off in order to reset the display. I solved this problem by moving the shift registers latch pin to digital pin 3 which is not a programming pin. Solving this also solved another problem for me because when I moved the latch pin it opened up digital pin 1 which had PWM usage, allowing for more things to be done with the board.&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;Granted this may not be the coolest product or idea, it still has its uses. The answer the question directly, &quot;What did you learn from doing this project&quot; I learned how to design from start to finish a PCB board. If I could do anything differently it would have been to use surface mount parts instead of through hole, then again it is just a prototype, one-off board. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://oshpark.com/shared_projects/LKBJyhOP&#xD;&#xA;  [2]: https://github.com/jamolnng/Arduino/tree/master/libraries/ShiftLCD&#xD;&#xA;  [3]: http://i.stack.imgur.com/3nETo.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/aXSfc.png&#xD;&#xA;  [5]: http://i.stack.imgur.com/DqIuw.jpg" />
  <row Id="2504" PostHistoryTypeId="5" PostId="877" RevisionGUID="56ff0559-6c05-40ce-831c-f49f078d3ff2" CreationDate="2014-03-23T16:32:27.653" UserId="774" Comment="deleted 166 characters in body" Text="I'm doing my first electronics project where a signal that varies between -1 to 1 V is going into an analog pin on the Arduino. The amplified signal has to be read as fast as possible by Arduino. The source signal is at 60 Hz.&#xD;&#xA;&#xD;&#xA;Will [this LM324][1] be a suitable 4-channel opamp for my needs? How concerned should I be about the 2 mV input offset and 20 nA input current bias?&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.digikey.com/product-detail/en/LM324N/296-1391-5-ND/277627&#xD;&#xA;  [2]: http://www.ebay.com/itm/SOP14-SSOP14-TSSOP14-to-DIP14-PCB-SMD-to-DIP-Adapter-plate-Pitch-0-65-1-27mm-/231183888806?pt=LH_DefaultDomain_0&amp;hash=item35d3a231a6&#xD;&#xA;" />
  <row Id="2505" PostHistoryTypeId="5" PostId="877" RevisionGUID="f2e00e2f-b1b5-4149-b037-0d60d53dd679" CreationDate="2014-03-23T16:38:03.013" UserId="774" Comment="deleted 34 characters in body" Text="I'm doing my first electronics project where a signal that varies between -1 to 1 V is going into an analog pin on the Arduino. The amplified signal has to be read as fast as possible by Arduino. The source signal is at 60 Hz.&#xD;&#xA;&#xD;&#xA;Will [this LM324][1] be a suitable 4-channel opamp for my needs? How concerned should I be about the 2 mV input offset and 20 nA input current bias?&#xD;&#xA;&#xD;&#xA;	&#xD;&#xA;To make full use of the 10bit ADC, would you recommend using an opamp with gain of 2 and biasing the signal by +2.5V? If so, will it be better to create the bias using a potential divider across +5V and GND, or using a 2.5V voltage regulator?&#xD;&#xA;&#xD;&#xA;	&#xD;&#xA;Or would it be better to set AREF to 2V and bias the signal by +1V? In this case, will it be better to use a 2V voltage regulator, or a voltage divider across Arduino's 3V3 and GND using 20M and 33M resistors? &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.digikey.com/product-detail/en/LM324N/296-1391-5-ND/277627&#xD;&#xA;  [2]: http://www.ebay.com/itm/SOP14-SSOP14-TSSOP14-to-DIP14-PCB-SMD-to-DIP-Adapter-plate-Pitch-0-65-1-27mm-/231183888806?pt=LH_DefaultDomain_0&amp;hash=item35d3a231a6&#xD;&#xA;" />
  <row Id="2506" PostHistoryTypeId="2" PostId="885" RevisionGUID="b88ec97b-0fb8-493d-9dea-5de22a174ea9" CreationDate="2014-03-24T00:18:30.070" UserId="368" Text="I currently do most of my AVR work on breadboards, but the large variety of Arduino shields and code out there makes me wonder if I'm not beating my head against the wall sometimes, and looking up port to pin mappings both wastes time and slows me down. Is there any convenient way to adapt AVRs other than those pin-compatible with current Arduinos to Arduino shields?" />
  <row Id="2507" PostHistoryTypeId="1" PostId="885" RevisionGUID="b88ec97b-0fb8-493d-9dea-5de22a174ea9" CreationDate="2014-03-24T00:18:30.070" UserId="368" Text="Adapting bare AVRs to Arduino shields" />
  <row Id="2508" PostHistoryTypeId="3" PostId="885" RevisionGUID="b88ec97b-0fb8-493d-9dea-5de22a174ea9" CreationDate="2014-03-24T00:18:30.070" UserId="368" Text="&lt;shields&gt;&lt;avr&gt;" />
  <row Id="2511" PostHistoryTypeId="2" PostId="886" RevisionGUID="c155d26c-75b2-4876-ad34-b8771e56c499" CreationDate="2014-03-24T01:27:06.783" UserId="734" Text="I am sending three signals from one arduino mega to another using xbees. On the receiving end I am using these signals in a Simulink code to control servo motors. Currently it is set up to read from analog pins without the wireless set up. With the wireless technology the signals are all being sent and received through one serial port. I believe I would need to change the inputs in Simulink to a serial receive block instead of an analog pin block. The problem is the documentation for the serial receive block says you can not assign more than one serial receive block to the same serial port. If anyone has a solution to this it would be greatly appreciated!&#xD;&#xA; " />
  <row Id="2512" PostHistoryTypeId="1" PostId="886" RevisionGUID="c155d26c-75b2-4876-ad34-b8771e56c499" CreationDate="2014-03-24T01:27:06.783" UserId="734" Text="Reading three signals sent serially on Simulink from Arduino" />
  <row Id="2513" PostHistoryTypeId="3" PostId="886" RevisionGUID="c155d26c-75b2-4876-ad34-b8771e56c499" CreationDate="2014-03-24T01:27:06.783" UserId="734" Text="&lt;serial&gt;&lt;arduino-mega&gt;" />
  <row Id="2515" PostHistoryTypeId="5" PostId="886" RevisionGUID="f6724b60-cd95-4586-8662-1e7aab9c5bac" CreationDate="2014-03-24T03:02:28.377" UserId="734" Comment="added 313 characters in body" Text="I am sending three signals from one arduino mega to another using xbees. On the receiving end I am using these signals in a Simulink code to control servo motors. Currently it is set up to read from analog pins without the wireless set up. With the wireless technology the signals are all being sent and received through one serial port. I believe I would need to change the inputs in Simulink to a serial receive block instead of an analog pin block. The problem is the documentation for the serial receive block says you can not assign more than one serial receive block to the same serial port. If anyone has a solution to this it would be greatly appreciated!  &lt;br/&gt;&#xD;&#xA;&lt;br/&gt;&#xD;&#xA;    int received1; &lt;br/&gt;&#xD;&#xA;    int received2;  &lt;br/&gt;&#xD;&#xA;    int received3;  &lt;br/&gt;&#xD;&#xA;    void setup() {  &lt;br/&gt;&#xD;&#xA;&#xD;&#xA;    Serial.begin(9600);  &#xD;&#xA;    }&#xD;&#xA;    void loop() {&#xD;&#xA;&#xD;&#xA;    if(Serial.available() )  &lt;br/&gt;&#xD;&#xA;    {  &lt;br/&gt;&#xD;&#xA;    received1, received2, received3 = Serial.read();  &lt;br/&gt;&#xD;&#xA;&#xD;&#xA;    }  &lt;br/&gt;&#xD;&#xA;    }    " />
  <row Id="2516" PostHistoryTypeId="5" PostId="886" RevisionGUID="e0e6eb4b-889e-4d1b-b8d5-9b12a02f92e0" CreationDate="2014-03-24T03:08:06.790" UserId="734" Comment="added 313 characters in body" Text="I am sending three signals from one arduino mega to another using xbees. On the receiving end I am using these signals in a Simulink code to control servo motors. Currently it is set up to read from analog pins without the wireless set up. With the wireless technology the signals are all being sent and received through one serial port. I believe I would need to change the inputs in Simulink to a serial receive block instead of an analog pin block. The problem is the documentation for the serial receive block says you can not assign more than one serial receive block to the same serial port. If anyone has a solution to this it would be greatly appreciated!  &lt;br/&gt;&#xD;&#xA;&lt;br/&gt;&#xD;&#xA;&#xD;&#xA;receiving code &lt;br/&gt;&#xD;&#xA;&#xD;&#xA;    int received1; &#xD;&#xA;    int received2;  &#xD;&#xA;    int received3;  &#xD;&#xA;    void setup() {  &#xD;&#xA;    Serial.begin(9600);  &#xD;&#xA;    }  &#xD;&#xA;    void loop() {  &#xD;&#xA;    if(Serial.available() )  &#xD;&#xA;    {  &#xD;&#xA;    received1, received2, received3 = Serial.read();  &#xD;&#xA;    }  &#xD;&#xA;    }    " />
  <row Id="2517" PostHistoryTypeId="2" PostId="887" RevisionGUID="f8962670-4d2e-4a6f-88f6-e31494206aa8" CreationDate="2014-03-24T03:17:43.857" UserId="8" Text="# &lt;small&gt;(fake)&lt;/small&gt; Linux on Arduino&#xD;&#xA;&#xD;&#xA;**I recently acquired a small composite LCD screen, which I quickly began playing with using the Arduino TVout library. What came next? Linux!**&#xD;&#xA;&#xD;&#xA;Description&#xD;&#xA;----&#xD;&#xA;&#xD;&#xA;While playing around with my TV screen and the TVout library, I discovered there is a premodern terminal handler for the TV. I soon began to experiment with using it as a TV terminal hooked up to a PS/2 keyboard. There were some problems with the PS/2 library I used, so I transitioned it to use the USB library on my Mega ADK along with a USB keyboard. That worked much better. Now for storage.&#xD;&#xA;&#xD;&#xA;My SD card shield isn't compatible with my Mega, so I wired it up somewhat haphazardly to the SPI at the end of the board. I wrote command handling to preform a few tasks like listing files and finding disk size, free space, etc.. The entire assembly isn't by any means finished, but I am happy with the progress I have made.&#xD;&#xA;&#xD;&#xA;The code will be relocated to Github eventually, watch the comments.&#xD;&#xA;&#xD;&#xA;Design&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![zoomed out pic][1]&#xD;&#xA;&#xD;&#xA;![clse up screen][2]&#xD;&#xA;&#xD;&#xA;Challenges&#xD;&#xA;--&#xD;&#xA;&#xD;&#xA;I had a lot of trouble concatenation g the I putted charactars to the string storing the current command because I wasn't casting right. Once I got that figured out, I also needed to fix the problem where some keys printed random garbage to the screen. This was caused by reading memory before the letter definitions, so a few `if`s cleared that up.&#xD;&#xA;&#xD;&#xA;Conclusion&#xD;&#xA;--&#xD;&#xA;&#xD;&#xA;I am very satisfied with the code. Once I add a few more utilities to it, I will put it on Github, so watch the comments. Overall, it was a very fun project. I learned how to use Stino in the process.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/cgzPU.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/L9PmB.jpg" />
  <row Id="2518" PostHistoryTypeId="5" PostId="887" RevisionGUID="56d3472d-c025-4757-899c-cd6050d9223d" CreationDate="2014-03-24T03:24:41.740" UserId="8" Comment="Minor typo" Text="# &lt;small&gt;(fake)&lt;/small&gt; Linux on Arduino&#xD;&#xA;&#xD;&#xA;**I recently acquired a small composite LCD screen, which I quickly began playing with using the Arduino TVout library. What came next? Linux!**&#xD;&#xA;&#xD;&#xA;Description&#xD;&#xA;----&#xD;&#xA;&#xD;&#xA;While playing around with my TV screen and the TVout library, I discovered there is a premodern terminal handler for the TV. I soon began to experiment with using it as a TV terminal hooked up to a PS/2 keyboard. There were some problems with the PS/2 library I used, so I transitioned it to use the USB library on my Mega ADK along with a USB keyboard. That worked much better. Now for storage.&#xD;&#xA;&#xD;&#xA;My SD card shield isn't compatible with my Mega, so I wired it up somewhat haphazardly to the SPI at the end of the board. I wrote command handling to preform a few tasks like listing files and finding disk size, free space, etc.. The entire assembly isn't by any means finished, but I am happy with the progress I have made.&#xD;&#xA;&#xD;&#xA;The code will be relocated to Github eventually, watch the comments.&#xD;&#xA;&#xD;&#xA;Design&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![zoomed out pic][1]&#xD;&#xA;&#xD;&#xA;![clse up screen][2]&#xD;&#xA;&#xD;&#xA;Challenges&#xD;&#xA;--&#xD;&#xA;&#xD;&#xA;I had a lot of trouble concatenating the inputted charactars to the string storing the current command because I wasn't casting right. Once I got that figured out, I also needed to fix the problem where some keys printed random garbage to the screen. This was caused by reading memory before the letter definitions, so a few `if`s cleared that up.&#xD;&#xA;&#xD;&#xA;Conclusion&#xD;&#xA;--&#xD;&#xA;&#xD;&#xA;I am very satisfied with the code. Once I add a few more utilities to it, I will put it on Github, so watch the comments. Overall, it was a very fun project. I learned how to use Stino in the process.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/cgzPU.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/L9PmB.jpg" />
  <row Id="2519" PostHistoryTypeId="5" PostId="881" RevisionGUID="f5f5fe15-4676-4e92-99ad-123619ceb8e8" CreationDate="2014-03-24T03:57:52.537" UserId="168" Comment="added 538 characters in body" Text="Just an alternate idea I saw: If you dont need high accuracy, you can use a voltage divider to bias -1 to +1 into 0 to 1, and set the analog reference to 1.2, and get almost the same result but skip the op amp.&#xD;&#xA;&#xD;&#xA;A voltage divider with 2 equal resistors will give you the voltage halfway between its two inputs. If the bottom of the voltage divider is at 1v, and the top input is at -1, you get 0 out.&#xD;&#xA;&#xD;&#xA;If the bottom is at +1, you get 1 out.&#xD;&#xA;&#xD;&#xA;I saw a really clever design using 2 1 megaohm resistors, and actually using the aref pin as an output to provide the bias for the divider, setting the reference to the 1.2v setting, putting the signal in the top of the divider and ground and connecting the adc to the output of the divider.&#xD;&#xA;&#xD;&#xA;Aref wasnt meant as a current source, but they use 1meg resistors so the current draw will be at most a few microamps.&#xD;&#xA;&#xD;&#xA;A filter cap on aref probably draws more than that if vcc is noisy(if there wasnt current to filter we wouldnt need the cap!) So a few uA should be fine.&#xD;&#xA;&#xD;&#xA;They put a 1nf capacitor betcan the input and ground to fix the issues with the ADC input current causing voltage drop. It worked up to 100hz. They never tested accuracy because it wasnt needed though. I'd guess that the adc internal reference was the major error source, probably a few percent.&#xD;&#xA;&#xD;&#xA;You can also actually bias with a voltage divider to the 5V supply, and get a 0 to ~1.6V output, it's just a little harder to understand.&#xD;&#xA;&#xD;&#xA;This simulation explains the concept(5v version)&#xD;&#xA;http://www.falstad.com/circuit/#%24+1+5.0E-6+81.92041607667615+50+5.0+50%0Ar+304+160+304+224+0+1000.0%0Ar+304+224+304+304+0+5000.0%0AR+304+304+256+304+0+0+40.0+5.0+0.0+0.0+0.5%0AR+304+160+208+160+0+1+40.0+1.0+0.0+0.0+0.5%0Aw+304+224+400+224+0%0Ax+368+208+456+214+0+24+To+ADC%0Ao+3+64+0+35+2.5+0.00625+0+-1%0Ao+4+64+0+35+2.5+9.765625E-5+1+-1%0A&#xD;&#xA;&#xD;&#xA;Left click the output, use view in scope." />
  <row Id="2520" PostHistoryTypeId="5" PostId="886" RevisionGUID="61c0a8ad-7037-4781-bd59-5d00512c6c8e" CreationDate="2014-03-24T04:01:35.497" UserId="734" Comment="added 319 characters in body" Text="I am sending three signals from one arduino mega to another using xbees. On the receiving end I am using these signals in a Simulink code to control servo motors. Currently it is set up to read from analog pins without the wireless set up. With the wireless technology the signals are all being sent and received through one serial port. I believe I would need to change the inputs in Simulink to a serial receive block instead of an analog pin block. The problem is the documentation for the serial receive block says you can not assign more than one serial receive block to the same serial port. If anyone has a solution to this it would be greatly appreciated!  &lt;br/&gt;&#xD;&#xA;&lt;br/&gt;&#xD;&#xA;&#xD;&#xA;receiving code &lt;br/&gt;&#xD;&#xA;&#xD;&#xA;    int received1; &#xD;&#xA;    int received2;  &#xD;&#xA;    int received3;  &#xD;&#xA;    void setup() {  &#xD;&#xA;    Serial.begin(9600);  &#xD;&#xA;    }  &#xD;&#xA;    void loop() {  &#xD;&#xA;    if(Serial.available() )  &#xD;&#xA;    {  &#xD;&#xA;    received1, received2, received3 = Serial.read();  &#xD;&#xA;    }  &#xD;&#xA;    }   &#xD;&#xA;&#xD;&#xA;transmitting code:&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;       Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      int sensorValue1 = analogRead(A0);&#xD;&#xA;      int sensorValue2 = analogRead(A1);&#xD;&#xA;      int sensorValue3 = analogRead(A2);&#xD;&#xA;      Serial.write(sensorValue1, sensorValue2, sensorValue3);&#xD;&#xA;      delay(1);       &#xD;&#xA;    }" />
  <row Id="2521" PostHistoryTypeId="2" PostId="888" RevisionGUID="93063748-dcdd-47ce-9251-8217d8a0d55b" CreationDate="2014-03-24T04:19:36.053" UserId="168" Text="How much accuracy do you really need? If it's just 1 or 2 extra bits of resolution you are after, you might be able to achieve that with a bit of oversampling.&#xD;&#xA;&#xD;&#xA;Basically, you take a ton of readings and average them. It only works if there is at least a few mV of random noise in your signal or in your ADC, and if your input signal bandwidth is low enough to be averaging samples together.&#xD;&#xA;&#xD;&#xA;Otherwise, go with a dedicated ADC chip." />
  <row Id="2523" PostHistoryTypeId="5" PostId="880" RevisionGUID="21b092c3-81a7-4305-9f86-c48800881da4" CreationDate="2014-03-24T06:06:09.920" UserId="83" Comment="added 109 characters in body" Text="# Energy saver for the absent minded PC user&#xD;&#xA;**This device switches on/off my desk lights when it is dark(ish) and in sync with my PC screensaver.**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;The project is little more than an combination of a light sensitive sensor, a relay and some smart code that monitors the screensaver on my PC. When it is dusk and when screen saver is not active, it switches on the lights over my desk. When I subsequently leave my desk the screensaver will activate, which will in turn trigger the desk light to be turned off. When there is enough light during day time, the lights are not switched on at all. The problem solved is to reduce the waste of energy due to the lighting in my office being switched on when I have left the room.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;Because the power of microcontrollers / Arduino only little extra hardware is required to create useful project. The same goes for this project where the hardware is little more than:&#xD;&#xA;&#xD;&#xA;- an Arduino&#xD;&#xA;- a couple of screw shields to connect the external components&#xD;&#xA;- an LDR in series with a resistor to measure ambient light&#xD;&#xA;- a relay card to switch on and off the mains powered lights&#xD;&#xA;- a 10μF capacitor from GND to RST to prevent the board from being reset and accidentally being programmed.&#xD;&#xA;&#xD;&#xA;&lt;!-- Begin schematic: In order to preserve an editable schematic, please&#xD;&#xA;     don't edit this section directly.&#xD;&#xA;     Click the &quot;edit&quot; link below the image in the preview instead. --&gt;&#xD;&#xA;&#xD;&#xA;![schematic](http://i.stack.imgur.com/cQlSi.png)&#xD;&#xA;&#xD;&#xA;&lt;!-- End schematic --&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;I learned how to interface the PC over the USB serial link with Arduino and how to read current state of the screensaver on my PC. If I would start over, I'd use a much smaller controller as I really only need a single digital output and a single analog input. Probably base the project on [V-USB](http://www.obdev.at/products/vusb/index.html). Arduino however is excellent for the quick and easy Proof of Concept. (The PoC is on my desk for at least 2 years already)." />
  <row Id="2524" PostHistoryTypeId="2" PostId="889" RevisionGUID="98b75ac4-3eaf-4ce0-bd7e-ba78effba63e" CreationDate="2014-03-24T06:29:52.423" UserId="83" Text="The Arduino-way of doing that is making a lookup table that translates pin number to PORTn / DDRn / PINn SFR and the related bit. You can use the same trick and make GPIO pins count in a convenient way as they are in the package. Only special peripherals (like SPI / PWM) cannot be accounted for in this way because they are hard wired to a pin.&#xD;&#xA;&#xD;&#xA;A good start is the below `Arduino.h` library sniplet if you want to re-use that concept.&#xD;&#xA;&#xD;&#xA;    // Get the bit location within the hardware port of the given virtual pin.&#xD;&#xA;    // This comes from the pins_*.c file for the active board configuration.&#xD;&#xA;    &#xD;&#xA;    #define analogInPinToBit(P) (P)&#xD;&#xA;    &#xD;&#xA;    // On the ATmega1280, the addresses of some of the port registers are&#xD;&#xA;    // greater than 255, so we can't store them in uint8_t's.&#xD;&#xA;    extern const uint16_t PROGMEM port_to_mode_PGM[];&#xD;&#xA;    extern const uint16_t PROGMEM port_to_input_PGM[];&#xD;&#xA;    extern const uint16_t PROGMEM port_to_output_PGM[];&#xD;&#xA;    &#xD;&#xA;    extern const uint8_t PROGMEM digital_pin_to_port_PGM[];&#xD;&#xA;    // extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];&#xD;&#xA;    extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];&#xD;&#xA;    extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];&#xD;&#xA;&#xD;&#xA;    // Get the bit location within the hardware port of the given virtual pin.&#xD;&#xA;    // This comes from the pins_*.c file for the active board configuration.&#xD;&#xA;    // &#xD;&#xA;    // These perform slightly better as macros compared to inline functions&#xD;&#xA;    //&#xD;&#xA;    #define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )&#xD;&#xA;    #define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )&#xD;&#xA;    #define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )&#xD;&#xA;    #define analogInPinToBit(P) (P)&#xD;&#xA;    #define portOutputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_output_PGM + (P))) )&#xD;&#xA;    #define portInputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_input_PGM + (P))) )&#xD;&#xA;    #define portModeRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_mode_PGM + (P))) )&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2525" PostHistoryTypeId="5" PostId="889" RevisionGUID="18757d46-5e1a-4d18-a9ea-deec5a9dec5b" CreationDate="2014-03-24T06:39:06.630" UserId="83" Comment="added 175 characters in body" Text="The Arduino-way of doing that is making a lookup table that translates pin number to PORTn / DDRn / PINn SFR and the related bit. You can use the same trick and make GPIO pins count in a convenient way as they are in the package. Only special peripherals (like SPI / PWM) cannot be accounted for in this way because they are hard wired to a pin.&#xD;&#xA;&#xD;&#xA;A good start is the below `Arduino.h` library sniplet if you want to re-use that concept.&#xD;&#xA;&#xD;&#xA;    // Get the bit location within the hardware port of the given virtual pin.&#xD;&#xA;    // This comes from the pins_*.c file for the active board configuration.&#xD;&#xA;    &#xD;&#xA;    #define analogInPinToBit(P) (P)&#xD;&#xA;    &#xD;&#xA;    // On the ATmega1280, the addresses of some of the port registers are&#xD;&#xA;    // greater than 255, so we can't store them in uint8_t's.&#xD;&#xA;    extern const uint16_t PROGMEM port_to_mode_PGM[];&#xD;&#xA;    extern const uint16_t PROGMEM port_to_input_PGM[];&#xD;&#xA;    extern const uint16_t PROGMEM port_to_output_PGM[];&#xD;&#xA;    &#xD;&#xA;    extern const uint8_t PROGMEM digital_pin_to_port_PGM[];&#xD;&#xA;    // extern const uint8_t PROGMEM digital_pin_to_bit_PGM[];&#xD;&#xA;    extern const uint8_t PROGMEM digital_pin_to_bit_mask_PGM[];&#xD;&#xA;    extern const uint8_t PROGMEM digital_pin_to_timer_PGM[];&#xD;&#xA;&#xD;&#xA;    // Get the bit location within the hardware port of the given virtual pin.&#xD;&#xA;    // This comes from the pins_*.c file for the active board configuration.&#xD;&#xA;    // &#xD;&#xA;    // These perform slightly better as macros compared to inline functions&#xD;&#xA;    //&#xD;&#xA;    #define digitalPinToPort(P) ( pgm_read_byte( digital_pin_to_port_PGM + (P) ) )&#xD;&#xA;    #define digitalPinToBitMask(P) ( pgm_read_byte( digital_pin_to_bit_mask_PGM + (P) ) )&#xD;&#xA;    #define digitalPinToTimer(P) ( pgm_read_byte( digital_pin_to_timer_PGM + (P) ) )&#xD;&#xA;    #define analogInPinToBit(P) (P)&#xD;&#xA;    #define portOutputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_output_PGM + (P))) )&#xD;&#xA;    #define portInputRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_input_PGM + (P))) )&#xD;&#xA;    #define portModeRegister(P) ( (volatile uint8_t *)( pgm_read_word( port_to_mode_PGM + (P))) )&#xD;&#xA;&#xD;&#xA;The `pinMode`, `digitalWrite` and `digitalRead` functions are defined in `/usr/share/arduino/hardware/arduino/cores/arduino/wiring_digital.c` which can be used for further inspiration.&#xD;&#xA;" />
  <row Id="2526" PostHistoryTypeId="2" PostId="890" RevisionGUID="15e6fee9-6aa1-4703-8288-76c1c7b6bacb" CreationDate="2014-03-24T06:46:25.323" UserId="785" Text="I have a servo motor with following specs&#xD;&#xA;Torque - 1.08Nm&#xD;&#xA;Max rpm - 3000&#xD;&#xA;Current rating - 7.8 amp&#xD;&#xA;Max voltage - 56V DC&#xD;&#xA;&#xD;&#xA;Please tell me how to calculate whether an arduino board - uno rev 3 can control the servo motor? If not, how to find out how many such boards are required?" />
  <row Id="2527" PostHistoryTypeId="1" PostId="890" RevisionGUID="15e6fee9-6aa1-4703-8288-76c1c7b6bacb" CreationDate="2014-03-24T06:46:25.323" UserId="785" Text="How to find out whether an arduino can control a servo motor" />
  <row Id="2528" PostHistoryTypeId="3" PostId="890" RevisionGUID="15e6fee9-6aa1-4703-8288-76c1c7b6bacb" CreationDate="2014-03-24T06:46:25.323" UserId="785" Text="&lt;arduino-uno&gt;&lt;motor&gt;" />
  <row Id="2530" PostHistoryTypeId="5" PostId="885" RevisionGUID="e2fab4ed-120c-4efb-8d37-e39258101ef4" CreationDate="2014-03-24T07:57:41.137" UserId="368" Comment="added 4 characters in body; edited tags" Text="I currently do most of my AVR work on breadboards, but the large variety of Arduino shields and code out there makes me wonder if I'm not beating my head against the wall sometimes, and looking up port to pin mappings both wastes time and slows me down. Is there any convenient way to adapt AVRs (*other* than those pin-compatible with current Arduinos) to Arduino shields?" />
  <row Id="2531" PostHistoryTypeId="6" PostId="885" RevisionGUID="e2fab4ed-120c-4efb-8d37-e39258101ef4" CreationDate="2014-03-24T07:57:41.137" UserId="368" Comment="added 4 characters in body; edited tags" Text="&lt;shields&gt;&lt;avr&gt;&lt;hardware&gt;" />
  <row Id="2532" PostHistoryTypeId="2" PostId="892" RevisionGUID="4d20cb81-92ad-4497-855b-25d840b07621" CreationDate="2014-03-24T09:37:35.727" UserId="679" Text="# Sonic Ray Gun&#xD;&#xA;**Two projects by kids**&#xD;&#xA;&#xD;&#xA;I'm working with a couple of home educated kids and we are having a lot of fun with an arduino. Their first project was a fake-bomb, like you see in the movies, with a LCD countdown timer and a classic &quot;do you cut the red or blue wire?&quot; type problem. &#xD;&#xA;&#xD;&#xA;Project two started with showing them the toneMelody example and a small speaker. The quickly found out that if you turn the frequency up to 15kHz it was rather annoying to teenagers. An hour later they had improved the design with a cup, toilet roll and a switch made from a paperclip making a directional sonic ray gun.&#xD;&#xA;&#xD;&#xA;Sadly no pictures.&#xD;&#xA;&#xD;&#xA;#Conclusion&#xD;&#xA;Don't leave kids unattended with an arduino." />
  <row Id="2533" PostHistoryTypeId="2" PostId="893" RevisionGUID="d1a95bf0-a62a-4845-98b1-4aab76398ac5" CreationDate="2014-03-24T10:22:29.783" UserId="785" Text="I am a novice user of Arduino. I am not sure whether I can connect both USB  and external supply through power adaptor to Arduino simultaneously. Would this burn the controller? &#xD;&#xA;&#xD;&#xA;Basically, I want to automatically shutdown the computer after saving all open documents before my UPS battery goes out whenever I am not there to manually shut it down. I am trying to notify the computer about the power failures of main supply - AC 220V 50 Hz ( notification/signal sent when power goes out) via USB using Arduino. I am thinking that this can be done by using the external voltage power supply pin. Whenever power goes out in the mains, the external voltage power supply pin will drop to 0 V from 7 V. The value of the voltage can be read using software ( I am unclear about this: Can it be done? If yes, how?). The arduino will still be powered up as it is connected to USB of computer and thereby communicate to the computer about the power failure. " />
  <row Id="2534" PostHistoryTypeId="1" PostId="893" RevisionGUID="d1a95bf0-a62a-4845-98b1-4aab76398ac5" CreationDate="2014-03-24T10:22:29.783" UserId="785" Text="Arduino : What happens if I power the arduino with both the USB and external power voltage simultaneously?" />
  <row Id="2535" PostHistoryTypeId="3" PostId="893" RevisionGUID="d1a95bf0-a62a-4845-98b1-4aab76398ac5" CreationDate="2014-03-24T10:22:29.783" UserId="785" Text="&lt;arduino-uno&gt;&lt;power&gt;" />
  <row Id="2536" PostHistoryTypeId="2" PostId="894" RevisionGUID="1e30922e-04a7-4c89-9730-1df54bf188a6" CreationDate="2014-03-24T10:37:08.933" UserId="368" Text="From &lt;a href=&quot;http://arduino.cc/en/Main/arduinoBoardUno&quot;&gt;arduinoBoardUno&lt;/a&gt;:&#xD;&#xA;&#xD;&#xA;&gt;#Power&#xD;&#xA;&#xD;&#xA;&gt;The Arduino Uno can be powered via the USB connection or with an external power supply. The power source is selected automatically. &#xD;&#xA;&#xD;&#xA;Put the external power through a voltage divider or regulator and into an analog (divider) or digital (regulator) pin and check the appropriate value from the pin." />
  <row Id="2537" PostHistoryTypeId="5" PostId="894" RevisionGUID="be3f8a88-5bc7-482e-8e07-a6026033a295" CreationDate="2014-03-24T10:42:33.763" UserId="368" Comment="added 99 characters in body" Text="From &lt;a href=&quot;http://arduino.cc/en/Main/arduinoBoardUno&quot;&gt;arduinoBoardUno&lt;/a&gt;:&#xD;&#xA;&#xD;&#xA;&gt;#Power&#xD;&#xA;&#xD;&#xA;&gt;The Arduino Uno can be powered via the USB connection or with an external power supply. The power source is selected automatically. &#xD;&#xA;&#xD;&#xA;Put the external power through a voltage divider or regulator and into an analog (divider) or digital (regulator) pin and check the appropriate value from the pin. Note that this does not require powering the Uno from external power, only connecting the grounds." />
  <row Id="2538" PostHistoryTypeId="5" PostId="894" RevisionGUID="bf93a240-432b-4c37-9cf2-67e3ea281c3b" CreationDate="2014-03-24T11:07:08.490" UserId="368" Comment="added 15 characters in body" Text="From &lt;a href=&quot;http://arduino.cc/en/Main/arduinoBoardUno&quot;&gt;arduinoBoardUno&lt;/a&gt;:&#xD;&#xA;&#xD;&#xA;&gt;#Power&#xD;&#xA;&#xD;&#xA;&gt;The Arduino Uno can be powered via the USB connection or with an external power supply. The power source is selected automatically. &#xD;&#xA;&#xD;&#xA;Put the external power through a voltage divider or transistor-based inverter and into an analog (divider) or digital (inverter) pin and check the appropriate value from the pin. Note that this does not require powering the Uno from external power, only connecting the grounds." />
  <row Id="2539" PostHistoryTypeId="2" PostId="895" RevisionGUID="d2b1be3e-5c51-4663-bc7c-0a87fe3bad58" CreationDate="2014-03-24T12:11:19.597" UserId="470" Text="You can make adapter boards (one for each mcu model).&#xD;&#xA;&#xD;&#xA;The bottom side (male headers) would plug to the breadboard and the upper side would have female headers with the same pinout as an Arduino board (female hearers placed in the appropriate positions to match Arduino shields).&#xD;&#xA;&#xD;&#xA;Such a board shouldn't be difficult to design." />
  <row Id="2540" PostHistoryTypeId="34" PostId="725" RevisionGUID="2fdb0957-5cf8-4382-a9b2-a9a05439d504" CreationDate="2014-03-24T13:11:55.900" UserId="-1" Comment="4" />
  <row Id="2541" PostHistoryTypeId="5" PostId="895" RevisionGUID="10c3d571-9fe7-4390-9df7-303e7866a1c1" CreationDate="2014-03-24T13:34:26.807" UserId="470" Comment="added 268 characters in body" Text="You can make adapter boards (one for each mcu model).&#xD;&#xA;&#xD;&#xA;The bottom side (male headers) would plug to the breadboard and the upper side would have female headers with the same pinout as an Arduino board (female hearers placed in the appropriate positions to match Arduino shields).&#xD;&#xA;&#xD;&#xA;Such a board shouldn't be difficult to design.&#xD;&#xA;&#xD;&#xA;Here is an image that resembles what I describe&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;It would adapt the pinout of a bare AVR to the pinout of a typical Arduino so that shields can by directly plugged on top of it.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;Also a pinout diagram may come handy to speedup things when you use a bare chip with Arduino code.   &#xD;&#xA;([image source](http://forum.arduino.cc/index.php/topic,146315.0.html))&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/LdseD.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/gNAJG.png" />
  <row Id="2542" PostHistoryTypeId="5" PostId="895" RevisionGUID="797c2c7d-5f67-4804-9e88-4d78f984191f" CreationDate="2014-03-24T13:41:10.970" UserId="470" Comment="added 251 characters in body" Text="You can make adapter boards (one for each mcu model).&#xD;&#xA;&#xD;&#xA;The bottom side (male headers) would plug to the breadboard and the upper side would have female headers with the same pinout as an Arduino board (female hearers placed in the appropriate positions to match Arduino shields).&#xD;&#xA;&#xD;&#xA;Such a board shouldn't be difficult to design.&#xD;&#xA;&#xD;&#xA;Here is an image that resembles what I describe&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;It would adapt the pinout of a bare AVR to the pinout of a typical Arduino so that shields can by directly plugged on top of it.&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;Also a pinout diagram may come handy to speedup things when you use a bare chip with Arduino code.   &#xD;&#xA;([image source](http://forum.arduino.cc/index.php/topic,146315.0.html))&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;Another similar solution is a small printed sticker placed on top of the AVR   &#xD;&#xA;([image source](http://makezine.com/2011/01/12/free-print-and-stick-pinout-label-f/))&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/LdseD.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/gNAJG.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/AMuWs.jpg" />
  <row Id="2543" PostHistoryTypeId="2" PostId="896" RevisionGUID="de40704c-89e0-4411-8cc7-2c10d740f131" CreationDate="2014-03-24T15:16:44.610" UserId="470" Text="&gt;I am a novice user of Arduino. I am not sure whether I can connect both USB and external supply through power adaptor to Arduino simultaneously. Would this burn the controller?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Lets study the schematic of [Arduino UNO R3](http://arduino.cc/en/uploads/Main/Arduino_Uno_Rev3-schematic.pdf)&#xD;&#xA;&#xD;&#xA;The input from the power supply plug (PWRIN, the power jack) goes through a diode D1 (to prevent reverse polarity), and feeds a [NCP1117](http://www.onsemi.com/pub/Collateral/NCP1117-D.PDF) regulator that down converts it to the 5v supply that feeds the 5v parts. &#xD;&#xA;&#xD;&#xA;![Power input][1]&#xD;&#xA;&#xD;&#xA;The alternative supply comes from the USB plug (USBVCC). The relevant circuit is shown below&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;The USB power lines goes through a P-mosfet (T1) that operates as a switch and then goes to the +5V node (that is the +5v regulator output as shown in the first schematic).&#xD;&#xA;&#xD;&#xA;The mosfet is controlled by an [LMV358](http://www.onsemi.com/pub/Collateral/LMV321-LMV358-LMV324-D.PDF) operational amplifier (OPAMP) that operates as a comparator.  &#xD;&#xA;The negative input of the opamp is tied to 3.3v and the positive one fed through a voltage divider with half the Vin supply level.&#xD;&#xA;&#xD;&#xA; - When Vin &gt;6.6V then the + input of the opamp become higher than the - input and the opamp turns the mosfet off.&#xD;&#xA;&#xD;&#xA; - When Vin &lt;6.6V then the + input of the opamp become lower than the - input and the opamp turns the mosfet on.&#xD;&#xA;&#xD;&#xA;Note that Vin is after the input diode so it's about 0.6v lower than the external connected power supply level. So when there is power supply connected to the power input that is higher than 6.6v+0.6v (where 0.6v is the diode D1 voltage drop), then the USB supply line is cutoff (because the mosfet turns off) and the power is provided from the power plug. Connecting or disconnecting the USP supply in this case will not make a difference, so you can have both power supplies connected simultaneously, only when the power input drops below the specified level (about 6.6V+0.6V=7.2V), the USB will start powering the board.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/bNsoC.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/r9NgC.gif" />
  <row Id="2544" PostHistoryTypeId="2" PostId="897" RevisionGUID="5eee2724-37a5-4393-a105-51af9e048ccc" CreationDate="2014-03-24T15:24:18.203" UserId="37" Text="# Button-pushing robot.&#xD;&#xA;**A four-wheeled eight-pound remote-control laser-shooting robot that pushes buttons.**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;I made this project over the course of last school year. I was in robotics class, and we decided to have a competition. Each team would make a robot that has a large button and a way to push other buttons. At the end of the year, we would have the final contest, where the three robots would try to push each other's buttons.&#xD;&#xA;&#xD;&#xA;By the end of the year, my robot only partially worked. Every part of the robot had at some point been working, but between a fried Arduino, fried motor drivers, terrible code organization, and me being the only person on my team to work on the robot for a total of more than five hours, I couldn't get it completely working.&#xD;&#xA;&#xD;&#xA;I haven't touched my robot in almost a year, so I know that if I wanted to get it working again I would have to rewire the bot and rewrite the code. I may decide to do that some day, but for now I'm going to work on less ambitious projects.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;### Overall Design&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;### Information/electricity flow&#xD;&#xA;&#xD;&#xA;    +--------------------------+   +-------------------------------------------------+&#xD;&#xA;    |         Computer         |   |      Robot                                      |&#xD;&#xA;    |--------------------------|   |-------------------------------------------------|&#xD;&#xA;    |                          |   |                                                 |&#xD;&#xA;    | Keyboard +--&gt; Processing |   |  Button +-------------+        Motor    Motor   |&#xD;&#xA;    |                          |   |                       |          ^       ^      |&#xD;&#xA;    |                    +     |   |                       |          |       |      |&#xD;&#xA;    |                    |     |   |  Batteries +-----+    |          +       +      |&#xD;&#xA;    |                    v     |   |                  |    |   +----&gt; Motor Driver   |&#xD;&#xA;    |                          |   |                  v    v   +                     |&#xD;&#xA;    |               Bluetooth +----|&gt; Bluetooth +--&gt; Arduino Uno +--&gt; Motor driver   |&#xD;&#xA;    |                          |   |                  +    +  +       +       +      |&#xD;&#xA;    +--------------------------+   |                  |    |  |       |       |      |&#xD;&#xA;                                   |                  |    |  |       v       v      |&#xD;&#xA;                                   |                  |    |  |    Motor     Motor   |&#xD;&#xA;                                   |                  |    |  |                      |&#xD;&#xA;                                   |                  |    |  |                      |&#xD;&#xA;                                   |                  |    |  +-----&gt; Laser          |&#xD;&#xA;                                   |  +---------------|----|----+                    |&#xD;&#xA;                                   |  |       Arm     |    |    |                    |&#xD;&#xA;                                   |  |---------------|----|----|                    |&#xD;&#xA;                                   |  |     +---------+    v    |                    |&#xD;&#xA;                                   |  |     |      Motor Driver |                    |&#xD;&#xA;                                   |  |     v              +    |                    |&#xD;&#xA;                                   |  |  Servo             |    |                    |&#xD;&#xA;                                   |  |                    v    |                    |&#xD;&#xA;                                   |  |                  Motor  |                    |&#xD;&#xA;                                   |  +-------------------------+                    |&#xD;&#xA;                                   +-------------------------------------------------+&#xD;&#xA;&#xD;&#xA;### Components&#xD;&#xA;&#xD;&#xA; - Arduino Uno&#xD;&#xA; - Transportation:&#xD;&#xA;     - [2 motor drivers][2], (one fried)&#xD;&#xA;     - [4 wheel motors][3], (24v, 360mA with no load)&#xD;&#xA;     - 4 wheels, (plastic jar lids)&#xD;&#xA; - [Easy Button][4]&#xD;&#xA; - Arm:&#xD;&#xA;     - [Servo][5], (continuous rotation)&#xD;&#xA;     - [Motor driver][6]&#xD;&#xA;     - Motor, (12v, found in teacher's junk pile)&#xD;&#xA;     - Eraser&#xD;&#xA;     - Counterweight, (homemade paper bag filled with pennies)&#xD;&#xA; - [2 battery packs][7], (12V, 1300mAh, Ni-MH rechargeable)&#xD;&#xA; - 2 solderless breadboards&#xD;&#xA; - Laser, (5mW)&#xD;&#xA; - Bluetooth:&#xD;&#xA;     - [mdfly Bluetooth module][8], (5v, 30ft)&#xD;&#xA;     - [Bluetooth adapter][9], (USB, 300+ ft)&#xD;&#xA; - Lots of wires&#xD;&#xA; - Lots of scrap metal and plexiglass, (found in teacher's machine shop)&#xD;&#xA;&#xD;&#xA;### Code&#xD;&#xA;&#xD;&#xA;I didn't organize my code very well, so I hope this is the right code.&#xD;&#xA;&#xD;&#xA; - Arduino: https://github.com/TheGuywithTheHat/robotics-2013/tree/master/Arduino&#xD;&#xA; - Processing: https://github.com/TheGuywithTheHat/robotics-2013/tree/master/Processing&#xD;&#xA;&#xD;&#xA;### More pictures&#xD;&#xA;&#xD;&#xA;![enter image description here][10]&#xD;&#xA;![enter image description here][11]&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;&#xD;&#xA;I'm really good at frying electronics.&#xD;&#xA;&#xD;&#xA;This was my first experience in an actual machine shop. I got to use a CNC milling machine, manual milling machine, lathe, and bandsaw. If I started a project like this again, I would make much better documentation, so I could figure out what the heck I was doing a year later.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/w7Gs6.png&#xD;&#xA;  [2]: http://www.pololu.com/product/2136/&#xD;&#xA;  [3]: http://www.allelectronics.com/make-a-store/item/dcm-395/3-24vdc-gear-motor-used/1.html&#xD;&#xA;  [4]: http://www.staples.com/Easy-Button/cat_CL163314&#xD;&#xA;  [5]: http://www.parallax.com/product/900-00008&#xD;&#xA;  [6]: http://www.pololu.com/product/2136/&#xD;&#xA;  [7]: http://compare.ebay.com/like/140474546940?var=lv&amp;ltyp=AllFixedPriceItemTypes&amp;var=sbar&#xD;&#xA;  [8]: http://www.mdfly.com/index.php?main_page=product_info&amp;cPath=&amp;products_id=769&amp;zenid=2qgknl98q9kppt6q14hk70rlr3&#xD;&#xA;  [9]: http://www.aziocorp.com/en/connectivity/16-usb-micro-bluetooth-adapter-v21-edr.html&#xD;&#xA;  [10]: http://i.stack.imgur.com/XoTWl.png&#xD;&#xA;  [11]: http://i.stack.imgur.com/pWIw8.jpg" />
  <row Id="2545" PostHistoryTypeId="5" PostId="897" RevisionGUID="78c44548-7140-4310-b4b5-597f3c78302b" CreationDate="2014-03-24T15:32:06.980" UserId="37" Comment="added 158 characters in body" Text="# Button-pushing robot.&#xD;&#xA;**A four-wheeled eight-pound remote-control laser-shooting robot that pushes buttons.**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;I made this project over the course of last school year. I was in robotics class, and we decided to have a competition. Each team would make a robot that has a large button and a way to push other buttons. At the end of the year, we would have the final contest, where the three robots would try to push each other's buttons.&#xD;&#xA;&#xD;&#xA;By the end of the year, my robot only partially worked. Every part of the robot had at some point been working, but between a fried Arduino, fried motor drivers, terrible code organization, and me being the only person on my team to work on the robot for a total of more than five hours, I couldn't get it completely working.&#xD;&#xA;&#xD;&#xA;I haven't touched my robot in almost a year, so I know that if I wanted to get it working again I would have to rewire the bot and rewrite the code. I may decide to do that some day, but for now I'm going to work on less ambitious projects.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;### Overall Design&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;### Information/electricity flow&#xD;&#xA;&#xD;&#xA;    +--------------------------+   +-------------------------------------------------+&#xD;&#xA;    |         Computer         |   |      Robot                                      |&#xD;&#xA;    |--------------------------|   |-------------------------------------------------|&#xD;&#xA;    |                          |   |                                                 |&#xD;&#xA;    | Keyboard +--&gt; Processing |   |  Button +-------------+        Motor    Motor   |&#xD;&#xA;    |                          |   |                       |          ^       ^      |&#xD;&#xA;    |                    +     |   |                       |          |       |      |&#xD;&#xA;    |                    |     |   |  Batteries +-----+    |          +       +      |&#xD;&#xA;    |                    v     |   |                  |    |   +----&gt; Motor Driver   |&#xD;&#xA;    |                          |   |                  v    v   +                     |&#xD;&#xA;    |               Bluetooth +----|&gt; Bluetooth +--&gt; Arduino Uno +--&gt; Motor driver   |&#xD;&#xA;    |                          |   |                  +    +  +       +       +      |&#xD;&#xA;    +--------------------------+   |                  |    |  |       |       |      |&#xD;&#xA;                                   |                  |    |  |       v       v      |&#xD;&#xA;                                   |                  |    |  |    Motor     Motor   |&#xD;&#xA;                                   |                  |    |  |                      |&#xD;&#xA;                                   |                  |    |  |                      |&#xD;&#xA;                                   |                  |    |  +-----&gt; Laser          |&#xD;&#xA;                                   |  +---------------|----|----+                    |&#xD;&#xA;                                   |  |       Arm     |    |    |                    |&#xD;&#xA;                                   |  |---------------|----|----|                    |&#xD;&#xA;                                   |  |     +---------+    v    |                    |&#xD;&#xA;                                   |  |     |      Motor Driver |                    |&#xD;&#xA;                                   |  |     v              +    |                    |&#xD;&#xA;                                   |  |  Servo             |    |                    |&#xD;&#xA;                                   |  |                    v    |                    |&#xD;&#xA;                                   |  |                  Motor  |                    |&#xD;&#xA;                                   |  +-------------------------+                    |&#xD;&#xA;                                   +-------------------------------------------------+&#xD;&#xA;&#xD;&#xA;### Components&#xD;&#xA;&#xD;&#xA; - Arduino Uno&#xD;&#xA; - Transportation:&#xD;&#xA;     - [2 motor drivers][2], (one fried)&#xD;&#xA;     - [4 wheel motors][3], (24v, 360mA with no load)&#xD;&#xA;     - 4 wheels, (plastic jar lids)&#xD;&#xA; - [Easy Button][4]&#xD;&#xA; - Arm:&#xD;&#xA;     - [Servo][5], (continuous rotation)&#xD;&#xA;     - [Motor driver][6]&#xD;&#xA;     - Motor, (12v, found in teacher's junk pile)&#xD;&#xA;     - Eraser&#xD;&#xA;     - Counterweight, (homemade paper bag filled with pennies)&#xD;&#xA; - [2 battery packs][7], (12V, 1300mAh, Ni-MH rechargeable)&#xD;&#xA; - 2 solderless breadboards&#xD;&#xA; - Laser, (5mW)&#xD;&#xA; - Bluetooth:&#xD;&#xA;     - [mdfly Bluetooth module][8], (5v, 30ft)&#xD;&#xA;     - [Bluetooth adapter][9], (USB, 300+ ft)&#xD;&#xA; - Lots of wires&#xD;&#xA; - Lots of scrap metal and plexiglass, (found in teacher's machine shop)&#xD;&#xA;&#xD;&#xA;### Code&#xD;&#xA;&#xD;&#xA;I didn't organize my code very well, so I hope this is the right code.&#xD;&#xA;&#xD;&#xA; - Arduino: https://github.com/TheGuywithTheHat/robotics-2013/tree/master/Arduino&#xD;&#xA; - Processing: https://github.com/TheGuywithTheHat/robotics-2013/tree/master/Processing&#xD;&#xA;&#xD;&#xA;### More pictures&#xD;&#xA;&#xD;&#xA;![enter image description here][10]&#xD;&#xA;![enter image description here][11]&#xD;&#xA;&#xD;&#xA;### Terrible video of a slow, armless, buttonless, laserless, and bluetoothless early version of the robot.&#xD;&#xA;&#xD;&#xA;https://www.youtube.com/watch?v=Q7MvE7-Xb0E&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;&#xD;&#xA;I'm really good at frying electronics.&#xD;&#xA;&#xD;&#xA;This was my first experience in an actual machine shop. I got to use a CNC milling machine, manual milling machine, lathe, and bandsaw. If I started a project like this again, I would make much better documentation, so I could figure out what the heck I was doing a year later.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/w7Gs6.png&#xD;&#xA;  [2]: http://www.pololu.com/product/2136/&#xD;&#xA;  [3]: http://www.allelectronics.com/make-a-store/item/dcm-395/3-24vdc-gear-motor-used/1.html&#xD;&#xA;  [4]: http://www.staples.com/Easy-Button/cat_CL163314&#xD;&#xA;  [5]: http://www.parallax.com/product/900-00008&#xD;&#xA;  [6]: http://www.pololu.com/product/2136/&#xD;&#xA;  [7]: http://compare.ebay.com/like/140474546940?var=lv&amp;ltyp=AllFixedPriceItemTypes&amp;var=sbar&#xD;&#xA;  [8]: http://www.mdfly.com/index.php?main_page=product_info&amp;cPath=&amp;products_id=769&amp;zenid=2qgknl98q9kppt6q14hk70rlr3&#xD;&#xA;  [9]: http://www.aziocorp.com/en/connectivity/16-usb-micro-bluetooth-adapter-v21-edr.html&#xD;&#xA;  [10]: http://i.stack.imgur.com/XoTWl.png&#xD;&#xA;  [11]: http://i.stack.imgur.com/pWIw8.jpg" />
  <row Id="2546" PostHistoryTypeId="2" PostId="898" RevisionGUID="2a646a07-2ba2-4681-82e1-a09d0df6aa04" CreationDate="2014-03-24T16:01:56.993" UserId="37" Text="An Uno most definitely cannot directly control that motor. According to the specs [here][1],&#xD;&#xA;&#xD;&#xA;&gt; They operate at 5 volts. Each pin can provide or receive a maximum of 40 mA&#xD;&#xA;&#xD;&#xA;So your motor has needs about ten times the voltage and _200_ times the amps that the Uno can supply. Of course, you can always get a driver of some sort for the servo.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardUno" />
  <row Id="2547" PostHistoryTypeId="4" PostId="885" RevisionGUID="d23bfbc0-9542-40b2-9c15-b5863df1a3b3" CreationDate="2014-03-24T16:42:25.623" UserId="278" Comment="clarifying from comment" Text="Is there a way to make wiring a bare microprocessor to a shield easier?" />
  <row Id="2548" PostHistoryTypeId="24" PostId="885" RevisionGUID="d23bfbc0-9542-40b2-9c15-b5863df1a3b3" CreationDate="2014-03-24T16:42:25.623" Comment="Proposed by 278 approved by 8, 65 edit id of 255" />
  <row Id="2550" PostHistoryTypeId="5" PostId="886" RevisionGUID="df90960d-c662-4054-85f5-59e2bd7f45c1" CreationDate="2014-03-24T17:50:57.260" UserId="37" Comment="improved formatting; cleaned code" Text="I am sending three signals from one arduino mega to another using xbees. On the receiving end I am using these signals in a Simulink code to control servo motors. Currently it is set up to read from analog pins without the wireless set up. With the wireless technology the signals are all being sent and received through one serial port. I believe I would need to change the inputs in Simulink to a serial receive block instead of an analog pin block. The problem is the documentation for the serial receive block says you can not assign more than one serial receive block to the same serial port. If anyone has a solution to this it would be greatly appreciated!&#xD;&#xA;&#xD;&#xA;receiving code&#xD;&#xA;&#xD;&#xA;    int received1; &#xD;&#xA;    int received2;  &#xD;&#xA;    int received3;  &#xD;&#xA;    void setup() {  &#xD;&#xA;      Serial.begin(9600);  &#xD;&#xA;    }  &#xD;&#xA;    void loop() {  &#xD;&#xA;      if(Serial.available() )  &#xD;&#xA;      {  &#xD;&#xA;        received1, received2, received3 = Serial.read();  &#xD;&#xA;      }  &#xD;&#xA;    }   &#xD;&#xA;&#xD;&#xA;transmitting code:&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      int sensorValue1 = analogRead(A0);&#xD;&#xA;      int sensorValue2 = analogRead(A1);&#xD;&#xA;      int sensorValue3 = analogRead(A2);&#xD;&#xA;      Serial.write(sensorValue1, sensorValue2, sensorValue3);&#xD;&#xA;      delay(1);       &#xD;&#xA;    }" />
  <row Id="2551" PostHistoryTypeId="24" PostId="886" RevisionGUID="df90960d-c662-4054-85f5-59e2bd7f45c1" CreationDate="2014-03-24T17:50:57.260" Comment="Proposed by 37 approved by 11 edit id of 256" />
  <row Id="2552" PostHistoryTypeId="2" PostId="899" RevisionGUID="2f5cc799-01a7-4c67-9a1d-093c4a3d690e" CreationDate="2014-03-24T20:25:52.473" UserId="790" Text="Does the Arduino Yun does it have a RTC?&#xD;&#xA;&#xD;&#xA;And if so is it connected to the Atheros AR9331 or the ATmega32u4?&#xD;&#xA;&#xD;&#xA;If there there is no RTC, can I connect a DS1307 to the Atheros AR9331?" />
  <row Id="2553" PostHistoryTypeId="1" PostId="899" RevisionGUID="2f5cc799-01a7-4c67-9a1d-093c4a3d690e" CreationDate="2014-03-24T20:25:52.473" UserId="790" Text="Arduino Yun does it have a RTC?" />
  <row Id="2554" PostHistoryTypeId="3" PostId="899" RevisionGUID="2f5cc799-01a7-4c67-9a1d-093c4a3d690e" CreationDate="2014-03-24T20:25:52.473" UserId="790" Text="&lt;time&gt;&lt;arduino-yun&gt;" />
  <row Id="2555" PostHistoryTypeId="2" PostId="900" RevisionGUID="9d0e9c05-8680-4cce-8579-c3ce6c441069" CreationDate="2014-03-24T20:31:15.207" UserId="790" Text="Can I compile c/c++ code on the linux part of the Arduino Yun?&#xD;&#xA;&#xD;&#xA;How complete is the linux part of the Arduino Yun?&#xD;&#xA;Can I scp some c/c++ code onto the Atheros AR9331 chip compile it?&#xD;&#xA;&#xD;&#xA;Or must I first crosscompile all software and then put them onto the Atheros?" />
  <row Id="2556" PostHistoryTypeId="1" PostId="900" RevisionGUID="9d0e9c05-8680-4cce-8579-c3ce6c441069" CreationDate="2014-03-24T20:31:15.207" UserId="790" Text="Can I compile c/c++ code on the linux part of the Arduino Yun?" />
  <row Id="2557" PostHistoryTypeId="3" PostId="900" RevisionGUID="9d0e9c05-8680-4cce-8579-c3ce6c441069" CreationDate="2014-03-24T20:31:15.207" UserId="790" Text="&lt;arduino-yun&gt;&lt;linux&gt;&lt;compile&gt;" />
  <row Id="2558" PostHistoryTypeId="2" PostId="901" RevisionGUID="571c9513-af2b-428d-8a97-8ef8ab06399b" CreationDate="2014-03-24T20:34:22.283" UserId="136" Text="The optical encoder you link to has 500 pulses per revolution. This means at 3000rpm , you will be generating pulses 25,000 times a second. You will also need to deal with overshoot (as there is nothing worse than a motor going overspeed and the feedback loop being unable to detect it).&#xD;&#xA;&#xD;&#xA;Dealing with an optical encoder generating pulses this quickly is actually quite a challenge, especially with Arduino (which has rather slow native I/O using digitalRead and digitalWrite), and the ATmega328 (which doesn't have any dedicated hardware to deal with high speed optical encoders).&#xD;&#xA;&#xD;&#xA;Driving a 56VDC, 7.8A motor isn't an easy challenge either - a motor driver for this isn't going to be easy to design.&#xD;&#xA;&#xD;&#xA;I'd probably look for a dedicated servo or CNC motor controller to deal with something like this." />
  <row Id="2559" PostHistoryTypeId="2" PostId="902" RevisionGUID="ea2e63e3-8783-4237-92d1-deaf6f7e50e2" CreationDate="2014-03-24T20:45:52.467" UserId="790" Text="You could try a Arduino Yun, it is like a Uno but it has a WiFi directly on the board." />
  <row Id="2561" PostHistoryTypeId="2" PostId="903" RevisionGUID="59e4fb2e-5b06-4bbf-a5af-f0a33f51054d" CreationDate="2014-03-24T20:57:47.627" UserId="790" Text="There is a half way solution as well since the Arduino IDE has support for external a editor, then the Arduio IDE just compiles and uploads.&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;Now you can use whatever IDE/editor you like to edit the code, &#xD;&#xA;and then you switch back to the Arduino IDE to press the compile and upload button when you are done.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/Tu78x.png" />
  <row Id="2562" PostHistoryTypeId="2" PostId="904" RevisionGUID="d05e9b8d-c9b6-4557-ad16-440812ddb282" CreationDate="2014-03-24T22:03:38.863" UserId="220" Text="&gt; the Yún doesn’t have a real time clock IC on board, so it can’t keep time when is powered off. Instead, it synchronizes with time servers automatically when it powers up and connects to a network using NTP.&#xD;&#xA;&#xD;&#xA;*([Arduino Blog](http://blog.arduino.cc/2013/09/02/arduino-yun-hardware-review/))*&#xD;&#xA;&#xD;&#xA;Therefore, the **Yun does *not* have a onboard RTC.**&#xD;&#xA;&#xD;&#xA;&gt; If there there is no RTC, can I connect a DS1307 to the Atheros AR9331?&#xD;&#xA;&#xD;&#xA;Probably not. It comes in a [LPCC package](https://www.google.com/search?q=LPCC+package&amp;espv=210&amp;es_sm=122&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ei=n6kwU5ncHaSHygGduoGYDQ&amp;ved=0CAoQ_AUoAg&amp;biw=1280&amp;bih=899), which has the solder joints on the bottom. This needs to be soldered by reflow. The Yun does not have any pins connected directly to that chip. You're probably thinking of the ATmega32u4, the actual Arduino chip. The other one is for a router.&#xD;&#xA;&#xD;&#xA;**To get the time, you have two options:**&#xD;&#xA;&#xD;&#xA; - **[Use the time from the time server](http://arduino.cc/en/Tutorial/TimeCheck)**&#xD;&#xA;&#xD;&#xA;    A few notes:&#xD;&#xA;    &gt; The Yún must be connected to a network to get the correct time. If you used the web-based WiFi interface to configure the Yún for the network, make sure you've selected the proper time zone.&#xD;&#xA; - **Connect it to a DS1307** (I find [this Adafruit tutorial helpful](http://learn.adafruit.com/ds1307-real-time-clock-breakout-board-kit)) You'll need only two pins to use this board. One note: there is a way to connect up to 121 I2C devices using these two pins. However, that gets a little more complicated." />
  <row Id="2563" PostHistoryTypeId="2" PostId="905" RevisionGUID="c6a630d9-7f4f-4318-a985-5eac5df0811e" CreationDate="2014-03-24T22:05:10.790" UserId="703" Text="The Yun's OS (Linino) is based on OpenWRT, and the official toolchain from OpenWRT does not appear to have changed much. It could probably be done, the question is if you'd really want to though.&#xA; &#xA;The limited resources (storage, RAM, CPU) means you would most likely not fit all the parts of the toolchain for C/C++ compilation (perhaps with the exception of very basic programs without many dependencies). The YUN's package manager (opkg) should contain pre-built packackes if they exist, but given that even the list of packages is only kept in RAM to conserve space, I doubt the entire toolchain with libraries needed to compile useful stuff would fit.&#xA;&#xA;The official way to build things for OpenWRT appears to be cross-compilation on a much beefier machine, if only because it takes a fraction of the time needed by a native compiler. All in all, you're also very likely to save time and resources by cross-compiling and have more resources left on the YUN itself." />
  <row Id="2564" PostHistoryTypeId="2" PostId="906" RevisionGUID="e3dd810a-4b59-4951-af5b-8e7b53c8bc58" CreationDate="2014-03-24T22:14:27.140" UserId="690" Text="I have made a simple program using the `int main() {}` function. It has a delay in it. It is evident the code before the delay is running, but the delay never seems to time out and let the next instructions through. Is this by design?&#xD;&#xA;&#xD;&#xA;If I rename the method and call it exactly once from the `loop() {}` function though, it does work." />
  <row Id="2565" PostHistoryTypeId="1" PostId="906" RevisionGUID="e3dd810a-4b59-4951-af5b-8e7b53c8bc58" CreationDate="2014-03-24T22:14:27.140" UserId="690" Text="Should a delay be expected to cause deadlock?" />
  <row Id="2566" PostHistoryTypeId="3" PostId="906" RevisionGUID="e3dd810a-4b59-4951-af5b-8e7b53c8bc58" CreationDate="2014-03-24T22:14:27.140" UserId="690" Text="&lt;arduino-mega&gt;&lt;timers&gt;" />
  <row Id="2567" PostHistoryTypeId="2" PostId="907" RevisionGUID="5a0034d1-2307-4a02-ab71-07426a2260ca" CreationDate="2014-03-24T22:46:53.803" UserId="639" Text="On Mac OSX Mavericks, why does Arduino Uno uses serial port named `/dev/cu.usbmodemfa131` while Arduino Nano uses `/dev/cu.usbserial-A702NY8S`?&#xD;&#xA;&#xD;&#xA;Are they using different FTDI drivers?" />
  <row Id="2568" PostHistoryTypeId="1" PostId="907" RevisionGUID="5a0034d1-2307-4a02-ab71-07426a2260ca" CreationDate="2014-03-24T22:46:53.803" UserId="639" Text="Serial port /dev/cu.usbmodemfa131 vs /dev/cu.usbserial-A702NY8S" />
  <row Id="2569" PostHistoryTypeId="3" PostId="907" RevisionGUID="5a0034d1-2307-4a02-ab71-07426a2260ca" CreationDate="2014-03-24T22:46:53.803" UserId="639" Text="&lt;arduino-uno&gt;&lt;serial&gt;&lt;arduino-nano&gt;" />
  <row Id="2570" PostHistoryTypeId="12" PostId="907" RevisionGUID="86f33975-c355-4938-b01d-5589517314bb" CreationDate="2014-03-24T22:52:27.610" UserId="639" Comment="via Vote" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:639,&quot;DisplayName&quot;:&quot;Nyxynyx&quot;}]}" />
  <row Id="2571" PostHistoryTypeId="13" PostId="907" RevisionGUID="e7f32e38-b8e1-4d6c-96dc-fd5336b3ffd3" CreationDate="2014-03-24T22:52:33.703" UserId="639" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:639,&quot;DisplayName&quot;:&quot;Nyxynyx&quot;}]}" />
  <row Id="2572" PostHistoryTypeId="5" PostId="887" RevisionGUID="453cb02d-ff8e-45f9-98a8-f41066832b08" CreationDate="2014-03-24T23:17:09.403" UserId="8" Comment="another small typo (AUTOCORRECT!!!!)" Text="# &lt;small&gt;(fake)&lt;/small&gt; Linux on Arduino&#xD;&#xA;&#xD;&#xA;**I recently acquired a small composite LCD screen, which I quickly began playing with using the Arduino TVout library. What came next? Linux!**&#xD;&#xA;&#xD;&#xA;Description&#xD;&#xA;----&#xD;&#xA;&#xD;&#xA;While playing around with my TV screen and the TVout library, I discovered there is a premade terminal handler for the TV. I soon began to experiment with using it as a TV terminal hooked up to a PS/2 keyboard. There were some problems with the PS/2 library I used, so I transitioned it to use the USB library on my Mega ADK along with a USB keyboard. That worked much better. Now for storage.&#xD;&#xA;&#xD;&#xA;My SD card shield isn't compatible with my Mega, so I wired it up somewhat haphazardly to the SPI at the end of the board. I wrote command handling to preform a few tasks like listing files and finding disk size, free space, etc.. The entire assembly isn't by any means finished, but I am happy with the progress I have made.&#xD;&#xA;&#xD;&#xA;The code will be relocated to Github eventually, watch the comments.&#xD;&#xA;&#xD;&#xA;Design&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![zoomed out pic][1]&#xD;&#xA;&#xD;&#xA;![clse up screen][2]&#xD;&#xA;&#xD;&#xA;Challenges&#xD;&#xA;--&#xD;&#xA;&#xD;&#xA;I had a lot of trouble concatenating the inputted charactars to the string storing the current command because I wasn't casting right. Once I got that figured out, I also needed to fix the problem where some keys printed random garbage to the screen. This was caused by reading memory before the letter definitions, so a few `if`s cleared that up.&#xD;&#xA;&#xD;&#xA;Conclusion&#xD;&#xA;--&#xD;&#xA;&#xD;&#xA;I am very satisfied with the code. Once I add a few more utilities to it, I will put it on Github, so watch the comments. Overall, it was a very fun project. I learned how to use Stino in the process.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/cgzPU.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/L9PmB.jpg" />
  <row Id="2573" PostHistoryTypeId="2" PostId="908" RevisionGUID="baf48209-dad3-487b-a9e2-e1caaa0350f4" CreationDate="2014-03-24T23:55:46.713" UserId="382" Text="Drivers are different. On older boards, such as Duemilanove you may need to actually [download serial drivers][1] to [talk to them][2] at all in Lion, Mountain Lion, Mavericks.&#xD;&#xA;There's some discussion of that problem [here][3].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.ftdichip.com/Drivers/VCP.htm&#xD;&#xA;  [2]: https://pixhawk.ethz.ch/tutorials/serial_terminal&#xD;&#xA;  [3]: http://forum.arduino.cc/index.php?topic=114652.0" />
  <row Id="2574" PostHistoryTypeId="5" PostId="625" RevisionGUID="defbde4c-a34b-4995-a3f4-11be26e72e82" CreationDate="2014-03-25T04:12:28.770" UserId="510" Comment="Copy edited. Removed historical information. Used the official name of Stack Overflow - see section &quot;Proper Use of the Stack Exchange Name&quot; in http://stackoverflow.com/legal/trademark-guidance (the last section)." Text="Well, this question has been wisely answered in [an answer to Stack&amp;nbsp;Overflow question *C: differences between char pointer and array*][1].&#xD;&#xA;&#xD;&#xA;Basically, what you're declaring as PROGMEM with,&#xD;&#xA;&#xD;&#xA;    const prog_char testStringD[] PROGMEM = &quot;JKL&quot;;&#xD;&#xA;&#xD;&#xA;is both the array and the memory it points to, that is, the elements of the array, both in current's scope stack. Whereas with:&#xD;&#xA;&#xD;&#xA;    const prog_char* testStringC PROGMEM = &quot;GHI&quot;;&#xD;&#xA;&#xD;&#xA;you declare a PROGMEM pointer to a constant string that may stay elsewhere in memory, but not declared as a PROGMEM string.&#xD;&#xA;&#xD;&#xA;Though I did *not* test that, but you should try to declare:&#xD;&#xA;&#xD;&#xA;    const prog_char* testStringC PROGMEM = F(&quot;GHI&quot;);&#xD;&#xA;&#xD;&#xA;to actually allocate the pointed string within the PROGMEM space. I *guess* it should be working, using Arduino's [`F()` macro][2], which adds a lot of boilerplate code to actually have the same result as the array declaration.&#xD;&#xA;&#xD;&#xA;As said in comments, if not in a global context, the `PSTR()` macro could be used instead of the `F()` macro.&#xD;&#xA;&#xD;&#xA;Simpler is better: use the array declaration, not the pointer one!&#xD;&#xA;&#xD;&#xA;Cf [that other answer](http://arduino.stackexchange.com/a/614/379), the `__flash` qualifier is a third solution ;-)&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/a/1335836/1290438&#xD;&#xA;  [2]: http://andybrown.me.uk/wk/wp-content/images//avr-gcc-4.7.0/WString.h&#xD;&#xA;" />
  <row Id="2575" PostHistoryTypeId="24" PostId="625" RevisionGUID="defbde4c-a34b-4995-a3f4-11be26e72e82" CreationDate="2014-03-25T04:12:28.770" Comment="Proposed by 510 approved by 11 edit id of 257" />
  <row Id="2576" PostHistoryTypeId="2" PostId="909" RevisionGUID="b5b53fed-61ef-4c9a-a98a-69bc4f5e932e" CreationDate="2014-03-25T05:49:46.733" UserId="84" Text="You don't seem to use standard Arduino stuff since you defined your own `main()` which is normally avoided when programming Arduino.&#xD;&#xA;&#xD;&#xA;If you take a look at Arduino provided `main()` (in **hardware/cores/arduino/main.cpp**), you'll see how it is defined:&#xD;&#xA;&#xD;&#xA;    #include &lt;Arduino.h&gt;&#xD;&#xA;&#xD;&#xA;    int main(void)&#xD;&#xA;    {&#xD;&#xA;    	init();&#xD;&#xA;    &#xD;&#xA;    #if defined(USBCON)&#xD;&#xA;    	USBDevice.attach();&#xD;&#xA;    #endif&#xD;&#xA;    	&#xD;&#xA;    	setup();&#xD;&#xA;        &#xD;&#xA;    	for (;;) {&#xD;&#xA;    		loop();&#xD;&#xA;    		if (serialEventRun) serialEventRun();&#xD;&#xA;    	}&#xD;&#xA;            &#xD;&#xA;    	return 0;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Did you notice the `init()` function call at the beginning?&#xD;&#xA;&#xD;&#xA;Its code is defined in **hardware/cores/arduino/wiring.c**; what it does is setup all timers used by Arduino functions, in particular a timer that is needed by `delay()`.&#xD;&#xA;&#xD;&#xA;In the same **wiring.c** file, you can also find the definition of `delay()`:&#xD;&#xA;&#xD;&#xA;    void delay(unsigned long ms)&#xD;&#xA;    {&#xD;&#xA;    	uint16_t start = (uint16_t)micros();&#xD;&#xA;    &#xD;&#xA;    	while (ms &gt; 0) {&#xD;&#xA;    		if (((uint16_t)micros() - start) &gt;= 1000) {&#xD;&#xA;    			ms--;&#xD;&#xA;    			start += 1000;&#xD;&#xA;    		}&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This will turn into an infinite loop if `micros()` always return the same value, and it does so if `init()` has never been called before.&#xD;&#xA;&#xD;&#xA;This is what happens with your code." />
  <row Id="2578" PostHistoryTypeId="2" PostId="910" RevisionGUID="010261cf-b724-4a61-ad42-926fa93d59fd" CreationDate="2014-03-25T09:26:50.040" UserId="794" Text="I'm using the `Serial1` of the Arduino Leonardo to send and receive data with another MCU. The following code will always retrieve garbled data:&#xD;&#xA;````&#xD;&#xA;    byte streamReadResponse;&#xD;&#xA;    Serial1.begin(115200);&#xD;&#xA;    Serial1.setTimeout(9000);&#xD;&#xA;    Serial1.print(cmd);&#xD;&#xA;    Serial1.print('\r');&#xD;&#xA;    Serial1.flush();  //wait for all the data to be sent to the serial&#xD;&#xA;    streamReadResponse = Serial1.readBytesUntil('&gt;', data, dataLength);&#xD;&#xA;````&#xD;&#xA;&#xD;&#xA;But, if I add a `delay(50)` before the Serial1 read, I would get the expected output. The value 50 was found by trial and error.&#xD;&#xA;&#xD;&#xA;What am I missing? Why is the `flush()` command not working as expected?" />
  <row Id="2579" PostHistoryTypeId="1" PostId="910" RevisionGUID="010261cf-b724-4a61-ad42-926fa93d59fd" CreationDate="2014-03-25T09:26:50.040" UserId="794" Text="Serial.read has garbled data after a Serial.write" />
  <row Id="2580" PostHistoryTypeId="3" PostId="910" RevisionGUID="010261cf-b724-4a61-ad42-926fa93d59fd" CreationDate="2014-03-25T09:26:50.040" UserId="794" Text="&lt;serial&gt;&lt;arduino-leonardo&gt;" />
  <row Id="2581" PostHistoryTypeId="5" PostId="906" RevisionGUID="d405ac37-19a0-4e8a-a4cb-cca3f4cea76f" CreationDate="2014-03-25T09:56:17.003" UserId="690" Comment="Added code snippet" Text="I have made a simple program using the `int main() {}` function. It has a delay in it. It is evident the code before the delay is running, but the delay never seems to time out and let the next instructions through. Is this by design?&#xD;&#xA;&#xD;&#xA;If I rename the method and call it exactly once from the `loop() {}` function though, it does work.&#xD;&#xA;&#xD;&#xA;**Edit:**&#xD;&#xA;&#xD;&#xA;The code borrowed the 'main()' function and I suppose redefined it:&#xD;&#xA;&#xD;&#xA;    int main() { &#xD;&#xA;        Forward();&#xD;&#xA;        delay(3000);&#xD;&#xA;        Reverse();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void Forward() {&#xD;&#xA;        //...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void Reverse() {&#xD;&#xA;        //... &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I can see this redefinition of `main()` could cause some serious issues based on the answer below." />
  <row Id="2583" PostHistoryTypeId="2" PostId="911" RevisionGUID="a2f108ff-7a4a-4b75-aeb9-ba7fff6169c7" CreationDate="2014-03-25T12:24:10.450" UserId="656" Text="I'm trying to build an Arduino example without using its IDE. My OS is **Windows 8.1** and I'm using the last version of **CMake (2.8.12.2)** and **MinGW (GNU Make 3.82.90)**. &#xD;&#xA;&#xD;&#xA;I downloaded [the Arduino CMakeLists](https://github.com/queezythegreat/arduino-cmake) and I learned all about ``make/upload`` any firmware in my Arduino. I'm using **Arduino UNO**.&#xD;&#xA;&#xD;&#xA;Then, if I modify the CMakeLists saved in ``~/arduino-cmake-master/example/CMakeLists.txt`` (***arduino-cmake-master*** is the repository folder) to build the WiFi example ***WiFiWebClient*** too:&#xD;&#xA;&#xD;&#xA;    ...&#xD;&#xA;    &#xD;&#xA;    #Add the WiFi example -&gt; WiFiWebClient&#xD;&#xA;    generate_arduino_example(wifi_example&#xD;&#xA;                         LIBRARY WiFi&#xD;&#xA;                         EXAMPLE WiFiWebClient)&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;And execute:&#xD;&#xA;&#xD;&#xA;      $ cmake -G &quot;MinGW Makefiles&quot;&#xD;&#xA;        &#xD;&#xA;      ...&#xD;&#xA;&#xD;&#xA;      CMake Warning (dev) in example/CMakeLists.txt:&#xD;&#xA;      Policy CMP0022 is not set: INTERFACE_LINK_LIBRARIES defines the link&#xD;&#xA;      interface.  Run &quot;cmake --help-policy CMP0022&quot; for policy details.  Use the&#xD;&#xA;      cmake_policy command to set the policy and suppress this warning.&#xD;&#xA;    &#xD;&#xA;      Target &quot;uno_example&quot; has an INTERFACE_LINK_LIBRARIES property.  This should&#xD;&#xA;      be preferred as the source of the link interface for this library but&#xD;&#xA;      because CMP0022 is not set CMake is ignoring the property and using the&#xD;&#xA;      link implementation as the link interface instead.&#xD;&#xA;    &#xD;&#xA;      INTERFACE_LINK_LIBRARIES:&#xD;&#xA;    &#xD;&#xA;        uno_CORE;uno_example;uno_Wire&#xD;&#xA;    &#xD;&#xA;      Link implementation:&#xD;&#xA;    &#xD;&#xA;        uno_CORE;uno_Wire&#xD;&#xA;    &#xD;&#xA;    This warning is for project developers.  Use -Wno-dev to suppress it.&#xD;&#xA;    &#xD;&#xA;    CMake Warning (dev) in example/CMakeLists.txt:&#xD;&#xA;      Policy CMP0022 is not set: INTERFACE_LINK_LIBRARIES defines the link&#xD;&#xA;      interface.  Run &quot;cmake --help-policy CMP0022&quot; for policy details.  Use the&#xD;&#xA;      cmake_policy command to set the policy and suppress this warning.&#xD;&#xA;    &#xD;&#xA;      Target &quot;uno_Wire&quot; has an INTERFACE_LINK_LIBRARIES property.  This should be&#xD;&#xA;      preferred as the source of the link interface for this library but because&#xD;&#xA;      CMP0022 is not set CMake is ignoring the property and using the link&#xD;&#xA;      implementation as the link interface instead.&#xD;&#xA;    &#xD;&#xA;      INTERFACE_LINK_LIBRARIES:&#xD;&#xA;    &#xD;&#xA;        uno_CORE;uno_Wire&#xD;&#xA;    &#xD;&#xA;      Link implementation:&#xD;&#xA;    &#xD;&#xA;        uno_CORE&#xD;&#xA;    &#xD;&#xA;    This warning is for project developers.  Use -Wno-dev to suppress it.&#xD;&#xA;    &#xD;&#xA;    CMake Warning (dev) in example/CMakeLists.txt:&#xD;&#xA;      Policy CMP0022 is not set: INTERFACE_LINK_LIBRARIES defines the link&#xD;&#xA;      interface.  Run &quot;cmake --help-policy CMP0022&quot; for policy details.  Use the&#xD;&#xA;      cmake_policy command to set the policy and suppress this warning.&#xD;&#xA;    &#xD;&#xA;      Target &quot;uno_SPI&quot; has an INTERFACE_LINK_LIBRARIES property.  This should be&#xD;&#xA;      preferred as the source of the link interface for this library but because&#xD;&#xA;      CMP0022 is not set CMake is ignoring the property and using the link&#xD;&#xA;      implementation as the link interface instead.&#xD;&#xA;    &#xD;&#xA;      INTERFACE_LINK_LIBRARIES:&#xD;&#xA;    &#xD;&#xA;        uno_CORE;uno_SPI&#xD;&#xA;    &#xD;&#xA;      Link implementation:&#xD;&#xA;    &#xD;&#xA;        uno_CORE&#xD;&#xA;    &#xD;&#xA;    This warning is for project developers.  Use -Wno-dev to suppress it.&#xD;&#xA;    &#xD;&#xA;    CMake Warning (dev) in example/CMakeLists.txt:&#xD;&#xA;      Policy CMP0022 is not set: INTERFACE_LINK_LIBRARIES defines the link&#xD;&#xA;      interface.  Run &quot;cmake --help-policy CMP0022&quot; for policy details.  Use the&#xD;&#xA;      cmake_policy command to set the policy and suppress this warning.&#xD;&#xA;    &#xD;&#xA;      Target &quot;uno_WiFi&quot; has an INTERFACE_LINK_LIBRARIES property.  This should be&#xD;&#xA;      preferred as the source of the link interface for this library but because&#xD;&#xA;      CMP0022 is not set CMake is ignoring the property and using the link&#xD;&#xA;      implementation as the link interface instead.&#xD;&#xA;    &#xD;&#xA;      INTERFACE_LINK_LIBRARIES:&#xD;&#xA;    &#xD;&#xA;        uno_CORE;uno_WiFi&#xD;&#xA;    &#xD;&#xA;      Link implementation:&#xD;&#xA;    &#xD;&#xA;        uno_CORE&#xD;&#xA;    &#xD;&#xA;    This warning is for project developers.  Use -Wno-dev to suppress it.&#xD;&#xA;&#xD;&#xA;    -- Generating done&#xD;&#xA;    -- Build files have been written to: ~/arduino-cmake-master&#xD;&#xA;&#xD;&#xA;Later I execute:&#xD;&#xA;&#xD;&#xA;    $ mingw32-make&#xD;&#xA;    &#xD;&#xA;    ...&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Linking CXX static library libuno_WiFi.a&#xD;&#xA;    [ 89%] Built target uno_WiFi&#xD;&#xA;    Scanning dependencies of target wifi_example&#xD;&#xA;    [ 92%] Building CXX object example/CMakeFiles/wifi_example.dir/wifi_example_WiFiWebClient.cpp.obj&#xD;&#xA;    Linking CXX executable wifi_example.elf&#xD;&#xA;    libuno_WiFi.a(WiFiClient.cpp.obj): In function `WiFiClient::status()':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFiClient.cpp:160: undefined reference to `ServerDrv::getClientState(unsigned char)'&#xD;&#xA;    libuno_WiFi.a(WiFiClient.cpp.obj): In function `WiFiClient::stop()':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFiClient.cpp:131: undefined reference to `ServerDrv::stopClient(unsigned char)'&#xD;&#xA;    libuno_WiFi.a(WiFiClient.cpp.obj): In function `WiFiClient::peek()':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFiClient.cpp:117: undefined reference to `ServerDrv::getData(unsigned char, unsigned char*, unsigned char)'&#xD;&#xA;    libuno_WiFi.a(WiFiClient.cpp.obj): In function `WiFiClient::read()':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFiClient.cpp:101: undefined reference to `ServerDrv::getData(unsigned char, unsigned char*, unsigned char)'&#xD;&#xA;    libuno_WiFi.a(WiFiClient.cpp.obj): In function `WiFiClient::read(unsigned char*, unsigned int)':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFiClient.cpp:107: undefined reference to `ServerDrv::getDataBuf(unsigned char, unsigned char*, unsigned int*)'&#xD;&#xA;    libuno_WiFi.a(WiFiClient.cpp.obj): In function `WiFiClient::available()':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFiClient.cpp:90: undefined reference to `ServerDrv::availData(unsigned char)'&#xD;&#xA;    libuno_WiFi.a(WiFiClient.cpp.obj): In function `WiFiClient::write(unsigned char const*, unsigned int)':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFiClient.cpp:73: undefined reference to `ServerDrv::sendData(unsigned char, unsigned char const*, unsigned int)'&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFiClient.cpp:78: undefined reference to `ServerDrv::checkDataSent(unsigned char)'&#xD;&#xA;    libuno_WiFi.a(WiFiClient.cpp.obj): In function `WiFiClient::connect(IPAddress, unsigned int)':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFiClient.cpp:36: undefined reference to `ServerDrv::startClient(unsigned long, unsigned int, unsigned char, unsigned char)'&#xD;&#xA;    libuno_WiFi.a(WiFi.cpp.obj): In function `WiFiClass::hostByName(char const*, IPAddress&amp;)':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFi.cpp:228: undefined reference to `WiFiDrv::getHostByName(char const*, IPAddress&amp;)'&#xD;&#xA;    libuno_WiFi.a(WiFi.cpp.obj): In function `WiFiClass::status()':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFi.cpp:223: undefined reference to `WiFiDrv::getConnectionStatus()'&#xD;&#xA;    libuno_WiFi.a(WiFi.cpp.obj): In function `WiFiClass::RSSI()':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFi.cpp:181: undefined reference to `WiFiDrv::getCurrentRSSI()'&#xD;&#xA;    libuno_WiFi.a(WiFi.cpp.obj): In function `WiFiClass::SSID()':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFi.cpp:169: undefined reference to `WiFiDrv::getCurrentSSID()'&#xD;&#xA;    libuno_WiFi.a(WiFi.cpp.obj): In function `WiFiClass::localIP()':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFi.cpp:149: undefined reference to `WiFiDrv::getIpAddress(IPAddress&amp;)'&#xD;&#xA;    libuno_WiFi.a(WiFi.cpp.obj): In function `WiFiClass::begin(char*, char const*)':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFi.cpp:87: undefined reference to `WiFiDrv::wifiSetPassphrase(char*, unsigned char, char const*, unsigned char)'&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFi.cpp:92: undefined reference to `WiFiDrv::getConnectionStatus()'&#xD;&#xA;    libuno_WiFi.a(WiFi.cpp.obj): In function `WiFiClass::init()':&#xD;&#xA;    C:\Program Files\Arduino\libraries\WiFi/WiFi.cpp:22: undefined reference to `WiFiDrv::wifiDriverInit()'&#xD;&#xA;    example\CMakeFiles\wifi_example.dir\build.make:95: recipe for target 'example/wifi_example.elf' failed&#xD;&#xA;    mingw32-make[2]: *** [example/wifi_example.elf] Error 1&#xD;&#xA;    CMakeFiles\Makefile2:748: recipe for target 'example/CMakeFiles/wifi_example.dir/all' failed&#xD;&#xA;    mingw32-make[1]: *** [example/CMakeFiles/wifi_example.dir/all] Error 2&#xD;&#xA;    Makefile:74: recipe for target 'all' failed&#xD;&#xA;    mingw32-make: *** [all] Error 2&#xD;&#xA;&#xD;&#xA;The problem is the Arduino.cmake because it's not linking correctly with the library WiFi, but it links with the Wire library.&#xD;&#xA;&#xD;&#xA;Anyone knows why that warning appears and why Wire links ok but WiFi doesn't?&#xD;&#xA;&#xD;&#xA;Thanks!&#xD;&#xA;&#xD;&#xA;**Note**: I'm using original code which is in the repository example, I've not modified this one." />
  <row Id="2584" PostHistoryTypeId="1" PostId="911" RevisionGUID="a2f108ff-7a4a-4b75-aeb9-ba7fff6169c7" CreationDate="2014-03-25T12:24:10.450" UserId="656" Text="Warning Arduino CMakeLists &quot;Policy CMP0022 is not set: INTERFACE_LINK_LIBRARIES&quot;" />
  <row Id="2585" PostHistoryTypeId="3" PostId="911" RevisionGUID="a2f108ff-7a4a-4b75-aeb9-ba7fff6169c7" CreationDate="2014-03-25T12:24:10.450" UserId="656" Text="&lt;arduino-uno&gt;" />
  <row Id="2586" PostHistoryTypeId="6" PostId="911" RevisionGUID="4ce2e180-61fc-4e31-a32a-ec4d01a4f588" CreationDate="2014-03-25T13:41:28.383" UserId="754" Comment="Add compile tag" Text="&lt;arduino-uno&gt;&lt;compile&gt;" />
  <row Id="2587" PostHistoryTypeId="24" PostId="911" RevisionGUID="4ce2e180-61fc-4e31-a32a-ec4d01a4f588" CreationDate="2014-03-25T13:41:28.383" Comment="Proposed by 754 approved by 8, 656 edit id of 258" />
  <row Id="2588" PostHistoryTypeId="5" PostId="910" RevisionGUID="d1309bae-05f0-4ae5-9df0-f14692248f87" CreationDate="2014-03-25T14:17:37.293" UserId="754" Comment="reformat code sample" Text="I'm using the `Serial1` of the Arduino Leonardo to send and receive data with another MCU. The following code will always retrieve garbled data:&#xD;&#xA;&#xD;&#xA;    byte streamReadResponse;&#xD;&#xA;    Serial1.begin(115200);&#xD;&#xA;    Serial1.setTimeout(9000);&#xD;&#xA;    Serial1.print(cmd);&#xD;&#xA;    Serial1.print('\r');&#xD;&#xA;    Serial1.flush();  //wait for all the data to be sent to the serial&#xD;&#xA;    streamReadResponse = Serial1.readBytesUntil('&gt;', data, dataLength);&#xD;&#xA;&#xD;&#xA;But, if I add a `delay(50)` before the Serial1 read, I would get the expected output. The value 50 was found by trial and error.&#xD;&#xA;&#xD;&#xA;What am I missing? Why is the `flush()` command not working as expected?" />
  <row Id="2589" PostHistoryTypeId="24" PostId="910" RevisionGUID="d1309bae-05f0-4ae5-9df0-f14692248f87" CreationDate="2014-03-25T14:17:37.293" Comment="Proposed by 754 approved by 8, 42 edit id of 259" />
  <row Id="2590" PostHistoryTypeId="5" PostId="897" RevisionGUID="baf17de3-8cae-472e-9530-943a0700830f" CreationDate="2014-03-25T14:22:57.180" UserId="37" Comment="added 18 characters in body" Text="# Button-pushing robot.&#xD;&#xA;**A four-wheeled eight-pound remote-control laser-shooting robot that pushes buttons.**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;I made this project over the course of last school year. I was in robotics class, and we decided to have a competition. Each team would make a robot that has a large button and a way to push other buttons. At the end of the year, we would have the final contest, where the three robots would try to push each other's buttons.&#xD;&#xA;&#xD;&#xA;By the end of the year, my robot only partially worked. Every part of the robot had at some point been working, but between a fried Arduino, fried motor drivers, terrible code organization, and me being the only person on my team to work on the robot for a total of more than five hours, I couldn't get it completely working.&#xD;&#xA;&#xD;&#xA;I haven't touched my robot in almost a year, so I know that if I wanted to get it working again I would have to rewire the bot and rewrite the code. I may decide to do that some day, but for now I'm going to work on less ambitious projects.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;### Overall Design&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;### Information/electricity flow&#xD;&#xA;&#xD;&#xA;    +--------------------------+   +-------------------------------------------------+&#xD;&#xA;    |         Computer         |   |      Robot                                      |&#xD;&#xA;    |--------------------------|   |-------------------------------------------------|&#xD;&#xA;    |                          |   |                                                 |&#xD;&#xA;    | Keyboard +--&gt; Processing |   |  Button +-------------+        Motor    Motor   |&#xD;&#xA;    |                          |   |                       |          ^       ^      |&#xD;&#xA;    |                    +     |   |                       |          |       |      |&#xD;&#xA;    |                    |     |   |  Batteries +-----+    |          +       +      |&#xD;&#xA;    |                    v     |   |                  |    |   +----&gt; Motor Driver   |&#xD;&#xA;    |                          |   |                  v    v   +                     |&#xD;&#xA;    |               Bluetooth +-----&gt; Bluetooth +--&gt; Arduino Uno +--&gt; Motor driver   |&#xD;&#xA;    |                          |   |                  +    +  +       +       +      |&#xD;&#xA;    +--------------------------+   |                  |    |  |       |       |      |&#xD;&#xA;                                   |                  |    |  |       v       v      |&#xD;&#xA;                                   |                  |    |  |    Motor     Motor   |&#xD;&#xA;                                   |                  |    |  |                      |&#xD;&#xA;                                   |                  |    |  |                      |&#xD;&#xA;                                   |                  |    |  +-----&gt; Laser          |&#xD;&#xA;                                   |  +---------------|----|----+                    |&#xD;&#xA;                                   |  |       Arm     |    |    |                    |&#xD;&#xA;                                   |  |---------------|----|----|                    |&#xD;&#xA;                                   |  |     +---------+    v    |                    |&#xD;&#xA;                                   |  |     |      Motor Driver |                    |&#xD;&#xA;                                   |  |     v              +    |                    |&#xD;&#xA;                                   |  |  Servo             |    |                    |&#xD;&#xA;                                   |  |                    v    |                    |&#xD;&#xA;                                   |  |                  Motor  |                    |&#xD;&#xA;                                   |  +-------------------------+                    |&#xD;&#xA;                                   +-------------------------------------------------+&#xD;&#xA;&#xD;&#xA;### Components&#xD;&#xA;&#xD;&#xA; - Arduino Uno, (fried)&#xD;&#xA; - Transportation:&#xD;&#xA;     - [2 motor drivers][2], (one fried)&#xD;&#xA;     - [4 wheel motors][3], (24v, 360mA with no load)&#xD;&#xA;     - 4 wheels, (plastic jar lids)&#xD;&#xA; - [Easy Button][4]&#xD;&#xA; - Arm:&#xD;&#xA;     - [Servo][5], (continuous rotation)&#xD;&#xA;     - [Motor driver][6], (fried)&#xD;&#xA;     - Motor, (12v, found in teacher's junk pile)&#xD;&#xA;     - Eraser&#xD;&#xA;     - Counterweight, (homemade paper bag filled with pennies)&#xD;&#xA; - [2 battery packs][7], (12V, 1300mAh, Ni-MH rechargeable)&#xD;&#xA; - 2 solderless breadboards&#xD;&#xA; - Laser, (5mW)&#xD;&#xA; - Bluetooth:&#xD;&#xA;     - [mdfly Bluetooth module][8], (5v, 30ft)&#xD;&#xA;     - [Bluetooth adapter][9], (USB, 300+ ft)&#xD;&#xA; - Lots of wires&#xD;&#xA; - Lots of scrap metal and plexiglass, (found in teacher's machine shop)&#xD;&#xA;&#xD;&#xA;### Code&#xD;&#xA;&#xD;&#xA;I didn't organize my code very well, so I hope this is the right code.&#xD;&#xA;&#xD;&#xA; - Arduino: https://github.com/TheGuywithTheHat/robotics-2013/tree/master/Arduino&#xD;&#xA; - Processing: https://github.com/TheGuywithTheHat/robotics-2013/tree/master/Processing&#xD;&#xA;&#xD;&#xA;### More pictures&#xD;&#xA;&#xD;&#xA;![enter image description here][10]&#xD;&#xA;![enter image description here][11]&#xD;&#xA;&#xD;&#xA;### Terrible video of a slow, armless, buttonless, laserless, and bluetoothless early version of the robot.&#xD;&#xA;&#xD;&#xA;https://www.youtube.com/watch?v=Q7MvE7-Xb0E&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;&#xD;&#xA;I'm really good at frying electronics.&#xD;&#xA;&#xD;&#xA;This was my first experience in an actual machine shop. I got to use a CNC milling machine, manual milling machine, lathe, and bandsaw. If I started a project like this again, I would make much better documentation, so I could figure out what the heck I was doing a year later.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/w7Gs6.png&#xD;&#xA;  [2]: http://www.pololu.com/product/2136/&#xD;&#xA;  [3]: http://www.allelectronics.com/make-a-store/item/dcm-395/3-24vdc-gear-motor-used/1.html&#xD;&#xA;  [4]: http://www.staples.com/Easy-Button/cat_CL163314&#xD;&#xA;  [5]: http://www.parallax.com/product/900-00008&#xD;&#xA;  [6]: http://www.pololu.com/product/2136/&#xD;&#xA;  [7]: http://compare.ebay.com/like/140474546940?var=lv&amp;ltyp=AllFixedPriceItemTypes&amp;var=sbar&#xD;&#xA;  [8]: http://www.mdfly.com/index.php?main_page=product_info&amp;cPath=&amp;products_id=769&amp;zenid=2qgknl98q9kppt6q14hk70rlr3&#xD;&#xA;  [9]: http://www.aziocorp.com/en/connectivity/16-usb-micro-bluetooth-adapter-v21-edr.html&#xD;&#xA;  [10]: http://i.stack.imgur.com/XoTWl.png&#xD;&#xA;  [11]: http://i.stack.imgur.com/pWIw8.jpg" />
  <row Id="2591" PostHistoryTypeId="5" PostId="902" RevisionGUID="fac240e4-8791-4d7f-889d-a8eb574ed23c" CreationDate="2014-03-25T14:46:07.343" UserId="790" Comment="Link to the Yun Guide about WiFi." Text="You could try a Arduino Yun, it is like a Uno but it has a WiFi directly on the board.&#xD;&#xA;&#xD;&#xA;There is a part in the [&quot;Guide to the Arduino Yún&quot; called &quot;Configuring the onboard WiFi&quot;][1], that describes how to configure the WiFi.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Guide/ArduinoYun#toc13" />
  <row Id="2592" PostHistoryTypeId="2" PostId="912" RevisionGUID="b85c3c80-386e-47d0-b306-e5896d668c8f" CreationDate="2014-03-25T16:44:45.167" UserId="497" Text="To communicate with the Arduino, it is only necessary to connect the RX and TX pins between the module and the Arduino.&#xD;&#xA;&#xD;&#xA;Source: http://www.mkroll.mobi/?page_id=386" />
  <row Id="2593" PostHistoryTypeId="2" PostId="913" RevisionGUID="a67bbdd1-d546-49bd-90f2-8a3f88917b87" CreationDate="2014-03-25T20:06:27.923" UserId="653" Text="#Marry OpenWrt and your Arduino&#xD;&#xA;&#xD;&#xA;Get a small OpenWrt-capable router like &quot;TP-Link TL-WR703N&quot;, flash it with the current stable version of OpenWrt and connect your Arduino to the router's USB port.&#xD;&#xA;&#xD;&#xA;This solution ist half or less of the cost of WiFi-shields and has far more power.&#xD;&#xA;&#xD;&#xA;...and cheaper as a YÙN.&#xD;&#xA;&#xD;&#xA;[Smart home automation webserver on OpenWRT router WR703N interfaced to Arduino, compared to Raspberry Pi and Ubuntu][1] may be a starting point to read about this and your favorite search engine will find many more links about marrying WR703N and Arduinos...&#xD;&#xA;&#xD;&#xA;  [1]: http://www.instructables.com/id/How-to-set-up-OpenWRT-on-a-pocket-router-WR703N/" />
  <row Id="2594" PostHistoryTypeId="5" PostId="847" RevisionGUID="8c7056d9-caca-4a19-bfd8-ae19bcdf00d1" CreationDate="2014-03-25T20:27:20.310" UserId="220" Comment="Fixed link problem" Text="I am a new user of Arduino (I have a Arduino Due) and also I am a new user of BLE112 (Bluegiga module 112)&#xD;&#xA;&#xD;&#xA;My teacher told me to make the BLE112 advertisable and furthermore he told me to look for information about UART@115K. (The Ble112 he gave me came with wires already soldered to the selected pins: I'm assuming I only need to use those.)&#xD;&#xA;&#xD;&#xA;    PIN NUMBER [PIN NAME] for BLE112&#xD;&#xA;&#xD;&#xA;        2         AVDD                    (Supply voltage 2-3.6V)&#xD;&#xA;        3         AVDD                    (Supply voltage 2-3.6V)&#xD;&#xA;        4        [P2_2]  DC- Debug clock  (DIGITAL I/O)&#xD;&#xA;        5        [P2_1]  DD- Debug data	  (DIGITAL I/O)&#xD;&#xA;        9        VDD_USB                  (Supply voltage 2-3.6V)&#xD;&#xA;        20        DVDD                    (Supply voltage 2-3.6V)&#xD;&#xA;        23       [P0_5]  RXD(Rx)          (DIGITAL I/O)&#xD;&#xA;        24       [P0_4]  TXD(TX)          (DIGITAL I/O)&#xD;&#xA;        25       [P0_3]  RTS              (DIGITAL I/O)&#xD;&#xA;        26       [P0_2]  CTS              (DIGITAL I/O)&#xD;&#xA;        29        RESET&#xD;&#xA;        30         GND&#xD;&#xA;&#xD;&#xA;I put:&#xD;&#xA;&#xD;&#xA;    BLE pins [2,3,9,20]    to     3.3v pin of Arduino &#xD;&#xA;    BLE pin  [30]          to     GND pin of Arduino &#xD;&#xA;&#xD;&#xA;Then I found a picture (attached at the bottom of this post) that describes that I should put CTS of BLE on RTS of Arduino and vice versa. Where is the CTS on an Arduino board? I think I have to program one of the Digital pins.&#xD;&#xA;&#xD;&#xA;I tried some other connections. I put:&#xD;&#xA;&#xD;&#xA;    BLE pin 26(CTS)   to    Arduino random digital pin 32, and &#xD;&#xA;    BLE pin 25(RTS)         Arduino random digital pin 34.&#xD;&#xA;&#xD;&#xA;    BLE pin 24(TX)          Arduino RX pin 0&#xD;&#xA;    BLE pin 23(RX)          Arduino TX pin 1&#xD;&#xA;&#xD;&#xA;I didn't connect `DC(Debug clock)`, `DD(Debug data)` and `Reset` on the BLE112.&#xD;&#xA;&#xD;&#xA;So then I found some more info on the web that if I use USART than I should use a wake up pin which is by the default `P0_0`(??) more about that in [this PDF][3]. (Search `wake_up`)&#xD;&#xA;&#xD;&#xA;Now I should mention sleep mode Ble112 (there are three kinds of it) and I believe that the one I am after is MODE 3 (that means that it consumes the minimum (power) of them all) &#xD;&#xA;&#xD;&#xA;I found some example named UART@115K&#xD;&#xA;&#xD;&#xA;&gt; UART@115k &#xD;&#xA;This example configures the BLE112 or BLE113 Bluetooth Smart module to expose the BGAPI protocol over UART interface with the following settings: 115200 bps, 8n1 and hardware flow control enabled. The power mode 3 is enabled in this example and the wake-up pin is configured to P0_0 pin (P0_0 button on DKBLE112 &#xD;&#xA;and DKBLE113). When the power mode 3 is enabled the device will not be able to receive commands or data over UART unless the wake-up pin is asserted.&#xD;&#xA;&#xD;&#xA;&gt; The example uses UART in the pin configuration channel 1 and alternate 1, which is the configuration used in the DKBLE112 and DKBLE113 development kits. &#xD;&#xA;If you try this example with DKBLE112 or DKBLE113 make sure the UART interface is enabled and the device is NOT powered with a CR2032 battery as it’s not able to power up the level shifter or UART to USB converter. &#xD;&#xA;&#xD;&#xA;&gt; This is also the factory default configuration for BLE112 and BLE113 Bluetooth Smart Modules.&#xD;&#xA;&#xD;&#xA;&gt;![Connection shown][1] &#xD;&#xA;&#xD;&#xA;*Source: [https://bluegiga.zendesk.com/entries/22412436][2]*&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/OwjIi.jpg&#xD;&#xA;  [2]: https://bluegiga.zendesk.com/entries/22412436&#xD;&#xA;  [3]: https://dl.dropboxusercontent.com/u/65932667/Bluetooth_Smart_Configuration_Guide_v33.pdf" />
  <row Id="2595" PostHistoryTypeId="2" PostId="914" RevisionGUID="edc720fc-ffbc-4869-9c1d-35bf099b7456" CreationDate="2014-03-25T21:21:44.917" UserId="220" Text="# The Knock-knock lamp&#xD;&#xA;**A lamp that toggles on/off when the desk is knocked on.** Currently in alpha phase, still prototyping, but I think it's the most useful Arduino project in existence. *Included corny joke generator... from previously recorded knock-knock jokes.* Note: I know I can't win in the rules, but there's no rule about entering... I can show off my project, too.&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;So far I've pretty much explained most of it. You knock, and the light turns on and off. I'm currently on breadboard. I'm using a [piezo element](http://antoinettejcitizen.files.wordpress.com/2011/03/piezo.jpg) to detect the knocks with vibrations. In parallel, I have a 1 megaohm resistor to protect my Arduino Uno SMD.&#xD;&#xA;&#xD;&#xA;I thought of this design after nearly knocking (haha punny) my lamp off of my desk while searching for the little toggle switch. I'm not exactly... well *adroit*. It's nice just to knock on the desk and then have light. I'm also using a Power Switch Tail SSR (solid state relay: no noise) to control it with two of my Arduino's pins.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;![Photo][1]&#xD;&#xA;*Image taken with webcam hanging over monitor... eek!*&#xD;&#xA;&#xD;&#xA;![Fritzing Diagram][2]&#xD;&#xA;&#xD;&#xA;**Components used to build the project:**&#xD;&#xA;&#xD;&#xA; - Piezo element ($3.00 USD)&#xD;&#xA; - Megaohm resistor ($0.30 USD each in 5pk)&#xD;&#xA; - Arduino Uno SMD (on hand)&#xD;&#xA; - Power Switch Tail SSR (~$25.00 USD with ship, but had on hand so no cost)&#xD;&#xA; - Breadboard and jumpers/extra wire (~$5.00 USD, but had on hand so no cost)&#xD;&#xA;&#xD;&#xA;**Cost to me: $3.30 USD + $0.02 USD (tax) == Only $3.32!**&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;Overall, it is a simple project but it's actually useful. That's a struggle with my Arduino projects: can I build something that I would actually *use*? Blinking an LED isn't exactly going to help you in life. It's fun, but that's about it.&#xD;&#xA;&#xD;&#xA;The biggest issue I faced (and kinda still do) is not getting a strong enough signal. I learned a lot about electrical signals: I figured out how to find the &quot;peak&quot; of a pulse and not just read the pin at a random interval and miss the higher voltage. I would try getting  more sensitive piezo element. A larger one would help. I'm trying to modify my circuit to not limit the voltage as much, but protect the Arduino. Some sort of fuse would help in this situation. I'm also playing around with resistor values. It'd help a lot to have a scope for this, but I guess not... :P&#xD;&#xA;&#xD;&#xA;After I perfect the circuit, I'm going to work on getting it on a PCB with an ATtiny... and maybe even develop some kits. I'll try to publish my findings on how to make the element more sensitive without risking my board in the process.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/KxflQ.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/yScgU.png" />
  <row Id="2596" PostHistoryTypeId="2" PostId="915" RevisionGUID="963c303a-ab2a-4fdd-9eb4-028b6b81f586" CreationDate="2014-03-25T21:49:33.790" UserId="754" Text="# Stateful questbox&#xD;&#xA;**A gps powered box that makes you visit a few spots before opening**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;Similar to [questbox][1] but stores small state info EPROM so you have to visit two or three different places before it opens. &#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;Needed hardware:&#xD;&#xA;&#xD;&#xA;* Arduino uno&#xD;&#xA;* Reverse Geocache Version 2&#xD;&#xA;* GlobalSat EM-406A GPS module&#xD;&#xA;* 2×8 blue LCD with connector header and cable&#xD;&#xA;* Hitec HS-55 servo motor&#xD;&#xA;* 4-40 push rod and clevis for latch (some versions provide a Z-bend rod instead)&#xD;&#xA;* 2 AA battery holder&#xD;&#xA;* Metallic push button with embedded blue LED and 4-pin cable&#xD;&#xA;* Pololu low voltage switch&#xD;&#xA;* Pololu 5V boost regulator&#xD;&#xA;* JST connector for EM-406A GPS module&#xD;&#xA;* Straight and right-angle header pins for the display, servo, and pushbutton connectors&#xD;&#xA;* 2 resistors for current limiting and display contrast adjustment&#xD;&#xA;* 2 small capacitors for power smoothing&#xD;&#xA;* larger capacitor for display contrast circuit&#xD;&#xA;&#xD;&#xA;Total hardware cost: **137$ + shipping**&#xD;&#xA;&#xD;&#xA;Aditional materials:&#xD;&#xA;&#xD;&#xA;* A nice box&#xD;&#xA;* Epoxy glue, wood to cover pieces, tools&#xD;&#xA;&#xD;&#xA;You can find assembling instructions in [sundial page][2] (you can buy most materials from them)&#xD;&#xA;&#xD;&#xA;I will upload stateful code and post a link here, unfortunately I wont get all need hardware on time, so this is just an idea :)&#xD;&#xA;&#xD;&#xA;Inspiration:![Original questbox][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;Learned how to integrate many components and libraries all toghether, I'll have to travel a bit to test it :)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sundial.com/&#xD;&#xA;  [2]: https://www.sundial.com/quest-box/notes-for-builders/&#xD;&#xA;  [3]: http://i.stack.imgur.com/864pF.jpg" />
  <row Id="2597" PostHistoryTypeId="2" PostId="916" RevisionGUID="b17c3f2b-01fe-48a8-bb13-fca82838ab7e" CreationDate="2014-03-25T22:32:09.513" UserId="353" Text="The Uno is not using FTDI drivers **at all**, since it does USB through an ATmega16u2, not an FTDI chip." />
  <row Id="2598" PostHistoryTypeId="2" PostId="917" RevisionGUID="44b96bae-efa6-4798-84b8-b5b96764fb54" CreationDate="2014-03-25T23:33:33.123" UserId="136" Text="I recently noticed how the map() function in Arduino was bulky in both terms of flash space used and time taken to execute, largely because it deals with `long` and involves a division and multiplication.&#xD;&#xA;&#xD;&#xA;Many times you can replace maps with more basic functions i.e.&#xD;&#xA;&#xD;&#xA;    output = map(input,0,1023,0,255); &#xD;&#xA;&#xD;&#xA;can become&#xD;&#xA;&#xD;&#xA;    output = input &gt;&gt; 2;&#xD;&#xA;&#xD;&#xA;or &#xD;&#xA;&#xD;&#xA;    output = map(input,0,1023,1023,0);&#xD;&#xA;&#xD;&#xA;can become&#xD;&#xA;&#xD;&#xA;    output = 1023 - input;&#xD;&#xA;&#xD;&#xA;I have one line in some code that says:&#xD;&#xA;&#xD;&#xA;    backlight = map(LDRreading,0,1023,50,250);&#xD;&#xA;&#xD;&#xA;How could this be simplified so that it is both space and time efficient?&#xD;&#xA;&#xD;&#xA;I'll allow slight differences in output values if it results in a much better solution.&#xD;&#xA;" />
  <row Id="2599" PostHistoryTypeId="1" PostId="917" RevisionGUID="44b96bae-efa6-4798-84b8-b5b96764fb54" CreationDate="2014-03-25T23:33:33.123" UserId="136" Text="What's the most efficient implementation of map(x,0,1023,50,250)?" />
  <row Id="2600" PostHistoryTypeId="3" PostId="917" RevisionGUID="44b96bae-efa6-4798-84b8-b5b96764fb54" CreationDate="2014-03-25T23:33:33.123" UserId="136" Text="&lt;optimisation&gt;&lt;map&gt;" />
  <row Id="2601" PostHistoryTypeId="2" PostId="918" RevisionGUID="8e76567e-b1b4-42f3-b25b-2e357120033d" CreationDate="2014-03-25T23:58:22.970" UserId="42" Text="You could approximate it quite closely using only two integer operations:&#xD;&#xA;&#xD;&#xA;    backlight = (LDRreading / 5) + 46;&#xD;&#xA;&#xD;&#xA;That effectively maps input range 0 - 1023 onto output range 46 - 250, so it's fairly accurate. If `LDRreading` is a 2 byte integer type then it should be significantly more efficient (comparatively speaking) than anything which uses `long`." />
  <row Id="2602" PostHistoryTypeId="2" PostId="919" RevisionGUID="5bd6eeba-dd98-4675-8cb9-7902e2cca826" CreationDate="2014-03-26T00:10:14.167" UserId="368" Text="This doesn't get you all the way to 250, but fairly close:&#xD;&#xA;&#xD;&#xA;    &gt;&gt;&gt; for i in range(0, 1024, 34):&#xD;&#xA;    ...   print (i &gt;&gt; 4) + (i &gt;&gt; 3) - (i &gt;&gt; 9) + 50&#xD;&#xA;    ... &#xD;&#xA;    50&#xD;&#xA;    56&#xD;&#xA;    62&#xD;&#xA;    68&#xD;&#xA;    75&#xD;&#xA;    81&#xD;&#xA;    87&#xD;&#xA;    93&#xD;&#xA;    101&#xD;&#xA;    107&#xD;&#xA;    113&#xD;&#xA;    119&#xD;&#xA;    126&#xD;&#xA;    132&#xD;&#xA;    138&#xD;&#xA;    144&#xD;&#xA;    151&#xD;&#xA;    157&#xD;&#xA;    163&#xD;&#xA;    169&#xD;&#xA;    176&#xD;&#xA;    182&#xD;&#xA;    188&#xD;&#xA;    194&#xD;&#xA;    202&#xD;&#xA;    208&#xD;&#xA;    214&#xD;&#xA;    220&#xD;&#xA;    227&#xD;&#xA;    233&#xD;&#xA;    239&#xD;&#xA;&#xD;&#xA;Do all your processing with a left-justified `int` (`ADLAR`=1) though, to minimize errors." />
  <row Id="2603" PostHistoryTypeId="12" PostId="919" RevisionGUID="e167e80f-1529-46c8-b66d-29cb0df43094" CreationDate="2014-03-26T00:16:27.473" UserId="368" Comment="via Vote" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:368,&quot;DisplayName&quot;:&quot;Ignacio Vazquez-Abrams&quot;}]}" />
  <row Id="2604" PostHistoryTypeId="5" PostId="919" RevisionGUID="f30e0dcb-ba28-45df-ba13-d38cfa192852" CreationDate="2014-03-26T00:17:02.987" UserId="368" Comment="deleted 4 characters in body" Text="This doesn't get you right to 250, but pretty close:&#xD;&#xA;&#xD;&#xA;    &gt;&gt;&gt; for i in range(0, 1024, 34):&#xD;&#xA;    ...   print (i &gt;&gt; 4) + (i &gt;&gt; 3) + (i &gt;&gt; 7) + 50&#xD;&#xA;    ... &#xD;&#xA;    50&#xD;&#xA;    56&#xD;&#xA;    62&#xD;&#xA;    68&#xD;&#xA;    76&#xD;&#xA;    82&#xD;&#xA;    88&#xD;&#xA;    94&#xD;&#xA;    103&#xD;&#xA;    109&#xD;&#xA;    115&#xD;&#xA;    121&#xD;&#xA;    129&#xD;&#xA;    135&#xD;&#xA;    141&#xD;&#xA;    147&#xD;&#xA;    156&#xD;&#xA;    162&#xD;&#xA;    168&#xD;&#xA;    175&#xD;&#xA;    182&#xD;&#xA;    188&#xD;&#xA;    194&#xD;&#xA;    201&#xD;&#xA;    209&#xD;&#xA;    215&#xD;&#xA;    221&#xD;&#xA;    228&#xD;&#xA;    235&#xD;&#xA;    241&#xD;&#xA;    247&#xD;&#xA;    &gt;&gt;&gt; print (1023 &gt;&gt; 4) + (1023 &gt;&gt; 3) + (1023 &gt;&gt; 7) + 50&#xD;&#xA;    247&#xD;&#xA;&#xD;&#xA;Do all your processing with a left-justified `int` (`ADLAR`=1) though, to minimize errors.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2605" PostHistoryTypeId="13" PostId="919" RevisionGUID="c03db9bc-bcc7-4218-926c-dd35033af580" CreationDate="2014-03-26T00:17:07.730" UserId="368" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:368,&quot;DisplayName&quot;:&quot;Ignacio Vazquez-Abrams&quot;}]}" />
  <row Id="2606" PostHistoryTypeId="5" PostId="919" RevisionGUID="fb490d6d-215e-4a23-912e-ada8e8327e2a" CreationDate="2014-03-26T00:32:30.417" UserId="368" Comment="deleted 124 characters in body" Text="![enter image description here][1]&#xD;&#xA;&#xD;&#xA;This doesn't get you right to 250, but pretty close:&#xD;&#xA;&#xD;&#xA;    &gt;&gt;&gt; for i in range(0, 1024, 34):&#xD;&#xA;    ...   print (i &gt;&gt; 3) + (i &gt;&gt; 4) + (i &gt;&gt; 7) + 50&#xD;&#xA;    ... &#xD;&#xA;    50&#xD;&#xA;    56&#xD;&#xA;    62&#xD;&#xA;       [snip]&#xD;&#xA;    235&#xD;&#xA;    241&#xD;&#xA;    247&#xD;&#xA;    &gt;&gt;&gt; print (1023 &gt;&gt; 3) + (1023 &gt;&gt; 4) + (1023 &gt;&gt; 7) + 50&#xD;&#xA;    247&#xD;&#xA;&#xD;&#xA;Do all your processing with a left-justified `int` (`ADLAR`=1) though, to minimize errors.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/efyls.png" />
  <row Id="2607" PostHistoryTypeId="36" PostId="920" RevisionGUID="8301c927-0e18-4272-9e5b-55516f82045e" CreationDate="2014-03-26T04:21:14.763" UserId="-1" Comment="from http://stackoverflow.com/questions/22273338/arduino-serial-monitor-only-returning-null-characters" />
  <row Id="2608" PostHistoryTypeId="2" PostId="920" RevisionGUID="514164e4-dd68-45f0-87cc-fe82a32194a7" CreationDate="2014-03-08T18:29:48.480" UserDisplayName="JcKelley" Text="I'm trying to simply access my HC_05 bluetooth module and conduct some AT commands through the Serial Monitor. For some reason though, **it only seems to be returning Null characters,** though it does some to be actually responding to the command in some way (given by the length of Null characters it returns.&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;So you can clearly see that the command `AT` and `AT+NAMEdevice` return different data, but they are both all `NUL` blocks. I am viewing the monitor in text. Changing the view to Hex or ASCII does not change results.&#xD;&#xA;&#xD;&#xA;Code for this simple program is below:&#xD;&#xA;&#xD;&#xA;    #include &lt;SoftwareSerial.h&gt;&#xD;&#xA;    &#xD;&#xA;    SoftwareSerial BTSerial(10, 11); // RX | TX&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      pinMode(9, OUTPUT);  // this pin will pull the HC-05 pin 34 (key pin) HIGH to switch module to AT mode&#xD;&#xA;      digitalWrite(9, HIGH);&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      Serial.println(&quot;Enter AT commands:&quot;);&#xD;&#xA;      BTSerial.begin(38400);  // HC-05 default speed in AT command more&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;      // Keep reading from HC-05 and send to Arduino Serial Monitor&#xD;&#xA;      if (BTSerial.available())&#xD;&#xA;        Serial.write(BTSerial.read());&#xD;&#xA;    &#xD;&#xA;      // Keep reading from Arduino Serial Monitor and send to HC-05&#xD;&#xA;      if (Serial.available())&#xD;&#xA;        BTSerial.write(Serial.read());&#xD;&#xA;&#xD;&#xA;}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Wire Diagram is as [here][2]&#xD;&#xA;*NOTE* I have used both a direct connection to the `5V` and also used a Voltage Divider. Neither changes the `NUL` return.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/NnELQ.png&#xD;&#xA;  [2]: http://www.instructables.com/file/FM8W4A2HKZAVRT9" />
  <row Id="2609" PostHistoryTypeId="1" PostId="920" RevisionGUID="514164e4-dd68-45f0-87cc-fe82a32194a7" CreationDate="2014-03-08T18:29:48.480" UserDisplayName="JcKelley" Text="Arduino Serial Monitor only returning Null Characters" />
  <row Id="2610" PostHistoryTypeId="3" PostId="920" RevisionGUID="514164e4-dd68-45f0-87cc-fe82a32194a7" CreationDate="2014-03-08T18:29:48.480" UserDisplayName="JcKelley" Text="&lt;bluetooth&gt;&lt;arduino-ide&gt;" />
  <row Id="2612" PostHistoryTypeId="5" PostId="920" RevisionGUID="baf1c1bb-b499-4d51-b9bf-2f7372e92d01" CreationDate="2014-03-26T06:11:11.613" UserId="11" Comment="added 2 characters in body; edited tags" Text="I'm trying to simply access my HC_05 bluetooth module and conduct some AT commands through the Serial Monitor. For some reason though, **it only seems to be returning Null characters,** though it does some to be actually responding to the command in some way (given by the length of Null characters it returns.&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;So you can clearly see that the command `AT` and `AT+NAMEdevice` return different data, but they are both all `NUL` blocks. I am viewing the monitor in text. Changing the view to Hex or ASCII does not change results.&#xD;&#xA;&#xD;&#xA;Code for this simple program is below:&#xD;&#xA;&#xD;&#xA;    #include &lt;SoftwareSerial.h&gt;&#xD;&#xA;    &#xD;&#xA;    SoftwareSerial BTSerial(10, 11); // RX | TX&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      pinMode(9, OUTPUT);  // this pin will pull the HC-05 pin 34 (key pin) HIGH to switch module to AT mode&#xD;&#xA;      digitalWrite(9, HIGH);&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      Serial.println(&quot;Enter AT commands:&quot;);&#xD;&#xA;      BTSerial.begin(38400);  // HC-05 default speed in AT command more&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;      // Keep reading from HC-05 and send to Arduino Serial Monitor&#xD;&#xA;      if (BTSerial.available())&#xD;&#xA;        Serial.write(BTSerial.read());&#xD;&#xA;    &#xD;&#xA;      // Keep reading from Arduino Serial Monitor and send to HC-05&#xD;&#xA;      if (Serial.available())&#xD;&#xA;        BTSerial.write(Serial.read());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Wire Diagram is as [here][2]&#xD;&#xA;*NOTE* I have used both a direct connection to the `5V` and also used a Voltage Divider. Neither changes the `NUL` return.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/NnELQ.png&#xD;&#xA;  [2]: http://www.instructables.com/file/FM8W4A2HKZAVRT9" />
  <row Id="2613" PostHistoryTypeId="6" PostId="920" RevisionGUID="baf1c1bb-b499-4d51-b9bf-2f7372e92d01" CreationDate="2014-03-26T06:11:11.613" UserId="11" Comment="added 2 characters in body; edited tags" Text="&lt;serial&gt;&lt;bluetooth&gt;" />
  <row Id="2614" PostHistoryTypeId="2" PostId="921" RevisionGUID="37e05209-5fe0-459d-9013-d6d10719aea3" CreationDate="2014-03-26T06:31:05.097" UserId="84" Text="Your question actually has 2 distinct parts:&#xD;&#xA;&#xD;&#xA; 1. Why does arduino-cmake generate the warning &quot;Policy CMP0022 is not set: INTERFACE_LINK_LIBRARIES...&quot;?&#xD;&#xA; 2. Why does `make`, using the generated MakeFile, fail when building WiFi example?&#xD;&#xA;&#xD;&#xA;**First off**, the arduino-cmake &quot;**Policy CMP0022**&quot; is just a warning, not an error. As per [this cmake article][1], that CMP policy has been only recently introduced in **CMake 2.8.12**.&#xD;&#xA;&#xD;&#xA;You get this warning simply because arduino-cmake has been created based on an older version of cmake and thus does not specifically support this new policy.&#xD;&#xA;&#xD;&#xA;In order to get rid of this warning, the documentation mentions you should add the `cmake_policy(SET CMP0022 OLD)` command to your cmake configuration.&#xD;&#xA;&#xD;&#xA;Unfortunately I tried it in the example `CMakeLists.txt` to no avail; maybe it has to be set directly in arduino-cmake files (which I have not tested).&#xD;&#xA;&#xD;&#xA;Thus, if you want to get rid of this boring warning, it seems the only solution you are left with is to disable all warnings when launching cmake:&#xD;&#xA;&#xD;&#xA;&gt; cmake -G &quot;MinGW Makefiles&quot; -Wno-dev&#xD;&#xA;&#xD;&#xA;This works fine and has removed all warnings..&#xD;&#xA;&#xD;&#xA;**Your second problem** (the real one I would say) is due to to the structure of WiFi library:&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;Indeed, as you can see above, it has a `utility` subdirectory that contains additional source code that **cannot be found by arduino-cmake**, as by default it searches for source code files only at first level directory.&#xD;&#xA;&#xD;&#xA;How to solve it? Just tell arduino-cmake to do a **recursive search for the WiFi library**; in your `CMakeLists.txt`, ensure you add the following line:&#xD;&#xA;&#xD;&#xA;    set(WiFi_RECURSE True)&#xD;&#xA;    generate_arduino_example(wifi_example&#xD;&#xA;                         LIBRARY WiFi&#xD;&#xA;                         EXAMPLE WiFiWebClient)&#xD;&#xA;&#xD;&#xA;The added `set(WiFi_RECURSE True)` line just tells arduino-cmake that, for WiFi library, it should recurse through subdirectories when looking for source code.&#xD;&#xA;&#xD;&#xA;I have checked it with &quot;Unix Makefiles&quot; (not &quot;MinGW Makefiles&quot; but I guess that won't make any difference) and it worked fine.&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/Kitware/CMake/blob/master/Help/policy/CMP0022.rst&#xD;&#xA;  [2]: http://i.stack.imgur.com/JUqed.png" />
  <row Id="2616" PostHistoryTypeId="5" PostId="919" RevisionGUID="9f331254-04b8-4c2d-99de-29f6828efa69" CreationDate="2014-03-26T07:38:52.737" UserId="136" Comment="Explained a couple of parts of the answer as I think it will help newer Arduino users. " Text="![enter image description here][1]&#xD;&#xA;&#xD;&#xA;The screenshot shows a base-2 (i.e. binary) result of calculating the constant part of a mapping. You can approximate this multiplication by a constant by a number of shifts added together. You need to break down each multiplication in the result first:&#xD;&#xA;&#xD;&#xA;x * 0.001&lt;sub&gt;2&lt;/sub&gt; = x &gt;&gt; 3&#xD;&#xA;&#xD;&#xA;x * 0.0001&lt;sub&gt;2&lt;/sub&gt; = x &gt;&gt; 4&#xD;&#xA;&#xD;&#xA;x * 0.0000001&lt;sub&gt;2&lt;/sub&gt; = x &gt;&gt; 7&#xD;&#xA;&#xD;&#xA;Then add these together. You are essentially breaking it down into convenient base-2 multiplies (which can always be represented by shifts) and adds - nearly always mor efficient.&#xD;&#xA;&#xD;&#xA;This doesn't get you right to 250, but pretty close:&#xD;&#xA;&#xD;&#xA;    &gt;&gt;&gt; for i in range(0, 1024, 34):&#xD;&#xA;    ...   print (i &gt;&gt; 3) + (i &gt;&gt; 4) + (i &gt;&gt; 7) + 50&#xD;&#xA;    ... &#xD;&#xA;    50&#xD;&#xA;    56&#xD;&#xA;    62&#xD;&#xA;       [snip]&#xD;&#xA;    235&#xD;&#xA;    241&#xD;&#xA;    247&#xD;&#xA;    &gt;&gt;&gt; print (1023 &gt;&gt; 3) + (1023 &gt;&gt; 4) + (1023 &gt;&gt; 7) + 50&#xD;&#xA;    247&#xD;&#xA;&#xD;&#xA;Do all your processing with a left-justified `int` (`ADLAR`=1) though, to minimize errors. The ADC returns a 10bit result, and ADLAR choses if this is aligned to the left or right of the two result registers.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/efyls.png" />
  <row Id="2617" PostHistoryTypeId="5" PostId="919" RevisionGUID="eb98e7b2-1cca-4350-bfda-b606940bd542" CreationDate="2014-03-26T07:44:26.820" UserId="136" Comment="Spelling mistake." Text="![enter image description here][1]&#xD;&#xA;&#xD;&#xA;The screenshot shows a base-2 (i.e. binary) result of calculating the constant part of a mapping. You can approximate this multiplication by a constant by a number of shifts added together. You need to break down each multiplication in the result first:&#xD;&#xA;&#xD;&#xA;x * 0.001&lt;sub&gt;2&lt;/sub&gt; = x &gt;&gt; 3&#xD;&#xA;&#xD;&#xA;x * 0.0001&lt;sub&gt;2&lt;/sub&gt; = x &gt;&gt; 4&#xD;&#xA;&#xD;&#xA;x * 0.0000001&lt;sub&gt;2&lt;/sub&gt; = x &gt;&gt; 7&#xD;&#xA;&#xD;&#xA;Then add these together. You are essentially breaking it down into convenient base-2 multiplies (which can always be represented by shifts) and adds - nearly always more efficient.&#xD;&#xA;&#xD;&#xA;This doesn't get you right to 250, but pretty close:&#xD;&#xA;&#xD;&#xA;    &gt;&gt;&gt; for i in range(0, 1024, 34):&#xD;&#xA;    ...   print (i &gt;&gt; 3) + (i &gt;&gt; 4) + (i &gt;&gt; 7) + 50&#xD;&#xA;    ... &#xD;&#xA;    50&#xD;&#xA;    56&#xD;&#xA;    62&#xD;&#xA;       [snip]&#xD;&#xA;    235&#xD;&#xA;    241&#xD;&#xA;    247&#xD;&#xA;    &gt;&gt;&gt; print (1023 &gt;&gt; 3) + (1023 &gt;&gt; 4) + (1023 &gt;&gt; 7) + 50&#xD;&#xA;    247&#xD;&#xA;&#xD;&#xA;Do all your processing with a left-justified `int` (`ADLAR`=1) though, to minimize errors. The ADC returns a 10bit result, and ADLAR choses if this is aligned to the left or right of the two result registers.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/efyls.png" />
  <row Id="2621" PostHistoryTypeId="2" PostId="923" RevisionGUID="18ed6c40-1a53-4a99-96da-55f4c7b3cde5" CreationDate="2014-03-26T08:36:55.867" UserId="754" Text="**You just described the problems the company I'm working for is trying to solve.** We've recently launced a product called **[biicode][1]**. It seems exactly what you are looking for. &#xD;&#xA;&#xD;&#xA;*biicode* is both an online central repository for code and and a client tool that features: &#xD;&#xA;&#xD;&#xA;* Easy to use by beginners, configurable for more advanced users &#xD;&#xA;* Dependencies resolution, transitively, as maven does, but without config files: reads dependencies directly from source code. &#xD;&#xA;* Central repository, anyone can upload their libraries. They can be explored, navigated and [discovered in the web][2] &#xD;&#xA;* Version control: it checks versions compatibility and allows safe updates of dependencies &#xD;&#xA;* You can use it with any text editor (it has optional eclipse support) &#xD;&#xA;* It manages project setup and compilations, flashes generated firmware to the board &#xD;&#xA;* It has a nice serial monitor as a plus &#xD;&#xA;&#xD;&#xA;You can see a quick demo [here][3] and read more in the [documentation][4]. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: biicode.com&#xD;&#xA;  [2]: biicode.com/…&#xD;&#xA;  [3]: https://asciinema.org/a/8324&#xD;&#xA;  [4]: docs.biicode.com/arduino.html" />
  <row Id="2622" PostHistoryTypeId="2" PostId="924" RevisionGUID="491629ed-1f9f-4f11-b8d0-0641bfa054f3" CreationDate="2014-03-26T09:32:03.957" UserId="575" Text="The bootloader on an arduino is just a piece of software written to enable you to update your sketches using the usb connection. Without the bootloader you can't upload sketches using just the arduino ide.&#xD;&#xA;&#xD;&#xA;More information about the bootloader can be found here: http://arduino.cc/en/Guide/Environment?from=Tutorial.Bootloader&#xD;&#xA;Look under the heading entitled uploading which explains the part the bootloader plays in uploading sketches.&#xD;&#xA;&#xD;&#xA;When you use the &quot;Burn Bootloader&quot; button in the arduino ide it will attempt to write a new copy of the bootloader onto the attached Arduino board. To do this the board must be attached in a specific manner - that is - using the icsp/isp header rather than the usb cable.&#xD;&#xA;&#xD;&#xA;Now to program the avr chip directly you have to use an external (hardware) programmer. Fortunately you don't have to buy one if you have a second arduino because the second arduino can be used as a programmer. Instructions for doing so can be found here: http://arduino.cc/en/Tutorial/ArduinoISP&#xD;&#xA;&#xD;&#xA;Even more info about the bootloader: http://arduino.cc/en/Hacking/Bootloader?from=Main.Bootloader" />
  <row Id="2623" PostHistoryTypeId="5" PostId="915" RevisionGUID="5f583dfb-fd6f-47f7-8b26-1dc69d2ea538" CreationDate="2014-03-26T09:33:55.780" UserId="754" Comment="Tips for budget reduction" Text="# Stateful questbox&#xD;&#xA;**A gps powered box that makes you visit a few spots before opening**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;Similar to [questbox][1] but stores small state info EPROM so you have to visit two or three different places before it opens. &#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;Needed hardware:&#xD;&#xA;&#xD;&#xA;* Arduino uno&#xD;&#xA;* Reverse Geocache Version 2&#xD;&#xA;* GlobalSat EM-406A GPS module&#xD;&#xA;* 2×8 blue LCD with connector header and cable&#xD;&#xA;* Hitec HS-55 servo motor&#xD;&#xA;* 4-40 push rod and clevis for latch (some versions provide a Z-bend rod instead)&#xD;&#xA;* 2 AA battery holder&#xD;&#xA;* Metallic push button with embedded blue LED and 4-pin cable&#xD;&#xA;* Pololu low voltage switch&#xD;&#xA;* Pololu 5V boost regulator&#xD;&#xA;* JST connector for EM-406A GPS module&#xD;&#xA;* Straight and right-angle header pins for the display, servo, and pushbutton connectors&#xD;&#xA;* 2 resistors for current limiting and display contrast adjustment&#xD;&#xA;* 2 small capacitors for power smoothing&#xD;&#xA;* larger capacitor for display contrast circuit&#xD;&#xA;&#xD;&#xA;Total hardware cost: **137$ + shipping**&#xD;&#xA;&#xD;&#xA;Aditional materials:&#xD;&#xA;&#xD;&#xA;* A nice box&#xD;&#xA;* Epoxy glue, wood to cover pieces, tools&#xD;&#xA;&#xD;&#xA;You can find assembling instructions in [sundial page][2] (you can buy most materials from them)&#xD;&#xA;&#xD;&#xA;I will upload stateful code and post a link here, unfortunately I wont get all need hardware on time, so this is just an idea :)&#xD;&#xA;&#xD;&#xA;Inspiration:![Original questbox][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;Learned how to integrate many components and libraries all toghether, I'll have to travel a bit to test it :)&#xD;&#xA;&#xD;&#xA;Budget can be cut quite a bit changing the concept a bit:&#xD;&#xA;&#xD;&#xA;* Change gps with a numerical keypad: the 'player' has to guess/obtain a code instead of traveling to a location&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sundial.com/&#xD;&#xA;  [2]: https://www.sundial.com/quest-box/notes-for-builders/&#xD;&#xA;  [3]: http://i.stack.imgur.com/864pF.jpg" />
  <row Id="2624" PostHistoryTypeId="5" PostId="923" RevisionGUID="14e14e01-af25-4c85-92c6-410e655c08f5" CreationDate="2014-03-26T10:56:00.323" UserId="754" Comment="fix links" Text="**You just described the problems the company I'm working for is trying to solve.** We've recently launced a product called **[biicode][1]**. It seems exactly what you are looking for. &#xD;&#xA;&#xD;&#xA;*biicode* is both an online central repository for code and and a client tool that features: &#xD;&#xA;&#xD;&#xA;* Easy to use by beginners, configurable for more advanced users &#xD;&#xA;* Dependencies resolution, transitively, as maven does, but without config files: reads dependencies directly from source code. &#xD;&#xA;* Central repository, anyone can upload their libraries. They can be explored, navigated and [discovered in the web][2] &#xD;&#xA;* Version control: it checks versions compatibility and allows safe updates of dependencies &#xD;&#xA;* You can use it with any text editor (it has optional eclipse support) &#xD;&#xA;* It manages project setup and compilations, flashes generated firmware to the board &#xD;&#xA;* It has a nice serial monitor as a plus &#xD;&#xA;&#xD;&#xA;You can see a quick demo [here][3] and read more in the [documentation][4]. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.biicode.com&#xD;&#xA;  [2]: https://www.biicode.com/search?words=arduino&amp;search=&#xD;&#xA;  [3]: https://asciinema.org/a/8324&#xD;&#xA;  [4]: http://docs.biicode.com/arduino.html" />
  <row Id="2625" PostHistoryTypeId="2" PostId="925" RevisionGUID="b672170e-cde4-42d8-8098-9bf7b9b6bdd7" CreationDate="2014-03-26T12:10:17.060" UserId="353" Text="How about this, mapping to 50..249?&#xD;&#xA;&#xD;&#xA;    output = ((input * 25) &gt;&gt; 7)+50;&#xD;&#xA;    &#xD;&#xA;Your input range was 1024 (0..1023). Output range is 200. These have a gcd of 8, so `output = (input * (200/8)) / (1024/8) + 50` will do, and the division by a power of 2 can be expressed with a shift. The nice thing is that `1024*25` still fits into a 16 bit integer, so no longs are needed.&#xD;&#xA;&#xD;&#xA;If you want full range, you can try throwing in rounding&#xD;&#xA;&#xD;&#xA;    output = ((input*25+64) &gt;&gt; 7)+50;&#xD;&#xA;" />
  <row Id="2626" PostHistoryTypeId="2" PostId="926" RevisionGUID="1800200f-faf7-4bf3-859d-a1f58810ac58" CreationDate="2014-03-26T14:56:05.410" UserId="639" Text="What is the maximum power consumption (in mW) of the [Arduino Nano 3.0][1], when it is running in its default state (at 16MHz, no LEDs removed) and powered by an external regulated 5V supply so it bypasses the built in voltage regulator.&#xD;&#xA;&#xD;&#xA;This will give us an upper bound on the power consumption of the Arduino Nano that can be used during estimates.&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/arduinoBoardNano&#xD;&#xA;  [2]: http://i.stack.imgur.com/ugt9m.png" />
  <row Id="2627" PostHistoryTypeId="1" PostId="926" RevisionGUID="1800200f-faf7-4bf3-859d-a1f58810ac58" CreationDate="2014-03-26T14:56:05.410" UserId="639" Text="What is the Max Power Consumption of Arduino Nano 3.0" />
  <row Id="2628" PostHistoryTypeId="3" PostId="926" RevisionGUID="1800200f-faf7-4bf3-859d-a1f58810ac58" CreationDate="2014-03-26T14:56:05.410" UserId="639" Text="&lt;power&gt;&lt;arduino-nano&gt;&lt;voltage-level&gt;" />
  <row Id="2629" PostHistoryTypeId="2" PostId="927" RevisionGUID="8cb9cb16-3771-4166-9d5f-396e134e8001" CreationDate="2014-03-26T15:15:42.813" UserId="810" Text="If the input range is limited in size and you have the memory for it nothing beats a simple lookup-table.&#xD;&#xA;&#xD;&#xA;like   &#xD;&#xA;unsigned char map[1024] = { 50, 50, &lt;&lt; more entries here  &gt;&gt;, 250 } ;  &#xD;&#xA;&#xD;&#xA;You can pre-compute the content in a part of the program that isn't time-critical or just compute the entire table-content beforehand and put it verbatim in the source-code.&#xD;&#xA;&#xD;&#xA;Doing a map is just a read of map[] with the original value as index.&#xD;&#xA;&#xD;&#xA;If you input range starts with a non-zero number just decrement all inputs by the lower-bound value so you have a 0-base index for the map array. (That works for negative lower-bounds too !)  &#xD;&#xA;&#xD;&#xA;At most 1 substract (to adjust for a non-zero lower-bound) and 1 addition to calculate the array-base + index.  &#xD;&#xA;And a good compiler will be able to optimize it further.  &#xD;&#xA;&#xD;&#xA;You can't get more efficient than that, but you do need the space to store the table somewhere.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2631" PostHistoryTypeId="2" PostId="928" RevisionGUID="088e5af2-2f07-4d9d-91c2-6a4bf3420374" CreationDate="2014-03-26T15:56:52.820" UserId="809" Text="![MySensors][1]&#xD;&#xA;&#xD;&#xA;*- Learn how to create your own low cost wireless sensors and connect them to the world.*&#xD;&#xA;&#xD;&#xA;http://www.mysensors.org&#xD;&#xA;&#xD;&#xA;We call it **&quot;Internet of Your Things&quot;** &#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;We've combined the Arduino platform with a small radio transceiver into a fun, flexible world of low cost wireless sensors.&#xD;&#xA;&#xD;&#xA;All the nitty-gritty details about the sensor communication has been packaged into a convenient software library so you don't have to worry about them.&#xD;&#xA;&#xD;&#xA;It is as easy as 1, 2, 3.&#xD;&#xA;![Arduino + NRF24L01+][2]&#xD;&#xA;&#xD;&#xA;1. Connect the parts. 2. Download the provided examples. 3. Start measuring and controlling the world!&#xD;&#xA;&#xD;&#xA;Read more about how the sensor network is automatically being formed using our Arduino Library on the site. It basically forms a star network and can reach hundred of meters.&#xD;&#xA;&#xD;&#xA;![The sensor network][3]&#xD;&#xA;&#xD;&#xA;In the middle you place an Arduion or Raspberry gateway that collects the information from your sensors.&#xD;&#xA;![Raspberry Controller][4]&#xD;&#xA;&#xD;&#xA;![Arduino Gateway][5]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Design and schematics&#xD;&#xA;We supply a list of easy to follow build instructions for a bunch of different wireless sensors and actuators. Here are some examples:&#xD;&#xA;&#xD;&#xA;Distance Sensor, Motion sensor, Relay actuator, Humidity, Light, Pressure, Rain, Temperature, ... &#xD;&#xA;&#xD;&#xA;![enter image description here][6]&#xD;&#xA;&#xD;&#xA;You will find all the build instructions here:&#xD;&#xA;http://www.mysensors.org/build/&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;The project is still in the starting blocks and we hope to provide plugins for a growing list of Home Automation controllers. The first thing on our list right now is to provide a DIY controller that provides a free cloud storage for your sensor data.&#xD;&#xA;&#xD;&#xA;![Hello][7]&#xD;&#xA;&#xD;&#xA;See you @ mysensors.org&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/UKSL4.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/VfWYX.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/ETVDA.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/s8GkQ.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/35AcP.jpg&#xD;&#xA;  [6]: http://i.stack.imgur.com/DE5oE.jpg&#xD;&#xA;  [7]: http://i.stack.imgur.com/VYgX4.png" />
  <row Id="2632" PostHistoryTypeId="2" PostId="929" RevisionGUID="25d15824-7c98-4e27-be3b-d50975b6eb9b" CreationDate="2014-03-26T17:18:26.827" UserId="136" Text="Whilst it is possible, and sometimes desirable, to use pin change interrupts to read the state of buttons, it is simpler to poll the state of buttons in `loop()`. This is a commonly used technique.&#xD;&#xA;&#xD;&#xA;If you `loop()` executes quickly enough, then button presses are always going to be caught and the use will not be able to perceive any delay or lag.&#xD;&#xA;&#xD;&#xA;It is possible thought that your loop would take so long as to cause a delay or lag to be perceived.&#xD;&#xA;&#xD;&#xA;The question is, how long would it be, in general, before a user would see this?" />
  <row Id="2633" PostHistoryTypeId="1" PostId="929" RevisionGUID="25d15824-7c98-4e27-be3b-d50975b6eb9b" CreationDate="2014-03-26T17:18:26.827" UserId="136" Text="How frequently do you need to poll UI buttons before they are perceived as laggy?" />
  <row Id="2634" PostHistoryTypeId="3" PostId="929" RevisionGUID="25d15824-7c98-4e27-be3b-d50975b6eb9b" CreationDate="2014-03-26T17:18:26.827" UserId="136" Text="&lt;button&gt;&lt;ui&gt;" />
  <row Id="2635" PostHistoryTypeId="2" PostId="930" RevisionGUID="85cbcc42-fe81-4ee2-a485-830bf868fa80" CreationDate="2014-03-26T17:37:55.967" UserId="186" Text="I think I see a lot of single-sample noise spikes in your noisy signal.&#xD;&#xA;&#xD;&#xA;The median filter does better at getting rid of single-sample noise spikes than any linear filter.&#xD;&#xA;(It is better than any low pass filter, moving average, weighted moving average, etc. in terms of its response time and its ability to ignore such single-sample noise spike outliers).&#xD;&#xA;&#xD;&#xA;There are, in fact, many signal-smoothing libraries for the Arduino, many of which include a median filter.&#xD;&#xA;&#xD;&#xA;signal-smoothing libraries at arduino.cc:&#xD;&#xA;&#xD;&#xA;* [Paul Badger: smooth digital low-pass filter][1]&#xD;&#xA;* [Paul Badger: digitalSmooth digital low-pass filter with outlier rejection][2]&#xD;&#xA;* [David A. Mellis and Tom Igoe: Smoothing tutorial][3]&#xD;&#xA;* [Majenki: Average Library][4]&#xD;&#xA;&#xD;&#xA;signal-smoothing libraries at github:&#xD;&#xA;&#xD;&#xA;* [AsheeshR / Microsmooth][5]&#xD;&#xA;* [jeroendoggen: Arduino-signal-filtering-library][6]&#xD;&#xA;* [karlward: Arduino data filtering library][7]&#xD;&#xA;* [sebnil: FIR-filter-Arduino-Library][8]&#xD;&#xA;* [daPhoosa: MedianFilter][9]&#xD;&#xA;* [arc12: A Collection of Digital Signal Filters (intended for use with Arduino)][10]&#xD;&#xA;* [sebnil: Selfbalancing robot in Arduino. Implemented with PID controllers, FIR filters, complementary filter.][11]&#xD;&#xA;&#xD;&#xA;Would something like this work in your robot?&#xD;&#xA;(The median-of-3 requires very little CPU power, and hence fast):&#xD;&#xA;&#xD;&#xA;    /*&#xD;&#xA;    median_filter.ino&#xD;&#xA;    2014-03-25: started by David Cary&#xD;&#xA;    */&#xD;&#xA;    &#xD;&#xA;    int median_of_3( int a, int b, int c ){&#xD;&#xA;        int the_max = max( max( a, b ), c );&#xD;&#xA;        int the_min = min( min( a, b ), c );&#xD;&#xA;        // unnecessarily clever code&#xD;&#xA;        int the_median = the_max ^ the_min ^ a ^ b ^ c;&#xD;&#xA;        return( the_median );&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int newest = 0;&#xD;&#xA;    int recent = 0;&#xD;&#xA;    int oldest = 0;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;        // read first value, initialize with it.&#xD;&#xA;        oldest = random(200);&#xD;&#xA;        recent = oldest;&#xD;&#xA;        newest = recent;&#xD;&#xA;        Serial.println(&quot;median filter example: &quot;);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        // drop oldest value and shift in latest value&#xD;&#xA;        oldest = recent;&#xD;&#xA;        recent = newest;&#xD;&#xA;        newest = random(200);&#xD;&#xA;    &#xD;&#xA;        Serial.print(&quot;new value: &quot;);&#xD;&#xA;        Serial.print(newest, DEC);&#xD;&#xA;    &#xD;&#xA;        int median = median_of_3( oldest, recent, newest );&#xD;&#xA;    &#xD;&#xA;        Serial.print(&quot;smoothed value: &quot;);&#xD;&#xA;        Serial.print(median, DEC);&#xD;&#xA;        Serial.println(&quot;&quot;);&#xD;&#xA;    &#xD;&#xA;        delay(5000);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Main/Smooth&#xD;&#xA;  [2]: http://playground.arduino.cc/Main/DigitalSmooth&#xD;&#xA;  [3]: http://arduino.cc/en/Tutorial/Smoothing&#xD;&#xA;  [4]: http://playground.arduino.cc/Main/Average&#xD;&#xA;  [5]: https://github.com/AsheeshR/Microsmooth&#xD;&#xA;  [6]: http://github.com/jeroendoggen/Arduino-signal-filtering-library&#xD;&#xA;  [7]: http://github.com/karlward/Filter&#xD;&#xA;  [8]: http://github.com/sebnil/FIR-filter-Arduino-Library&#xD;&#xA;  [9]: http://github.com/daPhoosa/MedianFilter&#xD;&#xA;  [10]: http://github.com/arc12/LibSimpleFilters&#xD;&#xA;  [11]: http://github.com/sebnil/Selfbalancing-robot" />
  <row Id="2636" PostHistoryTypeId="2" PostId="931" RevisionGUID="defcd8da-750b-4e80-a729-88dea4568f14" CreationDate="2014-03-26T17:39:33.920" UserId="46" Text="The short answer is that you have **100 miliseconds** to respond to the user if you want them to think the action occurred instantaneously.&#xD;&#xA;&#xD;&#xA;According to [Jacob Nielsen](http://www.nngroup.com/articles/author/jakob-nielsen/) in his book [Usability Engineering](http://www.nngroup.com/books/usability-engineering/), from 1993, which is considered an important reference in Systems Usability or User Experience:&#xD;&#xA;&#xD;&#xA;&gt; * **0.1 second** is about the limit for having the user feel that the system is reacting instantaneously, meaning that no special feedback is necessary except to display the result.&#xD;&#xA;&#xD;&#xA;He also mentions that this basic advice regarding response times has been about the same for many decades [Miller 1968; Card et al. 1991].&#xD;&#xA;&#xD;&#xA;I've taken this citation from this article: [Response Times: The 3 Important Limits](http://www.nngroup.com/articles/response-times-3-important-limits/), also writen by Jacob Nielsen.&#xD;&#xA;&#xD;&#xA;Notice that in this time you must include all time taken to read the button press and give feedback to the user.&#xD;&#xA;&#xD;&#xA;Other response time thresholds that are important for user experience, from the same source, but that were not mentioned directly by the OP are:&#xD;&#xA;&#xD;&#xA;&gt; * 1.0 second is about the limit for the user's flow of thought to stay uninterrupted, even though the user will notice the delay. Normally, no special feedback is necessary during delays of more than 0.1 but less than 1.0 second, but the user does lose the feeling of operating directly on the data.&#xD;&#xA;&#xD;&#xA;&gt; * 10 seconds is about the limit for keeping the user's attention focused on the dialogue. For longer delays, users will want to perform other tasks while waiting for the computer to finish, so they should be given feedback indicating when the computer expects to be done. Feedback during the delay is especially important if the response time is likely to be highly variable, since users will then not know what to expect.&#xD;&#xA;" />
  <row Id="2637" PostHistoryTypeId="5" PostId="931" RevisionGUID="dfb71285-349f-4536-8c3c-ceec07aafea7" CreationDate="2014-03-26T17:45:10.557" UserId="46" Comment="deleted 2 characters in body" Text="The short answer is that you have **100 miliseconds** to respond to the user if you want them to think the action occurred instantaneously.&#xD;&#xA;&#xD;&#xA;According to [Jacob Nielsen](http://www.nngroup.com/articles/author/jakob-nielsen/) in his book [Usability Engineering](http://www.nngroup.com/books/usability-engineering/), from 1993, which is considered an important reference in Systems Usability or User Experience:&#xD;&#xA;&#xD;&#xA;&gt; * **0.1 second** is about the limit for having the user feel that the system is reacting instantaneously, meaning that no special feedback is necessary except to display the result.&#xD;&#xA;&#xD;&#xA;He also mentions that this basic advice regarding response times has been about the same for many decades [Miller 1968; Card et al. 1991].&#xD;&#xA;&#xD;&#xA;I've taken this citation from this article: [Response Times: The 3 Important Limits](http://www.nngroup.com/articles/response-times-3-important-limits/), also writen by Jacob Nielsen.&#xD;&#xA;&#xD;&#xA;Note that in this time you must include all time taken to read the button press and give feedback to the user.&#xD;&#xA;&#xD;&#xA;Other response time thresholds that are important for user experience, from the same source, but that were not mentioned directly by the OP are:&#xD;&#xA;&#xD;&#xA;&gt; * 1.0 second is about the limit for the user's flow of thought to stay uninterrupted, even though the user will notice the delay. Normally, no special feedback is necessary during delays of more than 0.1 but less than 1.0 second, but the user does lose the feeling of operating directly on the data.&#xD;&#xA;&#xD;&#xA;&gt; * 10 seconds is about the limit for keeping the user's attention focused on the dialogue. For longer delays, users will want to perform other tasks while waiting for the computer to finish, so they should be given feedback indicating when the computer expects to be done. Feedback during the delay is especially important if the response time is likely to be highly variable, since users will then not know what to expect.&#xD;&#xA;" />
  <row Id="2638" PostHistoryTypeId="2" PostId="932" RevisionGUID="05f60e59-f65c-45ff-947b-d1c231101914" CreationDate="2014-03-26T17:55:03.483" UserId="815" Text="Well, it depends on what you have attached to the Arduino. If you are using the pins to do things you will defiantly require more current. &#xD;&#xA;&#xD;&#xA;If you are only want to ONLY power the arduino, then I calculated what I think it should be below. (You should also check with someone who own this device for an experimental value, and not just a calculated value. )&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Based on the datasheet (fig 30-8, p 319), I would say the the processor will draw around 2.4 mA at 5 volts.  &#xD;&#xA;http://www.atmel.com/images/doc2545.pdf&#xD;&#xA;&#xD;&#xA;The USB chip draws around 15 mA depending on several things (p 18)&#xD;&#xA;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT232R.pdf&#xD;&#xA;&#xD;&#xA;Then you have 2 leds with 680 ohm resistors. (Assuming 2 volt drop for each led)&#xD;&#xA;(5-2)/680  = around 4 mA per led.&#xD;&#xA;&#xD;&#xA;So depending on how much you use the serial port, and the leds I would guess around (2.4 + 15 + 4*4) = 33.4 mA&#xD;&#xA;&#xD;&#xA;33.4 mA * 5V  = 0.167 Watts&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Let me know if my number is way off." />
  <row Id="2639" PostHistoryTypeId="5" PostId="932" RevisionGUID="4033252a-32fe-4d85-820b-e7f76f6edbba" CreationDate="2014-03-26T18:11:05.670" UserId="815" Comment="added 1 characters in body" Text="Well, it depends on what you have attached to the Arduino. If you are using the pins to do things you will defiantly require more current. &#xD;&#xA;&#xD;&#xA;If you are only want to ONLY power the arduino, then I calculated what I think it should be below. (You should also check with someone who owns this device for an experimental value, and not just a calculated value. )&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Based on the datasheet (fig 30-8, p 319), I would say the the processor will draw around 2.4 mA at 5 volts.  &#xD;&#xA;http://www.atmel.com/images/doc2545.pdf&#xD;&#xA;&#xD;&#xA;The USB chip draws around 15 mA depending on several things (p 18)&#xD;&#xA;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT232R.pdf&#xD;&#xA;&#xD;&#xA;Then you have 2 leds with 680 ohm resistors. (Assuming 2 volt drop for each led)&#xD;&#xA;(5-2)/680  = around 4 mA per led.&#xD;&#xA;&#xD;&#xA;So depending on how much you use the serial port, and the leds I would guess around (2.4 + 15 + 4*4) = 33.4 mA&#xD;&#xA;&#xD;&#xA;33.4 mA * 5V  = 0.167 Watts&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Let me know if my number is way off." />
  <row Id="2640" PostHistoryTypeId="5" PostId="932" RevisionGUID="0257cd57-2e36-40b2-ad82-b9deacdbcb5d" CreationDate="2014-03-26T18:29:09.363" UserId="815" Comment="added 1 characters in body" Text="Well, it depends on what you have attached to the Arduino. If you are using the pins to do things you will defiantly require more current. &#xD;&#xA;&#xD;&#xA;If you are only want to **ONLY power the arduino**, then I calculated what I think it should be below. (You should also check with someone who owns this device for an experimental value, and not just a calculated value. )&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Based on the datasheet (fig 30-8, p 319), I would say the the processor will draw around 2.4 mA at 5 volts.  &#xD;&#xA;http://www.atmel.com/images/doc2545.pdf&#xD;&#xA;&#xD;&#xA;The USB chip draws around 15 mA depending on several things (p 18)&#xD;&#xA;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT232R.pdf&#xD;&#xA;&#xD;&#xA;Then you have 2 leds with 680 ohm resistors. (Assuming 2 volt drop for each led)&#xD;&#xA;(5-2)/680  = around 4 mA per led.&#xD;&#xA;&#xD;&#xA;So depending on how much you use the serial port, and the leds I would guess around (2.4 + 15 + 4*4) = 33.4 mA&#xD;&#xA;&#xD;&#xA;33.4 mA * 5V  = 0.167 Watts&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I suspect you want to know to the **total amount of power the arduino can source**, which is a bit harder to calculate.&#xD;&#xA;&#xD;&#xA;The pins can provide up to 200 mA. (p 303 http://www.atmel.com/images/doc2545.pdf)&#xD;&#xA;So 33.4 + 200 = 233.4&#xD;&#xA;&#xD;&#xA;I would also add a 20% safety margin (around 50 mA)&#xD;&#xA;So I would want a 280 mA supply, if I was going to attach the arduino to different things.&#xD;&#xA;&#xD;&#xA;280 mA * 5 = 1.4 Watts&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Let me know if my numbers are way off." />
  <row Id="2641" PostHistoryTypeId="5" PostId="932" RevisionGUID="253b7e81-479e-45c9-bcc5-cdb1eb7f4550" CreationDate="2014-03-26T18:36:15.473" UserId="815" Comment="added 1 characters in body" Text="Well, it depends on what you have attached to the Arduino. If you are using the pins to do things you will defiantly require more current. &#xD;&#xA;&#xD;&#xA;If you are only want to **ONLY power the arduino**, then I calculated what I think it should be below. (You should also check with someone who owns this device for an experimental value, and not just a calculated value. )&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Based on the datasheet (fig 30-8, p 319), I would say the the processor will draw around 2.4 mA at 5 volts.  &#xD;&#xA;http://www.atmel.com/images/doc2545.pdf&#xD;&#xA;&#xD;&#xA;The USB chip draws around 15 mA depending on several things (p 18)&#xD;&#xA;http://www.ftdichip.com/Support/Documents/DataSheets/ICs/DS_FT232R.pdf&#xD;&#xA;&#xD;&#xA;Then you have 2 leds with 680 ohm resistors. (Assuming 2 volt drop for each led)&#xD;&#xA;(5-2)/680  = around 4 mA per led.&#xD;&#xA;&#xD;&#xA;So depending on how much you use the serial port, and the leds I would guess around (2.4 + 15 + 4*4) = 33.4 mA&#xD;&#xA;&#xD;&#xA;33.4 mA * 5V  = 0.167 Watts&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I suspect you want to know to the **total amount of power the arduino can source**, which is a bit harder to calculate.&#xD;&#xA;&#xD;&#xA;The pins can provide up to 200 mA. (p 303 http://www.atmel.com/images/doc2545.pdf)&#xD;&#xA;So 33.4 + 200 = 233.4&#xD;&#xA;&#xD;&#xA;I would also add a 20% safety margin (around 50 mA)&#xD;&#xA;So I would want a 280 mA supply, if I was going to attach the arduino to different things.&#xD;&#xA;&#xD;&#xA;**280 mA * 5 = 1.4 Watts**&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Let me know if my numbers are way off.&#xD;&#xA;&#xD;&#xA;PS:Be careful making your own supply. It is critical that the voltage be very stable. An unstable supply can/will destroy an ardiuno. I suggest using a [liner regulator][1], like the [lm7805][2]. or maybe the [lm317][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Linear_regulator&#xD;&#xA;  [2]: http://www.fairchildsemi.com/ds/LM/LM7805.pdf&#xD;&#xA;  [3]: http://www.fairchildsemi.com/ds/LM/LM317.pdf" />
  <row Id="2642" PostHistoryTypeId="5" PostId="925" RevisionGUID="53eb9e07-7df3-4e22-a01a-874763e679fd" CreationDate="2014-03-26T18:39:08.740" UserId="353" Comment="added 87 characters in body" Text="How about this, mapping to 50..249?&#xD;&#xA;&#xD;&#xA;    output = ((input * 25) &gt;&gt; 7)+50;&#xD;&#xA;    &#xD;&#xA;Your input range was 1024 (0..1023). Output range is 200 (In the original specification, it would have been 201, which does not divide as neatly). These have a gcd of 8, so `output = (input * (200/8)) / (1024/8) + 50` will do, and the division by a power of 2 can be expressed with a shift. The nice thing is that `1024*25` still fits into a 16 bit integer, so no longs are needed.&#xD;&#xA;&#xD;&#xA;If you want full range, you can try throwing in rounding&#xD;&#xA;&#xD;&#xA;    output = ((input*25+64) &gt;&gt; 7)+50;" />
  <row Id="2643" PostHistoryTypeId="2" PostId="933" RevisionGUID="9ac6a2d2-3770-4340-90d2-a623988c607c" CreationDate="2014-03-26T19:24:50.607" UserId="313" Text="This sounds like baud-rate mismatch. These dongles don't have a reset ability; they remember their most recent settings. [See my answer][1] to another user having trouble communicating with one these.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://electronics.stackexchange.com/a/103868/3361" />
  <row Id="2644" PostHistoryTypeId="2" PostId="934" RevisionGUID="7f335bd2-7f8f-4c2b-9120-d70ad80c67e7" CreationDate="2014-03-26T20:20:31.750" UserId="781" Text="**Heating Controller**&#xD;&#xA;&#xD;&#xA;You know how it is - you set the heating to come on at a certain time and how many days do you work late and it's been on full bore for hours, or you go away for a few days and forget to turn it off? Or the rare occasion that you get home early and the house is cold? I decided that the simple way to get around this was to build a device that would allow me to turn my heating on or off by text message / sms. It would be in addition to the existing control system so as not to lose the flexibility which that can provide.&#xD;&#xA;&#xD;&#xA;The project consists of a few major parts: an Arduino Uno clone, a Seeedstudio GSM shield, a DHT22 temperature sensor and a 25 amp SSR.&#xD;&#xA;&#xD;&#xA;**How it works:**&#xD;&#xA;&#xD;&#xA;The existing heating controls are set to 'Off' and the new controller is wired up to override them. The Uno is programmed to respond to three different messages - On, Off and Query. In the case of the latter the unit will read the DHT22 and reply to the sender with the current temperature and the status of the unit (on or off). If the command is either On or Off then it will respond with a confirmation of the action carried out. Once messages have been acted upon they are deleted; any messages that do not conform to the specific message structure are left in the SIM card memory and can be examined later if desired.&#xD;&#xA;&#xD;&#xA;Power to the unit is supplied by a five volt three amp switch mode power supply. As the power pins on the Arduino are simply exposing the board's internal 5v bus I decided to power the ensemble through these and configure the shield to draw  power from the Arduino.&#xD;&#xA;&#xD;&#xA;The unit has three status LEDs. One green one to indicate that there is power, a blue one to indicate that the GSM board is 'live' and a red one to indicate the status of the heating. These are in addition to the status LEDs provided on the Arduino and shield. There is also a push button switch that allows manual control of the heating, with a 100nF capacitor to handle the debounce. &#xD;&#xA;&#xD;&#xA;**Next:**&#xD;&#xA;&#xD;&#xA;Much of the code relies upon good old delay() to give the shield enough time to perform its actions. I plan to improve the code so that it waits for confirmation from the shield rather than assuming that it has done what it was told to within the time allocated! I will also add a 'still alive' feature - at fixed intervals turn off the blue LED, send the AT command to the shield and on an acknowledgement turn the LED on again. The shield is under software control so if it fails to respond then turn it off and back on again.&#xD;&#xA;  &#xD;&#xA;The whole ensemble is to be mounted in a suitable enclosure and mounted adjacent to the existing controller. I have an internally illuminated push button switch that I will use instead of separate switch and red LED to handle the override.&#xD;&#xA;&#xD;&#xA;Longer term I'm planning to add an RTC, a 20 x 4 LCD and additional push buttons to allow the unit to be programmed and act as a time switch as well. &#xD;&#xA;&#xD;&#xA;Prototyping has already started!&#xD;&#xA;&#xD;&#xA;**Conclusion.**&#xD;&#xA;&#xD;&#xA;There is something slightly decadent about waking up on a cold winter's rest day, sending a text message / sms to turn the heating on, and rolling over and going back to sleep for an hour! And when you realise that you haven't turned it off on a night you can do so from the comfort of your bed!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![Controller Image 1][1]&#xD;&#xA;![Controller Image 2][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/yYGiv.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/raCwl.jpg" />
  <row Id="2645" PostHistoryTypeId="2" PostId="935" RevisionGUID="86a58e7e-258d-4faa-8747-4d6ccd7f8b81" CreationDate="2014-03-26T20:44:02.157" UserId="819" Text="I have done quite a few projects with Arduino, but have never done more than a &quot;Hello World&quot; in C. I am writing my first library, and a lot of the object oriented stuff is going over my head. Anyway, my library is working as it is supposed to, I pass a float to my function and it formats it properly and sends it out over serial. However, I implemented it in a clunky way. The Arduino API Style Guide mentions a way that seems much better:&#xD;&#xA;&#xD;&#xA;&gt; When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;. This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like SoftwareSerial. The Stream object can be passed to your library's constructor or to a begin() function (as a reference, not a pointer). See Firmata 2.3 or XBee 0.4 for examples of each approach.&#xD;&#xA;&#xD;&#xA;Can anybody elaborate on how to do this, or show me some code?" />
  <row Id="2646" PostHistoryTypeId="1" PostId="935" RevisionGUID="86a58e7e-258d-4faa-8747-4d6ccd7f8b81" CreationDate="2014-03-26T20:44:02.157" UserId="819" Text="Writing First Library - Serial Stream Object" />
  <row Id="2647" PostHistoryTypeId="3" PostId="935" RevisionGUID="86a58e7e-258d-4faa-8747-4d6ccd7f8b81" CreationDate="2014-03-26T20:44:02.157" UserId="819" Text="&lt;serial&gt;&lt;c++&gt;" />
  <row Id="2649" PostHistoryTypeId="6" PostId="935" RevisionGUID="6364baa4-d1f9-4921-9dca-ca0407e40a4e" CreationDate="2014-03-26T20:49:48.390" UserId="819" Comment="edited tags" Text="&lt;serial&gt;&lt;c++&gt;&lt;library&gt;" />
  <row Id="2650" PostHistoryTypeId="5" PostId="935" RevisionGUID="6364baa4-d1f9-4921-9dca-ca0407e40a4e" CreationDate="2014-03-26T20:49:48.390" UserId="819" Comment="edited tags" Text="I have done quite a few projects with Arduino, but have never done more than a &quot;Hello World&quot; in C. I am writing my first library, and a lot of the object oriented stuff is going over my head. Anyway, my library is working as it is supposed to, I pass a float to my function and it formats it properly and sends it out over serial. However, I implemented it in a clunky way. The [Arduino API Style Guide](http://arduino.cc/en/Reference/APIStyleGuide) mentions a way that seems much better:&#xD;&#xA;&#xD;&#xA;&gt; When using serial communication, allow the user to specify any Stream object, rather than hard-coding &quot;Serial&quot;. This will make your library compatible all serial ports on Mega and the Due, and can also use alternate interfaces like SoftwareSerial. The Stream object can be passed to your library's constructor or to a begin() function (as a reference, not a pointer). See Firmata 2.3 or XBee 0.4 for examples of each approach.&#xD;&#xA;&#xD;&#xA;Can anybody elaborate on how to do this, or show me some code?" />
  <row Id="2651" PostHistoryTypeId="5" PostId="929" RevisionGUID="19e5a27e-aa24-45a4-a61f-90b59df0c839" CreationDate="2014-03-26T21:40:57.043" UserId="136" Comment="added 1 characters in body" Text="Whilst it is possible, and sometimes desirable, to use pin change interrupts to read the state of buttons, it is simpler to poll the state of buttons in `loop()`. This is a commonly used technique.&#xD;&#xA;&#xD;&#xA;If you `loop()` executes quickly enough, then button presses are always going to be caught and the user will not be able to perceive any delay or lag.&#xD;&#xA;&#xD;&#xA;It is possible that your loop would take so long as to cause a delay or lag to be perceived.&#xD;&#xA;&#xD;&#xA;The question is, how long would it be, in general, before a user would see this?" />
  <row Id="2652" PostHistoryTypeId="2" PostId="936" RevisionGUID="52642a25-762b-4cd8-8c6f-874b7ab6155c" CreationDate="2014-03-26T23:18:58.250" UserId="666" Text="Here is a simple example (built and tested with a mega2560), with a class that can be passed a Stream object, and sends a Hello over this generic stream object. When constructing the object, you can pass the Stream object you want to actually communicate:&#xD;&#xA;&#xD;&#xA;    #include &quot;Arduino.h&quot;&#xD;&#xA;    &#xD;&#xA;    class MyProtocol&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;    	MyProtocol(Stream&amp; s):serial(s){}&#xD;&#xA;    	void send(){&#xD;&#xA;    		serial.println(&quot;Hello&quot;);&#xD;&#xA;    	}&#xD;&#xA;    private:&#xD;&#xA;    	Stream&amp; serial;&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    MyProtocol p(Serial);&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;    	Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        delay(1000);&#xD;&#xA;    	p.send();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;NOTE: The serial.println() is not the Serial global object, note the lower case, it is the internal Stream class variable." />
  <row Id="2653" PostHistoryTypeId="2" PostId="937" RevisionGUID="cb835171-cd4b-46b8-8aab-53202dc23ed2" CreationDate="2014-03-27T00:16:39.127" UserId="86" Text="I think this kind of barely fits within the rules, but it's interesting enough that I figure I'd post it anyways.&#xD;&#xA;&#xD;&#xA;# High-Precision, GPS-Synchronized timestamp generator for data-acquisition purposes.&#xD;&#xA;This is a rather interesting project that is intended to be used for providing a easy way of synchronizing multiple independent data-acquisition systems.&#xD;&#xA;&#xD;&#xA;Basically, I work in a research lab, and we often have instruments that have multiple independent data-acquisition systems. We need to be able to correlate the time at which samples from each system were taken, which can be difficult if you want to resolve sampling-times to a great degree of precision. Using something like a USB data-acquisition system, just the USB latency can introduce several hundred milliseconds of unknown latency, that can vary from acquisition to acquisition.&#xD;&#xA;&#xD;&#xA;The previous solution was a 24-bit parallel counter that was simply bussed everywhere, requiring an enormous wiring harness, and was kind of a pain in the butt.&#xD;&#xA;&#xD;&#xA;This system uses a [specialized timing GPS module](https://www.u-blox.com/de/lea-6t.html) that can synthesize arbitrary frequency clocks, that are phase and frequency locked to the atomic clocks in the GPS satellites. &#xD;&#xA;&#xD;&#xA;The MCU is responsible for tying together the GPS data messages (I had to heavily extend and optimize a existing protocol parser for the GPS data). The GPS is configured to use a proprietary binary protocol, and it's all parsed by the parser I wrote.&#xD;&#xA;&#xD;&#xA;The project has gone through a number of revisions (pictured below).&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;Revisions!&#xD;&#xA;![enter image description here][1]  &#xD;&#xA;Rev 1: Never worked, due to the fact that I was initially hoping to use a software dPLL off a much less expensive GPS, to synthesize a higher-frequency clock from only the 1 PPS output. It's probably possible to make it work, but the time-investment just made it not worthwhile. (and I'm too crappy a coder)&#xD;&#xA;&#xD;&#xA;Used a parallax propeller MCU. The lack of decent compiled languages was a major issue as well.&#xD;&#xA;&#xD;&#xA;![enter image description here][2]   &#xD;&#xA;Rev 2: Shifted to a ATmega2560. Worked, had lots of funky design aspects inherited from the first rev. Primarily, the continued use of shift-registers for the 32-bit output, despite the more then sufficient number of IO on the ATmega2560.&#xD;&#xA;&#xD;&#xA;First board that ran Optiboot, and was actually programmed entirely using the standard Arduino toolchain, before I got irritated with it and started modifying the toolchain to better suit my purposes.&#xD;&#xA;&#xD;&#xA;![enter image description here][3]  &#xD;&#xA;Rev 3: Also worked. The bodged wiring is because this board incorporated a built-in USB hub to reduce the number of required USB ports (the FTDI interface requires 1 USB, and the GPS has a USB interface as well). Unfortunately, the GPS wouldn't properly enumerate, though the FTDI device worked fine, and I've used this hub elsewhere without issue. Weird.&#xD;&#xA;&#xD;&#xA;![enter image description here][4]  &#xD;&#xA;Rev 4: Semi-final ATmega2560 version. Added a LCD for GPS status, fiddled with LEDs and so forth. Also, better footprints for the possible super-capacitors for maintaining the GPS status when not powered.&#xD;&#xA;&#xD;&#xA;This is the last Optiboot version.&#xD;&#xA;&#xD;&#xA;![enter image description here][5]  &#xD;&#xA;Rev 5: Complete architecture switch. Now uses a ATxmega128A1U processor. Not really &quot;Arduino&quot; at all anymore, but the ability to have multiple interrupt levels on the xmega processor series allowed me to considerably improve the code structure. &#xD;&#xA;&#xD;&#xA;The two bodge-wires are from me doing some experimentation, the board worked fine without them as well.&#xD;&#xA;&#xD;&#xA;### Looking forward:&#xD;&#xA;&#xD;&#xA;Rev 6!&#xD;&#xA;![enter image description here][6]  &#xD;&#xA;Add the ability to use different LCD sizes, more ESD protection on GPS antenna connection (that was an issue), ability to use a CR2032 battery for maintaining the GPS clock instead of super-capacitors.&#xD;&#xA;&#xD;&#xA;Also, much better labeling of debug and status LEDs.&#xD;&#xA;&#xD;&#xA;![enter image description here][7]  &#xD;&#xA;And bonus Nyan-Cat!&#xD;&#xA;&#xD;&#xA;(These boards are out for fabrication right now. When I get them, I'll add pictures of the real board.)&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;I did some long-duration testing between two of the ATmega2560 boards, and over 72 hours, the RMS time-error between the two units was ~20 uS. My design goal was &lt; 1 ms, so I'm pretty damn happy with that.&#xD;&#xA;&#xD;&#xA;On the whole, I think this does a good job illustrating how Arduino can be a useful tool for &#xD;&#xA;early prototyping for &quot;real&quot; products/systems. I use it for getting an initial test-version running with minimal effort, and when I'm confident the *idea* will work, I actually put the work in to migrate away to a completely custom, purpose-specific implementation.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Something is going on with my SVN server at the moment, and anonymous login isn't working, so I can't post links to the source and board files. When I get it fixed, I'll edit that in.&#xD;&#xA;&#xD;&#xA;Sorry for the crappy cell-phone pictures.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/Zt8N8.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/m40P9.jpg&#xD;&#xA;  [3]: http://i.stack.imgur.com/PjfGb.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/18PyD.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/qLfpS.jpg&#xD;&#xA;  [6]: http://i.stack.imgur.com/zdher.jpg&#xD;&#xA;  [7]: http://i.stack.imgur.com/fdMJZ.jpg" />
  <row Id="2654" PostHistoryTypeId="5" PostId="937" RevisionGUID="b653dd90-4652-4de6-be41-2061d1049de1" CreationDate="2014-03-27T00:26:40.040" UserId="86" Comment="added 802 characters in body" Text="I think this kind of barely fits within the rules, but it's interesting enough that I figure I'd post it anyways.&#xD;&#xA;&#xD;&#xA;# High-Precision, GPS-Synchronized timestamp generator for data-acquisition purposes.&#xD;&#xA;This is a rather interesting project that is intended to be used for providing a easy way of synchronizing multiple independent data-acquisition systems.&#xD;&#xA;&#xD;&#xA;Basically, I work in a research lab, and we often have instruments that have multiple independent data-acquisition systems. We need to be able to correlate the time at which samples from each system were taken, which can be difficult if you want to resolve sampling-times to a great degree of precision. Using something like a USB data-acquisition system, just the USB latency can introduce several hundred milliseconds of unknown latency, that can vary from acquisition to acquisition.&#xD;&#xA;&#xD;&#xA;The previous solution was a 24-bit parallel counter that was simply bussed everywhere, requiring an enormous wiring harness, and was kind of a pain in the butt.&#xD;&#xA;&#xD;&#xA;This system uses a [specialized timing GPS module](https://www.u-blox.com/de/lea-6t.html) that can synthesize arbitrary frequency clocks, that are phase and frequency locked to the atomic clocks in the GPS satellites. &#xD;&#xA;&#xD;&#xA;The MCU is responsible for tying together the GPS data messages (I had to heavily extend and optimize a existing protocol parser for the GPS data). The GPS is configured to use a proprietary binary protocol, and it's all parsed by the parser I wrote.&#xD;&#xA;&#xD;&#xA;The project has gone through a number of revisions (pictured below).&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;Revisions!&#xD;&#xA;![enter image description here][1]  &#xD;&#xA;Rev 1: Never worked, due to the fact that I was initially hoping to use a software dPLL off a much less expensive GPS, to synthesize a higher-frequency clock from only the 1 PPS output. It's probably possible to make it work, but the time-investment just made it not worthwhile. (and I'm too crappy a coder)&#xD;&#xA;&#xD;&#xA;Used a parallax propeller MCU. The lack of decent compiled languages was a major issue as well.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][2]   &#xD;&#xA;Rev 2: Shifted to a ATmega2560. Worked, had lots of funky design aspects inherited from the first rev. Primarily, the continued use of shift-registers for the 32-bit output, despite the more then sufficient number of IO on the ATmega2560.&#xD;&#xA;&#xD;&#xA;First board that ran Optiboot, and was actually programmed entirely using the standard Arduino toolchain, before I got irritated with it and started modifying the toolchain to better suit my purposes.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][3]  &#xD;&#xA;Rev 3: Also worked. The bodged wiring is because this board incorporated a built-in USB hub to reduce the number of required USB ports (the FTDI interface requires 1 USB, and the GPS has a USB interface as well). Unfortunately, the GPS wouldn't properly enumerate, though the FTDI device worked fine, and I've used this hub elsewhere without issue. Weird.&#xD;&#xA;&#xD;&#xA;I don't have a proper USB debugger, so I just dropped the USB hub entirely, rather then trying to fix the issue. The GPS usb isn't *really* used much outside of set-up anyways.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][4]  &#xD;&#xA;Rev 4: Semi-final ATmega2560 version. Added a LCD for GPS status, fiddled with LEDs and so forth. Also, better footprints for the possible super-capacitors for maintaining the GPS status when not powered.&#xD;&#xA;&#xD;&#xA;This is the last Optiboot version.&#xD;&#xA;&#xD;&#xA;`MStime` is the `MSTOW`, or Millisecond-Time-Of-Week, which is the name of the GPS data value that is output on the timestamp out. It's a 32-bit variable that increments once per milliseond, and rolls over each week. It's a more obscure part of the GPS standard.&#xD;&#xA;&#xD;&#xA;`ITOW` is another GPS-related value, being a value that corresponds to the 1PPS signal. The correlation between the two isn't properly reflected on the LCD, since I do not have the CPU time to update the LCD at the rate I'd like. This was actually one of the major things that improved in the upgrade to the Xmega devices.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][5]  &#xD;&#xA;Rev 5: Complete architecture switch. Now uses a ATxmega128A1U processor. Not really &quot;Arduino&quot; at all anymore, but the ability to have multiple interrupt levels on the xmega processor series allowed me to considerably improve the code structure. &#xD;&#xA;&#xD;&#xA;The two bodge-wires are from me doing some experimentation, the board worked fine without them as well.&#xD;&#xA;&#xD;&#xA;### Looking forward:&#xD;&#xA;&#xD;&#xA;Rev 6!&#xD;&#xA;![enter image description here][6]  &#xD;&#xA;Add the ability to use different LCD sizes, more ESD protection on GPS antenna connection (that was an issue), ability to use a CR2032 battery for maintaining the GPS clock instead of super-capacitors.&#xD;&#xA;&#xD;&#xA;Also, much better labeling of debug and status LEDs.&#xD;&#xA;&#xD;&#xA;![enter image description here][7]  &#xD;&#xA;And bonus Nyan-Cat!&#xD;&#xA;&#xD;&#xA;![enter image description here][8]&#xD;&#xA;&#xD;&#xA;(These boards are out for fabrication right now. When I get them, I'll add pictures of the real board.)&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;I did some long-duration testing between two of the ATmega2560 boards, and over 72 hours, the RMS time-error between the two units was ~20 uS. My design goal was &lt; 1 ms, so I'm pretty damn happy with that.&#xD;&#xA;&#xD;&#xA;On the whole, I think this does a good job illustrating how Arduino can be a useful tool for &#xD;&#xA;early prototyping for &quot;real&quot; products/systems. I use it for getting an initial test-version running with minimal effort, and when I'm confident the *idea* will work, I actually put the work in to migrate away to a completely custom, purpose-specific implementation.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Something is going on with my SVN server at the moment, and anonymous login isn't working, so I can't post links to the source and board files. When I get it fixed, I'll edit that in.&#xD;&#xA;&#xD;&#xA;Sorry for the crappy cell-phone pictures.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/Zt8N8.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/m40P9.jpg&#xD;&#xA;  [3]: http://i.stack.imgur.com/PjfGb.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/18PyD.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/qLfpS.jpg&#xD;&#xA;  [6]: http://i.stack.imgur.com/zdher.jpg&#xD;&#xA;  [7]: http://i.stack.imgur.com/fdMJZ.jpg&#xD;&#xA;  [8]: http://i.stack.imgur.com/lJSUA.png" />
  <row Id="2655" PostHistoryTypeId="5" PostId="937" RevisionGUID="6a5563bc-bf9e-41f2-be64-78a78bbb18bf" CreationDate="2014-03-27T00:33:53.847" UserId="86" Comment="added 112 characters in body" Text="I think this kind of barely fits within the rules, but it's interesting enough that I figure I'd post it anyways.&#xD;&#xA;&#xD;&#xA;# High-Precision, GPS-Synchronized timestamp generator for data-acquisition purposes.&#xD;&#xA;This is a rather interesting project that is intended to be used for providing a easy way of synchronizing multiple independent data-acquisition systems.&#xD;&#xA;&#xD;&#xA;Basically, I work in a research lab, and we often have instruments that have multiple independent data-acquisition systems, which can be physically separated by as much as 50 feet. We need to be able to correlate the time at which samples from each system were taken, which can be difficult if you want to resolve sampling-times to a great degree of precision. Using something like a USB data-acquisition system, just the USB latency can introduce several hundred milliseconds of unknown latency, that can vary from acquisition to acquisition.&#xD;&#xA;&#xD;&#xA;The previous solution was a 24-bit parallel counter that was simply bussed everywhere, requiring an enormous wiring harness, and was kind of a pain in the butt.&#xD;&#xA;&#xD;&#xA;This system uses a [specialized timing GPS module](https://www.u-blox.com/de/lea-6t.html) that can synthesize arbitrary frequency clocks, that are phase and frequency locked to the atomic clocks in the GPS satellites. &#xD;&#xA;&#xD;&#xA;The MCU is responsible for tying together the GPS data messages (I had to heavily extend and optimize a existing protocol parser for the GPS data). The GPS is configured to use a proprietary binary protocol, and it's all parsed by the parser I wrote.&#xD;&#xA;&#xD;&#xA;The project has gone through a number of revisions (pictured below).&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;Revisions!&#xD;&#xA;![enter image description here][1]  &#xD;&#xA;Rev 1: Never worked, due to the fact that I was initially hoping to use a software dPLL off a much less expensive GPS, to synthesize a higher-frequency clock from only the 1 PPS output. It's probably possible to make it work, but the time-investment just made it not worthwhile. (and I'm too crappy a coder)&#xD;&#xA;&#xD;&#xA;Used a parallax propeller MCU. The lack of decent compiled languages was a major issue as well.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][2]   &#xD;&#xA;Rev 2: Shifted to a ATmega2560. Worked, had lots of funky design aspects inherited from the first rev. Primarily, the continued use of shift-registers for the 32-bit output, despite the more then sufficient number of IO on the ATmega2560.&#xD;&#xA;&#xD;&#xA;First board that ran Optiboot, and was actually programmed entirely using the standard Arduino toolchain, before I got irritated with it and started modifying the toolchain to better suit my purposes.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][3]  &#xD;&#xA;Rev 3: Also worked. The bodged wiring is because this board incorporated a built-in USB hub to reduce the number of required USB ports (the FTDI interface requires 1 USB, and the GPS has a USB interface as well). Unfortunately, the GPS wouldn't properly enumerate, though the FTDI device worked fine, and I've used this hub elsewhere without issue. Weird.&#xD;&#xA;&#xD;&#xA;I don't have a proper USB debugger, so I just dropped the USB hub entirely, rather then trying to fix the issue. The GPS usb isn't *really* used much outside of set-up anyways.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][4]  &#xD;&#xA;Rev 4: Semi-final ATmega2560 version. Added a LCD for GPS status, fiddled with LEDs and so forth. Also, better footprints for the possible super-capacitors for maintaining the GPS status when not powered.&#xD;&#xA;&#xD;&#xA;This is the last Optiboot version.&#xD;&#xA;&#xD;&#xA;`MStime` is the `MSTOW`, or Millisecond-Time-Of-Week, which is the name of the GPS data value that is output on the timestamp out. It's a 32-bit variable that increments once per milliseond, and rolls over each week. It's a more obscure part of the GPS standard.&#xD;&#xA;&#xD;&#xA;`ITOW` is another GPS-related value, being a value that corresponds to the 1PPS signal. The correlation between the two isn't properly reflected on the LCD, since I do not have the CPU time to update the LCD at the rate I'd like. This was actually one of the major things that improved in the upgrade to the Xmega devices.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][5]  &#xD;&#xA;Rev 5: Complete architecture switch. Now uses a ATxmega128A1U processor. Not really &quot;Arduino&quot; at all anymore, but the ability to have multiple interrupt levels on the xmega processor series allowed me to considerably improve the code structure. &#xD;&#xA;&#xD;&#xA;The two bodge-wires are from me doing some experimentation, the board worked fine without them as well.&#xD;&#xA;&#xD;&#xA;### Looking forward:&#xD;&#xA;&#xD;&#xA;Rev 6!&#xD;&#xA;![enter image description here][6]  &#xD;&#xA;Add the ability to use different LCD sizes, more ESD protection on GPS antenna connection (that was an issue), ability to use a CR2032 battery for maintaining the GPS clock instead of super-capacitors.&#xD;&#xA;&#xD;&#xA;Also, much better labeling of debug and status LEDs.&#xD;&#xA;&#xD;&#xA;![enter image description here][7]  &#xD;&#xA;And bonus Nyan-Cat!&#xD;&#xA;&#xD;&#xA;![enter image description here][8]&#xD;&#xA;&#xD;&#xA;(These boards are out for fabrication right now. When I get them, I'll add pictures of the real board.)&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;I did some long-duration testing between two of the ATmega2560 boards, and over 72 hours, the RMS time-error between the two units was ~20 uS. This was with two completely independent antennas too. My design goal was &lt; 1 ms, so I'm pretty damn happy with that.&#xD;&#xA;&#xD;&#xA;On the whole, I think this does a good job illustrating how Arduino can be a useful tool for &#xD;&#xA;early prototyping for &quot;real&quot; products/systems. I use it for getting an initial test-version running with minimal effort, and when I'm confident the *idea* will work, I actually put the work in to migrate away to a completely custom, purpose-specific implementation.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Something is going on with my SVN server at the moment, and anonymous login isn't working, so I can't post links to the source and board files. When I get it fixed, I'll edit that in.&#xD;&#xA;&#xD;&#xA;Sorry for the crappy cell-phone pictures.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/Zt8N8.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/m40P9.jpg&#xD;&#xA;  [3]: http://i.stack.imgur.com/PjfGb.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/18PyD.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/qLfpS.jpg&#xD;&#xA;  [6]: http://i.stack.imgur.com/zdher.jpg&#xD;&#xA;  [7]: http://i.stack.imgur.com/fdMJZ.jpg&#xD;&#xA;  [8]: http://i.stack.imgur.com/lJSUA.png" />
  <row Id="2656" PostHistoryTypeId="2" PostId="938" RevisionGUID="0e00de39-2273-44ca-b3d2-e334cf254136" CreationDate="2014-03-27T00:49:59.517" UserId="627" Text="It's commonly known that people are unable to perceive changes when they happen underneath 10ms after their action. This responsiveness will result in an experience that has recently mostly been described as &quot;snappy&quot;. It's noticeable but for users it's hard to put a name on it.&#xD;&#xA;&#xD;&#xA;So if you want perfection, take about 15ms of delay. If you want really good, take 100 ms of delay. 100ms is 50ms on average, and will certainly pass for people.&#xD;&#xA;&#xD;&#xA;The application and the expected response time is vital too. A sliding door or elevator is given very large tolerance (as the physical object will always take a lot more time) whereas ticket vending machine interfaces are not given any time at all.&#xD;&#xA;&#xD;&#xA;The upper limit for polling would be around 1500ms. Around there people will always notice it is slow.&#xD;&#xA;&#xD;&#xA;This data is purely personal experience as a gamer and programmer. YMMV and remember that just trying it yourself is the best way to find out how it feels. The only &quot;scientific&quot; answer is the &lt;10 milliseconds, beyond that it's about the ability to perceive the delay (which varies per person and moment) and the tolerance of the user.&#xD;&#xA;&#xD;&#xA;As a side note, you can try fluctuating the delays in order to conserve battery or CPU time when the interface is not being used. The user-action, the faster the polling. When the application is doing it's thing, poll very slowly. Better to poll when it matters!" />
  <row Id="2657" PostHistoryTypeId="2" PostId="939" RevisionGUID="aed3912b-7d6f-4863-b677-7014802f0133" CreationDate="2014-03-27T02:22:22.547" UserId="826" Text="I hope this question is specific enough. Basically I want to know if it matters a great deal what kind of Motor Driver IC(s) or pre-assembled kits you use to drive a Unipolar Stepper Motor.&#xD;&#xA;&#xD;&#xA;For example: Can the following Driver be used to control this Stepper Motor?&#xD;&#xA;&#xD;&#xA;Driver: https://www.sparkfun.com/products/9670&#xD;&#xA;&#xD;&#xA;Motor: http://www.jaycar.com.au/productView.asp?ID=YM2754&#xD;&#xA;&#xD;&#xA;Thanks!" />
  <row Id="2658" PostHistoryTypeId="1" PostId="939" RevisionGUID="aed3912b-7d6f-4863-b677-7014802f0133" CreationDate="2014-03-27T02:22:22.547" UserId="826" Text="Which type of Motor Drivers to drive Unipolar Stepper Motors?" />
  <row Id="2659" PostHistoryTypeId="3" PostId="939" RevisionGUID="aed3912b-7d6f-4863-b677-7014802f0133" CreationDate="2014-03-27T02:22:22.547" UserId="826" Text="&lt;motor&gt;" />
  <row Id="2660" PostHistoryTypeId="2" PostId="940" RevisionGUID="87d9ce3d-3ca0-4c11-9e2e-4fde1934cd9b" CreationDate="2014-03-27T02:25:16.213" UserId="825" Text="I am finishing up a project- an LED game alarm clock. Seeing as this is a clock, I need to have a way to conserve power, which right now my Uno R3+ is eating up like a politician. My question is, how do I turn the screen off, or turn the back-light off using software only on a Hitachi HD44780 16x2 LCD screen? Or how do I set a sleep mode on one component? The way I plan on turning it off is with an ultrasonic range finder, if I get close it turns on the screen. If anything I say doesn't make sense, ask me to clarify, I'm in a bit of a rush." />
  <row Id="2661" PostHistoryTypeId="1" PostId="940" RevisionGUID="87d9ce3d-3ca0-4c11-9e2e-4fde1934cd9b" CreationDate="2014-03-27T02:25:16.213" UserId="825" Text="Changing the brightness on a Hitachi HD44780 LCD screen" />
  <row Id="2662" PostHistoryTypeId="3" PostId="940" RevisionGUID="87d9ce3d-3ca0-4c11-9e2e-4fde1934cd9b" CreationDate="2014-03-27T02:25:16.213" UserId="825" Text="&lt;arduino-uno&gt;&lt;lcd&gt;" />
  <row Id="2663" PostHistoryTypeId="5" PostId="219" RevisionGUID="c8a64fe4-f644-4e9c-8065-2108ee4a9b76" CreationDate="2014-03-27T03:13:05.270" UserId="86" Comment="added 57 characters in body" Text="There are no runtime exceptions. There is only undefined behaviour.&#xD;&#xA;&#xD;&#xA;Really, there are no exceptions *at all*. If you try to perform an invalid operation, it's results will be unknown.&#xD;&#xA;&#xD;&#xA;There is no runtime checking at all, except what **you** implement. Your program is running on bare-metal hardware. It's the Desktop equivalent of running in [ring-0](http://en.wikipedia.org/wiki/Ring_(computer_security)) all the time, because the ATmega *doesn't have rings*. " />
  <row Id="2664" PostHistoryTypeId="2" PostId="941" RevisionGUID="e8d0c538-a6d8-4ec4-84d7-058cdce9080d" CreationDate="2014-03-27T03:20:14.087" UserId="368" Text="Instead of tying the backlight directly to V+ and GND, connect it to a PWM pin (you may need to use a separate driver if the pin cannot source/sink enough current). This will allow you to control the brightness via `analogWrite()`.&#xD;&#xA;&#xD;&#xA;Turn the LCD display off (`LiquidCrystal::noDisplay()`) when not actively in use. The contents will remain in memory but the LCD segments will not be driven.&#xD;&#xA;&#xD;&#xA;Set the various bits in the `PRR` register to disable any peripherals not it use.&#xD;&#xA;&#xD;&#xA;And *don't forget to sleep the CPU when it doesn't need to run*. See the &quot;Power Management and Sleep Modes&quot; section of the datasheet for more information about this and the `PRR` register, as well as the &lt;a href=&quot;http://www.nongnu.org/avr-libc/user-manual/group__avr__sleep.html&quot;&gt;`&lt;avr/sleep.h&gt;` documentation&lt;/a&gt; for AVR Libc." />
  <row Id="2665" PostHistoryTypeId="2" PostId="942" RevisionGUID="359d895c-b01b-4bb5-a47b-def2fb4d0dfb" CreationDate="2014-03-27T03:22:47.667" UserId="46" Text="Place a transistor in series with a 33R resistor between the LCD pin 16 (backlight ground) and GND and switch the transistor on and off with a digital pin. That way you'll be able to turn the backlight on and off.&#xD;&#xA;&#xD;&#xA;You can have a finer control over brightness if you put a PWM pulse on said pin. Just call `analogWrite(D3, value)` where `value` is the desired brightness.&#xD;&#xA;&#xD;&#xA;The schematics is below. It's from [Freetronics 16x2 LCD SHield](http://freetronics.com/16x2lcd).&#xD;&#xA;&#xD;&#xA;![LCD Brightness control][1]&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/g0D2T.png" />
  <row Id="2666" PostHistoryTypeId="5" PostId="215" RevisionGUID="94cb4717-932d-4657-99e5-bb82188c1893" CreationDate="2014-03-27T03:29:58.047" UserId="46" Comment="Fixed conceptual problem as pointed out by Connor Wolf." Text="First, let's see a few examples of what can go wrong.&#xD;&#xA;&#xD;&#xA;# Uninitialized variables #&#xD;&#xA;&#xD;&#xA;    int status;&#xD;&#xA;    pinMode(13, OUTPUT);&#xD;&#xA;    digitalWrite(13, status);&#xD;&#xA;&#xD;&#xA;Although the variable status is not explicitly initialized by the code above, the C++ compiler does that for you. It sets it as zero. So, even though it's not explicit in the code, we know that the led won't be lit. However, it's not considered good practice to rely on that behaviour. Try and assign values to your variables as it makes the code clearer.&#xD;&#xA;&#xD;&#xA;# Memory overflow #&#xD;&#xA;&#xD;&#xA;    int array[10];&#xD;&#xA;    int v = array[100];&#xD;&#xA;    array[-100] = 10;&#xD;&#xA;&#xD;&#xA;The first problem here is that you don't know what will be assigned to v, but worse is that you don't know what you messed up with the assignment to position -100 of `array`. The good news is that you only messed up with RAM and not with the Flash memory, thus your program is safe.&#xD;&#xA;&#xD;&#xA;# Jump to an illegal instruction #&#xD;&#xA;&#xD;&#xA;    void doSomething( void ) { &#xD;&#xA;        for (int i = 0; i &lt; 1000; i++); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void setup () &#xD;&#xA;    {&#xD;&#xA;        void (*funcPtr)( void );&#xD;&#xA;&#xD;&#xA;        funcPtr = &amp;doSomething;&#xD;&#xA;        funcPtr(); // calls doSomething();&#xD;&#xA;&#xD;&#xA;        funcPtr = NULL;&#xD;&#xA;        funcPtr(); // undefined behavior&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The first call to `funcPtr()` will actually be a call to `doSomething()`. Calls like the second one may lead to undefined behavior. In this case, it will continue execution from memory address 0, which seems to be the start of the sketch (I just tested and that's equivalent to a soft boot - it doesn't even go through the bootloader). &#xD;&#xA;&#xD;&#xA;# Other bad things that may happen #&#xD;&#xA;&#xD;&#xA;Well, you can run out of RAM, for example. What else. In any case, I think your program will keep running, probably not the way you intended it to.&#xD;&#xA;&#xD;&#xA;# Kinds of Protection #&#xD;&#xA;&#xD;&#xA;In computer systems, problems like these are usually dealt with at various levels:&#xD;&#xA;&#xD;&#xA;1. By the compiler&#xD;&#xA;1. By the programming language runtime (as in Java for example). &#xD;&#xA;1. By the operating system or the processor (if your memory access a position outside the boundaries of the address space reserved to your program, the OS or the processor may have safety mechanisms to prevent that)&#xD;&#xA;&#xD;&#xA;Arduinos only have limited protection of the compiler, and probably nothing else. The good news is that they aren't multi-tasked, so the only program being affected is yours. In any case, any of those bugs will lead to erratic behavior.&#xD;&#xA;&#xD;&#xA;# The Answers #&#xD;&#xA;&#xD;&#xA;The assumptions are the all of the problems I stated above are runtime problems.&#xD;&#xA;&#xD;&#xA;&gt; What happens if there is a runtime error in a program? &#xD;&#xA;&#xD;&#xA;The program will continue and what happens will depend on the side-effects of the runtime error. A call to the null function pointer will probably make the program jump to an unknown location.&#xD;&#xA;&#xD;&#xA;&gt; Will execution of the program just stop?&#xD;&#xA;&#xD;&#xA;No, it will keep going as if nothing extraordinary happened, probably doing what you didn't intend it to do. It may reset or act erratically. It may turn some inputs into outputs and burn a sensor or two (but that's *highly unlikely*).&#xD;&#xA;&#xD;&#xA;&gt; Is there some way I get the Arduino to tell me what the error is?&#xD;&#xA;&#xD;&#xA;I don't think so. As I said earlier, the protection mechanisms aren't there. There's no runtime support from the language, no OS, no hardware checks for out-of-bounds memory access (the bootloader doesn't count as either). You just have to be careful with your program and probably set your own safety nets. &#xD;&#xA;&#xD;&#xA;The reason for the lack of protection is probably because Arduino controllers are too cheap, have too little memory, and should not run anything too important (yes, there seems to be a disclaimer by AVR somewhere for you not to use the MCUs normally used by Arduino in life support systems).&#xD;&#xA;" />
  <row Id="2667" PostHistoryTypeId="5" PostId="931" RevisionGUID="e274587f-f6e3-464a-9015-5b45e2967e0a" CreationDate="2014-03-27T03:50:41.280" UserId="46" Comment="added 1 characters in body" Text="The short answer is that you have **100 miliseconds** to respond to the user if you want them to feel the action occurred instantaneously.&#xD;&#xA;&#xD;&#xA;According to [Jacob Nielsen](http://www.nngroup.com/articles/author/jakob-nielsen/) in his book [Usability Engineering](http://www.nngroup.com/books/usability-engineering/), from 1993, which is considered an important reference in Systems Usability and User Experience:&#xD;&#xA;&#xD;&#xA;&gt; * **0.1 second** is about the limit for having the user feel that the system is reacting instantaneously, meaning that no special feedback is necessary except to display the result.&#xD;&#xA;&#xD;&#xA;He also mentions that this basic advice regarding response times has been about the same for many decades [Miller 1968; Card et al. 1991]. &#xD;&#xA;&#xD;&#xA;I've taken this citation from this article: [Response Times: The 3 Important Limits](http://www.nngroup.com/articles/response-times-3-important-limits/), also writen by Jacob Nielsen.&#xD;&#xA;&#xD;&#xA;Note that in this time you must include all time taken to read the button press and give feedback to the user.&#xD;&#xA;&#xD;&#xA;Other response time thresholds that are important for user experience, from the same source, but that were not mentioned directly by the OP are:&#xD;&#xA;&#xD;&#xA;&gt; * 1.0 second is about the limit for the user's flow of thought to stay uninterrupted, even though the user will notice the delay. Normally, no special feedback is necessary during delays of more than 0.1 but less than 1.0 second, but the user does lose the feeling of operating directly on the data.&#xD;&#xA;&#xD;&#xA;&gt; * 10 seconds is about the limit for keeping the user's attention focused on the dialogue. For longer delays, users will want to perform other tasks while waiting for the computer to finish, so they should be given feedback indicating when the computer expects to be done. Feedback during the delay is especially important if the response time is likely to be highly variable, since users will then not know what to expect.&#xD;&#xA;" />
  <row Id="2668" PostHistoryTypeId="5" PostId="919" RevisionGUID="c214510e-caab-43ea-96f0-d0d825d0032d" CreationDate="2014-03-27T03:51:01.603" UserId="368" Comment="deleted 7 characters in body" Text="![Scaling calculation][1]&#xD;&#xA;&#xD;&#xA;The screenshot shows a base-2 (i.e. binary) result of calculating the constant part of a mapping. You can approximate this multiplication by a constant by a number of shifts added together. You need to break down each multiplication in the result first:&#xD;&#xA;&#xD;&#xA;x * 0.001&lt;sub&gt;2&lt;/sub&gt; = x &gt;&gt; 3&#xD;&#xA;&#xD;&#xA;x * 0.0001&lt;sub&gt;2&lt;/sub&gt; = x &gt;&gt; 4&#xD;&#xA;&#xD;&#xA;x * 0.0000001&lt;sub&gt;2&lt;/sub&gt; = x &gt;&gt; 7&#xD;&#xA;&#xD;&#xA;Then add these together. You are essentially breaking it down into convenient base-2 multiplies (which can always be represented by shifts) and adds - nearly always more efficient.&#xD;&#xA;&#xD;&#xA;This doesn't get you right to 250, but pretty close:&#xD;&#xA;&#xD;&#xA;    &gt;&gt;&gt; for i in range(0, 1024, 34):&#xD;&#xA;    ...   print (i &gt;&gt; 3) + (i &gt;&gt; 4) + (i &gt;&gt; 7) + 50&#xD;&#xA;    ... &#xD;&#xA;    50&#xD;&#xA;    56&#xD;&#xA;    62&#xD;&#xA;       [snip]&#xD;&#xA;    235&#xD;&#xA;    241&#xD;&#xA;    247&#xD;&#xA;    &gt;&gt;&gt; print (1023 &gt;&gt; 3) + (1023 &gt;&gt; 4) + (1023 &gt;&gt; 7) + 50&#xD;&#xA;    247&#xD;&#xA;&#xD;&#xA;Do all your processing with a left-justified `int` (`ADLAR`=1) though, to minimize errors. The ADC returns a 10bit result, and ADLAR choses if this is aligned to the left or right of the two result registers.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/SJsei.png" />
  <row Id="2669" PostHistoryTypeId="2" PostId="943" RevisionGUID="16d63629-7a87-4e65-9772-bca96328604f" CreationDate="2014-03-27T05:13:29.857" UserId="76" Text="I have a project that I'm currently working on. We have built a green wall, wich consists of plants on a wall&#xD;&#xA;&#xD;&#xA;![Green wall][1]&#xD;&#xA;&#xD;&#xA;Now, we have a pump situated at the bottom that waters all the plants. There is an arduino board that decides when to put the pump on. Powering it, is a solar panel and wind turbine. We want to know how much energy we have saved by using the solar panel and turbine.&#xD;&#xA;&#xD;&#xA;**Question:**&#xD;&#xA;&#xD;&#xA;How do I measure the amount of volts used from 00h00 that day? Is there a library? Or is this not possible with arduino?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Thanks a lot.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/iIhSW.jpg" />
  <row Id="2670" PostHistoryTypeId="1" PostId="943" RevisionGUID="16d63629-7a87-4e65-9772-bca96328604f" CreationDate="2014-03-27T05:13:29.857" UserId="76" Text="How to measure total volts usage of an arduino board" />
  <row Id="2671" PostHistoryTypeId="3" PostId="943" RevisionGUID="16d63629-7a87-4e65-9772-bca96328604f" CreationDate="2014-03-27T05:13:29.857" UserId="76" Text="&lt;programming&gt;" />
  <row Id="2672" PostHistoryTypeId="5" PostId="943" RevisionGUID="c5cc2084-cdab-41bf-ad0e-8cf642e2715c" CreationDate="2014-03-27T06:02:55.187" UserId="84" Comment="Fixed issue with Voltage Vs Energy" Text="I have a project that I'm currently working on. We have built a green wall, wich consists of plants on a wall&#xD;&#xA;&#xD;&#xA;![Green wall][1]&#xD;&#xA;&#xD;&#xA;Now, we have a pump situated at the bottom that waters all the plants. There is an arduino board that decides when to put the pump on. Powering it, is a solar panel and wind turbine. We want to know how much energy we have saved by using the solar panel and turbine.&#xD;&#xA;&#xD;&#xA;**Question:**&#xD;&#xA;&#xD;&#xA;How do I measure the amount of energy, in Wh, used from 00h00 that day? Is there a library? Or is this not possible with arduino?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Thanks a lot.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/iIhSW.jpg" />
  <row Id="2673" PostHistoryTypeId="4" PostId="943" RevisionGUID="c5cc2084-cdab-41bf-ad0e-8cf642e2715c" CreationDate="2014-03-27T06:02:55.187" UserId="84" Comment="Fixed issue with Voltage Vs Energy" Text="How to measure total energy usage of an arduino board" />
  <row Id="2674" PostHistoryTypeId="6" PostId="943" RevisionGUID="c5cc2084-cdab-41bf-ad0e-8cf642e2715c" CreationDate="2014-03-27T06:02:55.187" UserId="84" Comment="Fixed issue with Voltage Vs Energy" Text="&lt;programming&gt;&lt;sensors&gt;&lt;energy&gt;" />
  <row Id="2675" PostHistoryTypeId="2" PostId="944" RevisionGUID="7d874e8e-6fa6-437d-ac5f-84734562517a" CreationDate="2014-03-27T06:17:07.867" UserId="467" Text="In order to calculte the amount of energy you have to calculate the power first.&#xD;&#xA;&#xD;&#xA;The relation is &#xD;&#xA;&#xD;&#xA;Energy = (Power * Time of usage)&#xD;&#xA;&#xD;&#xA;How to calculate the power?&#xD;&#xA;&#xD;&#xA;The voltage for each device in the system is constant. What changes is the current withdrwal in each component in the project.&#xD;&#xA;The main thing you have here is the pump and how much does it consume current.&#xD;&#xA;Usually, you will have on the &quot;plate&quot; of the pump the current withdrawal of it.&#xD;&#xA;&#xD;&#xA;Say it consumes 2 Amps.&#xD;&#xA;If that is not available there, use a DMM &quot;Digital Multimeter&quot; and connect in series with the pump and meausre the amount of current.&#xD;&#xA;&#xD;&#xA;If there are any other major/important components in your project just calculate the current withdrawal from them.&#xD;&#xA;&#xD;&#xA;Now add up all the currents and say you ended up with 2 Amps.&#xD;&#xA;&#xD;&#xA;If all the components are operating at the same voltage, just multiply the total amount of current withdrawal by the voltage.&#xD;&#xA;WHY?&#xD;&#xA;Because:&#xD;&#xA;P(power) = V(voltage)   * I(current)&#xD;&#xA;&#xD;&#xA;If not, just find the power of each component.&#xD;&#xA;Add up all the powers of all you components.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Now you will only have to calculate the energy.&#xD;&#xA;&#xD;&#xA;E(Energy) = Power * time&#xD;&#xA;&#xD;&#xA;Time here refers to how long is your system working?&#xD;&#xA;Is it a full day, couple of hours. IT doesn't matter. Usually to make things easier use time (in terms of hours).&#xD;&#xA;&#xD;&#xA;Say your power ended up with 3KW *Kilo Wat*&#xD;&#xA;You've run the system for 2 hours every day&#xD;&#xA;Energy = 3 * 2 = 6 KWh&#xD;&#xA;&#xD;&#xA;If you've kept this for a full month.&#xD;&#xA;Energy save in a month = 180KWH.&#xD;&#xA;&#xD;&#xA;Just find out how much do the ministry cost for each KHW, and you'll know how much money you've saved!" />
  <row Id="2676" PostHistoryTypeId="5" PostId="944" RevisionGUID="548d36fb-6fe5-45b5-92a7-e9b3198edbcf" CreationDate="2014-03-27T07:04:44.743" UserId="83" Comment="added 2 characters in body" Text="In order to calculate the amount of energy you have to calculate the power first.&#xD;&#xA;&#xD;&#xA;The relation is &#xD;&#xA;&#xD;&#xA;Energy = (Power * Time of usage)&#xD;&#xA;&#xD;&#xA;How to calculate the power?&#xD;&#xA;&#xD;&#xA;The voltage for each device in the system is constant. What changes is the current withdrawal in each component in the project.&#xD;&#xA;The main thing you have here is the pump and how much does it consume current.&#xD;&#xA;Usually, you will have on the &quot;plate&quot; of the pump the current withdrawal of it.&#xD;&#xA;&#xD;&#xA;Say it consumes 2 Amps.&#xD;&#xA;If that is not available there, use a DMM &quot;Digital Multimeter&quot; and connect in series with the pump and measure the amount of current.&#xD;&#xA;&#xD;&#xA;If there are any other major/important components in your project just calculate the current withdrawal from them.&#xD;&#xA;&#xD;&#xA;Now add up all the currents and say you ended up with 2 Amps.&#xD;&#xA;&#xD;&#xA;If all the components are operating at the same voltage, just multiply the total amount of current withdrawal by the voltage.&#xD;&#xA;WHY?&#xD;&#xA;Because:&#xD;&#xA;P(power) = V(voltage)   * I(current)&#xD;&#xA;&#xD;&#xA;If not, just find the power of each component.&#xD;&#xA;Add up all the powers of all you components.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Now you will only have to calculate the energy.&#xD;&#xA;&#xD;&#xA;E(Energy) = Power * time&#xD;&#xA;&#xD;&#xA;Time here refers to how long is your system working?&#xD;&#xA;Is it a full day, couple of hours. IT doesn't matter. Usually to make things easier use time (in terms of hours).&#xD;&#xA;&#xD;&#xA;Say your power ended up with 3kW *kilo Watt*&#xD;&#xA;You've run the system for 2 hours every day&#xD;&#xA;Energy = 3 * 2 = 6 kWh&#xD;&#xA;&#xD;&#xA;If you've kept this for a full month.&#xD;&#xA;Energy save in a month = 180kWh.&#xD;&#xA;&#xD;&#xA;Just find out how much do the ministry cost for each kWh, and you'll know how much money you've saved!" />
  <row Id="2677" PostHistoryTypeId="5" PostId="936" RevisionGUID="bdc391d0-82bc-45f1-9fd2-fa1fb65a1f16" CreationDate="2014-03-27T08:35:04.267" UserId="666" Comment="added 713 characters in body" Text="Here is a simple example (built and tested with a mega2560), with a class that can be passed a Stream object, and sends a Hello over this generic stream object. When constructing the object, you can pass the Stream object you want to actually communicate:&#xD;&#xA;&#xD;&#xA;    #include &quot;Arduino.h&quot;&#xD;&#xA;    &#xD;&#xA;    class MyProtocol&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;    	MyProtocol(Stream&amp; s):serial(s){}&#xD;&#xA;    	void send(){&#xD;&#xA;    		serial.println(&quot;Hello&quot;);&#xD;&#xA;    	}&#xD;&#xA;    private:&#xD;&#xA;    	Stream&amp; serial;&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    MyProtocol p(Serial);&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;    	Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        delay(1000);&#xD;&#xA;    	p.send();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;NOTE: The serial.println() is not the Serial global object, note the lower case, it is the internal Stream class variable.&#xD;&#xA;&#xD;&#xA;If you are confused with the OO and classes, take into account (while you gain more knowledge about it) that this approach can be also used with a simple function, you can pass the serial parameter. Furthermore, it is not necessary to hardwire the Serial interface for ever, you can in fact switch in run time and use a different channel depending on some condition:&#xD;&#xA;&#xD;&#xA;    #include &quot;Arduino.h&quot;&#xD;&#xA;    &#xD;&#xA;    void send(Stream&amp; serial){&#xD;&#xA;    	serial.println(&quot;Hello&quot;);&#xD;&#xA;    }&#xD;&#xA;  &#xD;&#xA;    void setup() {&#xD;&#xA;    	Serial.begin(9600);&#xD;&#xA;        Serial1.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        delay(1000);&#xD;&#xA;        if(someCondition)&#xD;&#xA;            send(Serial);&#xD;&#xA;        else&#xD;&#xA;            send(Serial1);&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="2678" PostHistoryTypeId="2" PostId="945" RevisionGUID="743736f5-bf09-4c67-af35-a34b87161d2a" CreationDate="2014-03-27T08:42:19.510" UserId="797" Text="Usually, this kind of issue is the result of the several times by time unity of loop statements execution, with the baudrate defined for your serial i/o it's very possible that the flush are override by the new information input and the result are the &quot;garbage&quot; on that.&#xD;&#xA;&#xD;&#xA;On my sketches, ever I put &quot;idle function calls&quot;  in some points of the code to avoid this and works succesfully." />
  <row Id="2679" PostHistoryTypeId="5" PostId="928" RevisionGUID="3fb8e8f2-9975-4091-90cd-79e9cfb91e38" CreationDate="2014-03-27T09:16:49.820" UserId="809" Comment="added 520 characters in body" Text="![MySensors][1]&#xD;&#xA;&#xD;&#xA;*- Learn how to create your own low cost wireless sensors and connect them to the world.*&#xD;&#xA;&#xD;&#xA;http://www.mysensors.org&#xD;&#xA;&#xD;&#xA;We call it **&quot;Internet of Your Things&quot;** &#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;We've combined the Arduino platform with a small radio transceiver into a fun, flexible world of low cost wireless sensors.&#xD;&#xA;&#xD;&#xA;All the nitty-gritty details about the sensor communication has been packaged into a convenient software library so you don't have to worry about them.&#xD;&#xA;&#xD;&#xA;It is as easy as 1, 2, 3.&#xD;&#xA;![Arduino + NRF24L01+][2]&#xD;&#xA;&#xD;&#xA;1. Connect the parts. 2. Download the provided examples. 3. Start measuring and controlling the world!&#xD;&#xA;&#xD;&#xA;Read more about how the sensor network is automatically being formed using our Arduino Library on the site. It basically forms a star network and can reach hundred of meters.&#xD;&#xA;&#xD;&#xA;![The sensor network][3]&#xD;&#xA;&#xD;&#xA;In the middle you place an Arduion or Raspberry gateway that collects the information from your sensors.&#xD;&#xA;![Raspberry Controller][4]&#xD;&#xA;&#xD;&#xA;![Arduino Gateway][5]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Design and schematics&#xD;&#xA;&#xD;&#xA;Here is one of the prototype motion sensors I created to control the garden light outside of my house. The motions status is sent to my HA controller which turns on the light (via z-wave) when motion has been detected. A light sensor (not in the image) makes sure only to turn on the lights at night.  &#xD;&#xA;![enter image description here][6]&#xD;&#xA;&#xD;&#xA;You will find all the build instructions here:&#xD;&#xA;http://www.mysensors.org/build/&#xD;&#xA;&#xD;&#xA;Othe site there is also easy-to-follow build instructions for a bunch of other wireless sensors and actuators. Here are some examples:&#xD;&#xA;&#xD;&#xA;Distance Sensor, Motion sensor, Relay actuator, Humidity, Light, Pressure, Rain, Temperature, ... &#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;The project is still in the starting blocks and we hope to provide plugins for a growing list of Home Automation controllers. The first thing on our list right now is to provide a DIY controller that provides a free cloud storage for your sensor data.&#xD;&#xA;&#xD;&#xA;![Hello][7]&#xD;&#xA;&#xD;&#xA;See you @ mysensors.org&#xD;&#xA;&#xD;&#xA;/Henrik Ekblad (the creator of the Open Source Arduino Library used for the communication between the sensors) &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;- UPDATE 27/3. Made the example more concrete and added my affiliation with open source project. &#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/UKSL4.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/VfWYX.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/ETVDA.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/s8GkQ.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/35AcP.jpg&#xD;&#xA;  [6]: http://i.stack.imgur.com/DE5oE.jpg&#xD;&#xA;  [7]: http://i.stack.imgur.com/VYgX4.png" />
  <row Id="2680" PostHistoryTypeId="5" PostId="928" RevisionGUID="e0ad90a0-db2f-47a2-8863-487a94849d76" CreationDate="2014-03-27T09:24:49.833" UserId="809" Comment="added 4 characters in body" Text="![MySensors][1]&#xD;&#xA;&#xD;&#xA;*- Learn how to create your own low cost wireless sensors and connect them to the world.*&#xD;&#xA;&#xD;&#xA;http://www.mysensors.org&#xD;&#xA;&#xD;&#xA;We call it **&quot;Internet of Your Things&quot;** &#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;We've combined the Arduino platform with a small radio transceiver into a fun, flexible world of low cost wireless sensors.&#xD;&#xA;&#xD;&#xA;All the nitty-gritty details about the sensor communication has been packaged into a convenient software library so you don't have to worry about them.&#xD;&#xA;&#xD;&#xA;It is as easy as 1, 2, 3.&#xD;&#xA;![Arduino + NRF24L01+][2]&#xD;&#xA;&#xD;&#xA;1. Connect the parts. 2. Download the provided examples. 3. Start measuring and controlling the world!&#xD;&#xA;&#xD;&#xA;Read more about how the sensor network is automatically being formed using our Arduino Library on the site. It basically forms a star network and can reach hundred of meters.&#xD;&#xA;&#xD;&#xA;![The sensor network][3]&#xD;&#xA;&#xD;&#xA;In the middle you place an Arduion or Raspberry gateway that collects the information from your sensors.&#xD;&#xA;![Raspberry Controller][4]&#xD;&#xA;&#xD;&#xA;![Arduino Gateway][5]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Design and schematics&#xD;&#xA;&#xD;&#xA;Here is one of the prototype motion sensors I created to control the garden light outside of my house. The motions status is sent to my HA controller which turns on the light (via z-wave) when motion has been detected. A light sensor (not in the image) makes sure only to turn on the lights at night.  &#xD;&#xA;![enter image description here][6]&#xD;&#xA;&#xD;&#xA;You will find all the build instructions here:&#xD;&#xA;http://www.mysensors.org/build/&#xD;&#xA;&#xD;&#xA;Othe site there is also easy-to-follow build instructions for a bunch of other wireless sensors and actuators. Here are some examples:&#xD;&#xA;&#xD;&#xA;Distance Sensor, Motion sensor, Relay actuator, Humidity, Light, Pressure, Rain, Temperature, ... &#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;The project is still in the starting blocks and we hope to provide plugins for a growing list of Home Automation controllers. The first thing on our list right now is to provide a DIY controller that provides a free cloud storage for your sensor data.&#xD;&#xA;&#xD;&#xA;![Hello][7]&#xD;&#xA;&#xD;&#xA;See you @ mysensors.org&#xD;&#xA;&#xD;&#xA;/Henrik Ekblad (the creator of the Open Source Arduino Library used for the communication between the sensors) &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;- UPDATE 27/3. Made the example more concrete and added my affiliation with the open source project. &#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/UKSL4.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/VfWYX.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/ETVDA.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/s8GkQ.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/35AcP.jpg&#xD;&#xA;  [6]: http://i.stack.imgur.com/DE5oE.jpg&#xD;&#xA;  [7]: http://i.stack.imgur.com/VYgX4.png" />
  <row Id="2681" PostHistoryTypeId="5" PostId="915" RevisionGUID="bad2ff5b-12e9-4e60-b392-84cc7b7d82da" CreationDate="2014-03-27T10:49:05.897" UserId="754" Comment="added alternative for geocache shield" Text="# Stateful questbox&#xD;&#xA;**A gps powered box that makes you visit a few spots before opening**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;Similar to [questbox][1] but stores small state info EPROM so you have to visit two or three different places before it opens. &#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;Needed hardware:&#xD;&#xA;&#xD;&#xA;* Arduino uno&#xD;&#xA;* Reverse Geocache Version 2 (or a protoshield)&#xD;&#xA;* GlobalSat EM-406A GPS module&#xD;&#xA;* 2×8 blue LCD with connector header and cable&#xD;&#xA;* Hitec HS-55 servo motor&#xD;&#xA;* 4-40 push rod and clevis for latch (some versions provide a Z-bend rod instead)&#xD;&#xA;* 2 AA battery holder&#xD;&#xA;* Metallic push button with embedded blue LED and 4-pin cable&#xD;&#xA;* Pololu low voltage switch&#xD;&#xA;* Pololu 5V boost regulator&#xD;&#xA;* JST connector for EM-406A GPS module&#xD;&#xA;* Straight and right-angle header pins for the display, servo, and pushbutton connectors&#xD;&#xA;* 2 resistors for current limiting and display contrast adjustment&#xD;&#xA;* 2 small capacitors for power smoothing&#xD;&#xA;* larger capacitor for display contrast circuit&#xD;&#xA;&#xD;&#xA;Total hardware cost: **137$ + shipping**&#xD;&#xA;&#xD;&#xA;Aditional materials:&#xD;&#xA;&#xD;&#xA;* A nice box&#xD;&#xA;* Epoxy glue, wood to cover pieces, tools&#xD;&#xA;&#xD;&#xA;You can find assembling instructions in [sundial page][2] (you can buy most materials from them)&#xD;&#xA;&#xD;&#xA;I will upload stateful code and post a link here, unfortunately I wont get all need hardware on time, so this is just an idea :)&#xD;&#xA;&#xD;&#xA;Inspiration:![Original questbox][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;Learned how to integrate many components and libraries all toghether, I'll have to travel a bit to test it :)&#xD;&#xA;&#xD;&#xA;Budget can be cut quite a bit changing the concept a bit:&#xD;&#xA;&#xD;&#xA;* Change gps with a numerical keypad: the 'player' has to guess/obtain a code instead of traveling to a location&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sundial.com/&#xD;&#xA;  [2]: https://www.sundial.com/quest-box/notes-for-builders/&#xD;&#xA;  [3]: http://i.stack.imgur.com/864pF.jpg" />
  <row Id="2682" PostHistoryTypeId="2" PostId="946" RevisionGUID="1b7d8193-89d1-439f-ad25-1bad3248a885" CreationDate="2014-03-27T12:00:56.460" UserId="755" Text="I would like to know if there is a way to call functions that are contained within C files using an Arduino sketch? &#xD;&#xA;&#xD;&#xA;My C file declares and defines a function. To save putting the messy function definition into my Arduino sketch, I'd like to call the function straight from the sketch. &#xD;&#xA;&#xD;&#xA;Is there a standard way to do this using Arduino and C?" />
  <row Id="2683" PostHistoryTypeId="1" PostId="946" RevisionGUID="1b7d8193-89d1-439f-ad25-1bad3248a885" CreationDate="2014-03-27T12:00:56.460" UserId="755" Text="How to call C functions from Arduino sketch?" />
  <row Id="2684" PostHistoryTypeId="3" PostId="946" RevisionGUID="1b7d8193-89d1-439f-ad25-1bad3248a885" CreationDate="2014-03-27T12:00:56.460" UserId="755" Text="&lt;arduino-uno&gt;&lt;software&gt;&lt;c&gt;" />
  <row Id="2685" PostHistoryTypeId="2" PostId="947" RevisionGUID="1285d104-cd60-4998-85b7-6f12c2c91da8" CreationDate="2014-03-27T13:30:18.870" UserId="84" Text="Yes, just copy its declaration line in your sketch:&#xD;&#xA;&#xD;&#xA;    extern &quot;C&quot; {&#xD;&#xA;        void myfunction(int arg);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2686" PostHistoryTypeId="5" PostId="946" RevisionGUID="713407a3-37eb-4d23-967c-388e7d0e1fbf" CreationDate="2014-03-27T14:14:13.763" UserId="755" Comment="added codes" Text="I would like to know if there is a way to call functions that are contained within C files using an Arduino sketch? &#xD;&#xA;&#xD;&#xA;My C file declares and defines a function. To save putting the messy function definition into my Arduino sketch, I'd like to call the function straight from the sketch. &#xD;&#xA;&#xD;&#xA;Is there a standard way to do this using Arduino and C?&#xD;&#xA;Here is the sketch: &#xD;&#xA;&#xD;&#xA;    #include &quot;crc16.h&quot;;&#xD;&#xA;&#xD;&#xA;    void setup(){&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop(){&#xD;&#xA;      &#xD;&#xA;      CalculateCRC16(&quot;&lt;09M&quot;, 4);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;and this is the trimmed down C file:&#xD;&#xA;&#xD;&#xA;    #include &lt;stdio.h&gt;&#xD;&#xA;    #include &lt;stdint.h&gt;&#xD;&#xA;    &#xD;&#xA;    uint16_t crctable[256] =&#xD;&#xA;    {&#xD;&#xA;        0x0000, 0x1189,.....&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t // Returns Calculated CRC value&#xD;&#xA;    CalculateCRC16( // Call example CalculateCRC16(&quot;&lt;09M&quot;, 4);&#xD;&#xA;        const void *c_ptr, // Pointer to byte array to perform CRC on&#xD;&#xA;        size_t len)        // Number of bytes to CRC&#xD;&#xA;    {&#xD;&#xA;        &#xD;&#xA;        uint16_t crc = 0xFFFF // Seed for CRC calculation&#xD;&#xA;        const uint8_t *c = c_ptr;&#xD;&#xA;    &#xD;&#xA;        while (len--)&#xD;&#xA;            crc = (crc &lt;&lt; 8) ^ crctable[((crc &gt;&gt; 8) ^ *c++)];&#xD;&#xA;    &#xD;&#xA;        return crc;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2687" PostHistoryTypeId="2" PostId="948" RevisionGUID="181b85d1-5abf-4727-94f3-f44d051b5857" CreationDate="2014-03-27T14:31:45.590" UserId="42" Text="Your CRC function can easily be converted to C++ so that it can go into a *.cpp file. All you need to do is use an explicit cast when you initialise your `c` pointer. Here's the 'proper' C++ way to do it:&#xD;&#xA;&#xD;&#xA;    const uint8_t *c = static_cast&lt;const uint8_t*&gt;(c_ptr);&#xD;&#xA;&#xD;&#xA;However, an old C-style cast would also work:&#xD;&#xA;&#xD;&#xA;    const uint8_t *c = (const uint8_t*)c_ptr;&#xD;&#xA;&#xD;&#xA;The problem is basically that C can be a little more permissive about letting you convert pointers implicitly between types. To do it in C++, you need to tell the compiler explicitly that the conversion is intentional." />
  <row Id="2688" PostHistoryTypeId="2" PostId="949" RevisionGUID="fff4db52-79d8-45a1-9e26-9bf099408bae" CreationDate="2014-03-27T14:33:40.687" UserId="666" Text="You can extern &quot;C&quot; #include like the following:&#xD;&#xA;&#xD;&#xA;    extern &quot;C&quot;{&#xD;&#xA;    #include &quot;crc16.h&quot;&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    void setup(){&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop(){&#xD;&#xA;      CalculateCRC16(&quot;&lt;09M&quot;, 4);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;And the crc16.h file could be (some minor fixes, the #pragma once, a cast):&#xD;&#xA;&#xD;&#xA;    #pragma once&#xD;&#xA;    &#xD;&#xA;    #include &lt;stdio.h&gt;&#xD;&#xA;    #include &lt;stdint.h&gt;&#xD;&#xA;    &#xD;&#xA;    uint16_t crctable[2] ={ 0x0000, 0x1189};&#xD;&#xA;    &#xD;&#xA;    uint16_t CalculateCRC16( // Call example CalculateCRC16(&quot;&lt;09M&quot;, 4);&#xD;&#xA;        const void *c_ptr, // Pointer to byte array to perform CRC on&#xD;&#xA;        size_t len)        // Number of bytes to CRC&#xD;&#xA;    {&#xD;&#xA;        uint16_t crc = 0xFFFF; // Seed for CRC calculation&#xD;&#xA;        const uint8_t *c = (const uint8_t *)c_ptr;&#xD;&#xA;    &#xD;&#xA;        while (len--)&#xD;&#xA;            crc = (crc &lt;&lt; 8) ^ crctable[((crc &gt;&gt; 8) ^ *c++)];&#xD;&#xA;    &#xD;&#xA;        return crc;&#xD;&#xA;    }" />
  <row Id="2689" PostHistoryTypeId="2" PostId="950" RevisionGUID="a934e6cd-07e2-4833-bb7a-4e95e9cc964a" CreationDate="2014-03-27T16:17:04.193" UserId="832" Text="I have made this small program to lighten up in sequence 8 LEDs, it starts fine, but it stops working after a minute or so and the first 2 LEDs stay permanently ON, its like the chip stoped, here is the code :&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    // Initialize an array with all 8 leds&#xD;&#xA;    // and give them the corresponding&#xD;&#xA;    // digital number.&#xD;&#xA;    const byte led[8] = {0,1,2,3,4,5,6,7};&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    // the setup routine runs once when you press reset:&#xD;&#xA;    void setup() {&#xD;&#xA;    &#xD;&#xA;      // initialize all 8 digital I/O pins as outputs.&#xD;&#xA;      for (byte i = 0; i&lt;9; i++) {&#xD;&#xA;        pinMode(led[i], OUTPUT);&#xD;&#xA;      }&#xD;&#xA;      pinMode(13, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void left (void);&#xD;&#xA;    void right (void);&#xD;&#xA;    &#xD;&#xA;    // the loop routine runs over and over again forever:&#xD;&#xA;    void loop() {&#xD;&#xA;    &#xD;&#xA;      right();&#xD;&#xA;      left();&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void left (void) {&#xD;&#xA;      for (byte i = 0; i&lt;9; i++) {&#xD;&#xA;        digitalWrite(led[i], HIGH);&#xD;&#xA;        delay(50);&#xD;&#xA;        digitalWrite(led[i], LOW);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void right (void) {&#xD;&#xA;      for (byte i = 8; i&gt;0; i--) {&#xD;&#xA;        digitalWrite(led[i], HIGH);&#xD;&#xA;        delay(50);&#xD;&#xA;        digitalWrite(led[i], LOW);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I am using a very old arduino duemilanove." />
  <row Id="2690" PostHistoryTypeId="1" PostId="950" RevisionGUID="a934e6cd-07e2-4833-bb7a-4e95e9cc964a" CreationDate="2014-03-27T16:17:04.193" UserId="832" Text="Program starts working after a minute" />
  <row Id="2691" PostHistoryTypeId="3" PostId="950" RevisionGUID="a934e6cd-07e2-4833-bb7a-4e95e9cc964a" CreationDate="2014-03-27T16:17:04.193" UserId="832" Text="&lt;led&gt;" />
  <row Id="2692" PostHistoryTypeId="4" PostId="950" RevisionGUID="ce76c0eb-cae7-40ee-a59b-dd662124da7f" CreationDate="2014-03-27T16:30:41.317" UserId="832" Comment="edited title" Text="Program stops working after a minute" />
  <row Id="2693" PostHistoryTypeId="2" PostId="951" RevisionGUID="a2ed7b3c-88b3-480a-84bc-2b334cb7af70" CreationDate="2014-03-27T16:45:06.363" UserId="42" Text="Your loop conditions aren't quite right, which could be resulting in undefined behaviour. I highly doubt it would cause it to stop working spontaneously, but it's possible in theory.&#xD;&#xA;&#xD;&#xA;In each loop that counts upwards, you basically need to stop *before* the counter reaches 8. For example:&#xD;&#xA;&#xD;&#xA;    for (byte i = 0; i&lt;8; i++) ...&#xD;&#xA;&#xD;&#xA;Note that it's `i&lt;8` instead of `i&lt;9`.&#xD;&#xA;&#xD;&#xA;The reason is that the array is only 8 elements long, so the indices run from 0 to 7 (inclusive). Currently, your loops are going all the way up to and including 8, which means it's trying to read past the end of your array.&#xD;&#xA;&#xD;&#xA;You'll need to fix that in `setup()` and `left()`.&#xD;&#xA;&#xD;&#xA;The loop that goes downwards in `right()` is a little more difficult. At the moment, it runs through indices 8 to 1, meaning it has the same problem of reading past the array. However, it also never actually reaches index 0.&#xD;&#xA;&#xD;&#xA;It's harder to fix because `byte` is an unsigned type, so you can't use `i&gt;=0` as your condition (as it will never terminate). Personally, I would rewrite the loop to count upwards, but then reverse the index order inside the loop, so that 0 becomes 7, and so on. For example:&#xD;&#xA;&#xD;&#xA;    for (byte i = 0; i&lt;8; i++) {&#xD;&#xA;        digitalWrite(led[7-i], HIGH);&#xD;&#xA;        delay(50);&#xD;&#xA;        digitalWrite(led[7-i], LOW);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Like I said, I doubt this will actually solve your problem. It's worth trying though." />
  <row Id="2694" PostHistoryTypeId="2" PostId="952" RevisionGUID="55ae1096-f809-46bd-af81-7db0f256622d" CreationDate="2014-03-27T16:51:49.300" UserId="835" Text="I am working on a project sending three analog signals serially using 2 series one xbees and two arduino megas.  I recently found out i need to use API mode and the xbee library for the receiving side.  I am a beginner to both xbee and arduinos and haven't worked with C++ in a few years so I am having a lot of trouble with the receiving side.  If anyone is willing to help it would be greatly appreciated!&#xD;&#xA;&#xD;&#xA;Here are the details for anyone willing to help.&#xD;&#xA;&#xD;&#xA;The project is a prosthetic arm that is currently programmed by a simulink code embedded into an arduino.  There are three emg signals used to power the arm. These signals are being put into the analog pins of the arduino and read by the simulink code. Currently the human arm used to power the arm with the emg signals cannot exceed a length of two feet away from the prosthetic arm so the goal is to make it wireless to make this distance greater.   I am planning on using this arduino to receive the signals.  I am using a series one xbee, xbee sheild, and arduino mega on both sides.  I am inputting the signals into the analog pins of the transmitting arduino to send to the receiving xbee.  The transmitting xbee is in AT mode.  The receiving xbee will be in API mode.  The receiving arduino will only need to read the signals into a variable so that the Simulink code used to program the arm. &#xD;&#xA;&#xD;&#xA;Here is my configuration for the xbees &lt;br/&gt;&#xD;&#xA;Transmitting xbee:&lt;br/&gt;&#xD;&#xA;Channel: 10 &lt;br/&gt;&#xD;&#xA;Pan ID:1234 &lt;br/&gt;&#xD;&#xA;MY: 10 &lt;br/&gt;&#xD;&#xA;DL: 11&#xD;&#xA;&#xD;&#xA;Receiving xbee: &lt;br/&gt;&#xD;&#xA;Channel: 10 &lt;br/&gt;&#xD;&#xA;Pan ID: 1234 &lt;br/&gt;&#xD;&#xA;MY: 11 &lt;br/&gt;&#xD;&#xA;DL: 10 &lt;br/&gt;&#xD;&#xA;API: enabled &lt;br/&gt;&#xD;&#xA;&#xD;&#xA;transmitting Arduino program:&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      // initialize serial communication at 9600 bits per second:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    void loop() {&#xD;&#xA;      // read the input on analog pin&#xD;&#xA;      int sensorValue1 = analogRead(A0);&#xD;&#xA;      int sensorValue2 = analogRead(A1);&#xD;&#xA;      int sensorValue3 = analogRead(A2);&#xD;&#xA;      // print out the value you read:&#xD;&#xA;      Serial.write(sensorValue1);&#xD;&#xA;      Serial.write(sensorValue2);&#xD;&#xA;      Serial.write(sensorValue3);&#xD;&#xA;      delay(100);      &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I've been told i have to separate the signals in some way on the transmitting side but i'm not sure how to do that.&#xD;&#xA;&#xD;&#xA;I tried looking at the example code from the xbee library for the receiving series one xbee but I wasn't sure what needed to be changed from that.  All i need to do with this code is parse the data and read the three signals into three different variables so simulink can read from these variables.&#xD;&#xA;&#xD;&#xA;If anyone has any advice or knows how to write the code for this you will be a life saver!!  If any other information is needed let me know!" />
  <row Id="2695" PostHistoryTypeId="1" PostId="952" RevisionGUID="55ae1096-f809-46bd-af81-7db0f256622d" CreationDate="2014-03-27T16:51:49.300" UserId="835" Text="help with xbee library" />
  <row Id="2696" PostHistoryTypeId="3" PostId="952" RevisionGUID="55ae1096-f809-46bd-af81-7db0f256622d" CreationDate="2014-03-27T16:51:49.300" UserId="835" Text="&lt;arduino-mega&gt;&lt;xbee&gt;" />
  <row Id="2697" PostHistoryTypeId="2" PostId="953" RevisionGUID="100b4ed5-9c93-499f-b332-b67b52a80cf0" CreationDate="2014-03-27T18:42:08.517" UserId="497" Text="You had several problems with your loop conditions.  Arrays are 0 indexed. If we declare `const byte led[8]`, `led[0]` is the first element and `led[7]` is the 8th and last element.&#xD;&#xA;&#xD;&#xA;Also, in `void right()`, you declared `i` as a `byte` which is an 8-bit, unsigned number from 0 to 255. While you wrote the conditional to be `i&gt;0`, it needs to be `i&gt;-1` or `i&gt;=0`. So, if we change the coditional and keep `i` as a `byte` the loop would decrement `i` like 8,7,6,5,4,3,2,1,0,255,254... forever.  So instead, `i` should be declared as a `char` which is an 8-bit, signed number from -128 to 127.&#xD;&#xA;&#xD;&#xA;    // Initialize an array with all 8 leds&#xD;&#xA;    // and give them the corresponding&#xD;&#xA;    // digital number.&#xD;&#xA;    const byte led[8] = {0,1,2,3,4,5,6,7};&#xD;&#xA;&#xD;&#xA;    // the setup routine runs once when you press reset:&#xD;&#xA;    void setup() {&#xD;&#xA;      // initialize all 8 digital I/O pins as outputs.&#xD;&#xA;      for (byte i = 0; i&lt;8; i++) {&#xD;&#xA;        pinMode(led[i], OUTPUT);&#xD;&#xA;      }&#xD;&#xA;      pinMode(13, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void left (void);&#xD;&#xA;    void right (void);&#xD;&#xA;&#xD;&#xA;    // the loop routine runs over and over again forever:&#xD;&#xA;    void loop() {&#xD;&#xA;      right();&#xD;&#xA;      left();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void left (void) {&#xD;&#xA;      for (byte i = 0; i&lt;8; i++) {&#xD;&#xA;        digitalWrite(led[i], HIGH);&#xD;&#xA;        delay(50);&#xD;&#xA;        digitalWrite(led[i], LOW);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void right (void) {&#xD;&#xA;      for (char i = 7; i&gt;=0; i--) {&#xD;&#xA;        digitalWrite(led[i], HIGH);&#xD;&#xA;        delay(50);&#xD;&#xA;        digitalWrite(led[i], LOW);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="2698" PostHistoryTypeId="5" PostId="943" RevisionGUID="b801aefd-88c2-4a47-ac28-1e415304e98e" CreationDate="2014-03-27T19:43:10.647" UserId="76" Comment="Explained more things" Text="I have a project that I'm currently working on. We have built a green wall, wich consists of plants on a wall&#xD;&#xA;&#xD;&#xA;![Green wall][1]&#xD;&#xA;&#xD;&#xA;Now, we have a pump situated at the bottom that waters all the plants. There is an arduino board that decides when to put the pump on. Powering it, is a solar panel and wind turbine. We want to know how much energy we have saved by using the solar panel and turbine.&#xD;&#xA;&#xD;&#xA;**Question:**&#xD;&#xA;&#xD;&#xA;How do I measure the amount of energy, in Wh, used from 00h00 that day? Is there a library? Or is this not possible with arduino?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Thanks a lot.&#xD;&#xA;&#xD;&#xA;**To clear up some things**&#xD;&#xA;&#xD;&#xA;No, the pump is not fueled directly by the arduino pin. We are using a motor shield.&#xD;&#xA;&#xD;&#xA;Yes, there is an accumulator in the circuit. The solar and wind power recharge a battery wich in turn powers the components.&#xD;&#xA;&#xD;&#xA;I would like to know the entire energy consumed, not just the pump.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/iIhSW.jpg" />
  <row Id="2699" PostHistoryTypeId="2" PostId="954" RevisionGUID="ca6908ba-f3e0-4963-9209-b02fbcd42cce" CreationDate="2014-03-27T19:55:06.863" UserId="836" Text="I just got my Arduino UNO and I'm trying to upload the blink example but the upload fails with&#xD;&#xA;&#xD;&#xA;    ioctl(&quot;TIOCMSET&quot;): Broken pipe&#xD;&#xA;    ioctl(&quot;TIOCMSET&quot;): Broken pipe&#xD;&#xA;    avrdude: stk500_recv(): programmer is not responding&#xD;&#xA;    ioctl(&quot;TIOCMSET&quot;): Broken pipe&#xD;&#xA;&#xD;&#xA;I have tried both Arduino IDE 1.0.1 (which I installed via my package manager) as well as version 1.0.5 which I downloaded from the arduino.cc website. I'm running Ubuntu Linux 12.10 if that makes a difference. &#xD;&#xA;&#xD;&#xA;I'd appreciate any and all help in getting my arduino up and running!" />
  <row Id="2700" PostHistoryTypeId="1" PostId="954" RevisionGUID="ca6908ba-f3e0-4963-9209-b02fbcd42cce" CreationDate="2014-03-27T19:55:06.863" UserId="836" Text="&quot;Broken Pipe&quot; when uploading to Arduino UNO" />
  <row Id="2701" PostHistoryTypeId="3" PostId="954" RevisionGUID="ca6908ba-f3e0-4963-9209-b02fbcd42cce" CreationDate="2014-03-27T19:55:06.863" UserId="836" Text="&lt;arduino-uno&gt;&lt;uploading&gt;" />
  <row Id="2702" PostHistoryTypeId="10" PostId="952" RevisionGUID="785b4ca5-390f-4fd9-8a7c-6a4039178b40" CreationDate="2014-03-27T20:50:15.377" UserId="220" Comment="104" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:220,&quot;DisplayName&quot;:&quot;Annonomus Person&quot;}]}" />
  <row Id="2703" PostHistoryTypeId="5" PostId="915" RevisionGUID="8d0a629d-e08c-4059-968d-e9812cd0ee5b" CreationDate="2014-03-27T21:15:00.760" UserId="754" Comment="Added link to code so far, more budget cutting down" Text="# Stateful questbox&#xD;&#xA;**A gps powered box that makes you visit a few spots before opening**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;Similar to [questbox][1] but stores small state info EPROM so you have to visit two or three different places before it opens. &#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;Needed hardware:&#xD;&#xA;&#xD;&#xA;* Arduino uno&#xD;&#xA;* Reverse Geocache Version 2 (or a protoshield)&#xD;&#xA;* GlobalSat EM-406A GPS module&#xD;&#xA;* 2×8 blue LCD with connector header and cable&#xD;&#xA;* Hitec HS-55 servo motor&#xD;&#xA;* 4-40 push rod and clevis for latch (some versions provide a Z-bend rod instead)&#xD;&#xA;* 2 AA battery holder&#xD;&#xA;* Metallic push button with embedded blue LED and 4-pin cable&#xD;&#xA;* Pololu low voltage switch&#xD;&#xA;* Pololu 5V boost regulator&#xD;&#xA;* JST connector for EM-406A GPS module&#xD;&#xA;* Straight and right-angle header pins for the display, servo, and pushbutton connectors&#xD;&#xA;* 2 resistors for current limiting and display contrast adjustment&#xD;&#xA;* 2 small capacitors for power smoothing&#xD;&#xA;* larger capacitor for display contrast circuit&#xD;&#xA;&#xD;&#xA;Total hardware cost: **137$ + shipping**&#xD;&#xA;&#xD;&#xA;Aditional materials:&#xD;&#xA;&#xD;&#xA;* A nice box&#xD;&#xA;* Epoxy glue, wood to cover pieces, tools&#xD;&#xA;&#xD;&#xA;You can find assembling instructions in [sundial page][2] (you can buy most materials from them)&#xD;&#xA;&#xD;&#xA;I will upload stateful code and post a link here, unfortunately I wont get all need hardware on time, so this is just an idea :)&#xD;&#xA;&#xD;&#xA;**Code written so far**:&#xD;&#xA;&#xD;&#xA;* [Persistent state machine library][3]&#xD;&#xA;&#xD;&#xA;Inspiration:![Original questbox][4]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;Learned how to integrate many components and libraries all toghether, I'll have to travel a bit to test it :)&#xD;&#xA;&#xD;&#xA;Budget can be cut quite a bit changing the concept a bit:&#xD;&#xA;&#xD;&#xA;* Change gps with a numerical keypad: the 'player' has to guess/obtain a code instead of traveling to a location&#xD;&#xA;* Polulu switch and regulator can be exchanged for a [latching relay with capacitance coupling](http://forum.arduino.cc/index.php/topic,64596.0.html)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sundial.com/&#xD;&#xA;  [2]: https://www.sundial.com/quest-box/notes-for-builders/&#xD;&#xA;  [3]: https://www.biicode.com/hithwen/blocks/hithwen/statemachine/branches/master#.UzSTlmR5NUk&#xD;&#xA;  [4]: http://i.stack.imgur.com/864pF.jpg" />
  <row Id="2704" PostHistoryTypeId="2" PostId="955" RevisionGUID="ab800c75-f14b-404a-a267-8cf9148ce871" CreationDate="2014-03-27T21:24:40.537" UserId="754" Text="I've seen that there are many resources on programming basis for arduino for people that have some electronics basis or background. Are there similar resources on the opposite? Basics electronics for programmers? Things that cover:&#xD;&#xA;&#xD;&#xA;* How to read schematics (different elements that appear there)&#xD;&#xA;* What different pins are used for (yeah, even on a more basic level than [arduino documentation][1])&#xD;&#xA;* General idea of how a protoboard/protoshield works and how to connect components&#xD;&#xA;* General common components (resitors, capacitors...) and when and how to use them...&#xD;&#xA;* Safety rules, what happens when you do something wrong&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/Board#.UzSV3WR5NUk" />
  <row Id="2705" PostHistoryTypeId="1" PostId="955" RevisionGUID="ab800c75-f14b-404a-a267-8cf9148ce871" CreationDate="2014-03-27T21:24:40.537" UserId="754" Text="'Basic electronics' resources" />
  <row Id="2706" PostHistoryTypeId="3" PostId="955" RevisionGUID="ab800c75-f14b-404a-a267-8cf9148ce871" CreationDate="2014-03-27T21:24:40.537" UserId="754" Text="&lt;hardware&gt;" />
  <row Id="2713" PostHistoryTypeId="5" PostId="937" RevisionGUID="fbe4677e-9076-4fe2-b53e-6803b21fdf68" CreationDate="2014-03-27T23:14:33.017" UserId="86" Comment="added 73 characters in body" Text="I think this kind of barely fits within the rules, but it's interesting enough that I figure I'd post it anyways.&#xD;&#xA;&#xD;&#xA;# High-Precision, GPS-Synchronized timestamp generator for data-acquisition purposes.&#xD;&#xA;This is a rather interesting project that is intended to be used for providing a easy way of synchronizing multiple independent data-acquisition systems.&#xD;&#xA;&#xD;&#xA;Basically, I work in a research lab, and we often have instruments that have multiple independent data-acquisition systems, which can be physically separated by as much as 50 feet. We need to be able to correlate the time at which samples from each system were taken, which can be difficult if you want to resolve sampling-times to a great degree of precision. Using something like a USB data-acquisition system, just the USB latency can introduce several hundred milliseconds of unknown latency, that can vary from acquisition to acquisition.&#xD;&#xA;&#xD;&#xA;The previous solution was a 24-bit parallel counter that was simply bussed everywhere, requiring an enormous wiring harness, and was kind of a pain in the butt.&#xD;&#xA;&#xD;&#xA;This system uses a [specialized timing GPS module](https://www.u-blox.com/de/lea-6t.html) that can synthesize arbitrary frequency clocks, that are phase and frequency locked to the atomic clocks in the GPS satellites. &#xD;&#xA;&#xD;&#xA;The MCU is responsible for tying together the GPS data messages (I had to heavily extend and optimize a existing protocol parser for the GPS data). The GPS is configured to use a proprietary binary protocol, and it's all parsed by the parser I wrote.&#xD;&#xA;&#xD;&#xA;The project has gone through a number of revisions (pictured below).&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;Revisions!&#xD;&#xA;![enter image description here][1]  &#xD;&#xA;Rev 1: Never worked, due to the fact that I was initially hoping to use a software dPLL off a much less expensive GPS, to synthesize a higher-frequency clock from only the 1 PPS output. It's probably possible to make it work, but the time-investment just made it not worthwhile. (and I'm too crappy a coder)&#xD;&#xA;&#xD;&#xA;Used a parallax propeller MCU. The lack of decent compiled languages was a major issue as well.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][2]   &#xD;&#xA;Rev 2: Shifted to a ATmega2560. Worked, had lots of funky design aspects inherited from the first rev. Primarily, the continued use of shift-registers for the 32-bit output, despite the more then sufficient number of IO on the ATmega2560.&#xD;&#xA;&#xD;&#xA;First board that ran Optiboot, and was actually programmed entirely using the standard Arduino toolchain, before I got irritated with it and started modifying the toolchain to better suit my purposes.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][3]  &#xD;&#xA;Rev 3: Also worked. The bodged wiring is because this board incorporated a built-in USB hub to reduce the number of required USB ports (the FTDI interface requires 1 USB, and the GPS has a USB interface as well). Unfortunately, the GPS wouldn't properly enumerate, though the FTDI device worked fine, and I've used this hub elsewhere without issue. Weird.&#xD;&#xA;&#xD;&#xA;I don't have a proper USB debugger, so I just dropped the USB hub entirely, rather then trying to fix the issue. The GPS usb isn't *really* used much outside of set-up anyways.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][4]  &#xD;&#xA;Rev 4: Semi-final ATmega2560 version. Added a LCD for GPS status, fiddled with LEDs and so forth. Also, better footprints for the possible super-capacitors for maintaining the GPS status when not powered.&#xD;&#xA;&#xD;&#xA;This is the last Optiboot version.&#xD;&#xA;&#xD;&#xA;`MStime` is the `MSTOW`, or Millisecond-Time-Of-Week, which is the name of the GPS data value that is output on the timestamp out. It's a 32-bit variable that increments once per milliseond, and rolls over each week. It's a more obscure part of the GPS standard.&#xD;&#xA;&#xD;&#xA;`ITOW` is another GPS-related value, being a value that corresponds to the 1PPS signal. The correlation between the two isn't properly reflected on the LCD, since I do not have the CPU time to update the LCD at the rate I'd like. This was actually one of the major things that improved in the upgrade to the Xmega devices.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][5]  &#xD;&#xA;Rev 5: Complete architecture switch. Now uses a ATxmega128A1U processor. Not really &quot;Arduino&quot; at all anymore, but the ability to have multiple interrupt levels on the xmega processor series allowed me to considerably improve the code structure. &#xD;&#xA;&#xD;&#xA;The two bodge-wires are from me doing some experimentation, the board worked fine without them as well.&#xD;&#xA;&#xD;&#xA;### Looking forward:&#xD;&#xA;&#xD;&#xA;Rev 6!&#xD;&#xA;![enter image description here][6]  &#xD;&#xA;Add the ability to use different LCD sizes, more ESD protection on GPS antenna connection (that was an issue), ability to use a CR2032 battery for maintaining the GPS clock instead of super-capacitors.&#xD;&#xA;&#xD;&#xA;Also, much better labeling of debug and status LEDs.&#xD;&#xA;&#xD;&#xA;![enter image description here][7]  &#xD;&#xA;And bonus Nyan-Cat!&#xD;&#xA;&#xD;&#xA;![enter image description here][8]&#xD;&#xA;&#xD;&#xA;(These boards are out for fabrication right now. When I get them, I'll add pictures of the real board.)&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;I did some long-duration testing between two of the ATmega2560 boards, and over 72 hours, the RMS time-error between the two units was ~20 uS. This was with two completely independent antennas too. My design goal was &lt; 1 ms, so I'm pretty damn happy with that.&#xD;&#xA;&#xD;&#xA;On the whole, I think this does a good job illustrating how Arduino can be a useful tool for &#xD;&#xA;early prototyping for &quot;real&quot; products/systems. I use it for getting an initial test-version running with minimal effort, and when I'm confident the *idea* will work, I actually put the work in to migrate away to a completely custom, purpose-specific implementation.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Design files:  &#xD;&#xA;https://fake-server.no-ip.org/svn/FPGAStuff/DAQ%20systems/  &#xD;&#xA;(In the &quot;GPS Timestamp&quot; series of directories).&#xD;&#xA;&#xD;&#xA;Source code:  &#xD;&#xA;https://fake-server.no-ip.org/svn/Programming/Code/AVR/  &#xD;&#xA;Again, in the &quot;gpsTimeStamp&quot; series of directories.&#xD;&#xA;&#xD;&#xA;Sorry for the crappy cell-phone pictures.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/Zt8N8.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/m40P9.jpg&#xD;&#xA;  [3]: http://i.stack.imgur.com/PjfGb.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/18PyD.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/qLfpS.jpg&#xD;&#xA;  [6]: http://i.stack.imgur.com/zdher.jpg&#xD;&#xA;  [7]: http://i.stack.imgur.com/fdMJZ.jpg&#xD;&#xA;  [8]: http://i.stack.imgur.com/lJSUA.png" />
  <row Id="2714" PostHistoryTypeId="2" PostId="958" RevisionGUID="fe1a5f75-8be6-4d18-932c-43e94ca7d890" CreationDate="2014-03-28T01:20:44.180" UserId="42" Text="# Serial Box&#xD;&#xA;**A portable serial monitor in a box**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;Sometimes it's useful for a device (Arduino or otherwise) to output some debug information via serial. That's great if you've got a computer on hand with an appropriate serial input. However, that's not always the case for a variety of reasons.&#xD;&#xA;&#xD;&#xA;This project is my attempt to address that problem by creating a portable Arduino-powered serial monitor, which I can hook-up to other devices in the field.&#xD;&#xA;&#xD;&#xA;By default, it will simply display text in a scrollback format; i.e. text appears on the bottom line, and everything scrolls up to make room when more arrives. This means it should work very neatly with all sorts of generic devices. However, it will also be possible to use escape sequences to control the display more precisely, so that devices can also be programmed specifically to take advantage of its capabilities.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;The design consists of a set of 4 alphanumeric LCD displays (16x2 characters each), aligned in a box something like this:&#xD;&#xA;&#xD;&#xA;![3d mockup of the Serial Box design][1]&#xD;&#xA;&#xD;&#xA;The displays are Epson EAX16027AR's, which unfortunately are not compatible with the standard Hitachi HD44780 driver. As such, I had to write [my own library][2] for them.&#xD;&#xA;&#xD;&#xA;I chose to use these displays (rather than e.g. one large display) mainly because I just had them lying around, and wanted to do something interesting with them. I also thought it would be quite handy to be able to control each display independently for some applications (e.g. displaying different information on each one).&#xD;&#xA;&#xD;&#xA;In terms of circuit design, the displays are connected in parallel, with chip select pins being used to direct data/commands to each one as needed.&#xD;&#xA;&#xD;&#xA;An ATMega328 will be the brains of the final unit, with serial input coming from a raw 5V RX line (for connecting directly to a similar MCU), or optionally from an RS232 9-pin D-sub socket (for connecting to various other systems). The unit will also have a contrast dial, a button for clearing the display, and a button for initiating a self-test mode. In future, I'd like to add buttons which let the user move through a scrollback history too.&#xD;&#xA;&#xD;&#xA;Below is a very preliminary circuit layout (I had a lot of trouble getting Fritzing to play nicely for some reason!). It includes an 8-bit SIPO shift register for driving the LCDs' data lines, which are shown in green. You can also see the chip select lines in orange.&#xD;&#xA;&#xD;&#xA;![Preliminary circuit layout][3]&#xD;&#xA;&#xD;&#xA;At the moment, the project is still at the working prototype stage, driven from an Uno (clone) board. Below, you can see a photo of it in action, displaying text which was passed via serial from my computer.&#xD;&#xA;&#xD;&#xA;![The prototype in action][4]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Source code&#xD;&#xA;I'm making my LCD library available on GitHub at the link below. Please note that it's at an early stage in development. In the near future, I intend to make it much more similar to the core LiquidCrystal library so that it's easier to transition between the two.&#xD;&#xA;&#xD;&#xA; * https://github.com/avid-insight/LiquidCrystalEAX&#xD;&#xA;&#xD;&#xA;You can find some basic code for my Serial Box prototype in the &quot;examples&quot; folder.&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;I think the project is coming along very nicely, and I was extremely pleased to get the prototype working. My main challenge is going to be mounting the whole thing in a box. I've already made a start on cutting out suitable holes for the displays, but I'm not very experienced at that sort of thing, and am finding it quite tricky to line everything up.&#xD;&#xA;&#xD;&#xA;I'll get there in the end though. It just may not look very pretty by the time I'm finished! :)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/m8Les.jpg&#xD;&#xA;  [2]: https://github.com/avid-insight/LiquidCrystalEAX&#xD;&#xA;  [3]: http://i.stack.imgur.com/plAfe.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/9xlB6.jpg" />
  <row Id="2715" PostHistoryTypeId="5" PostId="958" RevisionGUID="a77f7386-c982-4076-9cfe-9fd5220b7d4c" CreationDate="2014-03-28T02:03:07.957" UserId="42" Comment="added 9 characters in body" Text="# Serial Box&#xD;&#xA;**A portable serial monitor in a box**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;Sometimes it's useful for a device (Arduino or otherwise) to output some debug information via serial. That's great if you've got a computer on hand with an appropriate serial input. However, that's not always the case for a variety of reasons.&#xD;&#xA;&#xD;&#xA;This project is my attempt to address that problem by creating a portable Arduino-powered serial monitor, which I can hook-up to other devices in the field.&#xD;&#xA;&#xD;&#xA;By default, it will simply display text in a scrollback format; i.e. text appears on the bottom line, and everything scrolls up to make room when more arrives. This means it should work very neatly with all sorts of generic devices. However, it will also be possible to use escape sequences to control the display more precisely, so that devices can also be programmed specifically to take advantage of its capabilities.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;The design consists of a set of 4 alphanumeric LCD displays (16x2 characters each), aligned in a box something like this:&#xD;&#xA;&#xD;&#xA;![3d mockup of the Serial Box design][1]&#xD;&#xA;&#xD;&#xA;The displays are Epson EAX16027AR's, which unfortunately are not compatible with the standard Hitachi HD44780 driver. As such, I had to write [my own library][2] for them.&#xD;&#xA;&#xD;&#xA;I chose to use these displays (rather than e.g. one large display) mainly because I just had them lying around, and wanted to do something interesting with them. I also thought it would be quite handy to be able to control each display independently for some applications (e.g. displaying different information on each one).&#xD;&#xA;&#xD;&#xA;In terms of circuit design, the displays are connected in parallel, with chip select pins being used to direct data/commands to each one as needed.&#xD;&#xA;&#xD;&#xA;An ATMega328 will be the brains of the final unit, with serial data coming from a TTL-level line (for connecting directly to the TX of a similar MCU), or optionally from an RS232 9-pin D-sub socket (for connecting to various other systems). The unit will also have a contrast dial, a button for clearing the display, and a button for initiating a self-test mode. In future, I'd like to add buttons which let the user move through a scrollback history too.&#xD;&#xA;&#xD;&#xA;Below is a very preliminary circuit layout (I had a lot of trouble getting Fritzing to play nicely for some reason!). It includes an 8-bit SIPO shift register for driving the LCDs' data lines, which are shown in green. You can also see the chip select lines in orange.&#xD;&#xA;&#xD;&#xA;![Preliminary circuit layout][3]&#xD;&#xA;&#xD;&#xA;At the moment, the project is still at the working prototype stage, driven from an Uno (clone) board. Below, you can see a photo of it in action, displaying text which was passed via serial from my computer.&#xD;&#xA;&#xD;&#xA;![The prototype in action][4]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Source code&#xD;&#xA;I'm making my LCD library available on GitHub at the link below. Please note that it's at an early stage in development. In the near future, I intend to make it much more similar to the core LiquidCrystal library so that it's easier to transition between the two.&#xD;&#xA;&#xD;&#xA; * https://github.com/avid-insight/LiquidCrystalEAX&#xD;&#xA;&#xD;&#xA;You can find some basic code for my Serial Box prototype in the &quot;examples&quot; folder.&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;I think the project is coming along very nicely, and I was extremely pleased to get the prototype working. My main challenge is going to be mounting the whole thing in a box. I've already made a start on cutting out suitable holes for the displays, but I'm not very experienced at that sort of thing, and am finding it quite tricky to line everything up.&#xD;&#xA;&#xD;&#xA;I'll get there in the end though. It just may not look very pretty by the time I'm finished! :)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/m8Les.jpg&#xD;&#xA;  [2]: https://github.com/avid-insight/LiquidCrystalEAX&#xD;&#xA;  [3]: http://i.stack.imgur.com/plAfe.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/9xlB6.jpg" />
  <row Id="2716" PostHistoryTypeId="5" PostId="937" RevisionGUID="9817fb06-92de-4fd9-85d6-872c3873913a" CreationDate="2014-03-28T02:34:55.230" UserId="86" Comment="added 73 characters in body" Text="I think this kind of barely fits within the rules, but it's interesting enough that I figure I'd post it anyways.&#xD;&#xA;&#xD;&#xA;# High-Precision, GPS-Synchronized timestamp generator for data-acquisition purposes.&#xD;&#xA;This is a rather interesting project that is intended to be used for providing a easy way of synchronizing multiple independent data-acquisition systems.&#xD;&#xA;&#xD;&#xA;Basically, I work in a research lab, and we often have instruments that have multiple independent data-acquisition systems, which can be physically separated by as much as 50 feet. We need to be able to correlate the time at which samples from each system were taken, which can be difficult if you want to resolve sampling-times to a great degree of precision. Using something like a USB data-acquisition system, just the USB latency can introduce several hundred milliseconds of unknown latency, that can vary from acquisition to acquisition.&#xD;&#xA;&#xD;&#xA;The previous solution was a 24-bit parallel counter that was simply bussed everywhere, requiring an enormous wiring harness, and was kind of a pain in the butt.&#xD;&#xA;&#xD;&#xA;This system uses a [specialized timing GPS module](https://www.u-blox.com/de/lea-6t.html) that can synthesize arbitrary frequency clocks, that are phase and frequency locked to the atomic clocks in the GPS satellites. &#xD;&#xA;&#xD;&#xA;The MCU is responsible for tying together the GPS data messages (I had to heavily extend and optimize a existing protocol parser for the GPS data). The GPS is configured to use a proprietary binary protocol, and it's all parsed by the parser I wrote.&#xD;&#xA;&#xD;&#xA;The project has gone through a number of revisions (pictured below).&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;Revisions!&#xD;&#xA;![enter image description here][1]  &#xD;&#xA;Rev 1: Never worked, due to the fact that I was initially hoping to use a software dPLL off a much less expensive GPS, to synthesize a higher-frequency clock from only the 1 PPS output. It's probably possible to make it work, but the time-investment just made it not worthwhile. (and I'm too crappy a coder)&#xD;&#xA;&#xD;&#xA;Used a parallax propeller MCU. The lack of decent compiled languages was a major issue as well.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][2]   &#xD;&#xA;Rev 2: Shifted to a ATmega2560. Worked, had lots of funky design aspects inherited from the first rev. Primarily, the continued use of shift-registers for the 32-bit output, despite the more then sufficient number of IO on the ATmega2560.&#xD;&#xA;&#xD;&#xA;First board that ran Optiboot, and was actually programmed entirely using the standard Arduino toolchain, before I got irritated with it and started modifying the toolchain to better suit my purposes.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][3]  &#xD;&#xA;Rev 3: Also worked. The bodged wiring is because this board incorporated a built-in USB hub to reduce the number of required USB ports (the FTDI interface requires 1 USB, and the GPS has a USB interface as well). Unfortunately, the GPS wouldn't properly enumerate, though the FTDI device worked fine, and I've used this hub elsewhere without issue. Weird.&#xD;&#xA;&#xD;&#xA;I don't have a proper USB debugger, so I just dropped the USB hub entirely, rather then trying to fix the issue. The GPS usb isn't *really* used much outside of set-up anyways.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][4]  &#xD;&#xA;Rev 4: Semi-final ATmega2560 version. Added a LCD for GPS status, fiddled with LEDs and so forth. Also, better footprints for the possible super-capacitors for maintaining the GPS status when not powered.&#xD;&#xA;&#xD;&#xA;This is the last Optiboot version.&#xD;&#xA;&#xD;&#xA;`MStime` is the `MSTOW`, or Millisecond-Time-Of-Week, which is the name of the GPS data value that is output on the timestamp out. It's a 32-bit variable that increments once per milliseond, and rolls over each week. It's a more obscure part of the GPS standard.&#xD;&#xA;&#xD;&#xA;`ITOW` is another GPS-related value, being a value that corresponds to the 1PPS signal. The correlation between the two isn't properly reflected on the LCD, since I do not have the CPU time to update the LCD at the rate I'd like. This was actually one of the major things that improved in the upgrade to the Xmega devices.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;![enter image description here][5]  &#xD;&#xA;Rev 5: Complete architecture switch. Now uses a ATxmega128A1U processor. Not really &quot;Arduino&quot; at all anymore, but the ability to have multiple interrupt levels on the xmega processor series allowed me to considerably improve the code structure. &#xD;&#xA;&#xD;&#xA;The two bodge-wires are from me doing some experimentation, the board worked fine without them as well.&#xD;&#xA;&#xD;&#xA;### Looking forward:&#xD;&#xA;&#xD;&#xA;Rev 6!&#xD;&#xA;![enter image description here][6]  &#xD;&#xA;Add the ability to use different LCD sizes, more ESD protection on GPS antenna connection (that was an issue), ability to use a CR2032 battery for maintaining the GPS clock instead of super-capacitors.&#xD;&#xA;&#xD;&#xA;Also, much better labeling of debug and status LEDs.&#xD;&#xA;&#xD;&#xA;![enter image description here][7]  &#xD;&#xA;And bonus Nyan-Cat!&#xD;&#xA;&#xD;&#xA;![enter image description here][8]&#xD;&#xA;&#xD;&#xA;(These boards are out for fabrication right now. When I get them, I'll add pictures of the real board.)&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;I did some long-duration testing between two of the ATmega2560 boards, and over 72 hours, the RMS time-error between the two units was ~20 uS. This was with two completely independent antennas too. My design goal was &lt; 1 ms, so I'm pretty damn happy with that.&#xD;&#xA;&#xD;&#xA;On the whole, I think this does a good job illustrating how Arduino can be a useful tool for &#xD;&#xA;early prototyping for &quot;real&quot; products/systems. I use it for getting an initial test-version running with minimal effort, and when I'm confident the *idea* will work, I actually put the work in to migrate away to a completely custom, purpose-specific implementation.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;Design files:  &#xD;&#xA;https://fake-server.no-ip.org/svn/FPGAStuff/DAQ%20systems/  &#xD;&#xA;(In the &quot;GPS Timestamp&quot; series of directories).  &#xD;&#xA;(Note: Files are from Altium Designer. The are **not** eagle files). &#xD;&#xA;&#xD;&#xA;Source code:  &#xD;&#xA;https://fake-server.no-ip.org/svn/Programming/Code/AVR/  &#xD;&#xA;Again, in the &quot;gpsTimeStamp&quot; series of directories.&#xD;&#xA;&#xD;&#xA;Sorry for the crappy cell-phone pictures.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/Zt8N8.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/m40P9.jpg&#xD;&#xA;  [3]: http://i.stack.imgur.com/PjfGb.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/18PyD.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/qLfpS.jpg&#xD;&#xA;  [6]: http://i.stack.imgur.com/zdher.jpg&#xD;&#xA;  [7]: http://i.stack.imgur.com/fdMJZ.jpg&#xD;&#xA;  [8]: http://i.stack.imgur.com/lJSUA.png" />
  <row Id="2718" PostHistoryTypeId="2" PostId="959" RevisionGUID="81159db1-37be-420c-bf02-b97fb1ce2d83" CreationDate="2014-03-28T05:41:17.387" UserId="844" Text="Optiboot is about the smallest bootloader available.&#xD;&#xA;&#xD;&#xA;But, there is a much more powerful (with inbuilt console for hardware testing, RAM and Flash contents checking, etc) bootloader with a more developed and robust stk500v2 communications protocol between avrdude and the AVR bootloader.&#xD;&#xA;&#xD;&#xA;I've used it on the ATmega2560 and on the ATmega1284p. It works for both 3 byte and 2 byte program counter MCU.&#xD;&#xA;&#xD;&#xA;I have a version here.&#xD;&#xA;&#xD;&#xA;https://sourceforge.net/projects/avrfreertos/files/AVRstk500v2_bootloader/&#xD;&#xA;https://sourceforge.net/projects/avrfreertos/&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2719" PostHistoryTypeId="2" PostId="960" RevisionGUID="b7babb12-625f-498f-b08a-5fc0deab867b" CreationDate="2014-03-28T07:10:41.087" UserId="754" Text="Examples:&#xD;&#xA;&#xD;&#xA;* [Arduino Projects Schematics for dummies][1] &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.dummies.com/how-to/content/arduino-projects-schematic-symbols.html" />
  <row Id="2720" PostHistoryTypeId="2" PostId="961" RevisionGUID="b3989fa7-1b6a-4832-a58a-0736b510bfeb" CreationDate="2014-03-28T07:24:16.323" UserId="653" Text="#From zero to Arduino (maybe a HOWTO someday?)&#xD;&#xA;&#xD;&#xA;Rule zero:&#xD;&#xA;&#xD;&#xA; - Don't overestimate the other Arduino users! They all were not born with this knowledge too.&#xD;&#xA; - Never be too shy to ask!&#xD;&#xA; - Making mistakes is ok as long as they trigger learning.&#xD;&#xA;&#xD;&#xA;(-: short break :-)&#xD;&#xA;&#xD;&#xA;You'll find lots of HOWTOs and other tutorials in the wild wild web.&#xD;&#xA;&#xD;&#xA;I assume, the confusing thing is to read them in the wrong order.&#xD;&#xA;&#xD;&#xA;Forget your Arduino(s) for a while and start with reading about:&#xD;&#xA;&#xD;&#xA; - General common components (resitors, capacitors...) and when and how to use them...&#xD;&#xA;&#xD;&#xA;This will at least partially answer:&#xD;&#xA;&#xD;&#xA; - Safety rules, what happens when you do something wrong&#xD;&#xA; - How to read schematics (different elements that appear there)&#xD;&#xA;&#xD;&#xA;If not already done:&#xD;&#xA;&#xD;&#xA; - Read about ANDs, ORs, NANDs, NORs, FLIPFLOPs...&#xD;&#xA;&#xD;&#xA;This will show how their schematic symbols look like.&#xD;&#xA;&#xD;&#xA; - ...compare them to creating the same behaviour by programming (if,&#xD;&#xA;   and (&amp;&amp;), or (||), ...)&#xD;&#xA; - Have a look at bit operations (&amp;, |, ... on whole number variables.&#xD;&#xA;&#xD;&#xA;The programming up to this point can be done on your PC.&#xD;&#xA;&#xD;&#xA;After this, dedust your Arduino again and jump into:&#xD;&#xA;&#xD;&#xA; - What different pins are used for (yeah, even on a more basic level&#xD;&#xA;   than arduino documentation)&#xD;&#xA;&#xD;&#xA;(Happy end. At least for now.)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;(I make this a community wiki answer to invite others to expand this text.)" />
  <row Id="2721" PostHistoryTypeId="16" PostId="961" RevisionGUID="e235fea2-c43b-4e6a-8203-40e850a954ff" CreationDate="2014-03-28T07:24:16.323" UserId="653" />
  <row Id="2722" PostHistoryTypeId="2" PostId="962" RevisionGUID="9e4b8617-9d33-4363-8352-ee4dad532296" CreationDate="2014-03-28T07:31:56.483" UserId="845" Text="I have programmed an IR remote control along with an LED and an 8bit 7segment on an Arduino Uno.&#xD;&#xA;the segment displays the number I press via the remote, and the LED turns on and off&#xD;&#xA;here's my code:&#xD;&#xA;`case 16738455:&#xD;&#xA;      Serial.println(0);&#xD;&#xA;      if (oldvalue == results.value){&#xD;&#xA;        on(num0);&#xD;&#xA;        delay(1000);&#xD;&#xA;        on(num00);&#xD;&#xA;        delay(1000);&#xD;&#xA;        oldvalue = results.value;&#xD;&#xA;      }`&#xD;&#xA;oldvalue stores the last value pressed, which is the DEC value of the buttons, num0 displays the number zero, and num00 turns all the segments off.&#xD;&#xA;I want the 7segment to blink again when I press the same button again.&#xD;&#xA;Can anyone help me with this? &#xD;&#xA;Thanks" />
  <row Id="2723" PostHistoryTypeId="1" PostId="962" RevisionGUID="9e4b8617-9d33-4363-8352-ee4dad532296" CreationDate="2014-03-28T07:31:56.483" UserId="845" Text="7segment blink when the button is pressed" />
  <row Id="2724" PostHistoryTypeId="3" PostId="962" RevisionGUID="9e4b8617-9d33-4363-8352-ee4dad532296" CreationDate="2014-03-28T07:31:56.483" UserId="845" Text="&lt;arduino-uno&gt;&lt;ir&gt;" />
  <row Id="2725" PostHistoryTypeId="5" PostId="962" RevisionGUID="d6739ae4-cdec-4090-842c-dc081f8400f9" CreationDate="2014-03-28T07:55:19.817" UserId="42" Comment="Improved code formatting" Text="I have programmed an IR remote control along with an LED and an 8bit 7segment on an Arduino Uno.&#xD;&#xA;the segment displays the number I press via the remote, and the LED turns on and off&#xD;&#xA;here's my code:&#xD;&#xA;&#xD;&#xA;    case 16738455:&#xD;&#xA;      Serial.println(0);&#xD;&#xA;      if (oldvalue == results.value){&#xD;&#xA;        on(num0);&#xD;&#xA;        delay(1000);&#xD;&#xA;        on(num00);&#xD;&#xA;        delay(1000);&#xD;&#xA;        oldvalue = results.value;&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;oldvalue stores the last value pressed, which is the DEC value of the buttons, num0 displays the number zero, and num00 turns all the segments off.&#xD;&#xA;I want the 7segment to blink again when I press the same button again.&#xD;&#xA;Can anyone help me with this? &#xD;&#xA;Thanks" />
  <row Id="2726" PostHistoryTypeId="2" PostId="963" RevisionGUID="cd1b7e61-5fd0-4fe0-bf29-20f7d752f5c9" CreationDate="2014-03-28T11:39:54.723" UserId="304" Text="A simple solution would be to not worry about blinking as a piece of code, ie. remove those delays (I hate blocking code) and instead, if you are currently receiving a signal from the remote, do not display any number (or display your `num00`). Once the value is received and processed, then display that number. &#xD;&#xA;&#xD;&#xA;This way, whilst ever the remote button is down, the display will blank out, and the number will appear as soon as the number is released. If it's the same number, then you will see the number, see a blank display, and then see the same number again. Obviously, if it's a different number, the new number would be displayed. &#xD;&#xA;&#xD;&#xA;Since most people would only press the remote button for 100-1500ms, it should give you a nice delay anyway.&#xD;&#xA;&#xD;&#xA;Finally, you may encounter some flashing if you process the data so quickly and the remote auto repeats. This could be handy if that number is processed multiple times by the receiving unit. The flashing would indicate that that is the case. If that is undesired, implement a simple state machine." />
  <row Id="2727" PostHistoryTypeId="5" PostId="963" RevisionGUID="b85a891d-5b4c-4c67-9804-600130aa238b" CreationDate="2014-03-28T11:48:21.540" UserId="304" Comment="code appeared after I started writing this answer" Text="A simple solution would be to not worry about blinking as a piece of code, ie. remove those delays (I hate blocking code) and instead, if you are currently receiving a signal from the remote, do not display any number (or display your `num00`). Once the value is received and processed, then display that number. &#xD;&#xA;&#xD;&#xA;This way, whilst ever the remote button is down, the display will blank out, and the number will appear as soon as the number is released. If it's the same number, then you will see the number, see a blank display, and then see the same number again. Obviously, if it's a different number, the new number would be displayed. &#xD;&#xA;&#xD;&#xA;Since most people would only press the remote button for 100-1500ms, it should give you a nice delay anyway.&#xD;&#xA;&#xD;&#xA;Finally, you may encounter some flashing if you process the data so quickly and the remote auto repeats. This could be handy if that number is processed multiple times by the receiving unit. The flashing would indicate that that is the case. If that is undesired, implement a simple state machine.&#xD;&#xA;&#xD;&#xA;**edit:** your pastebin code came up whilst I was writing this answer. Having a quick look at your code, I would suggest that in the section:&#xD;&#xA;&#xD;&#xA;    &#xD;&#xA;    if (irrecv.decode(&amp;results)) {&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;you only set the variable to be displayed, but display `num00`. Then in the else, you can display that number" />
  <row Id="2728" PostHistoryTypeId="2" PostId="964" RevisionGUID="c733a153-d963-4736-8a6d-ef0eb8afdbf5" CreationDate="2014-03-28T11:55:33.653" UserId="848" Text="Is it possible to connect arduino to the Android Phone and use it for input output?&#xD;&#xA;Are conections possible over USB? Or Do I need to have wifi shield or Bluetooth Shields?" />
  <row Id="2729" PostHistoryTypeId="1" PostId="964" RevisionGUID="c733a153-d963-4736-8a6d-ef0eb8afdbf5" CreationDate="2014-03-28T11:55:33.653" UserId="848" Text="How to connect Android phone to Arudino?" />
  <row Id="2730" PostHistoryTypeId="3" PostId="964" RevisionGUID="c733a153-d963-4736-8a6d-ef0eb8afdbf5" CreationDate="2014-03-28T11:55:33.653" UserId="848" Text="&lt;serial&gt;" />
  <row Id="2732" PostHistoryTypeId="5" PostId="963" RevisionGUID="d2e9db37-35e8-4ef6-aea4-e02a9d5641c5" CreationDate="2014-03-28T12:10:04.683" UserId="304" Comment="added better code and fixed an error :)" Text="A simple solution would be to not worry about blinking as a piece of code, ie. remove those delays (I hate blocking code) and instead, if you are currently receiving a signal from the remote, do not display any number (or display your `num00`). Once the value is received and processed, then display that number. &#xD;&#xA;&#xD;&#xA;This way, whilst ever the remote button is down, the display will blank out, and the number will appear as soon as the number is released. If it's the same number, then you will see the number, see a blank display, and then see the same number again. Obviously, if it's a different number, the new number would be displayed. &#xD;&#xA;&#xD;&#xA;Since most people would only press the remote button for 100-1500ms, it should give you a nice delay anyway.&#xD;&#xA;&#xD;&#xA;Finally, you may encounter some flashing if you process the data so quickly and the remote auto repeats. This could be handy if that number is processed multiple times by the receiving unit. The flashing would indicate that that is the case. If that is undesired, implement a simple state machine.&#xD;&#xA;&#xD;&#xA;**edit:** your pastebin code came up whilst I was writing this answer. Having a quick look at your code, I would suggest that in the section:&#xD;&#xA;&#xD;&#xA;    &#xD;&#xA;    if (irrecv.decode(&amp;results)) {&#xD;&#xA;      //receiving data? display nothing&#xD;&#xA;      on(num00);&#xD;&#xA;      digitalWrite(ledPin, HIGH);&#xD;&#xA;      Serial.println(results.value, DEC);&#xD;&#xA;      irrecv.resume();&#xD;&#xA;      delay(100);&#xD;&#xA;      int oldvalue = results.value;&#xD;&#xA;      switch(results.value){&#xD;&#xA;        case 16738455:&#xD;&#xA;          Serial.println(0);&#xD;&#xA;          num2display=0;      // make sure to declare this var somewhere&#xD;&#xA;          //if (oldvalue == results.value){&#xD;&#xA;          //  on(num0);&#xD;&#xA;          //  delay(1000); &#xD;&#xA;          //  on(num00);&#xD;&#xA;          //  delay(1000); &#xD;&#xA;          //} else {   // I think you missed an else here&#xD;&#xA;          //  oldvalue = results.value;  &#xD;&#xA;          //}&#xD;&#xA;          //on(num0); &#xD;&#xA;          //delay(1000); // you don't want such large blocking delays&#xD;&#xA;          irrecv.resume();&#xD;&#xA;          break;&#xD;&#xA;        case 16724175:&#xD;&#xA;          Serial.println(1);&#xD;&#xA;          num2display=1;       // add this for each section&#xD;&#xA;          irrecv.resume();&#xD;&#xA;          break;&#xD;&#xA;          . . .&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    else{&#xD;&#xA;      digitalWrite(ledPin, LOW);&#xD;&#xA;      on(num2display);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;you only set the variable to be displayed, but display `num00`. Then in the else, you can display that number" />
  <row Id="2733" PostHistoryTypeId="2" PostId="966" RevisionGUID="27a86fbb-6260-4b9d-abed-03174a577a8e" CreationDate="2014-03-28T12:12:12.363" UserId="832" Text="Thank you guys, its fixed now, i just dont understand why i cant use byte if i do, i&gt;=0, this way i never goes to 255 anyway and if does, it doesn matter, unless im missing something.&#xD;&#xA;Here goes the final working code :&#xD;&#xA;&#xD;&#xA;    /*&#xD;&#xA;      Blink&#xD;&#xA;      Turns on all 8 leds in sequence back and forth.&#xD;&#xA;    &#xD;&#xA;     */&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    // Initialize an array with all 8 leds&#xD;&#xA;    // and give them the corresponding&#xD;&#xA;    // digital number.&#xD;&#xA;    const char led[8] = {0,1,2,3,4,5,6,7};&#xD;&#xA;    #define speed 40&#xD;&#xA;    &#xD;&#xA;    // the setup routine runs once when you press reset:&#xD;&#xA;    void setup() {&#xD;&#xA;    &#xD;&#xA;      // initialize all 8 digital I/O pins as outputs.&#xD;&#xA;      for (int i = 0; i&lt;8; i++) {&#xD;&#xA;        pinMode(led[i], OUTPUT);&#xD;&#xA;      }&#xD;&#xA;      pinMode(13, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void left (void);&#xD;&#xA;    void right (void);&#xD;&#xA;    &#xD;&#xA;    // the loop routine runs over and over again forever:&#xD;&#xA;    void loop() {&#xD;&#xA;      &#xD;&#xA;      // Turn off the buzzer on pin 13&#xD;&#xA;      digitalWrite(13, LOW);&#xD;&#xA;    &#xD;&#xA;      while(1) {&#xD;&#xA;      right();&#xD;&#xA;      left();&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void left (void) {&#xD;&#xA;      for (int i = 0; i&lt;8; i++) {&#xD;&#xA;        digitalWrite(led[i], HIGH);&#xD;&#xA;        delay(speed);&#xD;&#xA;        digitalWrite(led[i], LOW);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void right (void) {&#xD;&#xA;      for (int i = 7; i&gt;=0; i--) {&#xD;&#xA;        digitalWrite(led[i], HIGH);&#xD;&#xA;        delay(speed);&#xD;&#xA;        digitalWrite(led[i], LOW);&#xD;&#xA;      }&#xD;&#xA;    }" />
  <row Id="2734" PostHistoryTypeId="2" PostId="967" RevisionGUID="0859b6e6-8c15-4c32-a2a0-8f93173f0784" CreationDate="2014-03-28T13:14:08.820" UserId="8" Text="The [Arduino ADK](http://arduino.cc/en/Main/ArduinoBoardADK) is meant for that. It combines an Arduino Mega with a USB host chip and port. If you don't want to buy a full Arduino, you can buy a [USB host shield](https://www.sparkfun.com/products/9947). Excellent tutorial for it [here](http://labs.arduino.cc/ADK/Index).&#xD;&#xA;&#xD;&#xA;What those do is convert high speed USB signals to SPI, which is readable by a microcontroller. Android has libraries known as the Accessory Development Protocol, which can bridge communication from a phone to the USB and then to a microcontroller." />
  <row Id="2735" PostHistoryTypeId="2" PostId="968" RevisionGUID="e5603999-9c9d-45a7-b46d-7ec44d4b7ab4" CreationDate="2014-03-28T15:24:26.237" UserId="813" Text="You bet it's possible. I used a pretty cheap bluetooth module that I got from here http://www.amazon.com/gp/aw/d/B0093XAV4U , and wrote an app using the information on the official Android Developers page to connect to the Arduino. There are many guides online telling you how to hook up a module to the pins of the duino. &#xA;&#xA;You can probably get a cheaper module if you look on eBay and don't care how long it takes to arrive, and I think there's at least one app on the Play store for controlling an Arduino if you can make it work for your purpose.&#xA;&#xA;USB connections are probably possible, though I haven't done any of that." />
  <row Id="2736" PostHistoryTypeId="5" PostId="964" RevisionGUID="ac7cef8d-8654-49ed-8c36-f049e2e86e21" CreationDate="2014-03-28T16:15:04.400" UserId="42" Comment="Fixed some spelling mistakes. Added a relevant tag." Text="Is it possible to connect an Arduino to an Android Phone and use it for input/output?&#xD;&#xA;Are connections possible over USB? Or do I need to have a wifi or Bluetooth shield?" />
  <row Id="2737" PostHistoryTypeId="4" PostId="964" RevisionGUID="ac7cef8d-8654-49ed-8c36-f049e2e86e21" CreationDate="2014-03-28T16:15:04.400" UserId="42" Comment="Fixed some spelling mistakes. Added a relevant tag." Text="How to connect Android phone to Arduino?" />
  <row Id="2738" PostHistoryTypeId="6" PostId="964" RevisionGUID="ac7cef8d-8654-49ed-8c36-f049e2e86e21" CreationDate="2014-03-28T16:15:04.400" UserId="42" Comment="Fixed some spelling mistakes. Added a relevant tag." Text="&lt;serial&gt;&lt;android&gt;" />
  <row Id="2740" PostHistoryTypeId="10" PostId="955" RevisionGUID="1c1e40da-284a-4c89-8eb8-b8236476c52d" CreationDate="2014-03-28T17:40:30.537" UserId="11" Comment="104" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:65,&quot;DisplayName&quot;:&quot;AsheeshR&quot;},{&quot;Id&quot;:46,&quot;DisplayName&quot;:&quot;Ricardo&quot;},{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="2741" PostHistoryTypeId="2" PostId="969" RevisionGUID="16eb11a8-960f-48f7-8087-3b5bb49e095b" CreationDate="2014-03-28T18:06:11.050" UserId="84" Text="# 4-Digits LED display for Arduino&#xD;&#xA;**Small board with 4 7-segments LED digits, managed through 3 pins.**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;When I started working with Arduino, I wanted a way to display values collected by various sensors I experimented, but I did not want to output these values through `Serial` to a PC.&#xD;&#xA;&#xD;&#xA;I wanted a small board that I could easily reuse from one project to another and I wanted to spare a breadboard.&#xD;&#xA;&#xD;&#xA;This board, along with its small library, currently allows 4-digits numbers display and does not source any Arduino current during display (current is sourced only when communicating to the board the new value to display from now on).&#xD;&#xA;&#xD;&#xA;![display board with counter][1]&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;The design is rather simple as I decided to reuse a **MAX-7219** chip to drive my LED display (I had a few of them on hand).&#xD;&#xA;&#xD;&#xA;Thanks to this chip, the schematic was much simple, but it was important to correctly understand how to use it; fortunately, its [datasheet][2] was pretty clear.&#xD;&#xA;&#xD;&#xA;The original design was done on a breadboard and used **4 single LED 7-segment digits**; but it required too much wiring for my taste (need to connect segments by groups of 4). Also, during my very first experiment with 7-segment LED digits, I have fried one: it had 2 Ground pins, but I connected only one to GND instead of both :-(&#xD;&#xA;&#xD;&#xA;Then I decided to go for a **4x7-segment display, common cathode**, with segment anodes already connected for 4 digits: that's only 4+8 pins!&#xD;&#xA;&#xD;&#xA;![Board Schematic][3]&#xD;&#xA;&#xD;&#xA;During my tests, I have found a useful [Arduino library for working with MAX-7219][4] which I decided to reuse. I have built my [own library][5] upon it, with a very simple API.&#xD;&#xA;&#xD;&#xA;After breadboarding, it was time to make the design more permanent; since I had a bunch of stripboards on hand, I decided to go for it.&#xD;&#xA;&#xD;&#xA;I searched and found [an easy Stripboard designer][6] for PC that I have used for designing my board.&#xD;&#xA;&#xD;&#xA;The first stripboard design was not optimized in terms of space and I decided not to implement it:&#xD;&#xA;&#xD;&#xA;![STRIPBOARD DESIGN #1][7]&#xD;&#xA;&#xD;&#xA;Then I have reviewed the design to optimize the cost and size (just one small 50x75mm stripboard); that was easy with the stripboard designer I found before:&#xD;&#xA;&#xD;&#xA;![STRIPBOARD DESIGN #2][8]&#xD;&#xA;&#xD;&#xA;Once the board was ready, I decided to check it with an Arduino UNO and an Ultrasonic Sensor:&#xD;&#xA;&#xD;&#xA;![PICTURE][9]&#xD;&#xA;&#xD;&#xA;It seemed to work except I often had strange, inconsistent displayed values; after investigation, I found it was due to **noise triggered by the display board**, noise that interfered with the sensor. I just needed to **add a decoupling cap** as near the current supply pins of the sensor as possible and that worked perfectly (note that the display board already had decoupling caps for the MAX-7219 chip).&#xD;&#xA;&#xD;&#xA;Parts list:&#xD;&#xA;&#xD;&#xA; - 1 x LN5461AS:	common cathode 7-segments block of 4 digits&#xD;&#xA; - 1 x MAX7219:		multiplexed LED driver chip&#xD;&#xA; - 1 x IC support (24 pins)&#xD;&#xA; - 1 x 22K resistor&#xD;&#xA; - 1 x 10uF electrolytic cap&#xD;&#xA; - 1 x 100nF cap&#xD;&#xA; - 1 x male pin header (5 pins)&#xD;&#xA; - 1 x 90x50mm stripboard&#xD;&#xA; - wires, solder...&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;30 years after my last electronics experiments, I could get the virus again with Arduino and with this very first project which, although rather simple, taught me several things:&#xD;&#xA;&#xD;&#xA; - interpret datasheets for the components used (MAX7219 and LED display)&#xD;&#xA; - learn how to use and be effective with stripboard design&#xD;&#xA; - all pins marked GND or V+ should be connected: you don't choose the one you feel like connecting!&#xD;&#xA; - if there's something that appears strange when you test your circuit and you don't understand why: don't search, it must be noise, try to add a decoupling cap and that should do it! &#xD;&#xA; - learn how to create an Arduino library (not just a sketch)&#xD;&#xA;&#xD;&#xA;If I was to start this project again today, I would:&#xD;&#xA;&#xD;&#xA; - try to optimize further the stripboard design (probably I could reduce the size a bit further)&#xD;&#xA; - replace the straight pin headers on the board with right-angled headers so that wires connecting to Arduino are more protruding in front of the board&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/XAvXo.png&#xD;&#xA;  [2]: http://datasheets.maximintegrated.com/en/ds/MAX7219-MAX7221.pdf&#xD;&#xA;  [3]: http://i.stack.imgur.com/PnB3n.jpg&#xD;&#xA;  [4]: http://playground.arduino.cc/uploads/Main/LedControl.zip&#xD;&#xA;  [5]: https://github.com/jfpoilpret/arduino-libraries/tree/master/DisplayDriver&#xD;&#xA;  [6]: http://www.abacom-online.de/uk/html/lochmaster.html&#xD;&#xA;  [7]: http://i.stack.imgur.com/iE37V.png&#xD;&#xA;  [8]: http://i.stack.imgur.com/3dTgz.png&#xD;&#xA;  [9]: http://i.stack.imgur.com/MiLnL.jpg" />
  <row Id="2743" PostHistoryTypeId="5" PostId="968" RevisionGUID="bfb1a43b-aab9-4a9f-9367-43d5b0e9bd9d" CreationDate="2014-03-28T18:29:31.203" UserId="813" Comment="added 217 characters in body" Text="You bet it's possible. I used a pretty cheap bluetooth module that I got from here [http://www.amazon.com/gp/aw/d/B0093XAV4U][1] , and wrote an app using the information on the official Android Developers page ([http://developer.android.com/guide/topics/connectivity/bluetooth.html][2]) to connect to the Arduino. There are many guides online telling you how to hook up a module to the pins of the duino. &#xD;&#xA;&#xD;&#xA;You can probably get a cheaper module if you look on eBay and don't care how long it takes to arrive, and I think there's at least one app on the Play store for controlling an Arduino if you can make it work for your purpose.&#xD;&#xA;&#xD;&#xA;USB connections are probably possible, though I haven't done any of that.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.amazon.com/gp/aw/d/B0093XAV4U&#xD;&#xA;  [2]: http://developer.android.com/guide/topics/connectivity/bluetooth.html" />
  <row Id="2744" PostHistoryTypeId="2" PostId="970" RevisionGUID="f6f47537-6d76-4d88-a28b-15b7cf067daa" CreationDate="2014-03-28T18:40:04.683" UserId="37" Text="As with any communication error, try these:&#xD;&#xA;&#xD;&#xA; - Disconnect and reconnect the USB cable.&#xD;&#xA; - Use a different USB cable.&#xD;&#xA; - Press the reset button on the board.&#xD;&#xA; - Restart the Arduino IDE.&#xD;&#xA; - Make sure you select the right board in `Tools ► Board ►`, e.g. If you are using the Duemilanove 328, select that instead of Duemilanove 128. The board should say what version it is on the microchip.&#xD;&#xA; - Make sure you selected the right port in `Tools ► Serial Port ►`. One way to figure out which port it is on is by following these steps:&#xD;&#xA; 1. Disconnect the USB cable.&#xD;&#xA; 2. Go to `Tools ► Serial Port ►` and see which ports are listed (e.g. COM4 COM5 COM14).&#xD;&#xA; 3. Reconnect the USB cable.&#xD;&#xA; 4. Go back to `Tools ► Serial Port ►`, and see which port appeared that wasn't there before.&#xD;&#xA; - In extreme cases, you may need to burn the bootloader. There is a good guide on how to do that here: http://arduino.cc/en/Hacking/Bootloader?from=Main.Bootloader." />
  <row Id="2745" PostHistoryTypeId="2" PostId="971" RevisionGUID="3bd4bb12-dc29-4417-a4cd-0d3abe05af21" CreationDate="2014-03-28T18:56:14.830" UserId="851" Text="Like everyone mentions, as long as you're in the shade, hot temperature probably doesn't matter too much as it's within the limits of the components.&#xD;&#xA;&#xD;&#xA;I'm more worried about condensation in the mornings.  Water vapors will condense on electronics just like it does on grass.  You could try electrical epoxy to cover the circuit.  The Arduino doesn't run very hot, so the epoxy doesn't do much in terms of preventing it from cooling down.  But epoxy does keep water vapor condensation from being a problem." />
  <row Id="2746" PostHistoryTypeId="2" PostId="972" RevisionGUID="d8cefc65-1ee6-405f-b3c8-eb8c9e0370a9" CreationDate="2014-03-28T19:19:41.000" UserId="851" Text="What you want is pretty easy to do, and the code exists already.  But the way I invision it, you won't connect the sensor Arduino to your wifi.  Instead, you'll use another Arduino as your gateway like this:&#xD;&#xA;&#xD;&#xA;Sensor Arduino:  Located outside, connected to temperature sensor, wind speed, rain gauge?&#xD;&#xA;&#xD;&#xA;Gateway Arduino: Located inside, w/ Wiznet 5001 ethernet shield&#xD;&#xA;&#xD;&#xA;The Sensor Arduino and Gateway Arduino talks to each other using a VERY easy to use wireless transceiver, nRF24L01+.  The wireless modules are $3 each, and the library for use is very mature.  All the sensor data is easily communicated to the Gateway using this library.&#xD;&#xA;&#xD;&#xA;The Gateway Arduino w/ the ethernet acts as a webserver, enabling any computer in your local network to open up a page and view current conditions.  Look at this page for the Arduino code:&#xD;&#xA;http://arduino.cc/en/Tutorial/WebServer&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;You want to also save historical temperature/wind speed information right?  This is the best part! The Gateway Arduino can push data to a service like Xively, a free web-based data collection service that also gives you a nifty way to visualize/graph your data.  There is a little hiccup with using the Wiznet along with the nRF24L01 module.  The wireless module and ethernet shield both use the same bus to communicate, so take a look at this blog to see how you can use both at the same time:&#xD;&#xA;&#xD;&#xA;http://www.heald.ca/content/arduino-ethernet-nrf24l01-and-pachubecosmxively&#xD;&#xA;&#xD;&#xA;Xively also lets you make that data public or private, so you can chose to contribute your weather station data to the community.&#xD;&#xA;&#xD;&#xA;Some other notes:&#xD;&#xA;I like nRF24L01+ modules because they're dirt cheap.  Xbee modules cost more than the Arduinos themselves.  You can keep adding nRF24L01+ modules around the house once you establish a gateway.  The same cost problem exists with wifi shield - expensive." />
  <row Id="2749" PostHistoryTypeId="2" PostId="973" RevisionGUID="f4bcaa2a-ced5-4c35-a58f-3232802db52e" CreationDate="2014-03-28T22:36:59.827" UserId="854" Text="I'm new to arduino. I have nexus duino robot as described in http://www.aliexpress.com/item/3WD-48mm-Omni-Wheel-Mobile-Arduino-Robot-Kit-10019/688287804.html, the shield connected with motors and support xbee.&#xD;&#xA;&#xD;&#xA;With simple serial comm sketch, I'm able to communicate between arduino and PC if the shield not inserted, but not if I insert the shield as it seem arduino can't receive serial data (still can send data to PC tough). Someone says that the shield might be use RX TX so it interfere with serial comm.&#xD;&#xA;&#xD;&#xA;My Questions are, is there a way to check whether the shield use RX TX? If yes, can we make it not interfere with serial comm? Could be other problem causing this serial comm problem?&#xD;&#xA;Thanks in advance." />
  <row Id="2750" PostHistoryTypeId="1" PostId="973" RevisionGUID="f4bcaa2a-ced5-4c35-a58f-3232802db52e" CreationDate="2014-03-28T22:36:59.827" UserId="854" Text="Shield interfere with Serial Communication" />
  <row Id="2751" PostHistoryTypeId="3" PostId="973" RevisionGUID="f4bcaa2a-ced5-4c35-a58f-3232802db52e" CreationDate="2014-03-28T22:36:59.827" UserId="854" Text="&lt;serial&gt;" />
  <row Id="2753" PostHistoryTypeId="2" PostId="975" RevisionGUID="91df0ece-4023-4cf7-b626-a76c54e94f68" CreationDate="2014-03-28T23:10:21.200" UserId="46" Text="# Digital Wall Clock with Radio Frequency (RF) Remote Control&#xD;&#xA;**A large (40x30cm / 16x12&quot;) 7-segment display wall clock with R/F remote control.**&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;This project features a large (40x30cm / 16x12&quot;) 7-segment display **digital wall clock** with R/F remote control. It has the following features:&#xD;&#xA;&#xD;&#xA;* It shows the current time and date (hours, minutes, seconds, day, month, year) in two formats (hours or date in the large digits).&#xD;&#xA;* It shows the current temperature in °C.&#xD;&#xA;* Has a user defined countdown which will sound an (annoying) alarm when it reaches zero.&#xD;&#xA;* All functions controlled remotely by an RF remote control.&#xD;&#xA;* Has a small cursor keypad for controlling its functions (when the remote control isn't available).&#xD;&#xA;* Brightness control independent for each display line.&#xD;&#xA;* It continues to keep the current time accurately even when off, thanks to a real time clock IC powered by a coin cell battery.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;The key aspects of this project were the following:&#xD;&#xA;&#xD;&#xA;* It's completely based on Arduino and AVR ATmega328 microcontroller.&#xD;&#xA;* It keeps current time even when off, thanks to DR1307 RTC powered by a coin cell battery.&#xD;&#xA;* The digits are never multiplexed. Instead, each digit has a dedicated 8-bit serial shift register IC (74HC595) that keeps selected segments on independently of what's being displayed on the other digits and what the MCU is doing.&#xD;&#xA;* Segments are powered by Darlington arrays due to current consumption that exceeds that of the MCU or the shift registers.&#xD;&#xA;* The clock is controlled by a keypad on the controller board and also by an RF remote control. Radio communication is performed by a pair of inexpensive 434MHz radio receiver and transmitter.&#xD;&#xA;* The project has a modular design in which a single controller can manage up 12 single digits. Controller also accepts expandable modules for unlimited number of digits (maximum number of digits is limited by timing delay due to daisy chaining of shift registers and the attenuation of their clock signal).&#xD;&#xA;* The design supports a number of ready-made 7-segment display digits or custom digits made with LEDs. &#xD;&#xA;&#xD;&#xA;Below are the schematics for the controller and one of the 7-segments boards:&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;Here are some pictures of the boards that I designed, etched, and assembled, and the remote control:&#xD;&#xA;&#xD;&#xA;![enter image description here][4]&#xD;&#xA;![enter image description here][5]&#xD;&#xA;![enter image description here][6]&#xD;&#xA;&#xD;&#xA;And finally, here's a picture of another version of the clock. In this one, I'm making the 7-segment displays myself using rectangular LEDs and discrete components.&#xD;&#xA;&#xD;&#xA;![enter image description here][7]&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;&#xD;&#xA;This project took me a lot of time, effort and learning to get to this stage (it's never finished, as I've learned), but it was lots of fun. A few things I've learned:&#xD;&#xA;&#xD;&#xA;1. Study **all the libs** you're going to use in your project **before you assign GPIO pins in your controller** so you avoid potential conflicts. I've been unlucky to use the same PWM pin for brightness control that is associated with VirtualWire timer, so I had to patch the board to get brightness and RF working at the same time.&#xD;&#xA; &#xD;&#xA;1. Crimping KK molex and modu connectors takes A LOT OF TIME!!&#xD;&#xA;&#xD;&#xA;1. Laser cut acrylic pieces are the future. They add a lot of quality to the device even if you are clumsy.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/T0XE7.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/TAqPM.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/yIV4x.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/tnZ5K.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/7AtQ4.jpg&#xD;&#xA;  [6]: http://i.stack.imgur.com/r6aQR.jpg&#xD;&#xA;  [7]: http://i.stack.imgur.com/iicCN.jpg" />
  <row Id="2756" PostHistoryTypeId="2" PostId="976" RevisionGUID="98bc51df-026a-4c16-9a77-4fddee63ec07" CreationDate="2014-03-28T23:29:06.877" UserId="832" Text="I have recently designed a shield to my arduino duemilanove, which has 8 LEDs, on the digital GPIO, from 0 to 7, but it wont programme with the shield on because the voltage drop is too much on the RX and TX lines, my question like this user is, can i have an led on the TX/RX line with a minimum resistor value that allows me to program arduino ?" />
  <row Id="2757" PostHistoryTypeId="1" PostId="976" RevisionGUID="98bc51df-026a-4c16-9a77-4fddee63ec07" CreationDate="2014-03-28T23:29:06.877" UserId="832" Text="I have LEDs on TX/RX lines interfering with the programmig of the device" />
  <row Id="2758" PostHistoryTypeId="3" PostId="976" RevisionGUID="98bc51df-026a-4c16-9a77-4fddee63ec07" CreationDate="2014-03-28T23:29:06.877" UserId="832" Text="&lt;led&gt;" />
  <row Id="2759" PostHistoryTypeId="2" PostId="977" RevisionGUID="6c1afd18-5092-4de5-8750-c175fbb30613" CreationDate="2014-03-29T00:49:00.660" UserId="851" Text="### **TV Antenna Rotator** ### &#xD;&#xA;## **IR remote controlled antenna rotation**##&#xD;&#xA;&#xD;&#xA;Can't get off the couch to adjust the direction of the TV antenna?  And even if you do, sometimes your proximity to the antenna changes the reception.  It would be nice to be able to adjust the antenna from the couch.  Using the TV remote.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;## **Components:**## &#xD;&#xA;Arduino Uno&#xD;&#xA;IR receiver&#xD;&#xA;Stepper motor w/ driver board&#xD;&#xA;1&quot; ID bearing&#xD;&#xA;Swiffer mop handle&#xD;&#xA;Plastic box&#xD;&#xA;&#xD;&#xA;![behind TV][1]&#xD;&#xA;![Arduino w/ IR receiver up front][2]&#xD;&#xA;![Close up of box and bearing][3]&#xD;&#xA;![Swiffer handle][4]&#xD;&#xA;![These two buttons don't do anything on the TV anyways][5]&#xD;&#xA;&#xD;&#xA;## **Description**## &#xD;&#xA;Use an old Swiffer mop handle as the antenna post. Got a 1&quot; ID bearing from  my favorite online store, which the mop handle just squeezes into and stops.  I drilled a hole into the plastic box big enough for the mop handle to fit through, but not for the bearing.  I drilled a rectangular hole into the mop handle end to fit the shaft of a 28BYJ-48 stepper motor, and it it into the box as shown.  The mop handle actually rests on the bearing, and the bearing is super glued to the top of the plastic box. &#xD;&#xA;&#xD;&#xA;Used the stepper.h library to rotate the motor from an Uno.&#xD;&#xA;&#xD;&#xA;I took apart an unused DVD player and salvaged the IR receiver from it.  You can take apart any consumer appliance that has a remote and use the IR receiver from it, it'll work.  The IR receiver uses the IRremote.h library.  Using the serial monitor, I printed out the hex code that corresponded to the two buttons on the TV remote that I want to use to operate the antenna motor.  One for rotating left, one for right.&#xD;&#xA;&#xD;&#xA;To save energy, use the small_stepper.motorOff() function to turn off the coils after each movement.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;## **Conclusion**## &#xD;&#xA;This was a fun project that was also useful for my wife.  I didn't implement any acceleration/deceleration in the movement, which might be nice, especially if the antenna had more rotational inertia.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/KyUOA.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/4q8mv.jpg&#xD;&#xA;  [3]: http://i.stack.imgur.com/t4len.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/n80OR.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/hAevo.jpg" />
  <row Id="2760" PostHistoryTypeId="2" PostId="978" RevisionGUID="aefb7218-67c6-44ee-8b4f-40e5d22f1a3d" CreationDate="2014-03-29T00:52:33.750" UserId="220" Text="## It sounds like you have incorrect drivers or the wrong COM port (USB) selected in the IDE&#xD;&#xA;Both are easy to fix. I'd imagine that it would be the COM port.&#xD;&#xA;&#xD;&#xA;![IDE][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/esLpV.png&#xD;&#xA;&#xD;&#xA;To do this:&#xD;&#xA;&gt; Tools → Serial Port → [COM port... try a few different ones. Also you can use device manager to see which one disappears when you unplug your Arduino]&#xD;&#xA;&#xD;&#xA;Few notes on photo:&#xD;&#xA;&#xD;&#xA; #1. The selector for the COM port. Choose which one your board is on.&#xD;&#xA;&#xD;&#xA; #2. That shows the COM port selected and board. I don't have my UNO connected: ignore that the COM port isn't showing up on the menu." />
  <row Id="2761" PostHistoryTypeId="5" PostId="977" RevisionGUID="c4ad5380-f87d-4c86-b97a-5c0e4c24d2c2" CreationDate="2014-03-29T00:54:44.790" UserId="851" Comment="added 127 characters in body" Text="### **TV Antenna Rotator** ### &#xD;&#xA;## **IR remote controlled antenna rotation**##&#xD;&#xA;&#xD;&#xA;Can't get off the couch to adjust the direction of the TV antenna?  And even if you do, sometimes your proximity to the antenna changes the reception.  It would be nice to be able to adjust the antenna from the couch.  Using the TV remote.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;## **Components:**## &#xD;&#xA;Arduino Uno&#xD;&#xA;IR receiver&#xD;&#xA;Stepper motor w/ driver board&#xD;&#xA;1&quot; ID bearing&#xD;&#xA;Swiffer mop handle&#xD;&#xA;Plastic box&#xD;&#xA;&#xD;&#xA;![behind TV][1]&#xD;&#xA;![Arduino w/ IR receiver up front][2]&#xD;&#xA;![Close up of box and bearing][3]&#xD;&#xA;![Swiffer handle][4]&#xD;&#xA;![These two buttons don't do anything on the TV anyways][5]&#xD;&#xA;&#xD;&#xA;## **Description**## &#xD;&#xA;Use an old Swiffer mop handle as the antenna post. Got a 1&quot; ID bearing from  my favorite online store, which the mop handle just squeezes into and stops.  I drilled a hole into the plastic box big enough for the mop handle to fit through, but not for the bearing.  I drilled a rectangular hole into the mop handle end to fit the shaft of a 28BYJ-48 stepper motor, and it it into the box as shown.  The mop handle actually rests on the bearing, and the bearing is super glued to the top of the plastic box. &#xD;&#xA;&#xD;&#xA;Used the stepper.h library to rotate the motor from an Uno.&#xD;&#xA;&#xD;&#xA;I took apart an unused DVD player and salvaged the IR receiver from it.  You can take apart any consumer appliance that has a remote and use the IR receiver from it, it'll work.  The IR receiver uses the IRremote.h library.  Using the serial monitor, I printed out the hex code that corresponded to the two buttons on the TV remote that I want to use to operate the antenna motor.  One for rotating left, one for right.&#xD;&#xA;&#xD;&#xA;To save energy, use the small_stepper.motorOff() function to turn off the coils after each movement.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;## **Conclusion**## &#xD;&#xA;This was a fun project that was also useful for my wife.  I didn't implement any acceleration/deceleration in the movement, which might be nice, especially if the antenna had more rotational inertia.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/KyUOA.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/4q8mv.jpg&#xD;&#xA;  [3]: http://i.stack.imgur.com/t4len.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/n80OR.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/hAevo.jpg&#xD;&#xA;&#xD;&#xA;Edit:  sorry about the picture being sideways!  It's right side up on my computer, I have no idea why it's sideways online." />
  <row Id="2762" PostHistoryTypeId="5" PostId="977" RevisionGUID="6956e029-fd67-4e04-90d0-a6327da2721d" CreationDate="2014-03-29T00:56:49.803" UserId="11" Comment="formatting" Text="# TV Antenna Rotator&#xD;&#xA;**IR remote controlled antenna rotation**&#xD;&#xA;&#xD;&#xA;Can't get off the couch to adjust the direction of the TV antenna?  And even if you do, sometimes your proximity to the antenna changes the reception.  It would be nice to be able to adjust the antenna from the couch.  Using the TV remote.&#xD;&#xA;&#xD;&#xA;# Components&#xD;&#xA;Arduino Uno&#xD;&#xA;IR receiver&#xD;&#xA;Stepper motor w/ driver board&#xD;&#xA;1&quot; ID bearing&#xD;&#xA;Swiffer mop handle&#xD;&#xA;Plastic box&#xD;&#xA;&#xD;&#xA;![behind TV][1]&#xD;&#xA;![Arduino w/ IR receiver up front][2]&#xD;&#xA;![Close up of box and bearing][3]&#xD;&#xA;![Swiffer handle][4]&#xD;&#xA;![These two buttons don't do anything on the TV anyways][5]&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;Use an old Swiffer mop handle as the antenna post. Got a 1&quot; ID bearing from  my favorite online store, which the mop handle just squeezes into and stops.  I drilled a hole into the plastic box big enough for the mop handle to fit through, but not for the bearing.  I drilled a rectangular hole into the mop handle end to fit the shaft of a 28BYJ-48 stepper motor, and it it into the box as shown.  The mop handle actually rests on the bearing, and the bearing is super glued to the top of the plastic box. &#xD;&#xA;&#xD;&#xA;Used the stepper.h library to rotate the motor from an Uno.&#xD;&#xA;&#xD;&#xA;I took apart an unused DVD player and salvaged the IR receiver from it.  You can take apart any consumer appliance that has a remote and use the IR receiver from it, it'll work.  The IR receiver uses the IRremote.h library.  Using the serial monitor, I printed out the hex code that corresponded to the two buttons on the TV remote that I want to use to operate the antenna motor.  One for rotating left, one for right.&#xD;&#xA;&#xD;&#xA;To save energy, use the small_stepper.motorOff() function to turn off the coils after each movement.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;This was a fun project that was also useful for my wife.  I didn't implement any acceleration/deceleration in the movement, which might be nice, especially if the antenna had more rotational inertia.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/KyUOA.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/4q8mv.jpg&#xD;&#xA;  [3]: http://i.stack.imgur.com/t4len.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/n80OR.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/hAevo.jpg&#xD;&#xA;&#xD;&#xA;Edit:  sorry about the picture being sideways!  It's right side up on my computer, I have no idea why it's sideways online." />
  <row Id="2763" PostHistoryTypeId="2" PostId="979" RevisionGUID="7339bf01-9137-4877-823c-b560349b8620" CreationDate="2014-03-29T02:56:47.783" UserId="304" Text="I just found this reference ([using ICSP for output as well as programming][1] -- essentially the same thing), and it suggests a 4.7kOhm.&#xD;&#xA;&#xD;&#xA;I didn't have a 4.7k handy, and used a 15k instead and it works. &#xD;&#xA;&#xD;&#xA;In my scenario, I have run a sketch with a polarized buzzer connected between RX (digital 0) and `GND`. When connected directly (with no resistor) the sketch fails to load (but the buzzer works as expected). &#xD;&#xA;&#xD;&#xA;If I put the resistor in series with it, the sketch uploads without fail. &#xD;&#xA;&#xD;&#xA;You also probably realise, but mentioning for clarity/completeness, you will lose all serial port functionality for debugging purposes and won't be able to use `Serial.[anything]`. Make sure to not even initialise the port. &#xD;&#xA;&#xD;&#xA;  [1]: http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=printview&amp;t=70515&amp;start=0" />
  <row Id="2764" PostHistoryTypeId="2" PostId="980" RevisionGUID="b4750355-1725-4424-8367-531b8db3c01e" CreationDate="2014-03-29T03:05:08.680" UserId="304" Text="You really do need to provide information on the shield, there are many versions out there (and I own half of them &lt;G&gt;). &#xD;&#xA;&#xD;&#xA;In essence, unless you are using an alternate serial port (`SerialN`) or software serial, then YES, your XBee will be using the same lines as your Arduino. If you are using `Serial.print` or `Serial.write` to talk to the XBee, then that is a giveaway too. &#xD;&#xA;&#xD;&#xA;The reason for this is the XBee talks to your Arduino through the serial port, but the Arduino IDE also talks to your Arduino (for programming and `Serial.print`) as well. You can only do one successfully. " />
  <row Id="2765" PostHistoryTypeId="5" PostId="977" RevisionGUID="1861bb74-e166-4b51-b15f-c37fad05eaa8" CreationDate="2014-03-29T03:06:07.153" UserId="851" Comment="added 27 characters in body" Text="# TV Antenna Rotator&#xD;&#xA;**IR remote controlled antenna rotation**&#xD;&#xA;&#xD;&#xA;Can't get off the couch to adjust the direction of the TV antenna?  And even if you do, sometimes your proximity to the antenna changes the reception.  It would be nice to be able to adjust the antenna from the couch.  Using the TV remote.&#xD;&#xA;&#xD;&#xA;# Components&#xD;&#xA;Arduino Uno, &#xD;&#xA;IR receiver,&#xD;&#xA;Stepper motor w/ driver board, &#xD;&#xA;1&quot; ID bearing, &#xD;&#xA;Swiffer mop handle, &#xD;&#xA;Plastic box, &#xD;&#xA;&#xD;&#xA;![behind TV][1]&#xD;&#xA;![Arduino w/ IR receiver up front][2]&#xD;&#xA;![Close up of box and bearing][3]&#xD;&#xA;![Swiffer handle][4]&#xD;&#xA;![These two buttons don't do anything on the TV anyways][5]&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;Use an old Swiffer mop handle as the antenna post. Got a 1&quot; ID bearing from  my favorite online store, which the mop handle just squeezes into and stops.  I drilled a hole into the plastic box big enough for the mop handle to fit through, but not for the bearing.  I drilled a rectangular hole into the mop handle end to fit the shaft of a 28BYJ-48 stepper motor, and stuck the contraption into the box as shown.  The mop handle actually rests on the bearing, and the bearing is super glued to the top of the plastic box. &#xD;&#xA;&#xD;&#xA;Used the stepper.h library to rotate the motor from an Uno.&#xD;&#xA;&#xD;&#xA;I took apart an unused DVD player and salvaged the IR receiver from it.  You can take apart any consumer appliance that has a remote and use the IR receiver from it, it'll work.  The IR receiver uses the IRremote.h library.  Using the serial monitor, I printed out the hex code that corresponded to the two buttons on the TV remote that I want to use to operate the antenna motor.  One for rotating left, one for right.&#xD;&#xA;&#xD;&#xA;To save energy, use the small_stepper.motorOff() function to turn off the coils after each movement.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;This was a fun project that was also useful for my wife.  I didn't implement any acceleration/deceleration in the movement, which might be nice, especially if the antenna had more rotational inertia.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/KyUOA.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/4q8mv.jpg&#xD;&#xA;  [3]: http://i.stack.imgur.com/t4len.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/n80OR.jpg&#xD;&#xA;  [5]: http://i.stack.imgur.com/hAevo.jpg&#xD;&#xA;&#xD;&#xA;Edit:  sorry about the picture being sideways!  It's right side up on my computer, I have no idea why it's sideways online." />
  <row Id="2766" PostHistoryTypeId="5" PostId="980" RevisionGUID="dc74a875-cdbf-4c96-a1ff-81bf376e7591" CreationDate="2014-03-29T03:10:15.273" UserId="304" Comment="answered second question and added info" Text="You really do need to provide information on the shield, there are many versions out there (and I own half of them &lt;G&gt;). &#xD;&#xA;&#xD;&#xA;In essence, unless you are using an alternate serial port (`SerialN`) or software serial, then YES, your XBee will be using the same lines as your Arduino. If you are using `Serial.print` or `Serial.write` to talk to the XBee, then that is a giveaway too. &#xD;&#xA;&#xD;&#xA;The reason for this is the XBee talks to your Arduino through the serial port, but the Arduino IDE also talks to your Arduino (for programming and `Serial.print`) as well. You can only do one successfully. &#xD;&#xA;&#xD;&#xA;In answer to your second question, most likely not. It will be the XBee shield causing you your problems. &#xD;&#xA;&#xD;&#xA;edit: I thought I would add, I actually have ONE shield that uses RX and TX but also allows for programming at the same time. This is achieved through a series resistor and (in the case of the shield) an amplifier as well." />
  <row Id="2767" PostHistoryTypeId="6" PostId="973" RevisionGUID="f8870e31-53df-416a-88b9-c8cd49704326" CreationDate="2014-03-29T04:04:41.817" UserId="304" Comment="added xbee tag" Text="&lt;serial&gt;&lt;xbee&gt;" />
  <row Id="2768" PostHistoryTypeId="24" PostId="973" RevisionGUID="f8870e31-53df-416a-88b9-c8cd49704326" CreationDate="2014-03-29T04:04:41.817" Comment="Proposed by 304 approved by 220 edit id of 262" />
  <row Id="2769" PostHistoryTypeId="16" PostId="960" RevisionGUID="3ea092c6-da82-4ab5-8ec8-915653001977" CreationDate="2014-03-29T07:50:17.113" UserId="754" Comment="added 86 characters in body; deleted 11 characters in body; added 34 characters in body" />
  <row Id="2770" PostHistoryTypeId="5" PostId="960" RevisionGUID="3ea092c6-da82-4ab5-8ec8-915653001977" CreationDate="2014-03-29T07:50:17.113" UserId="754" Comment="added 86 characters in body; deleted 11 characters in body; added 34 characters in body" Text="This is an extract of an [introductory book](http://m.dummies.com/DummiesArticle/Arduino-Projects-For-Dummies-Cheat-Sheet.id-379124.html) that shows basic schematic  components: &#xD;&#xA;[![Basic schematic components](http://media.wiley.com/Lux/21/379121.image0.jpg)" />
  <row Id="2771" PostHistoryTypeId="5" PostId="960" RevisionGUID="28f65b14-549b-4b60-a979-f93bb6ec5e85" CreationDate="2014-03-29T07:55:21.433" UserId="754" Comment="deleted 1 characters in body" Text="This is an extract of an [introductory book](http://m.dummies.com/DummiesArticle/Arduino-Projects-For-Dummies-Cheat-Sheet.id-379124.html) that shows basic schematic  components: &#xD;&#xA;![Basic schematic components](http://media.wiley.com/Lux/21/379121.image0.jpg)" />
  <row Id="2772" PostHistoryTypeId="5" PostId="959" RevisionGUID="04d462b4-1990-4ae5-9c4c-06ec9eb9c1a1" CreationDate="2014-03-29T11:10:33.073" UserId="844" Comment="added 85 characters in body" Text="Optiboot is about the smallest bootloader available.&#xD;&#xA;&#xD;&#xA;But, there is a much more powerful (with inbuilt console for hardware testing, RAM and Flash contents checking, etc) bootloader with a more developed and robust stk500v2 communications protocol between avrdude and the AVR bootloader.&#xD;&#xA;&#xD;&#xA;I've used it on the ATmega2560 and on the ATmega1284p. It works for both 3 byte and 2 byte program counter MCU.&#xD;&#xA;&#xD;&#xA;I have a [STK500v2 Bootloader][1] version on [Sourceforge][2]&#xD;&#xA;&#xD;&#xA;  [1]: https://sourceforge.net/projects/avrfreertos/files/AVRstk500v2_bootloader/ &quot;STK500v2 Bootloader&quot;&#xD;&#xA;  [2]: https://sourceforge.net/projects/avrfreertos/ &quot;AVRfreeRTOS&quot;" />
  <row Id="2773" PostHistoryTypeId="2" PostId="981" RevisionGUID="a5f89ace-132b-40d0-a826-c99e71ed405c" CreationDate="2014-03-29T12:02:09.650" UserId="859" Text="Have you heard about support for IPv6 protocol for any Ethernet shield?&#xD;&#xA;As far as I know only IPv4 is supported.&#xD;&#xA;Maybe some one would like to write library?" />
  <row Id="2774" PostHistoryTypeId="1" PostId="981" RevisionGUID="a5f89ace-132b-40d0-a826-c99e71ed405c" CreationDate="2014-03-29T12:02:09.650" UserId="859" Text="Ethernet shield and IPv6 support" />
  <row Id="2775" PostHistoryTypeId="3" PostId="981" RevisionGUID="a5f89ace-132b-40d0-a826-c99e71ed405c" CreationDate="2014-03-29T12:02:09.650" UserId="859" Text="&lt;tcpip&gt;" />
  <row Id="2776" PostHistoryTypeId="2" PostId="982" RevisionGUID="788c0588-8e10-459b-bf81-5f73b70b142a" CreationDate="2014-03-29T12:51:59.663" UserId="220" Text="**There is no library, and there physically cannot be one.** IPv4 is built into the Ethernet shield itself. (It has a *Wiznet 510* chip.)&#xD;&#xA;&#xD;&#xA;&gt; Shields based on the MicroChip ENC28J60 chip (such as those sold by Ekitszone and Nuelectronics) are suitable for the implementation of an IPv6 or dual IPv4/IPv6 stack. This approach requires the TCP state machine to be implemented in software and results in more complex arduino code.&#xD;&#xA;&#xD;&#xA;*Source: [this tutorial](https://www.adafruit.com/blog/2012/09/17/ask-an-educator-how-can-i-get-my-arduino-to-use-ipv6/). (You may find it useful, I'd recommenced reading it.)*&#xD;&#xA;&#xD;&#xA;There is [this library for IPv6 on *other hardware*, not for the official Ethernet shield](https://sites.google.com/site/ghoelzl/ipv6ethershield)." />
  <row Id="2777" PostHistoryTypeId="2" PostId="983" RevisionGUID="084fe359-3064-4d49-8c9b-c638d8745299" CreationDate="2014-03-29T12:54:38.267" UserId="693" Text="I tested a MPU-6050 (GY-521) using an Arduino Nano. I used the I2CDevLib and opened the MPU6050_DMP6.ino with the Arduino IDE. I opened the Processing-file with processing. A few changes was necessary to make it work:&#xD;&#xA;&#xD;&#xA;    MPU6050 mpu;&#xD;&#xA;&#xD;&#xA;was changed into:&#xD;&#xA;    &#xD;&#xA;    MPU6050 mpu(0x68);&#xD;&#xA;&#xD;&#xA;Additionally I commented out this line:&#xD;&#xA;&#xD;&#xA;    #define OUTPUT_READABLE_YAWPITCHROLL&#xD;&#xA;&#xD;&#xA;and uncommented this line:&#xD;&#xA;&#xD;&#xA;    #define OUTPUT_TEAPOT&#xD;&#xA;&#xD;&#xA;When turning everything on, the arrow (Processing) would turn with 5 degrees/s clockwise around the z-axis (plus a very small amount around the other two axes). After about 20 seconds, it would stop, and turn around the x-axis pretty fast for 3 seconds. Then it would stop. Now, the gyroscope+accelerometer would work perfectly. This happens every time I test it.&#xD;&#xA;&#xD;&#xA;This happens only when the gyroscope is perfectly still on the ground. It does not stabilize if I move it around. Only after it is left completely still, it'll stabilize after 23 seconds.&#xD;&#xA;&#xD;&#xA;Is this how it should work, or is it a problem with the gyroscope? Could it even be caused by the I2CDevLib? Can anybody else confirm this?" />
  <row Id="2778" PostHistoryTypeId="1" PostId="983" RevisionGUID="084fe359-3064-4d49-8c9b-c638d8745299" CreationDate="2014-03-29T12:54:38.267" UserId="693" Text="Do gyroscopes need to self-calibrate?" />
  <row Id="2779" PostHistoryTypeId="3" PostId="983" RevisionGUID="084fe359-3064-4d49-8c9b-c638d8745299" CreationDate="2014-03-29T12:54:38.267" UserId="693" Text="&lt;gyroscope&gt;&lt;accelerometer&gt;&lt;i2cdevlib&gt;&lt;mpu6050&gt;" />
  <row Id="2780" PostHistoryTypeId="4" PostId="983" RevisionGUID="7071ef6a-8c55-489b-a2cf-f3b01770173f" CreationDate="2014-03-29T13:03:42.010" UserId="693" Comment="edited title" Text="Do gyroscopes purposefully show erroneous data?" />
  <row Id="2781" PostHistoryTypeId="2" PostId="984" RevisionGUID="58f68c71-e357-4bba-a423-5096fad718dc" CreationDate="2014-03-29T13:05:54.493" UserId="220" Text="Use this tag for designing a user experience of your project. This tag is often used with LCDs or with responsiveness, although it can have other uses.&#xD;&#xA;&#xD;&#xA;UIs often determine the usefulness and simplicity of your sketch. For example, a &quot;lagging UI&quot; is like a slow computer: when you click something there is a short (or long) delay." />
  <row Id="2782" PostHistoryTypeId="2" PostId="985" RevisionGUID="6f4d223d-e937-4813-8e6c-432207f37fed" CreationDate="2014-03-29T13:05:54.493" UserId="220" Text="Use this tag for designing a user experience of your project. This tag is often used with LCDs or with responsiveness, although it can have other uses." />
  <row Id="2783" PostHistoryTypeId="33" PostId="876" RevisionGUID="b8389598-c037-4f44-b568-c50e212fa28f" CreationDate="2014-03-29T17:03:39.227" UserId="11" Comment="5" />
  <row Id="2784" PostHistoryTypeId="5" PostId="959" RevisionGUID="21962b4d-b57c-4f0a-9f92-5576a497857e" CreationDate="2014-03-29T17:21:50.237" UserId="84" Comment="Reintegrated useful information from the comments." Text="Optiboot is about the smallest bootloader available.&#xD;&#xA;&#xD;&#xA;But, there is a much more powerful (with inbuilt console for hardware testing, RAM and Flash contents checking, etc) bootloader with a more developed and robust stk500v2 communications protocol between avrdude and the AVR bootloader.&#xD;&#xA;&#xD;&#xA;I've used it on the ATmega2560 and on the ATmega1284p. It works for both 3 byte and 2 byte program counter MCU.&#xD;&#xA;&#xD;&#xA;I have a [STK500v2 Bootloader][1] version on [Sourceforge][2].&#xD;&#xA;&#xD;&#xA;This bootloader is based the Peter Fleury STK500v2 bootloader, updated by Mark Sproul. I've made edits to have it supporting with the Goldilocks (an ATmega1284p) board.&#xD;&#xA;&#xD;&#xA;The key feature is to use the **STK500v2** protocol for uploading the Flash image to the Arduino. This protocol is more robust and gives better error capabilities than the **avr109** protocol. As an aside the avr109 protocol is called &quot;Arduino&quot; in the Arduino world, because it toggles DTR (to reset the board and automatically enter the bootloader), and the STK500v2 protocol is called &quot;Wiring&quot; in the Arduino world, because of the same reason.&#xD;&#xA;&#xD;&#xA;The Fleury/Sproul STK500v2 bootloader is designed to work with the ATmega2560 which has a 3 byte program register, because of the larger Flash size. But, it also supports normal 2 byte boards (everything else really).&#xD;&#xA;&#xD;&#xA;For boards with plenty of Flash (like Goldilocks 1284p), there is a **hardware monitor** that can be used to query Flash, SRAM and hardware; you can check connections without additional code, and check the actual contents of Flash and EEPROM. Because the 1284p supports 2 USART, I added the ability to have debugging on **USART1**, so that the upload process via **USART0** isn't disturbed.&#xD;&#xA;&#xD;&#xA;  [1]: https://sourceforge.net/projects/avrfreertos/files/AVRstk500v2_bootloader/ &quot;STK500v2 Bootloader&quot;&#xD;&#xA;  [2]: https://sourceforge.net/projects/avrfreertos/ &quot;AVRfreeRTOS&quot;" />
  <row Id="2786" PostHistoryTypeId="2" PostId="986" RevisionGUID="7a767665-828d-4188-8b6a-339c4c5be07a" CreationDate="2014-03-29T18:33:39.723" UserId="46" Text="Looking at my Arduino Uno R3 board and its [reference design schematic](http://arduino.cc/en/uploads/Main/arduino-uno-schematic.pdf) I noticed that there's a second ICSP 6-pin header. In the linked schematics, the connector I'm referring to is named ICSP1. &#xD;&#xA;&#xD;&#xA;**What's that for?** &#xD;&#xA;What useful things can an average Arduino user like me do with it?&#xD;&#xA;&#xD;&#xA;The relevant part of the schematic is below (marked in red).&#xD;&#xA;&#xD;&#xA;![Arduino Uno R3][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/2QP5f.png" />
  <row Id="2787" PostHistoryTypeId="1" PostId="986" RevisionGUID="7a767665-828d-4188-8b6a-339c4c5be07a" CreationDate="2014-03-29T18:33:39.723" UserId="46" Text="What's the 2nd ICSP header for in Arduino Uno R3?" />
  <row Id="2788" PostHistoryTypeId="3" PostId="986" RevisionGUID="7a767665-828d-4188-8b6a-339c4c5be07a" CreationDate="2014-03-29T18:33:39.723" UserId="46" Text="&lt;arduino-uno&gt;&lt;icsp&gt;" />
  <row Id="2789" PostHistoryTypeId="2" PostId="987" RevisionGUID="bf77302e-1648-463c-80f8-ed09323eb0c0" CreationDate="2014-03-29T19:12:38.940" UserId="368" Text="It's for the other MCU on the board.&#xD;&#xA;&#xD;&#xA;The main MCU on the Uno is labelled &quot;ZIC1&quot;. This is the one that is programmed when you press &quot;Upload&quot; in the IDE. But unlike other Arduinos that use a FTDI chip to connect to the serial port on the main MCU, the Uno uses another MCU instead, labelled &quot;U3&quot; on the left. This MCU runs a small bit of code that acts as a serial port via USB and passes through the bytes to its USART1. This then connects to the USART on the main MCU, where the bootloader on that chip accepts the bytes coming through and writes to flash and EEPROM on the main MCU.&#xD;&#xA;&#xD;&#xA;You can use this additional MCU as you would any other, but the only I/O it has available are the USB connection, the SPI connection via its ICSP header, the UART1 connection to both the main MCU and pins 0 and 1, and two LEDs on PD4 and PD5." />
  <row Id="2790" PostHistoryTypeId="2" PostId="988" RevisionGUID="7866cd2b-dcdd-4179-a44b-54b60cb6631d" CreationDate="2014-03-29T20:27:49.563" UserId="861" Text="I went through this last night.  I got the adapter cable [ .../852] and antenna from Adafruit.&#xD;&#xA;It appeared to be hard to snap into place, but it did go.  &#xD;&#xA;**It did not improve performance** though when testing signal strength with the Example&gt;Bridge&gt;WiFiStatus &#xD;&#xA;&#xD;&#xA;Which leads me to believe that the connector didn't mate -or- I damaged it -or- it isn't the proper connector.&#xD;&#xA;I am thinking the latter is the case.&#xD;&#xA;Still looking for the answer.&#xD;&#xA;&#xD;&#xA;Jim&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;I bought:&#xD;&#xA;1 ea.     RP-SMA to uFL/u.FL/IPX/IPEX RF Adapter Cable     $3.95&#xD;&#xA;http://www.adafruit.com/products/852&#xD;&#xA;1 ea.     2.4GHz Dipole Swivel Antenna with RP-SMA - 5dBi     $8.95&#xD;&#xA;http://www.adafruit.com/products/945&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2791" PostHistoryTypeId="2" PostId="989" RevisionGUID="04111568-4c05-44af-917d-a8b1522d5de4" CreationDate="2014-03-29T21:34:55.593" UserId="862" Text="hi i am using mcp23017 to read button presses for my joystick project and am using the internal pullup to minimize complications, is there a way to invert all the bits in the uint16_t so i can send the values as normally off? &#xD;&#xA;using the adafruit libary&#xD;&#xA;https://github.com/adafruit/Adafruit-MCP23017-Arduino-Library&#xD;&#xA;and the read&#xD;&#xA;uint16_t buttons = mcp.readGPIOAB();" />
  <row Id="2792" PostHistoryTypeId="1" PostId="989" RevisionGUID="04111568-4c05-44af-917d-a8b1522d5de4" CreationDate="2014-03-29T21:34:55.593" UserId="862" Text="using a i2c port expander to read buttons with pull ups and inverting the resulting uint16_t" />
  <row Id="2793" PostHistoryTypeId="3" PostId="989" RevisionGUID="04111568-4c05-44af-917d-a8b1522d5de4" CreationDate="2014-03-29T21:34:55.593" UserId="862" Text="&lt;arduino-leonardo&gt;" />
  <row Id="2794" PostHistoryTypeId="2" PostId="990" RevisionGUID="738147be-6013-42ac-8f64-9d21d5d0f54f" CreationDate="2014-03-29T21:37:40.513" UserId="368" Text="The inversion operator in C++ is `~`.&#xD;&#xA;&#xD;&#xA;    Serial.print(buttons, BIN);&#xD;&#xA;    Serial.print(~buttons, BIN);&#xD;&#xA;" />
  <row Id="2795" PostHistoryTypeId="2" PostId="991" RevisionGUID="ac1416d6-681d-4f2d-add3-54025848ba63" CreationDate="2014-03-29T21:53:49.723" UserId="304" Text="Following on from http://arduino.stackexchange.com/questions/986/whats-the-2nd-icsp-header-for-in-arduino-uno-r3 I was wondering how this could be hacked to our advantage. &#xD;&#xA;&#xD;&#xA;For example, could that firmware be rewritten to have the UNO recognised as a mouse/keyboard input? Could this be done after the boot loader process and leave the uploading process in tact?&#xD;&#xA;&#xD;&#xA;Given the limited IO, it seems it's functions might be limited. Plus I have no idea how much code is space is available. " />
  <row Id="2796" PostHistoryTypeId="1" PostId="991" RevisionGUID="ac1416d6-681d-4f2d-add3-54025848ba63" CreationDate="2014-03-29T21:53:49.723" UserId="304" Text="Can the 2nd MCU on the UNO R3 be used for keyboard emulation?" />
  <row Id="2797" PostHistoryTypeId="3" PostId="991" RevisionGUID="ac1416d6-681d-4f2d-add3-54025848ba63" CreationDate="2014-03-29T21:53:49.723" UserId="304" Text="&lt;arduino-uno&gt;&lt;programming&gt;" />
  <row Id="2798" PostHistoryTypeId="2" PostId="992" RevisionGUID="884211d6-cfac-455e-bbf5-9f60c6591570" CreationDate="2014-03-29T21:59:06.220" UserId="8" Text="Yes, it is possible. using LUFA, you can burn new firmware to the Serial converter. The only problem is that you need to re-burn the USB-Serial converter to upload another program.&#xD;&#xA;&#xD;&#xA;Info: http://www.fourwalledcubicle.com/LUFA.php" />
  <row Id="2799" PostHistoryTypeId="2" PostId="993" RevisionGUID="62bb6ad3-6e33-4bb2-8889-dfa2e45bbe68" CreationDate="2014-03-29T22:04:24.807" UserId="368" Text="The second MCU is similar to that used in the Leonardo, but is smaller and less capable (&lt;a href=&quot;http://www.atmel.com/devices/atmega16u2.aspx&quot;&gt;ATmega16U2&lt;/a&gt; vs. &lt;a href=&quot;http://www.atmel.com/devices/atmega32u4.aspx&quot;&gt;ATmega32U4&lt;/a&gt;). It is certainly possible to reprogram it to do what you like, but its limits means that you can have fewer USB &quot;devices&quot; at the same time.&#xD;&#xA;&#xD;&#xA;I have not looked at the existing firmware, but it should certainly be possible to add your own custom code into it such that both the normal serial connection to the main MCU as well as your additional code can coexist." />
  <row Id="2800" PostHistoryTypeId="5" PostId="992" RevisionGUID="cfd84463-0e0b-49f9-b2f3-12c0e8069fdb" CreationDate="2014-03-29T22:15:58.580" UserId="8" Comment="more links" Text="Yes, it is possible. using LUFA, you can burn new firmware to the Serial converter. The only problem is that you need to re-burn the USB-Serial converter to upload another program.&#xD;&#xA;&#xD;&#xA;Info: http://www.fourwalledcubicle.com/LUFA.php&#xD;&#xA;&#xD;&#xA;Specific page: http://mitchtech.net/arduino-usb-hid-keyboard/" />
  <row Id="2801" PostHistoryTypeId="2" PostId="994" RevisionGUID="17336391-4d4d-4704-accd-c8ffb0a5c88f" CreationDate="2014-03-29T22:24:57.340" UserId="862" Text="This is for a joystick project and am trying to keep everything a simple and low latency as possible. I am reading the pots with the onboard 10bit adc on the atmega 32u4 but may be upgrading to either a 16bit adc or 24 bit adc.&#xD;&#xA;Thanks &#xD;&#xA;" />
  <row Id="2802" PostHistoryTypeId="1" PostId="994" RevisionGUID="17336391-4d4d-4704-accd-c8ffb0a5c88f" CreationDate="2014-03-29T22:24:57.340" UserId="862" Text="i need a way to filter out noise from adc lines, need no delay and no signal change" />
  <row Id="2803" PostHistoryTypeId="3" PostId="994" RevisionGUID="17336391-4d4d-4704-accd-c8ffb0a5c88f" CreationDate="2014-03-29T22:24:57.340" UserId="862" Text="&lt;arduino-leonardo&gt;" />
  <row Id="2804" PostHistoryTypeId="5" PostId="989" RevisionGUID="cfa45207-081e-41ae-a67c-cf776a980ba7" CreationDate="2014-03-29T22:40:35.837" UserId="220" Comment="Improved formatting and minor spelling errors" Text="I am using a mcp23017 to read button presses for my joystick project and am using the internal pullup to minimize complications. Is there a way to invert all the bits in the uint16_t so i can send the values as normally off?&#xD;&#xA;&#xD;&#xA;I'm using [this Adafruit library](https://github.com/adafruit/Adafruit-MCP23017-Arduino-Library).&#xD;&#xA;&#xD;&#xA;And the reading code: `uint16_t buttons = mcp.readGPIOAB();`" />
  <row Id="2805" PostHistoryTypeId="4" PostId="989" RevisionGUID="cfa45207-081e-41ae-a67c-cf776a980ba7" CreationDate="2014-03-29T22:40:35.837" UserId="220" Comment="Improved formatting and minor spelling errors" Text="How do I use a i2c port expander to read buttons with pull ups and inverting the resulting uint16_t?" />
  <row Id="2806" PostHistoryTypeId="6" PostId="989" RevisionGUID="b8dec290-76b4-428d-9906-f94fff23d11a" CreationDate="2014-03-29T22:42:56.457" UserId="84" Comment="Added tag in relation to actual question" Text="&lt;programming&gt;&lt;arduino-leonardo&gt;" />
  <row Id="2807" PostHistoryTypeId="5" PostId="994" RevisionGUID="dbbbcf17-7a6e-4448-b48e-f7c417d338bf" CreationDate="2014-03-29T22:43:52.237" UserId="220" Comment="Added tags, improved formatting and minor spelling mistakes." Text="I'm working on a project with a joystick and I'm trying to keep everything a simple and low latency as possible. I am reading the pots with the onboard 10bit ADC on the ATmega 32u4 but may be upgrading to either a 16bit ADC or 24 bit ADC. **How can I filter noise out of the signals?**" />
  <row Id="2808" PostHistoryTypeId="4" PostId="994" RevisionGUID="dbbbcf17-7a6e-4448-b48e-f7c417d338bf" CreationDate="2014-03-29T22:43:52.237" UserId="220" Comment="Added tags, improved formatting and minor spelling mistakes." Text="How can I filter out noise from ADC lines without delay or signal change?" />
  <row Id="2809" PostHistoryTypeId="6" PostId="994" RevisionGUID="dbbbcf17-7a6e-4448-b48e-f7c417d338bf" CreationDate="2014-03-29T22:43:52.237" UserId="220" Comment="Added tags, improved formatting and minor spelling mistakes." Text="&lt;pins&gt;&lt;arduino-leonardo&gt;&lt;signal-processing&gt;&lt;electrical-noise&gt;" />
  <row Id="2810" PostHistoryTypeId="2" PostId="995" RevisionGUID="aa8c14e1-e6bb-464a-b938-9afb26dbfda9" CreationDate="2014-03-30T00:05:17.010" UserId="835" Text="I am sending three analog signals through the xbees to be written to analog pins on the receiving side so they can be read in Simulink. I connected both of the arduino megas to my laptop and uploaded the sketches. I have a shield and a series one xbee connected to each arduino. I pulled up the serial monitor for each sketch. I connected a 1 volt DC power supply to all three analog pins. On the transmitting serial monitor I got numbers close to 200 which I believe is correct but on the receiving side I was not getting anything. I believe the problem is with the arduino. After I uploaded the code on the transmitting side the TX led was green but the RX led on the receiving side was not lit up at all. The power LED on the transmitting arduino is red but it is green on the receiving side. The 'L' led on the transmitting side is red on the transmitting side is read and yellow on the receiving side. On both of the xbee shield the power led's are red and the DIO5 led blinks green. On the receiving xbee shield the DOUT LED is red and the DI LED is green. If more information is needed let me know.&#xD;&#xA;&#xD;&#xA;Here is my configuration for the xbees: (series 1. firmware version: 10ed) &lt;br/&gt;&#xD;&#xA;Transmitting Xbee: &lt;br/&gt;&#xD;&#xA;PAN ID: 1234 &lt;br/&gt;&#xD;&#xA;MY:10 &lt;br/&gt;&#xD;&#xA;DL:11 &#xD;&#xA;&#xD;&#xA;Receiving Xbee: &lt;br/&gt;&#xD;&#xA;PAN ID: 1234 &lt;br/&gt;&#xD;&#xA;MY: 11 &lt;br/&gt;&#xD;&#xA;DL: 10 &lt;br/&gt;&#xD;&#xA;&#xD;&#xA;Transmitting arduino program:&#xD;&#xA;&#xD;&#xA;    int val1 = 0;&#xD;&#xA;    int val2 = 0;&#xD;&#xA;    int val3 = 0;&#xD;&#xA;    int analogPin1 = 0; //these are you analog in pins&#xD;&#xA;    int analogPin2 = 1;&#xD;&#xA;    int analogPin3 = 2;&#xD;&#xA;    void setup()  {&#xD;&#xA;      Serial.begin(9600);  //start serial&#xD;&#xA;    }&#xD;&#xA;    void loop()                               // run over and over again&#xD;&#xA;    {&#xD;&#xA;            Serial.print(&quot;&lt;&quot;);                // This character signifies the begining of our data cycle&#xD;&#xA;                val1 = analogRead(analogPin1);    // read the input pin&#xD;&#xA;            Serial.println(val1);             // output the signal&#xD;&#xA;            Serial.print(&quot;\t&quot;);               // Signifies end of 1st piece of data&#xD;&#xA;                val2 = analogRead(analogPin2);    // read the input pin&#xD;&#xA;            Serial.println(val2);             // output the signal&#xD;&#xA;            Serial.print(&quot;\t&quot;);               // Signifies end of 2nd piece of data        &#xD;&#xA;                val3 = analogRead(analogPin3);    // read the input pin&#xD;&#xA;            Serial.println(val3);             // output the signal&#xD;&#xA;            Serial.print(&quot;&gt;&quot;);                // This character signifies the end of our data cycle&#xD;&#xA;            delay(100); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Receiving Arduino program:&#xD;&#xA;&#xD;&#xA;    #include &lt;SoftwareSerial.h&gt;&#xD;&#xA;    // software serial #1: TX = digital pin 0, RX = digital pin 1&#xD;&#xA;    SoftwareSerial portOne(0,1);&#xD;&#xA;    int Apin1 = 0; // These variables hold the current incoming value&#xD;&#xA;    int Apin2 = 0;&#xD;&#xA;    int Apin3 = 0;&#xD;&#xA;    int AnalogOut1 = 0;  //Set our analog pins&#xD;&#xA;    int AnalogOut2 = 1;&#xD;&#xA;    int AnalogOut3 = 2;&#xD;&#xA;    int Digits = 0; // Helps watch for comma&#xD;&#xA;    int Mode = 0; // This designates which section of reading we are doing - begin = 0, Apin1 = 1, Apin2 = 2, APin3 = 3, end = 4&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;     // Open serial communications and wait for port to open:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      // Start each software serial port&#xD;&#xA;      portOne.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      portOne.listen();&#xD;&#xA;      while (portOne.available() &gt; 0) {&#xD;&#xA;      // read the incoming byte:&#xD;&#xA;        char inByte = portOne.read();&#xD;&#xA;&#xD;&#xA;        if (isdigit(inByte) &amp;&amp; Mode == 1) {&#xD;&#xA;        int temp = inByte - '0';&#xD;&#xA;        Apin1 = (Apin1 * 10) + temp;&#xD;&#xA;        Serial.print('\n'); // This is just some debugging stuff, if you plug in your programmer this will output the data to a serial monitor&#xD;&#xA;        Serial.print(temp);&#xD;&#xA;        Serial.print('\n');&#xD;&#xA;        Serial.print(Apin1);&#xD;&#xA;        Serial.print('\n');&#xD;&#xA;        }&#xD;&#xA;       if (isdigit(inByte) &amp;&amp; Mode == 2) {&#xD;&#xA;        int temp = inByte - '0';&#xD;&#xA;        Apin2 = (Apin2 * 10) + temp;&#xD;&#xA;        Serial.print(temp); // This is just some debugging stuff, if you plug in your programmer this will output the data to a serial monitor&#xD;&#xA;        Serial.print('\n');&#xD;&#xA;        Serial.print(Apin2);&#xD;&#xA;        Serial.print('\n');&#xD;&#xA;        }&#xD;&#xA;      if (isdigit(inByte) &amp;&amp; Mode == 3) {&#xD;&#xA;        int temp = inByte - '0';&#xD;&#xA;        Apin3 = (Apin3 * 10) + temp;&#xD;&#xA;        Serial.print(temp); // This is just some debugging stuff, if you plug in your programmer this will output the data to a serial monitor&#xD;&#xA;        Serial.print('\n');&#xD;&#xA;        Serial.print(Apin3);&#xD;&#xA;        Serial.print('\n');&#xD;&#xA;        }&#xD;&#xA;        if (inByte == ',') {&#xD;&#xA;        Mode++;&#xD;&#xA;        }&#xD;&#xA;        if (inByte == '&lt;') {&#xD;&#xA;        Mode = 1;&#xD;&#xA;        }&#xD;&#xA;        if (inByte == '&gt;') {&#xD;&#xA;        Mode = 4;&#xD;&#xA;        if (Apin1 &gt; 0 &amp;&amp; Apin2 &gt; 0 &amp;&amp; Apin3 &gt; 0) {&#xD;&#xA;        analogWrite(AnalogOut1, Apin1);&#xD;&#xA;        analogWrite(AnalogOut2, Apin2);&#xD;&#xA;        analogWrite(AnalogOut3, Apin3);&#xD;&#xA;        }&#xD;&#xA;        Serial.print('\n'); // This is just some debugging stuff, if you plug in your programmer this will output the data to a serial monitor&#xD;&#xA;        Serial.print(Apin1);&#xD;&#xA;        Serial.print('\n');&#xD;&#xA;        Serial.print(Apin2);&#xD;&#xA;        Serial.print('\n');&#xD;&#xA;        Serial.print(Apin3);&#xD;&#xA;        Serial.print('\n');&#xD;&#xA;        Apin1 = 0; // These variables hold the current incoming value&#xD;&#xA;        Apin2 = 0;&#xD;&#xA;        Apin3 = 0;&#xD;&#xA;              }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="2811" PostHistoryTypeId="1" PostId="995" RevisionGUID="aa8c14e1-e6bb-464a-b938-9afb26dbfda9" CreationDate="2014-03-30T00:05:17.010" UserId="835" Text="Problem with Xbee or Arduino?" />
  <row Id="2812" PostHistoryTypeId="3" PostId="995" RevisionGUID="aa8c14e1-e6bb-464a-b938-9afb26dbfda9" CreationDate="2014-03-30T00:05:17.010" UserId="835" Text="&lt;arduino-mega&gt;&lt;xbee&gt;" />
  <row Id="2813" PostHistoryTypeId="2" PostId="996" RevisionGUID="53b2b227-db60-4355-94f7-52a3e896da53" CreationDate="2014-03-30T00:48:25.140" UserId="304" Text="I am assuming now that both XBee's are running in AT mode. &#xD;&#xA;&#xD;&#xA;The problem is the same as last time (http://arduino.stackexchange.com/questions/843/xbeearduino-communication-problem?rq=1)&#xD;&#xA;&#xD;&#xA;You are sending the data via: &#xD;&#xA;&#xD;&#xA;    Serial.println(val1);&#xD;&#xA;&#xD;&#xA;which outputs an `ASCII` representation of the number.&#xD;&#xA;&#xD;&#xA;But in your reading, you are reading in a `byte` value. Actually, I just realised you are reading in a `char` which is a signed (-128 to 127) value: &#xD;&#xA;&#xD;&#xA;    char inByte = portOne.read();&#xD;&#xA;&#xD;&#xA;first, change that to:&#xD;&#xA;&#xD;&#xA;    byte inByte = portOne.read();&#xD;&#xA;&#xD;&#xA;Now, you have three options:&#xD;&#xA;&#xD;&#xA;1. If (as you say) the numbers you expect are around `200` and will **always** be below `256` then you could send a byte value instead. That way, when you read the byte in, you get the same value. &#xD;&#xA;&#xD;&#xA;2. If you need to send larger than a byte value, eg `int`, then send as two bytes, HIGH and LOW. Then on the receiving end, take in two bytes when reading that data.&#xD;&#xA;&#xD;&#xA;3. Send as plain text but read in as plain text. Since you have delimiters, keep reading in the serial until you have all the data you need and then break it down. " />
  <row Id="2814" PostHistoryTypeId="5" PostId="996" RevisionGUID="f72c1fe3-70e8-466f-bcd3-042c4f9998da" CreationDate="2014-03-30T00:56:15.593" UserId="304" Comment="added 147 characters in body" Text="I am assuming now that both XBee's are running in AT mode. &#xD;&#xA;&#xD;&#xA;The problem is the same as last time (http://arduino.stackexchange.com/questions/843/xbeearduino-communication-problem?rq=1)&#xD;&#xA;&#xD;&#xA;You are sending the data via: &#xD;&#xA;&#xD;&#xA;    Serial.println(val1);&#xD;&#xA;&#xD;&#xA;which outputs an `ASCII` representation of the number.&#xD;&#xA;&#xD;&#xA;But in your reading, you are reading in a `byte` value. Actually, I just realised you are reading in a `char` which is a signed (-128 to 127) value: &#xD;&#xA;&#xD;&#xA;    char inByte = portOne.read();&#xD;&#xA;&#xD;&#xA;first, change that to:&#xD;&#xA;&#xD;&#xA;    byte inByte = portOne.read();&#xD;&#xA;&#xD;&#xA;Now, you have three options:&#xD;&#xA;&#xD;&#xA;1. If (as you say) the numbers you expect are around `200` and will **always** be below `256` (and positive) then you could send a byte value instead. That way, when you read the byte in, you get the same value. You would do this using `Serial.write(val1);` instead of `print`.&#xD;&#xA;&#xD;&#xA;2. If you need to send larger than a byte value, eg `int`, then send as two bytes, HIGH and LOW. Then on the receiving end, take in two bytes when reading that data.&#xD;&#xA;&#xD;&#xA;3. Send as plain text but read in as plain text. Since you have delimiters, keep reading in the serial until you have all the data you need and then break it down. (You could adapt the code I posted in the answer above to do that)." />
  <row Id="2815" PostHistoryTypeId="5" PostId="996" RevisionGUID="4cf97bce-70ff-4079-bafe-89ed614476e9" CreationDate="2014-03-30T01:02:13.790" UserId="304" Comment="removed assumption, it's apparent from the code" Text="The problem is the same as last time (http://arduino.stackexchange.com/questions/843/xbeearduino-communication-problem?rq=1)&#xD;&#xA;&#xD;&#xA;You are sending the data via: &#xD;&#xA;&#xD;&#xA;    Serial.println(val1);&#xD;&#xA;&#xD;&#xA;which outputs an `ASCII` representation of the number.&#xD;&#xA;&#xD;&#xA;But in your reading, you are reading in a `byte` value. Actually, I just realised you are reading in a `char` which is a signed (-128 to 127) value: &#xD;&#xA;&#xD;&#xA;    char inByte = portOne.read();&#xD;&#xA;&#xD;&#xA;first, change that to:&#xD;&#xA;&#xD;&#xA;    byte inByte = portOne.read();&#xD;&#xA;&#xD;&#xA;Now, you have three options:&#xD;&#xA;&#xD;&#xA;1. If (as you say) the numbers you expect are around `200` and will **always** be below `256` (and positive) then you could send a byte value instead. That way, when you read the byte in, you get the same value. You would do this using `Serial.write(val1);` instead of `print`.&#xD;&#xA;&#xD;&#xA;2. If you need to send larger than a byte value, eg `int`, then send as two bytes, HIGH and LOW. Then on the receiving end, take in two bytes when reading that data.&#xD;&#xA;&#xD;&#xA;3. Send as plain text but read in as plain text. Since you have delimiters, keep reading in the serial until you have all the data you need and then break it down. (You could adapt the code I posted in the answer above to do that)." />
  <row Id="2816" PostHistoryTypeId="5" PostId="996" RevisionGUID="2f3214bb-491d-41ab-888f-737a73dd8bd3" CreationDate="2014-03-30T01:52:26.537" UserId="304" Comment="Looked more deeply at their code. " Text="The problem is the same as last time (http://arduino.stackexchange.com/questions/843/xbeearduino-communication-problem?rq=1)&#xD;&#xA;&#xD;&#xA;You are sending the data via: &#xD;&#xA;&#xD;&#xA;    Serial.println(val1);&#xD;&#xA;&#xD;&#xA;which outputs an `ASCII` representation of the number.&#xD;&#xA;&#xD;&#xA;But in your reading, you are reading in a `byte` value. Actually, I just realised you are reading in a `char` which is a signed (-128 to 127) value: &#xD;&#xA;&#xD;&#xA;    char inByte = portOne.read();&#xD;&#xA;&#xD;&#xA;first, change that to:&#xD;&#xA;&#xD;&#xA;    byte inByte = portOne.read();&#xD;&#xA;&#xD;&#xA;Now, you have three options:&#xD;&#xA;&#xD;&#xA;1. If (as you say) the numbers you expect are around `200` and will **always** be below `256` (and positive) then you could send a byte value instead. That way, when you read the byte in, you get the same value. You would do this using `Serial.write(val1);` instead of `print`.&#xD;&#xA;&#xD;&#xA;2. If you need to send larger than a byte value, eg `int`, then send as two bytes, HIGH and LOW. Then on the receiving end, take in two bytes when reading that data.&#xD;&#xA;&#xD;&#xA;3. Send as plain text but read in as plain text. Since you have delimiters, keep reading in the serial until you have all the data you need and then break it down. (You could adapt the code I posted in the answer above to do that).&#xD;&#xA;&#xD;&#xA;**edit:** a couple of other points with your code:&#xD;&#xA;&#xD;&#xA;You're doing an `analogWrite` to digital pins `0, 1,` and `2`. Was that your intention? `analogWrite` is reserved for sending out PWM signals on only those pins that are capable (see: http://arduino.cc/en/Reference/analogWrite )&#xD;&#xA;&#xD;&#xA;`analogRead` will read a value of `0-1023` and if your intention is to just use PWM at the other end, then step it down to a value of `0-255`. In that case you can get away with writing byte values to `Serial.write`. &#xD;&#xA;&#xD;&#xA;You're never setting the `pinMode` of the outputs in the receiver. " />
  <row Id="2817" PostHistoryTypeId="2" PostId="997" RevisionGUID="0e911dbe-0f52-49e2-9d92-ec42b1047223" CreationDate="2014-03-30T03:02:36.897" UserId="220" Text="I already had this answer typed up on another question so I thought I'd post it here to help you. I've replaced &quot;tablet&quot; with &quot;phone&quot; for easy reading.&#xD;&#xA;&#xD;&#xA;&gt; ## You never mentioned your phone model... or Arduino model ##&#xD;&#xA;&gt; &#xD;&#xA;&gt; There are some phones designed to work with USB flash drives and&#xD;&#xA;&gt; printers. This is called OTG (on the go.&#xD;&#xA;&gt; &#xD;&#xA;&gt; **You need:**&#xD;&#xA;&gt; &#xD;&#xA;&gt;  - A phone supporting OTG&#xD;&#xA;&gt;  - An OTG adapter that fits into your phone's USB slot and is compatible&#xD;&#xA;&gt;  - [The Arduino Uno Communicator App](https://play.google.com/store/apps/details?id=com.primavera.arduino.listener)&#xD;&#xA;&gt;  - Arduino Uno (or clone) [Note: It says that it works with Atmega16U2 or Atmega8U2 programmed as a USB-to-serial converter so I would assume&#xD;&#xA;&gt; that that would cover a few boards more than the Uno.)&#xD;&#xA;&gt; &#xD;&#xA;&gt; Another alternitive is to look into&#xD;&#xA;&gt; [Bluetooth](https://www.google.com/search?q=arduino+bluetooth&amp;qscrl=1&amp;tbm=isch&amp;imgil=WyPC4O05Xn4rhM%253A%253Bhttps%253A%252F%252Fencrypted-tbn2.gstatic.com%252Fimages%253Fq%253Dtbn%253AANd9GcSfTtWqIuN9YYdd90OO_tlxsvLUYhV_pl7NfaMhHDzSRq9N6W9rNA%253B1200%253B1200%253B1soQc4CzMzh0MM%253Bhttp%25253A%25252F%25252Fm.dhgate.com%25252Fproduct%25252Fjy-mcu-arduino-bluetooth-wireless-serial%25252F151048482.html&amp;source=iu&amp;usg=__KyMLS4aeubxJnDaMvprgRgADxAs%3D&amp;sa=X&amp;ei=1BUCU635IYmEygGO1oHwCQ&amp;ved=0CGkQ9QEwBg&amp;biw=1280&amp;bih=899)&#xD;&#xA;&gt; (Note: I just picked a random link but there are hundreds of similar&#xD;&#xA;&gt; BT adapters)&#xD;&#xA;&#xD;&#xA;*[From my answer on a similar question](http://arduino.stackexchange.com/a/272/220)*" />
  <row Id="2818" PostHistoryTypeId="5" PostId="996" RevisionGUID="3e4cec47-6274-4afb-abf5-8a93431ac10a" CreationDate="2014-03-30T03:41:21.567" UserId="304" Comment="added about new line and hardware and software serials" Text="The problem is the same as last time (http://arduino.stackexchange.com/questions/843/xbeearduino-communication-problem?rq=1)&#xD;&#xA;&#xD;&#xA;You are sending the data via: &#xD;&#xA;&#xD;&#xA;    Serial.println(val1);&#xD;&#xA;&#xD;&#xA;which outputs an `ASCII` representation of the number.&#xD;&#xA;&#xD;&#xA;But in your reading, you are reading in a `byte` value. Actually, I just realised you are reading in a `char` which is a signed (-128 to 127) value: &#xD;&#xA;&#xD;&#xA;    char inByte = portOne.read();&#xD;&#xA;&#xD;&#xA;first, change that to:&#xD;&#xA;&#xD;&#xA;    byte inByte = portOne.read();&#xD;&#xA;&#xD;&#xA;Now, you have three options:&#xD;&#xA;&#xD;&#xA;1. If (as you say) the numbers you expect are around `200` and will **always** be below `256` (and positive) then you could send a byte value instead. That way, when you read the byte in, you get the same value. You would do this using `Serial.write(val1);` instead of `print`.&#xD;&#xA;&#xD;&#xA;2. If you need to send larger than a byte value, eg `int`, then send as two bytes, HIGH and LOW. Then on the receiving end, take in two bytes when reading that data.&#xD;&#xA;&#xD;&#xA;3. Send as plain text but read in as plain text. Since you have delimiters, keep reading in the serial until you have all the data you need and then break it down. (You could adapt the code I posted in the answer above to do that).&#xD;&#xA;&#xD;&#xA;**edit:** a couple of other points with your code:&#xD;&#xA;&#xD;&#xA;- You're doing an `analogWrite` to digital pins `0, 1,` and `2`. Was that your intention? `analogWrite` is reserved for sending out PWM signals on only those pins that are capable (see: http://arduino.cc/en/Reference/analogWrite )&#xD;&#xA;&#xD;&#xA;- `analogRead` will read a value of `0-1023` and if your intention is to just use PWM at the other end, then step it down to a value of `0-255`. In that case you can get away with writing byte values to `Serial.write`. &#xD;&#xA;&#xD;&#xA;- You're never setting the `pinMode` of the outputs in the receiver. &#xD;&#xA;&#xD;&#xA;- You're sending `val1`, `val2`, and `val3` out via `Serial.println` which will send your value out (as `ASCII`), followed by a newline, so the bytes sent from that one line will be `32 30 30 0D 0A`. You have to interpret that at the other end. &#xD;&#xA;&#xD;&#xA;- You're also using software serial on the hardware serial port (you're assigning digital pins 0 and 1. These are the hardware serial pins). **BUT** you're also initialising it via hardware serial. I'm guessing that it really wouldn't matter (if the pins are aligned), but you can't expect to receive data via software serial and send data via hardware serial if they're all using the same pins. " />
  <row Id="2819" PostHistoryTypeId="10" PostId="995" RevisionGUID="d49ce592-1007-414d-a0d3-cf4d56a42be5" CreationDate="2014-03-30T06:00:01.240" UserId="11" Comment="101" Text="{&quot;OriginalQuestionIds&quot;:[843],&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="2820" PostHistoryTypeId="5" PostId="983" RevisionGUID="8a610cc3-875e-4e77-9dda-24454fc28625" CreationDate="2014-03-30T08:54:04.773" UserId="693" Comment="added 1 characters in body" Text="I tested an MPU-6050 (GY-521) using an Arduino Nano. I used the I2CDevLib and opened the MPU6050_DMP6.ino with the Arduino IDE. I opened the Processing-file with Processing. A few changes was necessary to make it work:&#xD;&#xA;&#xD;&#xA;    MPU6050 mpu;&#xD;&#xA;&#xD;&#xA;was changed into:&#xD;&#xA;    &#xD;&#xA;    MPU6050 mpu(0x68);&#xD;&#xA;&#xD;&#xA;Additionally I commented out this line:&#xD;&#xA;&#xD;&#xA;    #define OUTPUT_READABLE_YAWPITCHROLL&#xD;&#xA;&#xD;&#xA;and uncommented this line:&#xD;&#xA;&#xD;&#xA;    #define OUTPUT_TEAPOT&#xD;&#xA;&#xD;&#xA;When turning everything on, the arrow (Processing) would turn with 5 degrees/s clockwise around the z-axis (plus a very small amount around the other two axes). After about 20 seconds, it would stop, and turn around the x-axis pretty fast for 3 seconds. Then it would stop. Now, the gyroscope+accelerometer would work perfectly. This happens every time I test it.&#xD;&#xA;&#xD;&#xA;This happens only when the gyroscope is perfectly still on the ground. It does not stabilize if I move it around. Only after it is left completely still, it'll stabilize after 23 seconds.&#xD;&#xA;&#xD;&#xA;Is this how it should work, or is it a problem with the gyroscope? Could it even be caused by the I2CDevLib? Can anybody else confirm this?" />
  <row Id="2821" PostHistoryTypeId="2" PostId="998" RevisionGUID="2dd34e24-4d75-494f-b7b9-b68ea3e4ff8b" CreationDate="2014-03-30T10:23:09.567" UserId="84" Text="Here is the way I finally decided to follow for my projects.&#xD;&#xA;&#xD;&#xA;# Arduino-CMake&#xD;&#xA;The first important decision I made was the choice of a build tool that could work for my environment (Windows) but was not limited to it (I want my projects easily reusable by other people).&#xD;&#xA;&#xD;&#xA;I have tested various open source Arduino make tools:&#xD;&#xA;&#xD;&#xA; - **[Guyzmo Makefile][1]** (suggested by @zmo answer): this is just a standard Makefile handcrafted for Arduino builds; this is a Unix Makefile but there  is a [good port][2] of **Unix make for Windows**; still, unfortunately this Makefile works only for Unix, of course it could be adapted for Windows, but I wanted a tool that works &quot;out of the box&quot;.&#xD;&#xA; - **[Arduino-Makefile][3]** (suggested by @adnues answer): this a more advanced project, based on Unix Makefile, that aims to be easily reusable by all Arduino projects; it is documented as working on Mac, Linux and Windows, but Windows support proved wrong in my first experiments (many dependencies on Unix shell).&#xD;&#xA; - **[Graduino][4]** (not suggested by any answer): this build tool is based on well-known [gradle][5] build tool from the [groovy][6] world; the tool seems quite well done but requires some (little) groovy/gradle knowlegde, and has only little documentation; I decided not to go with it due to the burden of installing groovy and gradle just for it (I'd like to avoid too many pre-requisites to people who want to build my projects on their environments).&#xD;&#xA; - **[Arduino-CMake][7]** (not suggested by any answer): this seems the best of all, it has a long history, has many supporters and maintainers, is very well documented, comes with simple examples and also has a few good tutorial blog posts on the Web, e.g. [here][8] and [there][9]. It is based on [CMake][10], a &quot;Cross-Platform Make&quot;.&#xD;&#xA;&#xD;&#xA;I have also found **[ArduinoDevel][11]**, another Arduino build tool -which I have not experimented- that can generate **Unix Makefiles** or [ant][12] `build.xml` files; that one seemed interesting but a bit limited in terms of functionality.&#xD;&#xA;&#xD;&#xA;Finally I decided to go with **Arduino-CMake**:&#xD;&#xA;&#xD;&#xA; - it was easy to setup: just install **CMake** on your machine and copy Arduino-CMake in some directory that is easily accessible (through relative paths) from your projects directories.&#xD;&#xA; - the examples worked out of the box for me (just followed the comments in `CMakeLists.txt` configuration file to adapt properties that needed to for my environment, e.g. Arduino type, serial port)&#xD;&#xA; - you can organize your projects any way you want&#xD;&#xA; - it can generate configuration files for various build tools out there (I have only tested **Unix Makefiles** though), including [Eclipse][13] projects.&#xD;&#xA; - in the generated make, several targets get created to support:&#xD;&#xA;&#xD;&#xA;   - libraries build&#xD;&#xA;   - programs build&#xD;&#xA;   - program upload to boards&#xD;&#xA;   - serial monitor launch&#xD;&#xA;   - and a few others I have not tested yet&#xD;&#xA;&#xD;&#xA;# Project Structure&#xD;&#xA;Since Arduono-CMake does not impose any directory structure for your project, you can choose the one that fits you best.&#xD;&#xA;&#xD;&#xA;Here is what I've done personnaly (that still requires further refinement, but I'm happy with it now):&#xD;&#xA;&#xD;&#xA;![enter image description here][14]&#xD;&#xA;&#xD;&#xA;I have decided to put all my projects under a common `arduino-stuff` directory (which I commit to github as a whole, I know I could use ***git submodules*** for a better organisation on github, but had no time to check that yet).&#xD;&#xA;&#xD;&#xA;`arduino-stuff` has the following content:&#xD;&#xA;&#xD;&#xA; - `build`: that's a directory where cmake and make will generate all their stuff (makefiles, cache, object files...); this one does ot get committed to github&#xD;&#xA; - `cmake`: that one is just a copy (unmodified) of [Arduino-CMake cmake][15] directory. This one gets on github so that it's easier for someone who wants to build my projects&#xD;&#xA; - `CMakeLists.txt`: that's the &quot;global&quot; CMake configuration that declares all defaults for my environment (board, serial port) and the list of build target subdirectories&#xD;&#xA; - `TaskManager`: this is my first project based on Arduino-CMake, this one is a library with examples; this idrectory also contains a `CMakeLists.txt` that states the targets for the project&#xD;&#xA;&#xD;&#xA;# Points to improve&#xD;&#xA;The current solution is not perfect though.&#xD;&#xA;Among improvements I see (that's rather for Arduino-CMake project to include these improvements if they see fit):&#xD;&#xA;&#xD;&#xA; - Feature to copy a library directory from the current project to the Arduino libraries directory&#xD;&#xA; - Feature to upload a library to github&#xD;&#xA; - Feature to download a library from github&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/guyzmo/Arduino-Tools&#xD;&#xA;  [2]: http://gnuwin32.sourceforge.net/packages/make.htm&#xD;&#xA;  [3]: https://github.com/sudar/Arduino-Makefile&#xD;&#xA;  [4]: https://bitbucket.org/magnomp/graduino/&#xD;&#xA;  [5]: http://www.gradle.org/&#xD;&#xA;  [6]: http://groovy.codehaus.org/&#xD;&#xA;  [7]: https://github.com/queezythegreat/arduino-cmake&#xD;&#xA;  [8]: http://www.pascalspoerri.ch/posts/2013/12/29/using-arduino-with-cmake/&#xD;&#xA;  [9]: http://duinoworks.bakketti.com/?p=11&#xD;&#xA;  [10]: http://www.cmake.org/&#xD;&#xA;  [11]: https://github.com/arons/ArduinoDevel&#xD;&#xA;  [12]: http://ant.apache.org/&#xD;&#xA;  [13]: https://www.eclipse.org/&#xD;&#xA;  [14]: http://i.stack.imgur.com/gV76h.png&#xD;&#xA;  [15]: https://github.com/queezythegreat/arduino-cmake/tree/master/cmake" />
  <row Id="2822" PostHistoryTypeId="2" PostId="999" RevisionGUID="bb3581a8-d2a1-4eb5-8d17-b93a3e09ed83" CreationDate="2014-03-30T11:01:29.997" UserId="693" Text="&gt; [...] d0, d1, d2, and d3 are optional; if omitted, the LCD will be controlled using only the four data lines (d4, d5, d6, d7).&#xD;&#xA;&#xD;&#xA;What is the point of `d0-d3` if they are not needed? Will they decrease the response time?" />
  <row Id="2823" PostHistoryTypeId="1" PostId="999" RevisionGUID="bb3581a8-d2a1-4eb5-8d17-b93a3e09ed83" CreationDate="2014-03-30T11:01:29.997" UserId="693" Text="What is the point of D0-D3 on LCD?" />
  <row Id="2824" PostHistoryTypeId="3" PostId="999" RevisionGUID="bb3581a8-d2a1-4eb5-8d17-b93a3e09ed83" CreationDate="2014-03-30T11:01:29.997" UserId="693" Text="&lt;lcd&gt;" />
  <row Id="2825" PostHistoryTypeId="5" PostId="999" RevisionGUID="b70004ce-fdc8-49e5-8e5b-f6f48f431457" CreationDate="2014-03-30T11:12:46.067" UserId="84" Comment="Clarified the question" Text="The [Arduino LiquidCrystalDisplay library][1] has 4 constructors wth different arguments:&#xD;&#xA;&#xD;&#xA;    LiquidCrystal(rs, enable, d4, d5, d6, d7) &#xD;&#xA;    LiquidCrystal(rs, rw, enable, d4, d5, d6, d7) &#xD;&#xA;    LiquidCrystal(rs, enable, d0, d1, d2, d3, d4, d5, d6, d7) &#xD;&#xA;    LiquidCrystal(rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7)&#xD;&#xA;&#xD;&#xA;The following comments are stated for the constructor arguments:&#xD;&#xA;&#xD;&#xA;&gt; [...] d0, d1, d2, and d3 are optional; if omitted, the LCD will be controlled using only the four data lines (d4, d5, d6, d7).&#xD;&#xA;&#xD;&#xA;What is the point of `d0-d3` if they are not needed? Will they decrease the response time?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/LiquidCrystalConstructor" />
  <row Id="2826" PostHistoryTypeId="2" PostId="1000" RevisionGUID="29b0bc77-3735-4232-82f4-654260646214" CreationDate="2014-03-30T11:21:43.323" UserId="84" Text="The answer is on the same page as the quote you mentioned (I have highlighted the important statement):&#xD;&#xA;&#xD;&#xA;&gt; Creates a variable of type LiquidCrystal. **The display can be controlled using 4 or 8 data lines**. If the former, omit the pin numbers for d0 to d3 and leave those lines unconnected. The RW pin can be tied to ground instead of connected to a pin on the Arduino; if so, omit it from this function's parameters.&#xD;&#xA;&#xD;&#xA;It turns out that the Hitachi HD44780 LCD display can work in 4-bit or 8-bit modes.&#xD;&#xA;" />
  <row Id="2827" PostHistoryTypeId="2" PostId="1001" RevisionGUID="5f721b3d-6ae5-42e3-92e6-f183512c23fb" CreationDate="2014-03-30T11:42:17.693" UserId="42" Text="8-bit mode is a basically just a little faster.&#xD;&#xA;&#xD;&#xA;When it's running in 4-bit mode, you need to send commands and data etc. in two batches of 4-bits. That means it requires double the number of cycles to get anything done.&#xD;&#xA;&#xD;&#xA;When text is being sent to the display, it will technically update a little quicker in 8-bit mode (it will take slightly less time to send each character). A person looking at it probably won't see a big speed difference though. The main impact will be on the microcontroller. If it can use the faster 8-bit mode then it can devote a little more processing time to other things. That's particularly helpful for timing-critical applications." />
  <row Id="2828" PostHistoryTypeId="5" PostId="999" RevisionGUID="3676f351-2b7d-4f35-b9aa-9f619b3aaf17" CreationDate="2014-03-30T11:43:39.910" UserId="42" Comment="Corrected library name, and another minor typo" Text="The [Arduino LiquidCrystal library][1] has 4 constructors with different arguments:&#xD;&#xA;&#xD;&#xA;    LiquidCrystal(rs, enable, d4, d5, d6, d7) &#xD;&#xA;    LiquidCrystal(rs, rw, enable, d4, d5, d6, d7) &#xD;&#xA;    LiquidCrystal(rs, enable, d0, d1, d2, d3, d4, d5, d6, d7) &#xD;&#xA;    LiquidCrystal(rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7)&#xD;&#xA;&#xD;&#xA;The following comments are stated for the constructor arguments:&#xD;&#xA;&#xD;&#xA;&gt; [...] d0, d1, d2, and d3 are optional; if omitted, the LCD will be controlled using only the four data lines (d4, d5, d6, d7).&#xD;&#xA;&#xD;&#xA;What is the point of `d0-d3` if they are not needed? Will they decrease the response time?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/LiquidCrystalConstructor" />
  <row Id="2829" PostHistoryTypeId="5" PostId="1001" RevisionGUID="d163c6fa-0bfd-4cb7-8609-d0fce6480e6f" CreationDate="2014-03-30T11:49:37.323" UserId="42" Comment="added 27 characters in body" Text="8-bit mode is a basically just a little faster.&#xD;&#xA;&#xD;&#xA;When it's running in 4-bit mode, you need to send commands and data etc. in two batches of 4-bits. That means it requires double the number of cycles to get anything done.&#xD;&#xA;&#xD;&#xA;When text is being sent to the display, it will technically update a little quicker in 8-bit mode (it will take slightly less time to send each character). A person looking at it probably won't see a big speed difference though. The main impact will be on the microcontroller (the Arduino in this case). If it can use the faster 8-bit mode then it can devote a little more processing time to other things. That's particularly helpful for timing-critical applications." />
  <row Id="2830" PostHistoryTypeId="2" PostId="1002" RevisionGUID="9ef02e14-46c9-4a9b-b112-0ed434c52e6b" CreationDate="2014-03-30T13:05:38.427" UserId="46" Text="I'm [debugging a couple of RS232-to-TTL converter boards](http://electronics.stackexchange.com/q/104466/29792) that I'm trying to use to program my Arduinos and one thing I would like to try would be to reduce the upload serial speed from 115200 to 19200. &#xD;&#xA;&#xD;&#xA;**How do I do that?**&#xD;&#xA;&#xD;&#xA;I imagine that there's a setting that can be easily changed on the Arduino IDE preferences. But where is it? But then the bootloader speed would have to match that? **How do I change the serial upload speed on optiboot, too?**&#xD;&#xA;" />
  <row Id="2831" PostHistoryTypeId="1" PostId="1002" RevisionGUID="9ef02e14-46c9-4a9b-b112-0ed434c52e6b" CreationDate="2014-03-30T13:05:38.427" UserId="46" Text="How to reduce serial speed on Arduino bootloader (optiboot) and on the IDE?" />
  <row Id="2832" PostHistoryTypeId="3" PostId="1002" RevisionGUID="9ef02e14-46c9-4a9b-b112-0ed434c52e6b" CreationDate="2014-03-30T13:05:38.427" UserId="46" Text="&lt;arduino-uno&gt;&lt;serial&gt;&lt;arduino-ide&gt;&lt;bootloader&gt;" />
  <row Id="2833" PostHistoryTypeId="2" PostId="1003" RevisionGUID="5e5d7a1d-d162-4856-a526-ffb7bdbf5eb4" CreationDate="2014-03-30T13:21:02.950" UserId="46" Text="The Arduino Uno has an ICSP header that I imagine is for programming the board using a separate ICSP programmer. That is, its ICSP header turn the board into a target.&#xD;&#xA;&#xD;&#xA;**Can one use that same ICSP to program other boards, turning the Arduino Uno effectively into a ICSP AVR programmer? How?**&#xD;&#xA;&#xD;&#xA;I'm assuming that the target boards would also be Arduinos and wanted the Uno to program them using the Arduino IDE. Is that possible?&#xD;&#xA;&#xD;&#xA;Reading the [AVR In-System Programming Application Note](http://www.atmel.in/Images/doc0943.pdf) it looks to me that the only issue would be to make the programmer (the Arduino Uno) control the target board reset line. I've seen something like that in ArduinoISP sketch, but in that sketch, the target reset is controlled by port D10. But one could program the reset line to be an output, right? So could we change the ArduinoISP sketch to use its own reset line as output to control the target board reset line? If not, **why not?**" />
  <row Id="2834" PostHistoryTypeId="1" PostId="1003" RevisionGUID="5e5d7a1d-d162-4856-a526-ffb7bdbf5eb4" CreationDate="2014-03-30T13:21:02.950" UserId="46" Text="Can the Arduino Uno become an AVR programmer and use the ICSP header to program the target board" />
  <row Id="2835" PostHistoryTypeId="3" PostId="1003" RevisionGUID="5e5d7a1d-d162-4856-a526-ffb7bdbf5eb4" CreationDate="2014-03-30T13:21:02.950" UserId="46" Text="&lt;arduino-uno&gt;&lt;icsp&gt;&lt;arduinoisp&gt;" />
  <row Id="2837" PostHistoryTypeId="2" PostId="1004" RevisionGUID="19939980-8aec-40e5-81a2-ab0256d9dd74" CreationDate="2014-03-30T13:44:16.507" UserId="84" Text="On Arduino IDE side, the upload speed is coded in `hardware/arduino/boards.txt` &#xD;&#xA;&#xD;&#xA;    uno.upload.speed=115200&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;for every kind of board; you cannot change it directly from the IDE (that would be too dangerous as that value must match the **expected speed for the actual bootloader** of every board).&#xD;&#xA;&#xD;&#xA;Now as per the optiboot loader side, the upload speed is defined in `BAUD_RATE` macro, in `optiboot.c`:&#xD;&#xA;&#xD;&#xA;    /* set the UART baud rate defaults */&#xD;&#xA;    #ifndef BAUD_RATE&#xD;&#xA;    #if F_CPU &gt;= 8000000L&#xD;&#xA;    #define BAUD_RATE   115200L // Highest rate Avrdude win32 will support&#xD;&#xA;    #elsif F_CPU &gt;= 1000000L&#xD;&#xA;    #define BAUD_RATE   9600L   // 19200 also supported, but with significant error&#xD;&#xA;    #elsif F_CPU &gt;= 128000L&#xD;&#xA;    #define BAUD_RATE   4800L   // Good for 128kHz internal RC&#xD;&#xA;    #else&#xD;&#xA;    #define BAUD_RATE 1200L     // Good even at 32768Hz&#xD;&#xA;    #endif&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;So I guess you can:&#xD;&#xA;&#xD;&#xA;1. `#define BAUD_RATE 19200` before that block of code&#xD;&#xA;2. recompile the optiboot loader&#xD;&#xA;3. upload your own new bootloader version&#xD;&#xA;4. update `uno.upload.speed` accordingly in `boards.txt`&#xD;&#xA;5. check it on the usual blink sketch and cross your fingers :-)&#xD;&#xA;&#xD;&#xA;NOTE that I disclaim any responsibility if you fry your Arduino!" />
  <row Id="2838" PostHistoryTypeId="2" PostId="1005" RevisionGUID="759ac043-dd9d-4c0e-b9ae-a5f331bbbc52" CreationDate="2014-03-30T13:50:53.060" UserId="83" Text="Yes you can program the Arduino's reset input pin as an output and use that to program another AVR, but you can no longer program your Arduino as that relies on the controller being reset through its own reset pin.&#xD;&#xA;&#xD;&#xA;Coming to think about it, I am not sure how the other devices (like the USB controller) responds to being reset by Arduino's controller itself. It resets the USB controller which may or may not reset the connection to the computer, possibly loosing data. With the USB controller being reset, GPIO-pins D0 and D1 (the serial interface between PC and Arduino's AVR) may corrupt the datastream. &#xD;&#xA;&#xD;&#xA;" />
  <row Id="2839" PostHistoryTypeId="5" PostId="968" RevisionGUID="233db4f8-6748-4b31-996d-a6e737ca82b8" CreationDate="2014-03-30T17:38:49.780" UserId="754" Comment="in-text links" Text="You bet it's possible. I used a pretty cheap bluetooth module that I got from [amazon](http://www.amazon.com/gp/aw/d/B0093XAV4U) , and wrote an app using the information on the official [Android Developers page](http://developer.android.com/guide/topics/connectivity/bluetooth.html) to connect to the Arduino. There are many guides online telling you how to hook up a module to the pins of the duino. &#xD;&#xA;&#xD;&#xA;You can probably get a cheaper module if you look on eBay and don't care how long it takes to arrive, and I think there's at least one app on the Play store for controlling an Arduino if you can make it work for your purpose.&#xD;&#xA;&#xD;&#xA;USB connections are probably possible, though I haven't done any of that.&#xD;&#xA;" />
  <row Id="2840" PostHistoryTypeId="24" PostId="968" RevisionGUID="233db4f8-6748-4b31-996d-a6e737ca82b8" CreationDate="2014-03-30T17:38:49.780" Comment="Proposed by 754 approved by -1 edit id of 263" />
  <row Id="2841" PostHistoryTypeId="5" PostId="968" RevisionGUID="27967b95-3857-4f72-b284-68c9fe2f2367" CreationDate="2014-03-30T17:38:49.780" UserId="42" Comment="in-text links" Text="You bet it's possible. I used a pretty cheap bluetooth module that I got from [Amazon](http://www.amazon.com/gp/aw/d/B0093XAV4U), and wrote an app using the information on the official [Android Developers page](http://developer.android.com/guide/topics/connectivity/bluetooth.html) to connect to the Arduino. There are many guides online telling you how to hook up a module to the pins of the duino. &#xD;&#xA;&#xD;&#xA;You can probably get a cheaper module if you look on eBay and don't care how long it takes to arrive, and I think there's at least one app on the Play store for controlling an Arduino if you can make it work for your purpose.&#xD;&#xA;&#xD;&#xA;USB connections are probably possible, though I haven't done any of that.&#xD;&#xA;" />
  <row Id="2846" PostHistoryTypeId="2" PostId="1007" RevisionGUID="82e67759-11bb-4f1c-904b-2be505f78290" CreationDate="2014-03-30T23:14:46.567" UserId="666" Text="I have a CC3000 wifi module from adafruit that is working OK. Now, I am trying to use it together with an external service, which code requires me to pass a Client (from Arduino SDK) reference, but the Adafruit_CC3000_Client does not inherit from Client nor WifiClient.&#xD;&#xA;&#xD;&#xA;I am looking for an appropiate wrapper, but unable to find one. Does anyone know about such wrapper?" />
  <row Id="2847" PostHistoryTypeId="1" PostId="1007" RevisionGUID="82e67759-11bb-4f1c-904b-2be505f78290" CreationDate="2014-03-30T23:14:46.567" UserId="666" Text="Client or WiFiClient wrapper for adafruit CC3000 wifi" />
  <row Id="2848" PostHistoryTypeId="3" PostId="1007" RevisionGUID="82e67759-11bb-4f1c-904b-2be505f78290" CreationDate="2014-03-30T23:14:46.567" UserId="666" Text="&lt;wifi&gt;" />
  <row Id="2849" PostHistoryTypeId="2" PostId="1008" RevisionGUID="7b733e6d-44d8-4d47-99e9-2ba1b15c33d3" CreationDate="2014-03-31T00:55:16.420" UserId="639" Text="I'm using `sprintf` to use a format specifier `myTemplate` with some strings. The result will then be written to Serial. Although the sketch compiles fine, it does not write any thing to the serial, nothing is seen in the Serial monitor.&#xD;&#xA;&#xD;&#xA;Is `sprintf` being used wrongly here?&#xD;&#xA;&#xD;&#xA;	char* result;&#xD;&#xA;	char* myTemplate;&#xD;&#xA;&#xD;&#xA;	void setup() {&#xD;&#xA;	  // put your setup code here, to run once:&#xD;&#xA;	    Serial.begin(9600);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	void loop() {&#xD;&#xA;	    myTemplate = &quot;Welcome %s. You have slept %s times&quot;;&#xD;&#xA;	    sprintf(result, myTemplate, &quot;Jane&quot;, &quot;many&quot;);&#xD;&#xA;	    Serial.println(result);&#xD;&#xA;	    Serial.println(&quot;hello&quot;);&#xD;&#xA;&#xD;&#xA;	}" />
  <row Id="2850" PostHistoryTypeId="1" PostId="1008" RevisionGUID="7b733e6d-44d8-4d47-99e9-2ba1b15c33d3" CreationDate="2014-03-31T00:55:16.420" UserId="639" Text="Nothng Written to Serial when using sprintf" />
  <row Id="2851" PostHistoryTypeId="3" PostId="1008" RevisionGUID="7b733e6d-44d8-4d47-99e9-2ba1b15c33d3" CreationDate="2014-03-31T00:55:16.420" UserId="639" Text="&lt;arduino-uno&gt;&lt;programming&gt;&lt;string&gt;" />
  <row Id="2852" PostHistoryTypeId="2" PostId="1009" RevisionGUID="577c92f7-23c2-4d29-bd2b-3e3ac160332c" CreationDate="2014-03-31T01:10:23.553" UserId="42" Text="When you use `sprintf()`, you need to have some space allocated for it to write the result to. At the moment, you're just passing an uninitialised pointer (`result`), meaning the behaviour of `sprintf()` is undefined. It might appear to work under some circumstances, but not others (and even if it did seem to work, it could have some nasty side effects on other parts of your code).&#xD;&#xA;&#xD;&#xA;The simplest approach is to allocate a static `char` buffer. You need to be sure it's big enough to contain all of the text you want it to store though (plus an extra null character at the end).&#xD;&#xA;&#xD;&#xA;For example:&#xD;&#xA;&#xD;&#xA;    char* myTemplate = &quot;&quot;;&#xD;&#xA;    char result[64] = {0};&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        myTemplate = &quot;Welcome %s. You have slept %s times&quot;;&#xD;&#xA;&#xD;&#xA;        sprintf(result, myTemplate, &quot;Jane&quot;, &quot;many&quot;);&#xD;&#xA;        Serial.println(result);&#xD;&#xA;        Serial.println(&quot;hello&quot;);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;As a side note, it's usually a good idea to initialise your variables. This is especially true for pointers." />
  <row Id="2853" PostHistoryTypeId="2" PostId="1010" RevisionGUID="684131a2-8749-486d-bb05-b4d6ca9c5137" CreationDate="2014-03-31T01:18:42.903" UserId="874" Text="I have an Arduino Uno R3. I have a paddlewheel waterspeed sensor that I use on an ISR on pin 2. The power supply is approximately 8v stepped down to 4.92v with a circuit yanked from the phone charger. I have also tried this with the arduino 5v.&#xD;&#xA;&#xD;&#xA;I send the 5v source straight to the pin and it works, but it does not work through the sensor.&#xD;&#xA;&#xD;&#xA;The ISR works fine on pin3. Why does it work on pin 3 and not pin 2 ISR?" />
  <row Id="2854" PostHistoryTypeId="1" PostId="1010" RevisionGUID="684131a2-8749-486d-bb05-b4d6ca9c5137" CreationDate="2014-03-31T01:18:42.903" UserId="874" Text="Arduino Uno R3 ISR does not work on pin 2?" />
  <row Id="2855" PostHistoryTypeId="3" PostId="1010" RevisionGUID="684131a2-8749-486d-bb05-b4d6ca9c5137" CreationDate="2014-03-31T01:18:42.903" UserId="874" Text="&lt;arduino-uno&gt;&lt;interrupt&gt;&lt;isr&gt;" />
  <row Id="2856" PostHistoryTypeId="5" PostId="1010" RevisionGUID="7c84e7e1-ba7b-4720-ba41-06d8854762ee" CreationDate="2014-03-31T01:53:40.473" UserId="874" Comment="deleted 8 characters in body" Text="I have an Arduino Uno R3. I have a paddlewheel waterspeed sensor that I use on an ISR on pin 2. The power supply is approximately 8v stepped down to 4.92v with a circuit yanked from the phone charger. I have also tried this with the arduino 5v.&#xD;&#xA;&#xD;&#xA;The pin returns the correct values with digitalRead(), so it's cycling between 1 and 0.&#xD;&#xA;&#xD;&#xA;The ISR works fine on pin3. Why does it work on pin 3 and not pin 2 ISR?" />
  <row Id="2857" PostHistoryTypeId="2" PostId="1011" RevisionGUID="601c99ad-bf03-42df-bab4-1237fe6e4735" CreationDate="2014-03-31T02:46:58.210" UserId="353" Text="First of all, as configured, the RESET pin can **not** be used as an output pin. In order to use it as an I/O pin, you would have to program the RSTDISBL fuse. But once you do that, as jippie said, it becomes near-impossible to reprogram your Arduino (if you have the socketed through hole variety of the MCU, you could pull it out and put it into a high voltage programmer; in all other cases, it's effectively impossible).&#xD;&#xA;&#xD;&#xA;So in theory, you can use the ICSP header the way you suggest. In practice, it's under almost any conceivable circumstance a terrible idea." />
  <row Id="2858" PostHistoryTypeId="5" PostId="1008" RevisionGUID="ea1ccfb2-e17e-478c-94f7-4e19b28b25c6" CreationDate="2014-03-31T02:59:09.047" UserId="639" Comment="added 353 characters in body" Text="I'm using `sprintf` to use a format specifier `myTemplate` with some strings. The result will then be written to Serial. Although the sketch compiles fine, it does not write any thing to the serial, nothing is seen in the Serial monitor.&#xD;&#xA;&#xD;&#xA;Is `sprintf` being used wrongly here?&#xD;&#xA;&#xD;&#xA;	char* result;&#xD;&#xA;	char* myTemplate;&#xD;&#xA;&#xD;&#xA;	void setup() {&#xD;&#xA;	  // put your setup code here, to run once:&#xD;&#xA;	    Serial.begin(9600);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	void loop() {&#xD;&#xA;	    myTemplate = &quot;Welcome %s. You have slept %s times&quot;;&#xD;&#xA;	    sprintf(result, myTemplate, &quot;Jane&quot;, &quot;many&quot;);&#xD;&#xA;	    Serial.println(result);&#xD;&#xA;	    Serial.println(&quot;hello&quot;);&#xD;&#xA;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;When I try to clear `message`, I get the error below. Whats the proper way to clear a buffer?&#xD;&#xA;&#xD;&#xA;    error: incompatible types in assignment of 'const char [1]' to 'char [16]'&#xD;&#xA;&#xD;&#xA;**Sketch**&#xD;&#xA;&#xD;&#xA;	char message[16];&#xD;&#xA;&#xD;&#xA;	void setup() {&#xD;&#xA;	    Serial.begin(9600);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	void loop() {&#xD;&#xA;	    Serial.println(message);&#xD;&#xA;	    message = &quot;&quot;;&#xD;&#xA;	}" />
  <row Id="2859" PostHistoryTypeId="5" PostId="1008" RevisionGUID="3a900273-bed9-461f-b5cd-0e43eca413a5" CreationDate="2014-03-31T03:07:08.517" UserId="639" Comment="added 219 characters in body" Text="I'm using `sprintf` to use a format specifier `myTemplate` with some strings. The result will then be written to Serial. Although the sketch compiles fine, it does not write any thing to the serial, nothing is seen in the Serial monitor.&#xD;&#xA;&#xD;&#xA;Is `sprintf` being used wrongly here?&#xD;&#xA;&#xD;&#xA;	char* result;&#xD;&#xA;	char* myTemplate;&#xD;&#xA;&#xD;&#xA;	void setup() {&#xD;&#xA;	  // put your setup code here, to run once:&#xD;&#xA;	    Serial.begin(9600);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	void loop() {&#xD;&#xA;	    myTemplate = &quot;Welcome %s. You have slept %s times&quot;;&#xD;&#xA;	    sprintf(result, myTemplate, &quot;Jane&quot;, &quot;many&quot;);&#xD;&#xA;	    Serial.println(result);&#xD;&#xA;	    Serial.println(&quot;hello&quot;);&#xD;&#xA;&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;When I try the follwing sketch and write something to the Serial monitor, I receive gibberish echoed back to me!  Why is this?&#xD;&#xA;&#xD;&#xA;**Sketch**&#xD;&#xA;&#xD;&#xA;	char received;&#xD;&#xA;	char* message = &quot;&quot;;&#xD;&#xA;&#xD;&#xA;	void setup() {&#xD;&#xA;	    Serial.begin(9600);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	void loop() {&#xD;&#xA;	    &#xD;&#xA;	    // Echos back&#xD;&#xA;	    if(Serial.available() &gt; 0) {&#xD;&#xA;	        received = Serial.read();&#xD;&#xA;	        Serial.println(message);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;	        if(received == '\n') {&#xD;&#xA;	            message = &quot;&quot;;&#xD;&#xA;	        }  else {&#xD;&#xA;	            message += received;&#xD;&#xA;	        }&#xD;&#xA;	        &#xD;&#xA;	        &#xD;&#xA;	    }&#xD;&#xA;	}	" />
  <row Id="2860" PostHistoryTypeId="2" PostId="1012" RevisionGUID="08fdbdec-09cb-4472-892b-3247ee87d89a" CreationDate="2014-03-31T03:29:01.343" UserId="65" Text="One possible approach is to go for a completely software side solution.&#xD;&#xA;&#xD;&#xA;[Microsmooth][1] is a signal processing library that I am working on that is specifically intended for low latency, low memory signal smoothing. It is still in development, but even now, most of the filters work in less than 100 microseconds per call while giving fairly good accuracy and smoothing. Also, the header file allows for simple configuration for certain filter parameters.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/AsheeshR/Microsmooth" />
  <row Id="2861" PostHistoryTypeId="2" PostId="1013" RevisionGUID="034d0f96-2e56-4a29-9265-e1fc17338114" CreationDate="2014-03-31T06:35:44.493" UserId="878" Text="I am sending a list of servo positions via the serial connection to the arduino in the following format&#xD;&#xA;&#xD;&#xA;    1:90&amp;2:80&amp;3:180&#xD;&#xA;&#xD;&#xA;ie&#xD;&#xA;&#xD;&#xA;servoId : Position &amp; servoId : Position &amp; servoId : Position&#xD;&#xA;&#xD;&#xA;how would i split these values up, and convert to INT?&#xD;&#xA;&#xD;&#xA;Thank you" />
  <row Id="2862" PostHistoryTypeId="1" PostId="1013" RevisionGUID="034d0f96-2e56-4a29-9265-e1fc17338114" CreationDate="2014-03-31T06:35:44.493" UserId="878" Text="How do i split an incoming string?" />
  <row Id="2863" PostHistoryTypeId="3" PostId="1013" RevisionGUID="034d0f96-2e56-4a29-9265-e1fc17338114" CreationDate="2014-03-31T06:35:44.493" UserId="878" Text="&lt;serial&gt;&lt;arduino-mega&gt;&lt;string&gt;" />
  <row Id="2864" PostHistoryTypeId="5" PostId="1010" RevisionGUID="6a6295e6-c6db-4efa-8f2a-85dd9646eb8e" CreationDate="2014-03-31T07:32:59.000" UserId="874" Comment="added 138 characters in body" Text="I have an Arduino Uno R3. I have a paddlewheel waterspeed sensor that I use on an ISR on pin 2. The power supply is approximately 8v stepped down to 4.92v with a circuit yanked from the phone charger. I have also tried this with the arduino 5v.&#xD;&#xA;&#xD;&#xA;The pin returns the correct values with digitalRead(), so it's cycling between 1 and 0.&#xD;&#xA;&#xD;&#xA;The ISR works fine on pin3. Why does it work on pin 3 and not pin 2 ISR?&#xD;&#xA;&#xD;&#xA;    void itest() {&#xD;&#xA;        Serial.println( &quot;test&quot; );&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;        attachInterrupt(0, itest, FALLING);&#xD;&#xA;    }" />
  <row Id="2865" PostHistoryTypeId="2" PostId="1014" RevisionGUID="db99b508-0af1-4b66-9dae-cdef2ccb3560" CreationDate="2014-03-31T07:36:29.347" UserId="27" Text="You can use [`Stream.readStringUntil(terminator)`][1] passing a different terminator for each part.&#xD;&#xA;&#xD;&#xA;On each part you then call [`String.toInt`][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/StreamReadStringUntil&#xD;&#xA;  [2]: http://arduino.cc/en/Reference/StringToInt" />
  <row Id="2866" PostHistoryTypeId="2" PostId="1015" RevisionGUID="99ef3235-bd1d-4471-aa13-da9e8091df12" CreationDate="2014-03-31T07:51:40.857" UserId="666" Text="You could do something like the following, but please take into account several things:&#xD;&#xA;&#xD;&#xA;If you use readStringUntil(), it will wait until it receives the caracter or timeouts. Thus, with your current string, the last position will last a little longer, as it as to wait. You can add a trailing &amp; to avoid this timout.&#xD;&#xA;&#xD;&#xA;You actually do not need the servo index, you can just send your string of positions, and get the servo index by the value position in the string, something like: &quot;90&amp;80&amp;180&amp;&quot;&#xD;&#xA;&#xD;&#xA;You have to check that the returning string from readStringUntil is not empty. If the function timeouts, you didnt receive enough data, and thus any attempt to extract your Int values will produce strange results.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;    	Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;    	int i;&#xD;&#xA;    	for(int i=1;i&lt;=3;i++){&#xD;&#xA;    		String servo = Serial.readStringUntil(':');&#xD;&#xA;    		if(servo!=&quot;&quot;){&#xD;&#xA;    			//here you could check the servo number&#xD;&#xA;    			String pos = Serial.readStringUntil('&amp;');&#xD;&#xA;    			int int_pos=pos.toInt();&#xD;&#xA;    			Serial.println(&quot;Pos&quot;);&#xD;&#xA;    			Serial.println(int_pos);&#xD;&#xA;    		}&#xD;&#xA;    	}&#xD;&#xA;    }" />
  <row Id="2867" PostHistoryTypeId="5" PostId="1015" RevisionGUID="891a8870-451e-4ead-9979-0cb07fe0e109" CreationDate="2014-03-31T07:56:43.537" UserId="666" Comment="added 143 characters in body" Text="You could do something like the following, but please take into account several things:&#xD;&#xA;&#xD;&#xA;If you use readStringUntil(), it will wait until it receives the caracter or timeouts. Thus, with your current string, the last position will last a little longer, as it as to wait. You can add a trailing &amp; to avoid this timout. You can easily check this behavior in your monitor, try to send the string with and without the extra &amp; and you will see such timeout delay.&#xD;&#xA;&#xD;&#xA;You actually do not need the servo index, you can just send your string of positions, and get the servo index by the value position in the string, something like: &quot;90&amp;80&amp;180&amp;&quot;. If you use the servo index, maybe you want to check it (convert to Int, and then match the loop index i) to ensure that nothing went wrong with your message.&#xD;&#xA;&#xD;&#xA;You have to check that the returning string from readStringUntil is not empty. If the function timeouts, you didnt receive enough data, and thus any attempt to extract your Int values will produce strange results.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;    	Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;    	int i;&#xD;&#xA;    	for(int i=1;i&lt;=3;i++){&#xD;&#xA;    		String servo = Serial.readStringUntil(':');&#xD;&#xA;    		if(servo!=&quot;&quot;){&#xD;&#xA;    			//here you could check the servo number&#xD;&#xA;    			String pos = Serial.readStringUntil('&amp;');&#xD;&#xA;    			int int_pos=pos.toInt();&#xD;&#xA;    			Serial.println(&quot;Pos&quot;);&#xD;&#xA;    			Serial.println(int_pos);&#xD;&#xA;    		}&#xD;&#xA;    	}&#xD;&#xA;    }" />
  <row Id="2868" PostHistoryTypeId="2" PostId="1016" RevisionGUID="970b523f-48d8-4e60-ac94-b990ce997454" CreationDate="2014-03-31T08:07:11.147" UserId="881" Text="I recommend going out and buying an AVR Dragon - costs aroud $US50. That gives you ISCP programming plus debugwire debugging (using the Atmel Studio IDE)." />
  <row Id="2869" PostHistoryTypeId="2" PostId="1017" RevisionGUID="7b61a6a5-d47f-4b9f-a008-48f3796bc454" CreationDate="2014-03-31T08:31:55.013" UserId="881" Text="I have always wanted to use Eclipse, since that is our standard (for Java) at work. But I never managed to get the debugger working with my AVR Dragon board - just too many layers between the source code and the chip.&#xD;&#xA;So I am back to using Atmel Studio. You can set the keyboard mapping to emulate various other IDEs (including Eclipse and Netbeans). I can accept the Microsft quirkiness in return for a stable debugging environment, multi-file support and professional source control features." />
  <row Id="2870" PostHistoryTypeId="2" PostId="1018" RevisionGUID="af4d8d69-09ad-419a-8f46-884e1ddc976a" CreationDate="2014-03-31T08:47:31.953" UserId="881" Text="Making your own is quite possible, especially if you own a router (or even better a router table). You need a V shaped 90 degree router bit, a tube of proper perspex glue and some acrylic sheet. Try searching Youtube on &quot;acrylic box making&quot;. There are several videos. My first two efforts were pretty bad, but the last couple are fine, and are of course exactly the right size." />
  <row Id="2871" PostHistoryTypeId="2" PostId="1019" RevisionGUID="7adc975e-e9fb-4fce-b199-1649d61cf0cf" CreationDate="2014-03-31T09:02:50.587" UserId="881" Text="The way most of the libraries do this is to put an instance of (in your case) Timer in the Timer.cpp file, and reference it with an extern definition when needed - typically in your main cpp file.&#xD;&#xA;Also you are calling digitalWrite() and digitalRead() during an ISR. This can be bad since those functions are slow, and may not be guaranteed to behave when interrupts are disabled (as they are during an ISR). A safer approach is for your ISR to set a flag in your Timer class that can be read by an Timer.isExpired() or similar method in your loop() code." />
  <row Id="2872" PostHistoryTypeId="2" PostId="1020" RevisionGUID="cc76b01b-e18e-4fca-b8a2-992e733385c0" CreationDate="2014-03-31T09:25:32.280" UserId="881" Text="In my experience, it is best to avoid &lt;b&gt;new&lt;/b&gt; and &lt;b&gt;delete&lt;/b&gt; when running on machines with limited memory. &#xD;&#xA;&lt;ul&gt;&#xD;&#xA;  &lt;li&gt;The memory management itself uses valuable program and RAM space&lt;/li&gt;&#xD;&#xA;  &lt;li&gt;ISR vectors are set at compile tme. It is difficult (impossible?) for a class instance to claim an ISR at run time&lt;/li&gt;&#xD;&#xA;  &lt;li&gt;Generally you will know at compile time what class instances you need - e.g. 3 button debouncers, a display driver and a 2-line display driver&lt;/li&gt;&#xD;&#xA;  &lt;li&gt;Memory management introduces unknown delays when you use new or delete.&#xD;&#xA;&lt;/ul&gt;&#xD;&#xA;There may be cases where it is justified to use dynamic instance construction and destruction, but I suspect they are rare. " />
  <row Id="2873" PostHistoryTypeId="2" PostId="1021" RevisionGUID="091f5b35-b9c9-49ce-b9e4-b714d7406e52" CreationDate="2014-03-31T09:51:33.417" UserId="881" Text="You can turn the carrier on and off simply by toggling the carrier pin mode between output and input. I have used this to control a heat pump through the 37KHz infrared (remote control) port." />
  <row Id="2874" PostHistoryTypeId="5" PostId="1015" RevisionGUID="07bc3051-b56a-4268-aabc-187328c3ec9f" CreationDate="2014-03-31T11:11:17.513" UserId="84" Comment="removed var redefinition." Text="You could do something like the following, but please take into account several things:&#xD;&#xA;&#xD;&#xA;If you use readStringUntil(), it will wait until it receives the caracter or timeouts. Thus, with your current string, the last position will last a little longer, as it as to wait. You can add a trailing &amp; to avoid this timout. You can easily check this behavior in your monitor, try to send the string with and without the extra &amp; and you will see such timeout delay.&#xD;&#xA;&#xD;&#xA;You actually do not need the servo index, you can just send your string of positions, and get the servo index by the value position in the string, something like: &quot;90&amp;80&amp;180&amp;&quot;. If you use the servo index, maybe you want to check it (convert to Int, and then match the loop index i) to ensure that nothing went wrong with your message.&#xD;&#xA;&#xD;&#xA;You have to check that the returning string from readStringUntil is not empty. If the function timeouts, you didnt receive enough data, and thus any attempt to extract your Int values will produce strange results.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;    	Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;    	for(int i=1;i&lt;=3;i++){&#xD;&#xA;    		String servo = Serial.readStringUntil(':');&#xD;&#xA;    		if(servo!=&quot;&quot;){&#xD;&#xA;    			//here you could check the servo number&#xD;&#xA;    			String pos = Serial.readStringUntil('&amp;');&#xD;&#xA;    			int int_pos=pos.toInt();&#xD;&#xA;    			Serial.println(&quot;Pos&quot;);&#xD;&#xA;    			Serial.println(int_pos);&#xD;&#xA;    		}&#xD;&#xA;    	}&#xD;&#xA;    }" />
  <row Id="2875" PostHistoryTypeId="2" PostId="1022" RevisionGUID="90893da8-f887-4466-9eb6-ecd7f73197c0" CreationDate="2014-03-31T11:50:23.240" UserId="46" Text="To answer my own question, just to report that I found something close to what I was looking for, which I link and describe briefly below.&#xD;&#xA;&#xD;&#xA;[Gammon Software Solutions forum - Atmega Bootloader Programmer - Programming Cable](http://www.gammon.com.au/forum/?id=11635)&#xD;&#xA;&#xD;&#xA;On that page, the author suggest that we cut pin 5 from the 6-pin ICSP programming cable, solder a pin to it, and wire it to pin D10. Like so:&#xD;&#xA;&#xD;&#xA;![Modified ICSP programming cable][1] &#xD;&#xA;&#xD;&#xA;Then, you can load the Arduino Uno with the ArduinoISP sketch and program the target board as usual.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/tMAP4.jpg" />
  <row Id="2876" PostHistoryTypeId="2" PostId="1023" RevisionGUID="6a35e07d-4063-4f28-b29d-cda806d0a1aa" CreationDate="2014-03-31T12:04:11.680" UserId="643" Text="never use Serial inside an interrupt handler, increment a (volatile) variable and print it in the loop()." />
  <row Id="2877" PostHistoryTypeId="2" PostId="1024" RevisionGUID="ec278f38-a41d-4c54-b5e8-2c68ad47bd05" CreationDate="2014-03-31T12:56:56.303" UserId="883" Text="I built a simple clock using a 4 digits 7 segments LCD display. I display one digit at a time, switching on and off very quicky and cycling through digits.&#xD;&#xA;&#xD;&#xA;Everything is ok, but I used 8 + 4 = 12 arduino pins. I need 2 more pins for other features and I don't want to use 0 and 1 as I need onboard programming features of Arduino Mini.&#xD;&#xA;&#xD;&#xA;I used I2C for RTC clock, I could add some interface here (like a PCF8574) and get some pins from here. But I'd like a different (and more educational, for me) approach.&#xD;&#xA;&#xD;&#xA;Is there an IC that sends an HIGH output on one of four output pins driven by 2 input pins? I need this:&#xD;&#xA;&#xD;&#xA;    IN     OUT&#xD;&#xA;    P0 P1  D0 D1 D2 D3&#xD;&#xA;    0  0   1  0  0  0&#xD;&#xA;    0  1   0  1  0  0&#xD;&#xA;    1  0   0  0  1  0&#xD;&#xA;    1  1   0  0  0  1&#xD;&#xA;&#xD;&#xA;This way I can connect OUT to digit selection and spare 2 pins.&#xD;&#xA;&#xD;&#xA;Thanks for your hints." />
  <row Id="2878" PostHistoryTypeId="1" PostId="1024" RevisionGUID="ec278f38-a41d-4c54-b5e8-2c68ad47bd05" CreationDate="2014-03-31T12:56:56.303" UserId="883" Text="Save some arduino pins when driving a 4 digits 7 segments display" />
  <row Id="2879" PostHistoryTypeId="3" PostId="1024" RevisionGUID="ec278f38-a41d-4c54-b5e8-2c68ad47bd05" CreationDate="2014-03-31T12:56:56.303" UserId="883" Text="&lt;lcd&gt;&lt;display&gt;" />
  <row Id="2880" PostHistoryTypeId="2" PostId="1025" RevisionGUID="872f4e1e-3888-48b6-8a60-83bb170657b4" CreationDate="2014-03-31T13:07:35.223" UserId="42" Text="A 2-to-4 line decoder should do what you need. I've used a [74HC139][1] with Arduino before, which contains two decoders in a 16-pin DIP.&#xD;&#xA;&#xD;&#xA;There are lots of other options though. In the past, I've used an 8 bit serial-to-parallel shift register ([74HC595][2]) to control a 7 segment display. It effectively lets you control 8 (or more) outputs using only 3 pins on your microcontroller. You have to be careful of power requirements though. Most shift registers aren't able to drive such a display directly, but I was able to incorporate transistors quite easily to get around that.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.fairchildsemi.com/ds/74/74VHC139.pdf&#xD;&#xA;  [2]: https://www.sparkfun.com/datasheets/IC/SN74HC595.pdf" />
  <row Id="2881" PostHistoryTypeId="2" PostId="1026" RevisionGUID="5d202012-3cd3-4bc9-8e8a-e8750090b883" CreationDate="2014-03-31T13:37:49.573" UserId="59" Text="An [I2C IO expander][1] might be your best bet.  If your existing I2C device uses a different address, you may be able to put both devices on the same I2C bus.  You would then use 0 additional pins compared to your current design.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.digikey.com/product-detail/en/MCP23017-E/SP/MCP23017-E/SP-ND/894272 &quot;I2C&quot;" />
  <row Id="2882" PostHistoryTypeId="2" PostId="1027" RevisionGUID="32a53af8-aaee-4a8e-8ca6-3456ab3bb91b" CreationDate="2014-03-31T13:41:23.967" UserId="304" Text="I know it's not what you asked, but you're using a lot of pins, why not try streamlining them and go to an I2C backpack? [This one from adafruit][1] includes a single 4x7 segment display.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.adafruit.com/products/879" />
  <row Id="2883" PostHistoryTypeId="5" PostId="1027" RevisionGUID="a2fa1b79-0022-4fdb-bc85-6bd07dff3611" CreationDate="2014-03-31T14:16:35.650" UserId="304" Comment="options" Text="I know it's not what you asked, but you're using a lot of pins, why not try streamlining them and go to an I2C backpack? [This one from adafruit][1] includes a single 4x7 segment display.&#xD;&#xA;&#xD;&#xA;given your comment, another option would be an [I2C/SPI 7 Segment driver][2]. ([datasheet][3]). &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.adafruit.com/products/879&#xD;&#xA;  [2]: http://uk.farnell.com/nxp/saa1064-n2/ic-led-driver-4dgt-i2c-24dip/dp/1627002&#xD;&#xA;  [3]: http://www.fortito.mx/wp-content/uploads/technical/SAA1064.pdf" />
  <row Id="2887" PostHistoryTypeId="5" PostId="983" RevisionGUID="417b97c4-d339-44fc-9686-29323a43b99f" CreationDate="2014-03-31T15:18:40.347" UserId="186" Comment="add explicit links to the files alluded to" Text="I tested an [MPU-6050 (GY-521)][1] using an Arduino Nano. I used the I2CDevLib and opened the [MPU6050_DMP6.ino][2] with the Arduino IDE. I opened the [MPUTeapot.pde][3] Processing-file with Processing. A few changes was necessary to make it work:&#xD;&#xA;&#xD;&#xA;    MPU6050 mpu;&#xD;&#xA;&#xD;&#xA;was changed into:&#xD;&#xA;    &#xD;&#xA;    MPU6050 mpu(0x68);&#xD;&#xA;&#xD;&#xA;Additionally I commented out this line:&#xD;&#xA;&#xD;&#xA;    #define OUTPUT_READABLE_YAWPITCHROLL&#xD;&#xA;&#xD;&#xA;and uncommented this line:&#xD;&#xA;&#xD;&#xA;    #define OUTPUT_TEAPOT&#xD;&#xA;&#xD;&#xA;When turning everything on, the arrow (Processing) would turn with 5 degrees/s clockwise around the z-axis (plus a very small amount around the other two axes). After about 20 seconds, it would stop, and turn around the x-axis pretty fast for 3 seconds. Then it would stop. Now, the gyroscope+accelerometer would work perfectly. This happens every time I test it.&#xD;&#xA;&#xD;&#xA;This happens only when the gyroscope is perfectly still on the ground. It does not stabilize if I move it around. Only after it is left completely still, it'll stabilize after 23 seconds.&#xD;&#xA;&#xD;&#xA;Is this how it should work, or is it a problem with the gyroscope? Could it even be caused by the I2CDevLib? Can anybody else confirm this?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Main/MPU-6050#.Uzl8TvldU-0&#xD;&#xA;  [2]: https://github.com/jrowberg/i2cdevlib/tree/master/Arduino/MPU6050/Examples/MPU6050_DMP6&#xD;&#xA;  [3]: https://github.com/jrowberg/i2cdevlib/tree/master/Arduino/MPU6050/Examples/MPU6050_DMP6/Processing" />
  <row Id="2888" PostHistoryTypeId="24" PostId="983" RevisionGUID="417b97c4-d339-44fc-9686-29323a43b99f" CreationDate="2014-03-31T15:18:40.347" Comment="Proposed by 186 approved by 8, 693 edit id of 264" />
  <row Id="2889" PostHistoryTypeId="2" PostId="1029" RevisionGUID="785b81a2-5433-4373-bf1f-94b4fbe41116" CreationDate="2014-03-31T15:50:26.920" UserId="497" Text="First, change all `Serial.write` to `Serial.print` I think that might be half your problem.&#xD;&#xA;&#xD;&#xA;Next,&#xD;&#xA;&#xD;&#xA;      pinMode(9, OUTPUT);  // this pin will pull the HC-05 pin 34 (key pin) HIGH to switch module to AT mode&#xD;&#xA;      digitalWrite(9, HIGH);&#xD;&#xA;&#xD;&#xA;The way you are doing this will probably put the HC-05 into 9600 baud mode. You can fix this one of two ways: &#xD;&#xA;&#xD;&#xA;Change ` BTSerial.begin(38400);  ` to ` BTSerial.begin(9600); ` &#xD;&#xA;&#xD;&#xA;Or, as jfpoilpret suggested, tie the Key pin directly to VCC.  The reason is that in order to go into 38400 baud mode, there must be voltage on Key at the time the module is powered up.  By the time the digital write in your code happens, it's too late.  &#xD;&#xA;&#xD;&#xA;If for some reason you'd like to have digital control over the Key pin rather than directly wiring it to VCC, yet you'd like the module to operate at 38400 baud, you can simply change the default baud rate by issuing the appropriate AT command - I believe it's `AT+UART=` off the top of my head.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2890" PostHistoryTypeId="5" PostId="1029" RevisionGUID="31502ed3-047e-4762-a908-31e8717b9b22" CreationDate="2014-03-31T16:03:03.513" UserId="497" Comment="added code" Text="First, change all `Serial.write` to `Serial.print` I think that might be half your problem.&#xD;&#xA;&#xD;&#xA;Next,&#xD;&#xA;&#xD;&#xA;      pinMode(9, OUTPUT);  // this pin will pull the HC-05 pin 34 (key pin) HIGH to switch module to AT mode&#xD;&#xA;      digitalWrite(9, HIGH);&#xD;&#xA;&#xD;&#xA;The way you are doing this will probably put the HC-05 into 9600 baud mode. You can fix this one of two ways: &#xD;&#xA;&#xD;&#xA;Change ` BTSerial.begin(38400);  ` to ` BTSerial.begin(9600); ` &#xD;&#xA;&#xD;&#xA;Or, as jfpoilpret suggested, tie the Key pin directly to VCC.  The reason is that in order to go into 38400 baud mode, there must be voltage on Key at the time the module is powered up.  By the time the digital write in your code happens, it's too late.  &#xD;&#xA;&#xD;&#xA;If for some reason you'd like to have digital control over the Key pin rather than directly wiring it to VCC, yet you'd like the module to operate at 38400 baud, you can simply change the default baud rate by issuing the appropriate AT command - I believe it's `AT+UART=` off the top of my head.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Also, I'm not sure, but jfpoilpret might be right as well about how your serial read/write handling is done within loop() but here is code that I know works:&#xD;&#xA;&#xD;&#xA;    #include &lt;SoftwareSerial.h&gt;&#xD;&#xA;&#xD;&#xA;    SoftwareSerial BTSerial(10, 11); // RX | TX&#xD;&#xA;    char myChar;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      ...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      while (BTSerial.available()) {&#xD;&#xA;        myChar = BTSerial.read();&#xD;&#xA;        Serial.print(myChar);&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      while (Serial.available()) {&#xD;&#xA;        myChar = Serial.read();&#xD;&#xA;        Serial.print(myChar); //echo&#xD;&#xA;        BTSerial.print(myChar);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="2891" PostHistoryTypeId="2" PostId="1030" RevisionGUID="f0f664a8-b5e3-44b0-98a5-423057565478" CreationDate="2014-03-31T16:09:26.943" UserId="693" Text="Following [this guide][1], it says to include a library in the C++ Linker called `m`. What is this for?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Code/Eclipse#.UzgDN_nEKG4" />
  <row Id="2892" PostHistoryTypeId="1" PostId="1030" RevisionGUID="f0f664a8-b5e3-44b0-98a5-423057565478" CreationDate="2014-03-31T16:09:26.943" UserId="693" Text="What is the library m in C++ linker?" />
  <row Id="2893" PostHistoryTypeId="3" PostId="1030" RevisionGUID="f0f664a8-b5e3-44b0-98a5-423057565478" CreationDate="2014-03-31T16:09:26.943" UserId="693" Text="&lt;c++&gt;" />
  <row Id="2894" PostHistoryTypeId="2" PostId="1031" RevisionGUID="59f86c93-807c-4f40-a9db-c234df72d17b" CreationDate="2014-03-31T16:15:42.750" UserId="666" Text="The m library is the &quot;math&quot; library. You have to link with it in most flavours of gnu compilers (it is typically not required in other, as it is included in the standard lib) when using functions and stuff from the header file &quot;math.h&quot;." />
  <row Id="2895" PostHistoryTypeId="5" PostId="1030" RevisionGUID="eb253a59-06d6-4bdf-b114-7722baf8c16b" CreationDate="2014-03-31T16:25:27.933" UserId="304" Comment="provided a better reference" Text="Following [this guide][1], it says to include a library in the C++ Linker called `m`. What is this for?&#xD;&#xA;&#xD;&#xA;Specifically, [Your second Arduino project][2]. &#xD;&#xA;&#xD;&#xA;4) **Configure project**&#xD;&#xA;&#xD;&#xA;5th dot point:&#xD;&#xA;&gt; AVR C++ Linker -&gt; Libraries: Under libraries, add arduino_core and m (in that order). Under path, add the path to the correct core library, e.g. &quot;`${workspace_loc:/arduino_core/328P_16MHz}`&quot;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Code/Eclipse#.UzgDN_nEKG4&#xD;&#xA;  [2]: http://playground.arduino.cc/Code/Eclipse#YourSecondArduinoProject" />
  <row Id="2896" PostHistoryTypeId="24" PostId="1030" RevisionGUID="eb253a59-06d6-4bdf-b114-7722baf8c16b" CreationDate="2014-03-31T16:25:27.933" Comment="Proposed by 304 approved by 42 edit id of 265" />
  <row Id="2897" PostHistoryTypeId="5" PostId="1004" RevisionGUID="32dd05e8-c805-4db6-9029-af38ca831026" CreationDate="2014-03-31T16:27:17.983" UserId="84" Comment="added 40 characters in body" Text="On Arduino IDE side, the upload speed is coded in `hardware/arduino/boards.txt` &#xD;&#xA;&#xD;&#xA;    uno.upload.speed=115200&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;for every kind of board; you cannot change it directly from the IDE (that would be too dangerous as that value must match the **expected speed for the actual bootloader** of every board).&#xD;&#xA;&#xD;&#xA;Now as per the optiboot loader side, the upload speed is defined in `BAUD_RATE` macro, in `optiboot.c`:&#xD;&#xA;&#xD;&#xA;    /* set the UART baud rate defaults */&#xD;&#xA;    #ifndef BAUD_RATE&#xD;&#xA;    #if F_CPU &gt;= 8000000L&#xD;&#xA;    #define BAUD_RATE   115200L // Highest rate Avrdude win32 will support&#xD;&#xA;    #elsif F_CPU &gt;= 1000000L&#xD;&#xA;    #define BAUD_RATE   9600L   // 19200 also supported, but with significant error&#xD;&#xA;    #elsif F_CPU &gt;= 128000L&#xD;&#xA;    #define BAUD_RATE   4800L   // Good for 128kHz internal RC&#xD;&#xA;    #else&#xD;&#xA;    #define BAUD_RATE 1200L     // Good even at 32768Hz&#xD;&#xA;    #endif&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;So I guess you can:&#xD;&#xA;&#xD;&#xA;1. `#define BAUD_RATE 19200` before that block of code&#xD;&#xA;2. recompile the optiboot loader&#xD;&#xA;3. upload your own new bootloader version&#xD;&#xA;4. update `uno.upload.speed` accordingly in `boards.txt`&#xD;&#xA;5. check it on the usual blink sketch and cross your fingers :-)&#xD;&#xA;&#xD;&#xA;Please note that this kind of task is not for beginners, you need to know what you're doing.&#xD;&#xA;Also note that I disclaim any responsibility if you get unable to upload programs to your Arduino afterwards!" />
  <row Id="2899" PostHistoryTypeId="2" PostId="1032" RevisionGUID="fa73490b-7d69-4ebd-9faa-c8f66961fed7" CreationDate="2014-03-31T17:01:17.500" UserId="349" Text="Are you using your analog pins?  Did you know [they can be used as digital pins][1]?&#xD;&#xA;&#xD;&#xA;&gt; The analog pins can be used identically to the digital pins, using the aliases A0 (for analog input 0), A1, etc. For example, the code would look like this to set analog pin 0 to an output, and to set it HIGH:&#xD;&#xA;&#xD;&#xA;&gt;     pinMode(A0, OUTPUT);&#xD;&#xA;&gt;     digitalWrite(A0, HIGH);&#xD;&#xA;&#xD;&#xA;This is your best bet if you aren't using all your analog pins.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Tutorial/AnalogInputPins" />
  <row Id="2900" PostHistoryTypeId="2" PostId="1033" RevisionGUID="e4e0b594-382b-4a8c-9575-a9a2857f500a" CreationDate="2014-03-31T18:12:50.343" UserId="84" Text="Contrarily to other answers, I'd rather stay away from `String` for the following reasons:&#xD;&#xA;&#xD;&#xA;- dynamic memory usage (that may quickly lead to **heap fragmentation** and **memory exhaustion**)&#xD;&#xA;- **quite slow** due to construction/destruction/assignment operators&#xD;&#xA;&#xD;&#xA;In an embedded environment like Arduino (even for a Mega that has more SRAM), I'd rather use **standard C functions**:&#xD;&#xA;&#xD;&#xA; - [`strchr()`][1]: search for a character in a C string (i.e. `char *`)&#xD;&#xA; - [`strtok()`][2]: splits a C string into substrings, based on a separator character &#xD;&#xA; - [`atoi()`][3]: converts a C string to an `int`&#xD;&#xA;&#xD;&#xA;That would lead to the following code sample:&#xD;&#xA;&#xD;&#xA;    // Calculate based on max input size expected for one command&#xD;&#xA;    #define INPUT_SIZE 30&#xD;&#xA;    ...&#xD;&#xA;&#xD;&#xA;    // Get next command from Serial (add 1 for final 0)&#xD;&#xA;    char input[INPUT_SIZE + 1];&#xD;&#xA;    byte size = Serial.readBytes(input, INPUT_SIZE);&#xD;&#xA;    // Add the final 0 to end the C string&#xD;&#xA;    input[size] = 0;&#xD;&#xA;&#xD;&#xA;    // Read each command pair &#xD;&#xA;    char* command = strtok(input, &quot;&amp;&quot;);&#xD;&#xA;    while (command != 0)&#xD;&#xA;    {&#xD;&#xA;        // Split the command in 2 values&#xD;&#xA;        char* separator = strchr(command, ':'))&#xD;&#xA;        if (separator != 0)&#xD;&#xA;        {&#xD;&#xA;            // Actually split the string in 2: replace ':' with 0&#xD;&#xA;            *separator = 0;&#xD;&#xA;            int servoId = atoi(command);&#xD;&#xA;            ++separator;&#xD;&#xA;            int position = atoi(separator);&#xD;&#xA;            &#xD;&#xA;            // Do something with servoId and position&#xD;&#xA;        }&#xD;&#xA;        // Find the next command in input string&#xD;&#xA;        command = strtok(0, &quot;&amp;&quot;);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The advantage here is that no dynamic memory allocation takes place; you can even declare `input` as a local variable inside a function that would read the commands and execute them; once the function is returned the size occupied by `input` (in the stack) is recovered.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.cplusplus.com/reference/cstring/strchr/&#xD;&#xA;  [2]: http://www.cplusplus.com/reference/cstring/strtok/&#xD;&#xA;  [3]: http://www.cplusplus.com/reference/cstdlib/atoi/" />
  <row Id="2902" PostHistoryTypeId="34" PostId="876" RevisionGUID="f5743740-1b28-43d1-bcd4-4f8c6fbd0650" CreationDate="2014-03-31T20:52:36.930" UserId="11" Comment="5" />
  <row Id="2903" PostHistoryTypeId="5" PostId="876" RevisionGUID="8ab611da-5ef3-42f3-b897-a9e783494717" CreationDate="2014-03-31T20:54:42.860" UserId="11" Comment="added 211 characters in body" Text="&gt; &lt;img src=&quot;http://i.stack.imgur.com/hYRnU.png&quot; width=&quot;450&quot; height=&quot;200&quot; &gt; &#xD;&#xA;&#xD;&#xA;&gt; &lt;sub&gt;The logo is a derivative of the [Arduino Community Logo][1] licensed under [Creative Commons license CC-SA-BY-NC 3.0][2]&lt;/sub&gt; &#xD;&#xA;&#xD;&#xA;# Update: Winners Announced&#xD;&#xA;The winners of the contest have been announced. Please see the [Meta post for details][3].&#xD;&#xA;&#xD;&#xA;To celebrate [10 years of Arduino][4], we are proud to announce the *first event ever* on Arduino Stack Exchange.&#xD;&#xA;&#xD;&#xA;&gt; Get your boards and soldering equipment out, dig out the ICs and&#xD;&#xA;&gt; resistors. The first Arduino Stack Exchange contest is just round the&#xD;&#xA;&gt; corner. We will be looking for interesting projects that are built&#xD;&#xA;&gt; using Arduinos. The contest is aimed towards sharing, discussing and&#xD;&#xA;&gt; providing feedback on projects that you and other members are working&#xD;&#xA;&gt; on. &lt;sub&gt;[See announcement post][5]&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;# Details: &#xD;&#xA;&#xD;&#xA; - The prize is an official **Stack Exchange t-shirt**&#xD;&#xA; - Limit two entries per person. If more than two are provided, only the first two will be considered. &#xD;&#xA; - Clones *are* allowed.&#xD;&#xA; - Projects for consideration will be accepted through **March 29th, 2014 at 4:00 UTC.** The question will still remain open in case someone wants to show off their project they made on Arduino Day 2014.&#xD;&#xA;&#xD;&#xA;Visit the [Meta post][6] for discussion about this event and further information.&#xD;&#xA;&#xD;&#xA;# Answer Format&#xD;&#xA;&#xD;&#xA;You may post up to two projects (as two separate answers) as entries for the contest. All extra entries will be deleted. Consider following the following template for entries:&#xD;&#xA;&#xD;&#xA;&gt; # Project Title&#xD;&#xA;&gt; &#xD;&#xA;&gt; **Very Brief Description**&#xD;&#xA;&gt; &#xD;&#xA;&gt; # Description&#xD;&#xA;&gt; &#xD;&#xA;&gt; What is your project? What does it do? What problem does it solve?&#xD;&#xA;&gt; &#xD;&#xA;&gt; # Design&#xD;&#xA;&gt; &#xD;&#xA;&gt; Things to include in this section:&#xD;&#xA;&gt; &#xD;&#xA;&gt; - Schematics and other design documentation. [Fritzing][7] is a good tool for drawing breadboard schematics like the one shown in the&#xD;&#xA;&gt; project logo above.&#xD;&#xA;&gt; - Components used to build the project&#xD;&#xA;&gt; - Pictures or video&#xD;&#xA;&gt; &#xD;&#xA;&gt; # Conclusion&#xD;&#xA;&gt; &#xD;&#xA;&gt; Final thoughts. What did you learn from doing this project? What would&#xD;&#xA;&gt; you do differently if you had to start over?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;You can copy/paste the following text if you want to use this template.&#xD;&#xA;&#xD;&#xA;    # Project Title&#xD;&#xA;    **Very Brief Description**&#xD;&#xA;    &#xD;&#xA;    # Description&#xD;&#xA;    What is your project? What does it do? What problem does it solve?&#xD;&#xA;    &#xD;&#xA;    # Design&#xD;&#xA;    Things to include in this section:&#xD;&#xA;    &#xD;&#xA;    - Schematics and other design documentation. [Fritzing][8] is a good tool for drawing breadboard schematics like the one shown in the project logo above.&#xD;&#xA;    - Components used to build the project&#xD;&#xA;    - Pictures or video&#xD;&#xA;    &#xD;&#xA;    # Conclusion&#xD;&#xA;    Final thoughts. What did you learn from doing this project? What would you do differently if you had to start over?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Prizes&#xD;&#xA;&#xD;&#xA;There are two prizes! The winner will be the submission getting the maximum number of upvotes (downvotes do not count) and will get a Stack Exchange T-shirt*! There will be something for the runner-up as well. The runner-up will be decided at the discretion of the event organizers.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;*Certain restrictions may apply. International shipping may take a few weeks. &lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;# Where do I submit my projects?&#xD;&#xA;Post your projects as answers to this post.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Trademark/HomePage?from=Main.Trademark&#xD;&#xA;  [2]: http://creativecommons.org/licenses/&#xD;&#xA;  [3]: http://meta.arduino.stackexchange.com/questions/184/project-showcase-14-winners&#xD;&#xA;  [4]: http://day.arduino.cc/&#xD;&#xA;  [5]: http://meta.arduino.stackexchange.com/questions/153/project-showcase-14-is-coming-to-arduino-stack-exchange-updated-3-19-14&#xD;&#xA;  [6]: http://meta.arduino.stackexchange.com/questions/171/project-showcase-14-detailed-information&#xD;&#xA;  [7]: http://fritzing.org/home/&#xD;&#xA;  [8]: http://fritzing.org/home/" />
  <row Id="2904" PostHistoryTypeId="2" PostId="1034" RevisionGUID="15641fb2-9f3f-4760-af9d-49c02b58d830" CreationDate="2014-04-01T00:08:17.063" UserId="888" Text="Hi I'm trying to upgrade firmware on my wifi shield by following the http://arduino.cc/en/Hacking/WiFiShieldFirmwareUpgrading instructions for mac. I was wondering what this means?&#xD;&#xA;&#xD;&#xA;&quot;Connect a jumper on the J3 connector, that put the shield in the programming mode. Then connect the USB cable to the shield USB mini socket&quot;?&#xD;&#xA;" />
  <row Id="2905" PostHistoryTypeId="1" PostId="1034" RevisionGUID="15641fb2-9f3f-4760-af9d-49c02b58d830" CreationDate="2014-04-01T00:08:17.063" UserId="888" Text="updating firmware on arduino wifi shield" />
  <row Id="2906" PostHistoryTypeId="3" PostId="1034" RevisionGUID="15641fb2-9f3f-4760-af9d-49c02b58d830" CreationDate="2014-04-01T00:08:17.063" UserId="888" Text="&lt;arduino-uno&gt;&lt;wifi&gt;&lt;firmware&gt;" />
  <row Id="2907" PostHistoryTypeId="2" PostId="1035" RevisionGUID="5ed99e92-c7a4-4da7-a9d7-0134f6b08998" CreationDate="2014-04-01T00:21:15.250" UserId="368" Text="A &quot;jumper&quot; is a little piece of metal (or a 0-ohm resistor) that connects two pads or pins together. So, create an electrical connection across J3 (&quot;DFU programming jumper&quot; in all the pictures). You will then be able to program the shield via USB." />
  <row Id="2910" PostHistoryTypeId="5" PostId="1034" RevisionGUID="5f99bcb5-871c-4d4f-8fa7-57eae41ace70" CreationDate="2014-04-01T00:59:31.933" UserId="220" Comment="added 32 characters in body" Text="I'm trying to upgrade firmware on my wifi shield by following the [upgrade instructions for Mac](http://arduino.cc/en/Hacking/WiFiShieldFirmwareUpgrading). I was wondering what this means?:&#xD;&#xA;&#xD;&#xA;&gt; Connect a jumper on the J3 connector, that put the shield in the programming mode. Then connect the USB cable to the shield USB mini socket&#xD;&#xA;&#xD;&#xA;**How can I do this?**" />
  <row Id="2911" PostHistoryTypeId="2" PostId="1036" RevisionGUID="07d23151-e6dc-4bf7-94b4-5b299e7e9213" CreationDate="2014-04-01T01:22:05.590" UserId="889" Text="The oft-repeated advice to &quot;just do `sudo usermod -aG dialout &lt;username&gt;` never worked for me, and I finally figured out why. On my machine, `/dev/ttyUSB0` is of the group `serial` and not `dialout`, so adding my username to `dialout` did nothing.&#xD;&#xA;&#xD;&#xA;    # ls -l&#xD;&#xA;    # crw-rw---- 1 root serial 188, 0 Mar 31 20:52 /dev/ttyUSB0&#xD;&#xA;                        ^^^^^^ (group-name)&#xD;&#xA;&#xD;&#xA;Finally: `sudo usermod -aG &lt;group-name&gt; &lt;username&gt;` fixed it for me.&#xD;&#xA;&#xD;&#xA;Embarrassingly, this is also explicitly mentioned [here](http://playground.arduino.cc/Linux/All#.UzoSq1VX-uZ) under &quot;SET THE PERMISSION&quot;. Sigh." />
  <row Id="2912" PostHistoryTypeId="2" PostId="1037" RevisionGUID="5357b3ae-69c9-4743-81a8-69021ceea980" CreationDate="2014-04-01T01:55:41.950" UserId="887" Text="It does matter.  There are pros and cons to each different driver setup. &#xD;&#xA;&#xD;&#xA;If you wire the motor as a bipolar, which I'm not sure that you can, you can use the driver that you linked, but it is not very good for driving stepper motors.  [https://www.sparkfun.com/products/11876][1] is a better driver for steppers for half the price.  (still have to wire it bipolar)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;If you need to stick with unipolar wiring, [PCBheaven.com][2] shows an example using a CD4017, MOSFETs, and diodes to run a unipolar motor.  It will only turn one direction.  Instead you could use a micro-controller, such as an Arduino, in place of the CD4017 along with logic-level MOSFETs to go both directions.&#xD;&#xA;&#xD;&#xA;A tutorial on the Arduino site uses a ULN2003A, which is not powerful enough to drive your motor to its full potential (does it need to turn, or turn well?) and doesn't have the diodes (important to protect your IC!), but the Arduino sketches would still work using the schematic from PCBheaven.&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sparkfun.com/products/11876&#xD;&#xA;  [2]: http://www.pcbheaven.com/circuitpages/Simple_Unipolar_Stepper_Motor_Full_Step_Controller/" />
  <row Id="2913" PostHistoryTypeId="2" PostId="1038" RevisionGUID="33d706cb-f953-4b40-bf4e-8042b6585355" CreationDate="2014-04-01T03:00:35.130" UserId="774" Text="At this stage, my finalized design includes Arduino Nano 3.0, a breakout board and a few electrical components on a breadboard. &#xD;&#xA;&#xD;&#xA;Will there be an appreciable cost savings from not buying a ready-made Arduino? The Arduino Nano clone being used costs $17.20. &#xD;&#xA;&#xD;&#xA;And is it a good idea if everything is soldered on to a custom fabricated PCB board, including the components of Arduino Nano 3.0? The PCB board will cost around $10 at the quantities I'm starting with." />
  <row Id="2914" PostHistoryTypeId="1" PostId="1038" RevisionGUID="33d706cb-f953-4b40-bf4e-8042b6585355" CreationDate="2014-04-01T03:00:35.130" UserId="774" Text="Building Arduino Nano from components" />
  <row Id="2915" PostHistoryTypeId="3" PostId="1038" RevisionGUID="33d706cb-f953-4b40-bf4e-8042b6585355" CreationDate="2014-04-01T03:00:35.130" UserId="774" Text="&lt;arduino-nano&gt;" />
  <row Id="2916" PostHistoryTypeId="2" PostId="1039" RevisionGUID="94233687-d757-4ca7-ab1b-0a4848fab15f" CreationDate="2014-04-01T03:39:04.360" UserId="497" Text="You can probably do a lot better than $17 but not much better than $8:&#xD;&#xA;&#xD;&#xA;http://www.ebay.com/itm/Mini-USB-Nano-V3-0-ATmega328P-5V-Micro-controller-Board-For-Arduino-compatible-/130977189883?pt=LH_DefaultDomain_0&amp;hash=item1e7ed94ffb&#xD;&#xA;&#xD;&#xA;If you don't need USB, you can use a Pro Mini and they go for about $4 and that's really hard to beat." />
  <row Id="2917" PostHistoryTypeId="2" PostId="1040" RevisionGUID="e7d997df-e3e4-483e-af9d-a35d4c3d09d7" CreationDate="2014-04-01T04:10:46.677" UserId="204" Text="The accepted answer of jfpoilpret is very well written, perfectly valid and in 99% of the cases I will do exactly what he explains. His solutions are well within your defined parameters, so they should work very well. But what is better than &quot;*very well*&quot;? **Perfection!** After all, question is about generating a exact value. As said close enough is good in most cases (arguably all), and even when dealing with something as a clocks when 1 second need to be 1 second, you still have to suffer inherited parts imperfections.&#xD;&#xA;&#xD;&#xA;What I will suggest is not always possible. In some cases, it's possible but with much more hassle and effort than this case. Is it worthy depend on case by case basis. My goal is mostly to show a alternative for future refferences, that is better in somewhat fringe cases. This is written with novice Arduino users in mind, that don't have extensive experience in electronics. For more advanced people this probably will look too verbose and dumbed down. But I believe that, those same people probably already know it and don't need this answer. This is also aplicable to every MCU and every manufactorer and architecture. But for other MCU's you will need to consult the correct datasheet to find out propper registers and prescale names and values.&#xD;&#xA;&#xD;&#xA;In your case, you need a specific frequency and the nice thing about it, is that exactly 56 Khz actually can be achieved very easy (not counting practical imperfections of the parts). So this is also a perfect example case.&#xD;&#xA;&#xD;&#xA;Generating a signal depends on the timers and clock source of MCU, as explained well by jfpoilpret. His answer deal with the problem of one point of view only and that is fiddling with timers. But you can fiddle with clock source too, or even better with both for synergy and awesome results. By changing the parameters of the enviorenment, in this case hacking the system and replacing the clock source, we can deal with specific problem with much, much more ease and simplicity.&#xD;&#xA;&#xD;&#xA; First to remind, because of togling the pin state, you need to execute ISR two times more than signal frequency. This is 112 000 times per second. &#xD;&#xA; 56 000 and 16 000 000 don't add up very nicely as pointed already. We need to change either the signal frequency or tact frequency. Let's deal for now with immutable signal frequency and find a better clock speed. It would be most strait-forward to choose a clock with some order of magnitude bigger than 56 (or 112 but is practicaly the same), as you only add zeros and this kind of math is simplest for most people. Unfortunately everything in this world is some kind of compromiss with something. Not every value will work.&#xD;&#xA;&#xD;&#xA; First example is with too low tact generator speed.&#xD;&#xA; If you choose a 56 000 hz clock you won't be able to do anything as you will need to call the ISR every cycle and can't do anything else. It is utterly useless. If you choose 10 times faster speed (560 Khz), you will have 9 (10 cycles for timer to reach it's max value  - 1 cycle to call ISR function) mcu cycles to do your work and this quite possible can be not enough. You simply often need more computational power.&#xD;&#xA;&#xD;&#xA; If you choose value far too great at other hand,  as 56 Mhz the MCU simply can't work with it. It is way too fast. So, simply choosing bigest value in the shop won't cut it either.&#xD;&#xA;&#xD;&#xA;Original Arduino UNO R3 have a stock clock at 16 Mhz, so anything slower that that is garanteed to work. Next value that is order of magnitute bigger than 56 and lower than 16 Mhz is 5,6 Mhz (5.6 Mhz for USA citizens). This will lead to be able to call the ISR every 50 cycles and will create perfect 112 000 hz timer frequency. And your signal will be exactly 56 Khz. You will have 49 MCU cycles to execute your program between ISR calls, but it is still around 1/3 of the speed of the original clock. One can use 112 as base and use 11,2 Mhz clock and this will give a about 2/3 of the stock 16 Mhz resonator. ISR function will be called every 100 cycles and still generating perfect 56 Khz signal.&#xD;&#xA;&#xD;&#xA; However two major problems exist with this values. &#xD;&#xA;&#xD;&#xA; - First problem severity depend on your needs: You sacrifice about 1/3 (with 11,2 Mhz) of your maximum computational power to get exact signal frequency that use easy to find register value ( OCR *iirc*). You may be fine with it or you may not. &#xD;&#xA;&#xD;&#xA; - Second problem is a **hard showstopper**: This very easy to find values, very often simply do not exist as manufactored clock source. This is [**Farnell resonator web page**][1], that simply lack both 5,6 Mhz and 11,2 Mhz.&#xD;&#xA;&#xD;&#xA;To circumvent this we can look at available resonator values and find out something else that can be used to generate exactly desired values. If we divide 56 by 4 we get 14 and luckily there is a 14 Mhz resonator. This provide us with much higher speed and more power and with equally easy to find register value. To call the ISR 112 000 times per second we need to put value of decimal 124 or heximal 0x7C in OCR register so with counting 124 cycles + 1 for calling ISR, we get our desired perfect value.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# N.B. &#xD;&#xA;&#xD;&#xA;1. ISR - Interrupt Service Routine (this is the code that is executed only on generated interrupts)&#xD;&#xA;2. How big your program can be, depend ot the memory size! Nothing to do with clock speed. Nothing to do with how often you call ISR.&#xD;&#xA;3. When MCU start with program command a counter is incremented, if interrupt is generated ,the ISR is called and this value is stored in special register. When ISR code complete, value of the program counter is restered from this special register and the program continue from where it was interrupted as if it was never happend. &lt;br/&gt;&#xD;&#xA;I will give a extremly dumbed down example, if you a purist, I warn you: Nose and eye bleeding can occur. &lt;br/&gt;&#xD;&#xA;Imagine you have to walk from somewhere to somewhere. The step by step route instructions are your main program and it's commands. How fast you walk or run, depend on your &quot;clock speed&quot;, but not on the route instructions (30 steps forward, 1 turn 90 grad. left, 10 steps forward, 45 grad. right, etc.) They are always the same. Now imagine a little kid or greedy corrupt local politician untie your shoes now and then. This is the event that generate a interrupt. Then you halt after your last step, kneel and tie your shoe again. This is your ISR program. Then you continue from the place you have stopped, you do not start from beginning. When you walk without a care in the world and with all the time, you don't care even if you have to tie your shoe every other step. If you however do it with time constrains, like running in 100 metters on olimpics (or running from hungry flesh eating predator), stopping and tieing your shoes can have dire consequences. The same is with MCU's. Even if you execute only 1 line of code your program will continue, albeit slow. If you don't care about speed at all, it won't be a problem. If you have to do some time related, like using other timer dependant actions, interferance can be very unwanted and problematic.&#xD;&#xA;4. Less is more! Not always faster clock is better. Slower clocked devices use considerably less power. This can be cruicial point in battery operated device.&#xD;&#xA;5. Needed cycles are derived from this formulae: &lt;br/&gt;&#xD;&#xA;( clock speed / (prescaler value * needed ISR calling frequency) ) - 1 &lt;br/&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://bg.farnell.com/crystals" />
  <row Id="2918" PostHistoryTypeId="5" PostId="1037" RevisionGUID="65b3497d-e262-4ee0-8ce2-7939cd4a4c7d" CreationDate="2014-04-01T05:27:44.073" UserId="887" Comment="Added two links to driver boards.  " Text="It does matter.  There are pros and cons to each different driver setup. &#xD;&#xA;&#xD;&#xA;If you wire the motor as a bipolar, which I'm not sure that you can, you can use the driver that you linked, but it is not very good for driving stepper motors.  [https://www.sparkfun.com/products/11876][1] is a better driver for steppers for half the price.  (still have to wire it bipolar)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;If you need to stick with unipolar wiring, [PCBheaven.com][2] shows an example using a CD4017, MOSFETs, and diodes to run a unipolar motor.  It will only turn one direction.  Instead you could use a micro-controller, such as an Arduino, in place of the CD4017 along with logic-level MOSFETs to go both directions.&#xD;&#xA;&#xD;&#xA;A tutorial on the Arduino site uses a ULN2003A, which is not powerful enough to drive your motor to its full potential (does it need to turn, or turn well?) and doesn't have the diodes (important to protect your IC!), but the Arduino sketches would still work using the schematic from PCBheaven.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;A couple of complete driver boards:&#xD;&#xA;&#xD;&#xA;[UNIPOLAR STEPPER MOTOR DRIVER][3]&#xD;&#xA;&#xD;&#xA;[FANCY UNIPOLAR STEPPER MOTOR DRIVER][4]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sparkfun.com/products/11876&#xD;&#xA;  [2]: http://www.pcbheaven.com/circuitpages/Simple_Unipolar_Stepper_Motor_Full_Step_Controller/&#xD;&#xA;  [3]: http://www.electronickits.com/kit/complete/motor/ck1405.htm&#xD;&#xA;  [4]: http://www.stepperboard.com/SS1010.htm" />
  <row Id="2919" PostHistoryTypeId="2" PostId="1041" RevisionGUID="431ce93b-cc30-49e8-99dd-f94fd28c0916" CreationDate="2014-04-01T07:13:23.783" UserId="639" Text="Are there any i2c LCD screens that are larger than 2004 characters and larger than 4.8 x 2.7 x 1.2 inches in dimensions?&#xD;&#xA;&#xD;&#xA;I have the Sainsmart 2004 LCD but it can't display all the information that I need. Maybe a 20x8 character screen? Because the screen will be viewed from a distance of about 50cm, the screen size should be at least 5&quot; in diagonal.&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/X6vHl.png" />
  <row Id="2920" PostHistoryTypeId="1" PostId="1041" RevisionGUID="431ce93b-cc30-49e8-99dd-f94fd28c0916" CreationDate="2014-04-01T07:13:23.783" UserId="639" Text="LCDs larger than 20x04 and 5&quot; diagonal" />
  <row Id="2921" PostHistoryTypeId="3" PostId="1041" RevisionGUID="431ce93b-cc30-49e8-99dd-f94fd28c0916" CreationDate="2014-04-01T07:13:23.783" UserId="639" Text="&lt;lcd&gt;&lt;i2c&gt;" />
  <row Id="2922" PostHistoryTypeId="2" PostId="1042" RevisionGUID="0ecfc1d3-e71a-4ee4-a60c-b06f2289f95b" CreationDate="2014-04-01T07:42:21.237" UserId="653" Text="Naked displays... search e.g. Ebay for &quot;40x4 lcd&quot; (maybe enable &quot;worldwide&quot; search)...&#xD;&#xA;&#xD;&#xA;...naked... so not i2c ... but Arduino libs for these displays exist (e.g.: [liquidcrystal440][1]), so add an Arduino-Pro or such and you can have i2c... basically they are two 40x2 displays on the same spi bus selected by different chip select lines...&#xD;&#xA;&#xD;&#xA;  [1]: https://code.google.com/p/liquidcrystal440/" />
  <row Id="2923" PostHistoryTypeId="2" PostId="1043" RevisionGUID="f4ca6eb0-ca7d-4965-baf5-7ca37831d5a3" CreationDate="2014-04-01T08:12:01.450" UserId="881" Text="There is no need to use an ISR to create the carrier. Just set up a timer to produce a 50% PWM output at the required carrier frequency. The ISR is then just in charge of modulating the carrier - typically at 0.5 or 1ms intervals - a far more comfortable rate. In my experience a 5% error in carrier frequency is tolerated by most IR receivers. I used a Freetronics EtherMega 2560 (which has plenty of timers) but I'm sure other CPUs will do just as well." />
  <row Id="2924" PostHistoryTypeId="5" PostId="1018" RevisionGUID="92fc5a93-5e63-4812-b076-5d024d0b2814" CreationDate="2014-04-01T09:03:23.940" UserId="881" Comment="added 224 characters in body" Text="Making your own is quite possible, especially if you own a router (or even better a router table). You need a V shaped 90 degree router bit, a tube of proper perspex glue and some acrylic sheet. The glue is hard to find, but plastic sign manufacturers generally will sell it. Unless you are a DIY expert, I suggest the gap filling type of glue rather than the watery product that only fills perfectly matched surfaces. Try searching Youtube on &quot;acrylic box making&quot;. There are several videos. My first two efforts were pretty bad, but the last couple are fine, and are of course exactly the right size." />
  <row Id="2927" PostHistoryTypeId="2" PostId="1045" RevisionGUID="7340ed84-b9a4-4770-878e-acf91e809525" CreationDate="2014-04-01T14:01:43.577" UserId="878" Text="I am connecting my Arduino to my Cubieboard that is running android.&#xD;&#xA;&#xD;&#xA;I tested this origionally with my android tablet and usb cable.  This worked successfully for the most part using the firmata kit but i would like to not use firmata.&#xD;&#xA;&#xD;&#xA;I want a basic function library written in java eclipse for use with unity ( eg [Library Tutorial Video][1] ) to connect to the arduino via serial port connection ( usb ) much like i am with my windows computer.&#xD;&#xA;&#xD;&#xA;Basic command functions like:&#xD;&#xA;&#xD;&#xA;Connect / Open&#xD;&#xA;Write&#xD;&#xA;Read&#xD;&#xA;Flush&#xD;&#xA;Close&#xD;&#xA;&#xD;&#xA;I was thinking maybe of using this library [here][2]  but i am unsure how to go about this.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.dropbox.com/s/i1mera8850cp6u8/Creating%20a%20Simple%20Unity%20plugin%20to%20Android.mp4&#xD;&#xA;  [2]: https://github.com/mik3y/usb-serial-for-android" />
  <row Id="2928" PostHistoryTypeId="1" PostId="1045" RevisionGUID="7340ed84-b9a4-4770-878e-acf91e809525" CreationDate="2014-04-01T14:01:43.577" UserId="878" Text="How to create a serial communication connection between Cubieboard running Android and Arduino" />
  <row Id="2929" PostHistoryTypeId="3" PostId="1045" RevisionGUID="7340ed84-b9a4-4770-878e-acf91e809525" CreationDate="2014-04-01T14:01:43.577" UserId="878" Text="&lt;serial&gt;&lt;android&gt;" />
  <row Id="2930" PostHistoryTypeId="2" PostId="1046" RevisionGUID="12e5f658-50b8-48fa-a8d5-8f665b55fb2f" CreationDate="2014-04-01T14:10:24.757" UserId="46" Text="This is a follow on question from http://arduino.stackexchange.com/questions/1002/how-to-reduce-serial-speed-on-arduino-bootloader-optiboot-and-on-the-ide&#xD;&#xA;&#xD;&#xA;I did manage recompile optiboot bootloader to work at 57600 bps and uploaded it to a couple of ATmega328-PUs. I just changed the `BAUD_RATE` to `57600L` in Makefile and recompiled it.&#xD;&#xA;&#xD;&#xA;They worked just fine with my [Arduino Single Sided Serial (Severino)](http://arduino.cc/en/Main/ArduinoBoardSerialSingleSided3) and a couple of custom standalone Arduino boards with FTDI-like header.&#xD;&#xA;&#xD;&#xA;However, I couldn't program the same MCUs using my Arduino Uno R3. When I try to upload a sketch, avrdude just sits there waiting for a response that doesn't come. The output I got is something like this:&#xD;&#xA;&#xD;&#xA;    avrdude: Version 5.11, compiled on Sep  2 2011 at 19:38:36&#xD;&#xA;             Copyright (c) 2000-2005 Brian Dean, http://www.bdmicro.com/&#xD;&#xA;             Copyright (c) 2007-2009 Joerg Wunsch&#xD;&#xA;    &#xD;&#xA;             System wide configuration file is &quot;C:\Users\Ricardo\arduino-1.0.5\hardware/tools/avr/etc/avrdude.conf&quot;&#xD;&#xA;    &#xD;&#xA;             Using Port                    : \\.\COM3&#xD;&#xA;             Using Programmer              : arduino&#xD;&#xA;             Overriding Baud Rate          : 57600&#xD;&#xA;    avrdude: Send: 0 [30]   [20] &#xD;&#xA;    avrdude: Send: 0 [30]   [20] &#xD;&#xA;    avrdude: Send: 0 [30]   [20] &#xD;&#xA;    avrdude: Recv: &#xD;&#xA;    avrdude: stk500_getsync(): not in sync: resp=0x00&#xD;&#xA;    &#xD;&#xA;    avrdude done.  Thank you.&#xD;&#xA;&#xD;&#xA;Would that have anything to do with the 2nd MCU that acts as the USB driver on the Uno - the [ATmega16U2](http://www.atmel.com/devices/atmega16u2.aspx)? Do I have to patch it, too?&#xD;&#xA;&#xD;&#xA;So, my questions are: &#xD;&#xA;&#xD;&#xA;**1. Why my recompiled optiboot didn't work with my Arduino Uno R3?** &#xD;&#xA;&#xD;&#xA;**2. What can I do to check what's wrong with the upload process using my new bootloader?**&#xD;&#xA;" />
  <row Id="2931" PostHistoryTypeId="1" PostId="1046" RevisionGUID="12e5f658-50b8-48fa-a8d5-8f665b55fb2f" CreationDate="2014-04-01T14:10:24.757" UserId="46" Text="Why my Arduino Uno R3 doesn't work with a recompiled optiboot with BAUD_RATE=57600" />
  <row Id="2932" PostHistoryTypeId="3" PostId="1046" RevisionGUID="12e5f658-50b8-48fa-a8d5-8f665b55fb2f" CreationDate="2014-04-01T14:10:24.757" UserId="46" Text="&lt;arduino-uno&gt;&lt;atmega328&gt;&lt;optiboot&gt;" />
  <row Id="2934" PostHistoryTypeId="36" PostId="1048" RevisionGUID="56486fa3-404b-494e-a150-a48c95a58c51" CreationDate="2014-04-01T15:31:09.423" UserId="-1" Comment="from http://stackoverflow.com/questions/22726959/whats-the-difference-relationship-between-arduino-and-avr" />
  <row Id="2935" PostHistoryTypeId="36" PostId="1049" RevisionGUID="fde12c0f-e2a7-4611-b2e4-1405d59896f8" CreationDate="2014-04-01T15:31:09.423" UserId="-1" Comment="from http://stackoverflow.com/questions/22726959/whats-the-difference-relationship-between-arduino-and-avr/22727059#22727059" />
  <row Id="2936" PostHistoryTypeId="2" PostId="1049" RevisionGUID="752cb470-0b57-47bf-8610-f3c32e66505d" CreationDate="2014-03-29T04:35:46.177" UserDisplayName="JayG" Text="The Arduino is an AVR processor running special code that lets you use the Arduino environment.&#xD;&#xA;&#xD;&#xA;AVR's can be used by themselves with some additional supporting components.&#xD;&#xA;&#xD;&#xA;Arduino is a combination of both AVR(chip) and breadboard.&#xD;&#xA;&#xD;&#xA;AVR is a single chip, and would require a breadboard.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2937" PostHistoryTypeId="2" PostId="1048" RevisionGUID="140d9f1a-30d9-44ca-9742-099fe426ee5b" CreationDate="2014-03-29T04:21:26.530" UserDisplayName="user3383182" Text="I'd always thought Arduino was a microcontroller platform but the actual microcontroller is an AVR chip made by Atmel, or something like that made by someone else, based on a RISC ISA, and Arduino is usually used to refer to the whole circuit board powered by this AVR chip. Is my understanding correct?&#xA;&#xA;What's the difference/relationship between Arduino and AVR?" />
  <row Id="2938" PostHistoryTypeId="1" PostId="1048" RevisionGUID="140d9f1a-30d9-44ca-9742-099fe426ee5b" CreationDate="2014-03-29T04:21:26.530" UserDisplayName="user3383182" Text="What's the difference/relationship between Arduino and AVR?" />
  <row Id="2939" PostHistoryTypeId="3" PostId="1048" RevisionGUID="140d9f1a-30d9-44ca-9742-099fe426ee5b" CreationDate="2014-03-29T04:21:26.530" UserDisplayName="user3383182" Text="&lt;avr&gt;" />
  <row Id="2940" PostHistoryTypeId="2" PostId="1050" RevisionGUID="c10ed41f-fa81-4063-ad49-a492cb167c01" CreationDate="2014-04-01T16:02:02.227" UserId="643" Text="MPU6050 is a chip that has an intenal (closed and unknown) algorith to calculate orientation. Because you ar reading ANGLE, that means you are using that algoritm, and that &quot;time&quot; may be the time needed for the warm up.&#xD;&#xA;&#xD;&#xA;what do you have as output on the serial?" />
  <row Id="2941" PostHistoryTypeId="5" PostId="1050" RevisionGUID="ee129fd5-2a6c-48fa-9485-a0b8df886955" CreationDate="2014-04-01T16:15:50.920" UserId="643" Comment="added 4 characters in body" Text="MPU6050 is a chip that has an intenal (closed and unknown) algorith to calculate orientation. Because you ar reading ANGLE, that means you are using that algoritm, and that &quot;time&quot; may be the time needed for the calibration.&#xD;&#xA;&#xD;&#xA;what do you have as output on the serial?" />
  <row Id="2942" PostHistoryTypeId="2" PostId="1051" RevisionGUID="9a0b2dd9-0bc3-4078-8db2-026718884082" CreationDate="2014-04-01T17:03:15.273" UserId="643" Text="There are some chip that measure current flow (like ACS714). Just be sure to buy a chip that will not fry under your load, and mount it in serie with the pump. That chip will bring an analog (but there a re &quot;smarter&quot; chip witch use i2c or spi) signal to arduino, using the formula on the datasheet you can find out real (well, as always there are small error) current flow. &#xD;&#xA;&#xD;&#xA;You should already know the voltage of the pump, but you can easily read it with a similar chip or even a [voltage divider][1], just pay attention if you are using PWM as if it will fake your reading)&#xD;&#xA;&#xD;&#xA;Now, as already pointed out by Adel Bibi, you can multiply the voltage of the pump with the current value readed (find power), multiply with the time elapsed from the last measure and sum up with precedent measure (integral of the power by time)&#xD;&#xA;&#xD;&#xA;you can do the same on the wind/solar panel, just invert the sign of the current (as you are Producing and not Consuming power) and voilà!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Voltage_divider" />
  <row Id="2943" PostHistoryTypeId="2" PostId="1052" RevisionGUID="b850470e-a953-4444-a563-545cf59f13c6" CreationDate="2014-04-01T17:38:07.207" UserId="575" Text="Using the library you linked should be a simple case of downloading the library's jar file from https://github.com/mik3y/usb-serial-for-android/releases and adding it as a reference/library/dependency (I forget what eclipse calls them) in your eclipse project.&#xD;&#xA;&#xD;&#xA;Then of course providing you connect with the right baud rates and so on it should work." />
  <row Id="2944" PostHistoryTypeId="2" PostId="1053" RevisionGUID="8b6756d5-2215-417c-b0ce-3e7ae3058cf2" CreationDate="2014-04-01T21:20:19.730" UserId="655" Text="LCD works fine with arduino and liquidcristal library, but I was wondering... What about d0 to d3?&#xD;&#xA;&#xD;&#xA;These pins are never connected in the schematics i have used. &#xD;&#xA;&#xD;&#xA;What are they for?" />
  <row Id="2945" PostHistoryTypeId="1" PostId="1053" RevisionGUID="8b6756d5-2215-417c-b0ce-3e7ae3058cf2" CreationDate="2014-04-01T21:20:19.730" UserId="655" Text="D0 to D3 in generic 16x2 LCD" />
  <row Id="2946" PostHistoryTypeId="3" PostId="1053" RevisionGUID="8b6756d5-2215-417c-b0ce-3e7ae3058cf2" CreationDate="2014-04-01T21:20:19.730" UserId="655" Text="&lt;lcd&gt;" />
  <row Id="2947" PostHistoryTypeId="10" PostId="1053" RevisionGUID="d89c2ba9-8e51-494e-8c96-3e8a38b02f1c" CreationDate="2014-04-01T21:47:58.563" UserId="42" Comment="101" Text="{&quot;OriginalQuestionIds&quot;:[999],&quot;Voters&quot;:[{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;}]}" />
  <row Id="2948" PostHistoryTypeId="2" PostId="1054" RevisionGUID="5cdacd96-8bb6-4ffe-9617-2d9c76ba63b2" CreationDate="2014-04-01T21:55:20.263" UserId="655" Text="I always try to isolate the hardware logic from the rest of the domain logic. &#xD;&#xA;&#xD;&#xA;Classes (or whatever) from domain logic can be programmed in c++ (with the known arduino restrictions like exceptions or std lib) and can be tested with gtest. &#xD;&#xA;When these classes are tested, simply instance from arduino program excluding the main with tests.&#xD;&#xA;&#xD;&#xA;If your project is pure hardware this solution will not help you very much, but if you have your own algorithms, protocols...etc, test them with Google test will save you hours of on board testing and memory problems with unexpected results and your software will gain in quality." />
  <row Id="2949" PostHistoryTypeId="5" PostId="1001" RevisionGUID="5e9aa645-cb58-4932-ad65-6faa956ede1f" CreationDate="2014-04-01T22:03:14.057" UserId="42" Comment="Re-drafted answer to make it clearer" Text="That type of LCD has two main modes of operation: 4-bit mode which uses 4 data pins (d4-d7), and 8-bit mode which uses all 8 data pins (d0-d7).&#xD;&#xA;&#xD;&#xA;4-bit mode has the advantage of requiring fewer output pins on your Arduino. However, it means your sketch needs to send each command/character as two separate batches of 4-bits (one after the other). This is handled for you automatically by the LiquidCrystal library, so you won't need any extra complexity in your code. However, it does mean that your sketch requires roughly double the number of processor cycles to send anything to the LCD.&#xD;&#xA;&#xD;&#xA;In contrast, 8-bit mode sends each command/character as a single batch of 8-bits. That simply means it technically runs a little faster.&#xD;&#xA;&#xD;&#xA;With that said, a person looking at the display probably won't see a significant speed difference most of the time, as it still goes very quickly. The main impact will be on the microcontroller (the Arduino in this case). If it can use the faster 8-bit mode then it can devote a little more processing time to other things. That can be particularly helpful for timing-critical applications." />
  <row Id="2950" PostHistoryTypeId="5" PostId="1045" RevisionGUID="57e49387-fd07-4c69-bddf-3b9bbb25d8ab" CreationDate="2014-04-01T22:24:51.150" UserId="220" Comment="added 287 characters in body" Text="I am connecting my Arduino to my Cubieboard that is running Android.&#xD;&#xA;&#xD;&#xA;I tested this originally with my android tablet and USB cable. This worked successfully for the most part using the firmata kit but I don't want to use firmata.&#xD;&#xA;&#xD;&#xA;I want a basic function library written in Java for use with Unity (eg [Library Tutorial Video][1]) to connect to the Arduino via the USB serial port connection much like a connection with my Windows computer.&#xD;&#xA;&#xD;&#xA;**I'd like basic command functions like:**&#xD;&#xA;&#xD;&#xA; - Connect / Open&#xD;&#xA; - Write&#xD;&#xA; - Read&#xD;&#xA; - Flush&#xD;&#xA; - Close&#xD;&#xA;&#xD;&#xA;I was thinking maybe of using this library [here][2] but I am unsure how to go about this. I know similar discussion have already taken place on the forum claiming it may not be possible, but it is very clear that it is. It has been done many times. All I need to do is send strings with serial after finding the Arduino's COM port and reading from the serial.&#xD;&#xA;&#xD;&#xA;  [1]: https://www.dropbox.com/s/i1mera8850cp6u8/Creating%20a%20Simple%20Unity%20plugin%20to%20Android.mp4&#xD;&#xA;  [2]: https://github.com/mik3y/usb-serial-for-android" />
  <row Id="2951" PostHistoryTypeId="2" PostId="1055" RevisionGUID="06010bde-9568-43d0-86ba-9ae9041e79de" CreationDate="2014-04-01T22:32:49.503" UserId="643" Text="arduino is a prototiping board. AVR is the architecture (devolped by atmel) of the microcontroller chip used in all official 8bit board, and almost all clone.&#xD;&#xA;Arduino UNO and 2009, the most used, use AtMega328P&#xD;&#xA;&#xD;&#xA;Many times, arduino is used to quick test some idea, sensor, and circuitry, then a stand-alone board is builded around the atmega chip, as it cost alost 1/10 of the arduino board, and soldered ciurcuit on a stripboard or on a custom PCB are more reitable, and can be optimized on some aspect, loke power utlization, space occupied, and so on.&#xD;&#xA;&#xD;&#xA;Newest and advanced arduino board use different chip with very different architecture; the arduino yun use a SAM plus a classic AVR, the due use an ARM (same architecture used by many smartphone), the galileo use an x86 (like a classic pre-multicore cpu)" />
  <row Id="2952" PostHistoryTypeId="2" PostId="1056" RevisionGUID="cd3e5185-fe5d-44b9-ac4d-79b3115f5126" CreationDate="2014-04-02T04:43:15.870" UserId="904" Text="I have Code for Mod bus Library as below. I have Gone through lots of forum. How to assign device ID, slave address, length using below library function:&#xD;&#xA;&#xD;&#xA;    #include &lt;SimpleModbusSlave.h&gt;&#xD;&#xA;    #define  LED 9  &#xD;&#xA;    enum &#xD;&#xA;    {     &#xD;&#xA;    &#xD;&#xA;      ADC_VAL,     &#xD;&#xA;      PWM_VAL,        &#xD;&#xA;      HOLDING_REGS_SIZE // leave this one&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    unsigned int holdingRegs[HOLDING_REGS_SIZE]; &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      modbus_configure(&amp;Serial, 9600, SERIAL_8N2, 1, 2, HOLDING_REGS_SIZE, holdingRegs);    &#xD;&#xA;      pinMode(LED, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      modbus_update();&#xD;&#xA;      holdingRegs[ADC_VAL] = analogRead(A0); // update data to be read by the master to adjust the PWM&#xD;&#xA;      analogWrite(LED, holdingRegs[PWM_VAL]&gt;&gt;2); // constrain adc value from the arduino master to 255&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I am getting Error has.&#xD;&#xA;&#xD;&#xA;    SimpleModbusSlaveArduino.cpp: In function 'void setup()':&#xD;&#xA;    SimpleModbusSlaveArduino:79: error: 'SERIAL_8N2' was not declared in this scope&#xD;&#xA;&#xD;&#xA;Let me know how to resolve issue." />
  <row Id="2953" PostHistoryTypeId="1" PostId="1056" RevisionGUID="cd3e5185-fe5d-44b9-ac4d-79b3115f5126" CreationDate="2014-04-02T04:43:15.870" UserId="904" Text="Modbus Protocol COmpile Error" />
  <row Id="2954" PostHistoryTypeId="3" PostId="1056" RevisionGUID="cd3e5185-fe5d-44b9-ac4d-79b3115f5126" CreationDate="2014-04-02T04:43:15.870" UserId="904" Text="&lt;arduino-uno&gt;&lt;programming&gt;&lt;arduino-mega&gt;&lt;networking&gt;" />
  <row Id="2956" PostHistoryTypeId="2" PostId="1058" RevisionGUID="bf32439a-2e7c-4322-b17b-3e0375e05530" CreationDate="2014-04-02T05:20:16.370" UserId="11" Text="Not sure where you got the library from, but if it's from this [github repo][1], you're using it wrong.&#xD;&#xA;&#xD;&#xA;The function prototype for `modbus_configure` is:&#xD;&#xA;&#xD;&#xA;    void modbus_configure(long baud, byte _slaveID, byte _TxEnablePin, unsigned int _holdingRegsSize, unsigned char _lowLatency);&#xD;&#xA;&#xD;&#xA;The [example file][2] shows how to use it correctly&#xD;&#xA;&#xD;&#xA;    modbus_configure(115200, 1, 2, TOTAL_REGS_SIZE);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/thibs0/EWC2013-Greenhouse-demo/tree/master/Arduino/libraries/SimpleModbusSlave&#xD;&#xA;  [2]: https://github.com/thibs0/EWC2013-Greenhouse-demo/blob/master/Arduino/libraries/SimpleModbusSlave/examples/SimpleModbusSlaveExample/SimpleModbusSlaveExample.ino" />
  <row Id="2957" PostHistoryTypeId="4" PostId="1056" RevisionGUID="80d2c00d-c504-45aa-ac01-acf6a9b6a510" CreationDate="2014-04-02T05:21:38.120" UserId="11" Comment="edited tags; edited title" Text="Modbus Protocol Compile Error" />
  <row Id="2958" PostHistoryTypeId="6" PostId="1056" RevisionGUID="80d2c00d-c504-45aa-ac01-acf6a9b6a510" CreationDate="2014-04-02T05:21:38.120" UserId="11" Comment="edited tags; edited title" Text="&lt;programming&gt;&lt;networking&gt;" />
  <row Id="2960" PostHistoryTypeId="5" PostId="1056" RevisionGUID="570f1fdc-bf11-4eeb-887a-2deb30784ab1" CreationDate="2014-04-02T07:12:08.690" UserId="904" Comment="added 486 characters in body" Text="I have Code for Mod bus Library as below. I have Gone through lots of forum. How to assign device ID, slave address, length using below library function:&#xD;&#xA;&#xD;&#xA;    #include &lt;SimpleModbusSlave.h&gt;&#xD;&#xA;    #define  LED 9  &#xD;&#xA;    enum &#xD;&#xA;    {     &#xD;&#xA;    &#xD;&#xA;      ADC_VAL,     &#xD;&#xA;      PWM_VAL,        &#xD;&#xA;      HOLDING_REGS_SIZE // leave this one&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    unsigned int holdingRegs[HOLDING_REGS_SIZE]; &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      modbus_configure(&amp;Serial, 9600, SERIAL_8N2, 1, 2, HOLDING_REGS_SIZE, holdingRegs);    &#xD;&#xA;      pinMode(LED, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      modbus_update();&#xD;&#xA;      holdingRegs[ADC_VAL] = analogRead(A0); // update data to be read by the master to adjust the PWM&#xD;&#xA;      analogWrite(LED, holdingRegs[PWM_VAL]&gt;&gt;2); // constrain adc value from the arduino master to 255&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I am getting Error has.&#xD;&#xA;&#xD;&#xA;    SimpleModbusSlaveArduino.cpp: In function 'void setup()':&#xD;&#xA;    SimpleModbusSlaveArduino:79: error: 'SERIAL_8N2' was not declared in this scope&#xD;&#xA;&#xD;&#xA;Let me know how to resolve issue.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Error2&#xD;&#xA;&#xD;&#xA;    mod_bus1.cpp: In function 'void setup()':&#xD;&#xA;    mod_bus1:14: error: invalid conversion from 'unsigned int*' to 'unsigned char'&#xD;&#xA;    mod_bus1:14: error: initializing argument 5 of 'void modbus_configure(long int, unsigned char, unsigned char, unsigned int, unsigned char)'&#xD;&#xA;    mod_bus1.cpp: In function 'void loop()':&#xD;&#xA;    mod_bus1:-1: error: too few arguments to function 'unsigned int modbus_update(unsigned int*)'&#xD;&#xA;    mod_bus1:20: error: at this point in file&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2961" PostHistoryTypeId="5" PostId="1055" RevisionGUID="f82d804d-4722-4c6a-91a2-68694f0cad7f" CreationDate="2014-04-02T08:51:10.980" UserId="643" Comment="some spelling correction" Text="Arduino is a prototiping board, and also the term &quot;Arduino&quot; is used to referr to the IDE and library on the PC side, and all its ecosystem.&#xD;&#xA;AVR is the architecture (developed by atmel) of the microcontroller chip used in all official 8bit board, and almost all clone.&#xD;&#xA;Arduino UNO and 2009, the most used, use the AtMega328P chip.&#xD;&#xA;&#xD;&#xA;Many times, Arduino is used to quick test some idea, sensor, and circuitry, then a stand-alone board is builded around the AtMega chip, as it cost 1/10 of the Arduino board, soldered ciurcuit on a stripboard or on a custom PCB are more reitable, and can be optimized on some aspect, like power utlization, space occupied, high current/voltage, and so on.&#xD;&#xA;&#xD;&#xA;Newest and advanced arduino board use different chip with very different architecture; the arduino yun use a SAM plus a classic AVR, the due use an ARM (same architecture used by many smartphone), the galileo use an x86 (like a classic pre-multicore cpu)" />
  <row Id="2962" PostHistoryTypeId="2" PostId="1059" RevisionGUID="5b7ce605-69f9-446f-9349-f2de879593d5" CreationDate="2014-04-02T09:03:53.263" UserId="643" Text="In your first example the error is that SERIAL_8N2 is not declared. maybe you are using an old Arduino IDE? try latest 1.0.x or 1.5.x&#xD;&#xA;&#xD;&#xA;in the second case TOTAL_REGS_SIZE is a pointer to int, while the function expect a char. Without code is hard to tell what is wrong and how, but in your first code it should be&#xD;&#xA;&#xD;&#xA;    modbus_configure(115200, 1, 2, HOLDING_REGS_SIZE);&#xD;&#xA;&#xD;&#xA;also because you are not passing a reference to the array, you have to pass a pointer pointing the current element in the update function&#xD;&#xA;&#xD;&#xA;    modbus_update(holdingRegs[i]);&#xD;&#xA;    i++&#xD;&#xA;" />
  <row Id="2963" PostHistoryTypeId="2" PostId="1060" RevisionGUID="84046d4a-5d50-47c2-b9ea-98d7bacb7ee3" CreationDate="2014-04-02T10:29:48.043" UserId="906" Text="With the accumulator in the system, current draw will increase as that is topped off. The accumulator provides sufficient pressure to drive the system. As system pressure draws down, the pump turns on to bring up the accumulator, with maximum draw nearing cut-off pressure. Taking the total run time of the pump in question (@DLJ) you may chop this up into discrete chunks and measure the draw over those periods, plot that out. I like that greenwall, and I want one. -- Aloha nui loa, MKK" />
  <row Id="2964" PostHistoryTypeId="5" PostId="1060" RevisionGUID="7a4fecb3-7fc1-46e7-bd30-ac3f0ee0fdf7" CreationDate="2014-04-02T10:48:40.010" UserId="906" Comment="added 193 characters in body" Text="With the accumulator in the system, current draw will increase as that is topped off. The accumulator provides sufficient pressure to drive the system. As system pressure draws down, the pump turns on to bring up the accumulator, with maximum draw nearing cut-off pressure. Taking the total run time of the pump in question (@DLJ) you may chop this up into discrete chunks and measure the draw over those periods, plot that out. I like that greenwall, and I want one. -- Aloha nui loa, MKK&#xD;&#xA;edit -- As an aside, even a 12V pump driving the smallest 1 liter accumulator to 250 kPa, will draw up to 3A for a few moments, given the size of your system. What motor shield are you using?" />
  <row Id="2965" PostHistoryTypeId="2" PostId="1061" RevisionGUID="3286ec41-a689-4c2f-b1ff-a61d771fb08c" CreationDate="2014-04-02T14:16:34.047" UserId="313" Text="[Arduino is a set of open-source hardware- and software specifications, originally conceived as a students' platform.][1] There are &quot;official&quot; Arduino boards made by an Italian company but being open-sourced, there are lots of good variants from other sources well.&#xD;&#xA;&#xD;&#xA;AVR is the MCU, manufactureby Atmel, used in the original designs.&#xD;&#xA;&#xD;&#xA;  [1]: https://en.wikipedia.org/wiki/Arduino#History" />
  <row Id="2966" PostHistoryTypeId="5" PostId="1061" RevisionGUID="1ce47065-4359-46e7-8c7c-de3a3cce3507" CreationDate="2014-04-02T14:35:01.487" UserId="313" Comment="Clarify 2d paragraph" Text="[Arduino is a set of open-source hardware- and software specifications, originally conceived as a students' platform.][1] There are &quot;official&quot; Arduino boards made by an Italian company but being open-sourced, there are lots of good variants from other sources well.&#xD;&#xA;&#xD;&#xA;AVR refers to the line of MCUs manufactured by Atmel and used in the original designs.&#xD;&#xA;&#xD;&#xA;  [1]: https://en.wikipedia.org/wiki/Arduino#History" />
  <row Id="2967" PostHistoryTypeId="2" PostId="1062" RevisionGUID="a64e2deb-b83b-41ac-b9bc-9c1134954cdb" CreationDate="2014-04-02T15:20:44.623" UserId="655" Text="There is a way to get a DateTime object from a unix timestamp + hour offset?&#xD;&#xA;&#xD;&#xA;I want to be able to print a formatted string, for example: _&quot;Wed Apr 02 17:15:06 2014&quot;_&#xD;&#xA;&#xD;&#xA;I have:&#xD;&#xA;&#xD;&#xA; 1. an **unix timestamp**: _1396451852_&#xD;&#xA; 2. an offset from my hour zone, _+1_ hour &#xD;&#xA;&#xD;&#xA;Note: I get the timestamp from an internet service and want to make the conversion in the arduino" />
  <row Id="2968" PostHistoryTypeId="1" PostId="1062" RevisionGUID="a64e2deb-b83b-41ac-b9bc-9c1134954cdb" CreationDate="2014-04-02T15:20:44.623" UserId="655" Text="Can i get a Datetime object from a unix timestamp?" />
  <row Id="2969" PostHistoryTypeId="3" PostId="1062" RevisionGUID="a64e2deb-b83b-41ac-b9bc-9c1134954cdb" CreationDate="2014-04-02T15:20:44.623" UserId="655" Text="&lt;time&gt;" />
  <row Id="2970" PostHistoryTypeId="2" PostId="1063" RevisionGUID="ccd5409b-95a9-4187-9237-3717e651849e" CreationDate="2014-04-02T15:44:39.493" UserId="313" Text="The [Arduino Time Library][1] looks like it can do it. Or have a look at the strftime() function from unix and unix-oid environments. There is [source to strftime() here][2]. It's pretty large but you can probably cut it down considerably to just the format parts you need. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Code/Time&#xD;&#xA;  [2]: http://www.jbox.dk/sanos/source/lib/strftime.c.html" />
  <row Id="2971" PostHistoryTypeId="5" PostId="1062" RevisionGUID="be028376-93da-462e-99dd-80d681580f74" CreationDate="2014-04-02T17:08:23.607" UserId="37" Comment="fixed grammar, improved formatting" Text="Is there a way to get a DateTime object from a unix timestamp and hour offset? I want to be able to print a formatted string, for example `Wed Apr 02 17:15:06 2014`.&#xD;&#xA;&#xD;&#xA;I have:&#xD;&#xA;&#xD;&#xA; 1. A unix timestamp: `1396451852`.&#xD;&#xA; 2. An offset from my hour zone, `+1` hour.&#xD;&#xA;&#xD;&#xA;Note: I get the timestamp from an internet service and want to make the conversion in the Arduino." />
  <row Id="2972" PostHistoryTypeId="4" PostId="1062" RevisionGUID="be028376-93da-462e-99dd-80d681580f74" CreationDate="2014-04-02T17:08:23.607" UserId="37" Comment="fixed grammar, improved formatting" Text="Can I get a Datetime object from a unix timestamp?" />
  <row Id="2973" PostHistoryTypeId="6" PostId="1062" RevisionGUID="be028376-93da-462e-99dd-80d681580f74" CreationDate="2014-04-02T17:08:23.607" UserId="37" Comment="fixed grammar, improved formatting" Text="&lt;programming&gt;&lt;time&gt;" />
  <row Id="2974" PostHistoryTypeId="24" PostId="1062" RevisionGUID="be028376-93da-462e-99dd-80d681580f74" CreationDate="2014-04-02T17:08:23.607" Comment="Proposed by 37 approved by 46, 84 edit id of 267" />
  <row Id="2976" PostHistoryTypeId="2" PostId="1064" RevisionGUID="866db614-a346-4b5d-bce8-9e32273bda39" CreationDate="2014-04-03T03:46:02.530" UserId="600" Text="I'm trying to understand how to fully use the COMPB vector ISR of Timer0 on the ATMega328 (standard Arduino core). I realize it will make delay() and millis() not work but that's ok by me. I've setup some test code that *should* output a 244Hz signal on D4 and 488Hz on D5 (note, this is running at 8MHz). But D5 (COMPB) is always what D4 (COMPA) is. Any thoughts? Code below:&#xD;&#xA;&#xD;&#xA;    #include &lt;avr/interrupt.h&gt;&#xD;&#xA;    &#xD;&#xA;    volatile bool stateA = false;&#xD;&#xA;    ISR(TIMER0_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;    	if (stateA)&#xD;&#xA;    		PORTD |= _BV(PIND4);&#xD;&#xA;    	else&#xD;&#xA;    		PORTD &amp;= ~(_BV(PIND4));&#xD;&#xA;    &#xD;&#xA;    	stateA = !stateA;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    volatile bool stateB = false;&#xD;&#xA;    ISR(TIMER0_COMPB_vect)&#xD;&#xA;    {&#xD;&#xA;    	if (stateB)&#xD;&#xA;    		PORTD |= _BV(PIND5);&#xD;&#xA;    	else&#xD;&#xA;    		PORTD &amp;= ~(_BV(PIND5));&#xD;&#xA;    &#xD;&#xA;    	stateB = !stateB;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    	DDRD |= _BV(PIND4) | _BV(PIND5); &#xD;&#xA;    &#xD;&#xA;    	//set timer0 interrupt at 2kHz&#xD;&#xA;    	TCCR0A = 0;// set entire TCCR2A register to 0&#xD;&#xA;    	TCCR0B = 0;// same for TCCR2B&#xD;&#xA;    	TCNT0 = 0;//initialize counter value to 0&#xD;&#xA;    	// set compare match register for 2khz increments&#xD;&#xA;    	OCR0A = 255;//244Hz&#xD;&#xA;    	OCR0B = 127;//488Hz&#xD;&#xA;    	// turn on CTC mode&#xD;&#xA;    	TCCR0A |= (1 &lt;&lt; WGM01);&#xD;&#xA;    	// Set CS01 and CS00 bits for 64 prescaler&#xD;&#xA;    	TCCR0B |= (1 &lt;&lt; CS01) | (1 &lt;&lt; CS00);&#xD;&#xA;    	// enable timer compare interrupt&#xD;&#xA;    	TIMSK0 |= (1 &lt;&lt; OCIE0B) | (1 &lt;&lt; OCIE0A);&#xD;&#xA;    &#xD;&#xA;    	interrupts();&#xD;&#xA;    &#xD;&#xA;    }" />
  <row Id="2977" PostHistoryTypeId="1" PostId="1064" RevisionGUID="866db614-a346-4b5d-bce8-9e32273bda39" CreationDate="2014-04-03T03:46:02.530" UserId="600" Text="Using TIMER0_COMPB_vect" />
  <row Id="2978" PostHistoryTypeId="3" PostId="1064" RevisionGUID="866db614-a346-4b5d-bce8-9e32273bda39" CreationDate="2014-04-03T03:46:02.530" UserId="600" Text="&lt;timers&gt;&lt;interrupt&gt;" />
  <row Id="2979" PostHistoryTypeId="5" PostId="943" RevisionGUID="7bd480ad-9e8c-4532-bd1d-1a58d49faf11" CreationDate="2014-04-03T03:57:22.923" UserId="-1" Comment="fixed spelling/grammar" Text="I have a project that I'm currently working on. We have built a green wall, wich consists of plants on a wall&#xD;&#xA;&#xD;&#xA;![Green wall][1]&#xD;&#xA;&#xD;&#xA;Now, we have a pump situated at the bottom that waters all the plants. There is an arduino board that decides when to put the pump on. Powering it is a solar panel and wind turbine. We want to know how much energy we have saved by using the solar panel and turbine.&#xD;&#xA;&#xD;&#xA;**Question:**&#xD;&#xA;&#xD;&#xA;How do I measure the amount of energy, in Wh, used from 00h00 that day? Is there a library? Or is this not possible with Arduino?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Thanks a lot.&#xD;&#xA;&#xD;&#xA;**To clear up some things**&#xD;&#xA;&#xD;&#xA;No, the pump is not fueled directly by the Arduino pin. We are using a motor shield.&#xD;&#xA;&#xD;&#xA;Yes, there is an accumulator in the circuit. The solar and wind power recharge a battery which in turn powers the components.&#xD;&#xA;&#xD;&#xA;I would like to know the entire energy consumed, not just the pump.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/iIhSW.jpg" />
  <row Id="2980" PostHistoryTypeId="24" PostId="943" RevisionGUID="7bd480ad-9e8c-4532-bd1d-1a58d49faf11" CreationDate="2014-04-03T03:57:22.923" Comment="Proposed by 173.0.242.100|774c6cbe-19ef-49bb-865d-58a8923a4400 approved by 84, 8 edit id of 268" />
  <row Id="2981" PostHistoryTypeId="2" PostId="1065" RevisionGUID="a9bc10da-9c26-4e80-9ef4-555d102015a2" CreationDate="2014-04-03T04:08:58.643" UserId="368" Text="Your code doesn't do what you think it does. The timer always runs at 244Hz, and OCR0B only matches twice per period, causing it to have the same frequency but a different phase. What you need to do is set OC0B on compare match and clear it in the overflow ISR. OCR0A you can simply set to toggle on match.&#xD;&#xA;&#xD;&#xA;    TCCR0A = _BV(COM0A0) | _BV(COM0B1) | _BV(COM0B0) | _BV(WGM01);&#xD;&#xA;    &#xD;&#xA;     ...&#xD;&#xA;    &#xD;&#xA;    ISR(TIMER0_OVF_vect)&#xD;&#xA;    {&#xD;&#xA;      PORTB &amp;= ~_BV(PD5);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Note that **this code won't actually compile against the Arduino libraries**; those libraries use `TIMER0_OVF_vect` for timing, and so you will have a symbol conflict when linking.&#xD;&#xA;&#xD;&#xA;Also, OC0A is D6, not D4." />
  <row Id="2982" PostHistoryTypeId="2" PostId="1066" RevisionGUID="bc961e92-627f-4948-876d-cd65d851519a" CreationDate="2014-04-03T04:10:31.113" UserId="84" Text="I think your code did not set `TIMSK0` properly.&#xD;&#xA;&#xD;&#xA;Instead of:&#xD;&#xA;&#xD;&#xA;    TIMSK0 |= (1 &lt;&lt; OCIE0B) | (1 &lt;&lt; OCIE0A);&#xD;&#xA;&#xD;&#xA;You should use:&#xD;&#xA;&#xD;&#xA;    TIMSK0 = (1 &lt;&lt; OCIE0B) | (1 &lt;&lt; OCIE0A);&#xD;&#xA;&#xD;&#xA;Why? Because `TIMSK0` is already initialized by Arduino libraries before your `setup()` is called.&#xD;&#xA;&#xD;&#xA;If you take a look at `hardware/arduino/cores/arduino/wiring.c` and search for the `init()` function, you will see that it contains the following lines:&#xD;&#xA;&#xD;&#xA;    	// enable timer 0 overflow interrupt&#xD;&#xA;    #if defined(TIMSK) &amp;&amp; defined(TOIE0)&#xD;&#xA;    	sbi(TIMSK, TOIE0);&#xD;&#xA;    #elif defined(TIMSK0) &amp;&amp; defined(TOIE0)&#xD;&#xA;    	sbi(TIMSK0, TOIE0);&#xD;&#xA;    #else&#xD;&#xA;    	#error	Timer 0 overflow interrupt not set correctly&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;With these lines, the `TOIE0` bit of `TIMSK0` is set, but your `setup()` does not clear it.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2983" PostHistoryTypeId="2" PostId="1067" RevisionGUID="a634251f-f939-4f90-ae28-b5b738715d58" CreationDate="2014-04-03T04:19:30.183" UserId="888" Text="Hi I just bought a wifi shield and I cannot connect to my wireless network (WPA2). I used the sketch from the arduino site for connecting to WPA network and put my SSID and password on but it doesn't connect. Help?" />
  <row Id="2984" PostHistoryTypeId="1" PostId="1067" RevisionGUID="a634251f-f939-4f90-ae28-b5b738715d58" CreationDate="2014-04-03T04:19:30.183" UserId="888" Text="Connecting to network with wifi shield" />
  <row Id="2985" PostHistoryTypeId="3" PostId="1067" RevisionGUID="a634251f-f939-4f90-ae28-b5b738715d58" CreationDate="2014-04-03T04:19:30.183" UserId="888" Text="&lt;arduino-uno&gt;&lt;shields&gt;&lt;wifi&gt;" />
  <row Id="2986" PostHistoryTypeId="5" PostId="1065" RevisionGUID="e400c9e3-7fdf-4ac3-a899-7b65cc66ccd7" CreationDate="2014-04-03T04:26:08.277" UserId="368" Comment="added 25 characters in body" Text="Your code doesn't do what you think it does. The timer always runs at 244Hz, and OCR0B only matches twice per period, causing it to have the same frequency but a different phase. What you need to do is set OC0B on compare match and clear it in the overflow ISR. OCR0A you can simply set to toggle on match.&#xD;&#xA;&#xD;&#xA;    TCCR0A = _BV(COM0A0) | _BV(COM0B1) | _BV(COM0B0) | _BV(WGM01);&#xD;&#xA;    TIMSK0 |= (1 &lt;&lt; TOIE0);&#xD;&#xA;&#xD;&#xA;     ...&#xD;&#xA;    &#xD;&#xA;    ISR(TIMER0_OVF_vect)&#xD;&#xA;    {&#xD;&#xA;      PORTB &amp;= ~_BV(PD5);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Note that **this code won't actually compile against the Arduino libraries**; those libraries use `TIMER0_OVF_vect` for timing, and so you will have a symbol conflict when linking.&#xD;&#xA;&#xD;&#xA;Also, OC0A is D6, not D4." />
  <row Id="2987" PostHistoryTypeId="2" PostId="1068" RevisionGUID="942f6762-3f6f-438a-9a3c-13569cb09ab7" CreationDate="2014-04-03T04:36:41.190" UserId="84" Text="Actually, after reading the ATmega328P datasheet again, I al not sure that you can use both `OCR0A` and `OCR0B` in normal timer mode. &#xD;&#xA;&#xD;&#xA;In particular, since you use CTC mode, I think that `TCNT0` will be cleared every time its value reaches `OCR0A` i.e. 127.&#xD;&#xA;&#xD;&#xA;Since you need 244Hz and 488Hz (exactly twice 244Hz), I think you can operte with only one of `OCR0A` or `OCRB0` and do the work in one ISR only:&#xD;&#xA;&#xD;&#xA;    #include &lt;avr/interrupt.h&gt;&#xD;&#xA;    &#xD;&#xA;    volatile bool setBothPins = false;&#xD;&#xA;    ISR(TIMER0_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;        if (setBothPins)&#xD;&#xA;            // D4 is changed only once (244Hz)for every 2 changes of D5 (488Hz)&#xD;&#xA;            PORTD ^= _BV(PIND4);&#xD;&#xA;        PORTD ^= _BV(PIND5);&#xD;&#xA;    &#xD;&#xA;        setBothPins = !setBothPins;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        DDRD |= _BV(PIND4) | _BV(PIND5); &#xD;&#xA;    &#xD;&#xA;        //set timer0 interrupt at 2kHz&#xD;&#xA;        TCCR0A = 0;// set entire TCCR2A register to 0&#xD;&#xA;        TCCR0B = 0;// same for TCCR2B&#xD;&#xA;        TCNT0 = 0;//initialize counter value to 0&#xD;&#xA;        // set compare match register for 2khz increments&#xD;&#xA;        OCR0A = 127;//488Hz&#xD;&#xA;        // turn on CTC mode&#xD;&#xA;        TCCR0A |= (1 &lt;&lt; WGM01);&#xD;&#xA;        // Set CS01 and CS00 bits for 64 prescaler&#xD;&#xA;        TCCR0B |= (1 &lt;&lt; CS01) | (1 &lt;&lt; CS00);&#xD;&#xA;        // enable timer compare interrupt&#xD;&#xA;        TIMSK0 = (1 &lt;&lt; OCIE0A);&#xD;&#xA;    &#xD;&#xA;        interrupts();&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="2988" PostHistoryTypeId="5" PostId="1065" RevisionGUID="afb9adbd-bfe3-4b0f-a276-d8112ccbbe99" CreationDate="2014-04-03T04:39:17.847" UserId="368" Comment="deleted 183 characters in body" Text="Your code doesn't do what you think it does. The timer always runs at 244Hz, and OCR0B only matches twice per period, causing it to have the same frequency but a different phase. What you need to do is set OC0B on compare match and clear it in the overflow ISR. OCR0A you can simply set to toggle on match.&#xD;&#xA;&#xD;&#xA;    TCCR0A = _BV(COM0A0) | _BV(COM0B1) | _BV(COM0B0) | _BV(WGM01);&#xD;&#xA;    TIMSK0 |= _BV(OCIE0A);&#xD;&#xA;&#xD;&#xA;     ...&#xD;&#xA;    &#xD;&#xA;    ISR(TIMER0_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;      PORTB &amp;= ~_BV(PD5);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Also, OC0A is D6, not D4." />
  <row Id="2989" PostHistoryTypeId="5" PostId="1068" RevisionGUID="10034563-e0e6-47ce-a2fb-67d3726ac1d7" CreationDate="2014-04-03T04:56:34.597" UserId="84" Comment="stupid typo" Text="Actually, after reading the ATmega328P datasheet again, I am not sure that you can use both `OCR0A` and `OCR0B` in normal timer mode. &#xD;&#xA;&#xD;&#xA;In particular, since you use CTC mode, I think that `TCNT0` will be cleared every time its value reaches `OCR0A` i.e. 127.&#xD;&#xA;&#xD;&#xA;Since you need 244Hz and 488Hz (exactly twice 244Hz), I think you can operate with only one of `OCR0A` or `OCRB0` and do the work in one ISR only:&#xD;&#xA;&#xD;&#xA;    #include &lt;avr/interrupt.h&gt;&#xD;&#xA;    &#xD;&#xA;    volatile bool setBothPins = false;&#xD;&#xA;    ISR(TIMER0_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;        if (setBothPins)&#xD;&#xA;            // D4 is changed only once (244Hz)for every 2 changes of D5 (488Hz)&#xD;&#xA;            PORTD ^= _BV(PIND4);&#xD;&#xA;        PORTD ^= _BV(PIND5);&#xD;&#xA;    &#xD;&#xA;        setBothPins = !setBothPins;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        DDRD |= _BV(PIND4) | _BV(PIND5); &#xD;&#xA;    &#xD;&#xA;        //set timer0 interrupt at 2kHz&#xD;&#xA;        TCCR0A = 0;// set entire TCCR2A register to 0&#xD;&#xA;        TCCR0B = 0;// same for TCCR2B&#xD;&#xA;        TCNT0 = 0;//initialize counter value to 0&#xD;&#xA;        // set compare match register for 2khz increments&#xD;&#xA;        OCR0A = 127;//488Hz&#xD;&#xA;        // turn on CTC mode&#xD;&#xA;        TCCR0A |= (1 &lt;&lt; WGM01);&#xD;&#xA;        // Set CS01 and CS00 bits for 64 prescaler&#xD;&#xA;        TCCR0B |= (1 &lt;&lt; CS01) | (1 &lt;&lt; CS00);&#xD;&#xA;        // enable timer compare interrupt&#xD;&#xA;        TIMSK0 = (1 &lt;&lt; OCIE0A);&#xD;&#xA;    &#xD;&#xA;        interrupts();&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="2990" PostHistoryTypeId="5" PostId="1056" RevisionGUID="3c836911-4f5c-49e3-9c1d-cd814d1ff736" CreationDate="2014-04-03T06:09:20.177" UserId="904" Comment="deleted 515 characters in body" Text="I have Code for Mod bus Library as below. I have Gone through lots of forum. How to assign device ID, slave address, length using below library function:&#xD;&#xA;&#xD;&#xA;    #include &lt;SimpleModbusSlave.h&gt;&#xD;&#xA;    #define  LED 9  &#xD;&#xA;    enum &#xD;&#xA;    {     &#xD;&#xA;    &#xD;&#xA;      ADC_VAL,     &#xD;&#xA;      PWM_VAL,        &#xD;&#xA;      HOLDING_REGS_SIZE // leave this one&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    unsigned int holdingRegs[HOLDING_REGS_SIZE]; &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      modbus_configure(&amp;Serial, 9600, SERIAL_8N2, 1, 2, HOLDING_REGS_SIZE, holdingRegs);    &#xD;&#xA;      pinMode(LED, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      modbus_update();&#xD;&#xA;      holdingRegs[ADC_VAL] = analogRead(A0); // update data to be read by the master to adjust the PWM&#xD;&#xA;      analogWrite(LED, holdingRegs[PWM_VAL]&gt;&gt;2); // constrain adc value from the arduino master to 255&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I am getting Error has.&#xD;&#xA;&#xD;&#xA;    SimpleModbusSlaveArduino.cpp: In function 'void setup()':&#xD;&#xA;    SimpleModbusSlaveArduino:79: error: 'SERIAL_8N2' was not declared in this scope&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="2991" PostHistoryTypeId="2" PostId="1069" RevisionGUID="24771a90-8823-4280-856c-793fbdd3de4b" CreationDate="2014-04-03T06:14:35.190" UserId="904" Text="I have below code for Modbus protocol. This program uploaded successfully. I have below setup to monitor data from Modbus. I could not able to receive data. I can able to send data from master but not getting any response. Let me know how to resolve this&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    11:42:17.000: Device Address: 01h, Register: 000Dh&#xD;&#xA;    11:42:17.000: |-&gt; Read Register: 000Dh&#xD;&#xA;    11:42:17.015: -&gt; [01h] [0Dh] [00h] [0Dh] [00h] [01h] [08h] [7Ch] &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![MYsetup][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &lt;modbus.h&gt;&#xD;&#xA;    #include &lt;modbusDevice.h&gt;&#xD;&#xA;    #include &lt;modbusRegBank.h&gt;&#xD;&#xA;    #include &lt;modbusSlave.h&gt;&#xD;&#xA;    &#xD;&#xA;    /*&#xD;&#xA;    This example code shows a quick and dirty way to get an&#xD;&#xA;    arduino to talk to a modbus master device with a&#xD;&#xA;    device ID of 1 at 9600 baud.&#xD;&#xA;    */&#xD;&#xA;    &#xD;&#xA;    //Setup the brewtrollers register bank&#xD;&#xA;    //All of the data accumulated will be stored here&#xD;&#xA;    modbusDevice regBank;&#xD;&#xA;    //Create the modbus slave protocol handler&#xD;&#xA;    modbusSlave slave;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {   &#xD;&#xA;    &#xD;&#xA;    //Assign the modbus device ID.  &#xD;&#xA;      regBank.setId(1);&#xD;&#xA;    &#xD;&#xA;    /*&#xD;&#xA;    modbus registers follow the following format&#xD;&#xA;    00001-09999  Digital Outputs, A master device can read and write to these registers&#xD;&#xA;    10001-19999  Digital Inputs, A master device can only read the values from these registers&#xD;&#xA;    30001-39999  Analog Inputs, A master device can only read the values from these registers&#xD;&#xA;    40001-49999  Analog Outputs, A master device can read and write to these registers &#xD;&#xA;    &#xD;&#xA;    Analog values are 16 bit unsigned words stored with a range of 0-32767&#xD;&#xA;    Digital values are stored as bytes, a zero value is OFF and any nonzer value is ON&#xD;&#xA;    &#xD;&#xA;    It is best to configure registers of like type into contiguous blocks.  this&#xD;&#xA;    allows for more efficient register lookup and and reduces the number of messages&#xD;&#xA;    required by the master to retrieve the data&#xD;&#xA;    */&#xD;&#xA;    &#xD;&#xA;    //Add Digital Output registers 00001-00016 to the register bank&#xD;&#xA;      regBank.add(1);&#xD;&#xA;      regBank.add(2);&#xD;&#xA;      regBank.add(3);&#xD;&#xA;      regBank.add(4);&#xD;&#xA;      regBank.add(5);&#xD;&#xA;      regBank.add(6);&#xD;&#xA;      regBank.add(7);&#xD;&#xA;      regBank.add(8);&#xD;&#xA;      regBank.add(9);&#xD;&#xA;      regBank.add(10);&#xD;&#xA;      regBank.add(11);&#xD;&#xA;      regBank.add(12);&#xD;&#xA;      regBank.add(13);&#xD;&#xA;      regBank.add(14);&#xD;&#xA;      regBank.add(15);&#xD;&#xA;      regBank.add(16);&#xD;&#xA;    &#xD;&#xA;    //Add Digital Input registers 10001-10008 to the register bank&#xD;&#xA;      regBank.add(10001);  &#xD;&#xA;      regBank.add(10002);  &#xD;&#xA;      regBank.add(10003);  &#xD;&#xA;      regBank.add(10004);  &#xD;&#xA;      regBank.add(10005);  &#xD;&#xA;      regBank.add(10006);  &#xD;&#xA;      regBank.add(10007);  &#xD;&#xA;      regBank.add(10008);  &#xD;&#xA;    &#xD;&#xA;    //Add Analog Input registers 30001-10010 to the register bank&#xD;&#xA;      regBank.add(30001);  &#xD;&#xA;      regBank.add(30002);  &#xD;&#xA;      regBank.add(30003);  &#xD;&#xA;      regBank.add(30004);  &#xD;&#xA;      regBank.add(30005);  &#xD;&#xA;      regBank.add(30006);  &#xD;&#xA;      regBank.add(30007);  &#xD;&#xA;      regBank.add(30008);  &#xD;&#xA;      regBank.add(30009);  &#xD;&#xA;      regBank.add(30010);  &#xD;&#xA;    &#xD;&#xA;    //Add Analog Output registers 40001-40020 to the register bank&#xD;&#xA;      regBank.add(40001);  &#xD;&#xA;      regBank.add(40002);  &#xD;&#xA;      regBank.add(40003);  &#xD;&#xA;      regBank.add(40004);  &#xD;&#xA;      regBank.add(40005);  &#xD;&#xA;      regBank.add(40006);  &#xD;&#xA;      regBank.add(40007);  &#xD;&#xA;      regBank.add(40008);  &#xD;&#xA;      regBank.add(40009);  &#xD;&#xA;      regBank.add(40010);  &#xD;&#xA;      regBank.add(40011);  &#xD;&#xA;      regBank.add(40012);  &#xD;&#xA;      regBank.add(40013);  &#xD;&#xA;      regBank.add(40014);  &#xD;&#xA;      regBank.add(40015);  &#xD;&#xA;      regBank.add(40016);  &#xD;&#xA;      regBank.add(40017);  &#xD;&#xA;      regBank.add(40018);  &#xD;&#xA;      regBank.add(40019);  &#xD;&#xA;      regBank.add(40020);  &#xD;&#xA;    &#xD;&#xA;    /*&#xD;&#xA;    Assign the modbus device object to the protocol handler&#xD;&#xA;    This is where the protocol handler will look to read and write&#xD;&#xA;    register data.  Currently, a modbus slave protocol handler may&#xD;&#xA;    only have one device assigned to it.&#xD;&#xA;    */&#xD;&#xA;      slave._device = &amp;regBank;  &#xD;&#xA;    &#xD;&#xA;    // Initialize the serial port for coms at 9600 baud  &#xD;&#xA;      slave.setBaud(9600);   &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    //put some data into the registers&#xD;&#xA;      regBank.set(1, 1);  &#xD;&#xA;      regBank.set(2, 1);  &#xD;&#xA;      regBank.set(3, 0);  &#xD;&#xA;      regBank.set(4, 1);  &#xD;&#xA;      regBank.set(5, 1);  &#xD;&#xA;      regBank.set(6, 0);  &#xD;&#xA;      regBank.set(7, 1);  &#xD;&#xA;      regBank.set(8, 0);  &#xD;&#xA;    &#xD;&#xA;      regBank.set(10001, 1);&#xD;&#xA;      regBank.set(10002, 1);  &#xD;&#xA;      regBank.set(10003, 1);  &#xD;&#xA;      regBank.set(10004, 1);  &#xD;&#xA;      regBank.set(10005, 0);  &#xD;&#xA;      regBank.set(10006, 0);  &#xD;&#xA;      regBank.set(10007, 0);  &#xD;&#xA;      regBank.set(10008, 0);  &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      regBank.set(30001,1);&#xD;&#xA;      regBank.set(30002,2);&#xD;&#xA;      regBank.set(30003,3);&#xD;&#xA;      regBank.set(30004,4);&#xD;&#xA;      regBank.set(30005,5);&#xD;&#xA;      regBank.set(30006,6);&#xD;&#xA;      regBank.set(30007,7);&#xD;&#xA;      regBank.set(30008,8);&#xD;&#xA;      regBank.set(30009,9);&#xD;&#xA;      regBank.set(30010,10);&#xD;&#xA;    &#xD;&#xA;      regBank.set(40001,1);&#xD;&#xA;      regBank.set(40002,2);&#xD;&#xA;      regBank.set(40003,2);&#xD;&#xA;      regBank.set(40004,4);&#xD;&#xA;      regBank.set(40005,5);&#xD;&#xA;      regBank.set(40006,6);&#xD;&#xA;      regBank.set(40007,7);&#xD;&#xA;      regBank.set(40008,8);&#xD;&#xA;      regBank.set(40009,9);&#xD;&#xA;      regBank.set(40010,10);&#xD;&#xA;      &#xD;&#xA;     while(1)&#xD;&#xA;      {&#xD;&#xA;        //put a random number into registers 1, 10001, 30001 and 40001&#xD;&#xA;        regBank.set(1, (byte) random(0, 2));&#xD;&#xA;        regBank.set(10001, (byte) random(0, 2));&#xD;&#xA;        regBank.set(30001, (word) random(0, 32767));&#xD;&#xA;        regBank.set(40001, (word) random(0, 32767));&#xD;&#xA;        &#xD;&#xA;         slave.run();  &#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/PVKco.jpg" />
  <row Id="2992" PostHistoryTypeId="1" PostId="1069" RevisionGUID="24771a90-8823-4280-856c-793fbdd3de4b" CreationDate="2014-04-03T06:14:35.190" UserId="904" Text="MODbus response for configure data" />
  <row Id="2993" PostHistoryTypeId="3" PostId="1069" RevisionGUID="24771a90-8823-4280-856c-793fbdd3de4b" CreationDate="2014-04-03T06:14:35.190" UserId="904" Text="&lt;arduino-uno&gt;&lt;arduino-mega&gt;" />
  <row Id="2994" PostHistoryTypeId="5" PostId="1069" RevisionGUID="5f348ecf-1c62-425b-a537-c426ce9dbee1" CreationDate="2014-04-03T06:18:13.220" UserId="11" Comment="grammar, tags" Text="I am not able to receive data. I am able to send data from master but am not getting any response. This program uploaded successfully. I have below setup to monitor data from Modbus.&#xD;&#xA;&#xD;&#xA;I have included code for Modbus protocol below.&#xD;&#xA;&#xD;&#xA;Also, can someone suggest me the link to download modbus slave config library without any error along with wiring diagram&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    11:42:17.000: Device Address: 01h, Register: 000Dh&#xD;&#xA;    11:42:17.000: |-&gt; Read Register: 000Dh&#xD;&#xA;    11:42:17.015: -&gt; [01h] [0Dh] [00h] [0Dh] [00h] [01h] [08h] [7Ch] &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![MYsetup][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &lt;modbus.h&gt;&#xD;&#xA;    #include &lt;modbusDevice.h&gt;&#xD;&#xA;    #include &lt;modbusRegBank.h&gt;&#xD;&#xA;    #include &lt;modbusSlave.h&gt;&#xD;&#xA;    &#xD;&#xA;    /*&#xD;&#xA;    This example code shows a quick and dirty way to get an&#xD;&#xA;    arduino to talk to a modbus master device with a&#xD;&#xA;    device ID of 1 at 9600 baud.&#xD;&#xA;    */&#xD;&#xA;    &#xD;&#xA;    //Setup the brewtrollers register bank&#xD;&#xA;    //All of the data accumulated will be stored here&#xD;&#xA;    modbusDevice regBank;&#xD;&#xA;    //Create the modbus slave protocol handler&#xD;&#xA;    modbusSlave slave;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {   &#xD;&#xA;    &#xD;&#xA;    //Assign the modbus device ID.  &#xD;&#xA;      regBank.setId(1);&#xD;&#xA;    &#xD;&#xA;    /*&#xD;&#xA;    modbus registers follow the following format&#xD;&#xA;    00001-09999  Digital Outputs, A master device can read and write to these registers&#xD;&#xA;    10001-19999  Digital Inputs, A master device can only read the values from these registers&#xD;&#xA;    30001-39999  Analog Inputs, A master device can only read the values from these registers&#xD;&#xA;    40001-49999  Analog Outputs, A master device can read and write to these registers &#xD;&#xA;    &#xD;&#xA;    Analog values are 16 bit unsigned words stored with a range of 0-32767&#xD;&#xA;    Digital values are stored as bytes, a zero value is OFF and any nonzer value is ON&#xD;&#xA;    &#xD;&#xA;    It is best to configure registers of like type into contiguous blocks.  this&#xD;&#xA;    allows for more efficient register lookup and and reduces the number of messages&#xD;&#xA;    required by the master to retrieve the data&#xD;&#xA;    */&#xD;&#xA;    &#xD;&#xA;    //Add Digital Output registers 00001-00016 to the register bank&#xD;&#xA;      regBank.add(1);&#xD;&#xA;      regBank.add(2);&#xD;&#xA;      regBank.add(3);&#xD;&#xA;      regBank.add(4);&#xD;&#xA;      regBank.add(5);&#xD;&#xA;      regBank.add(6);&#xD;&#xA;      regBank.add(7);&#xD;&#xA;      regBank.add(8);&#xD;&#xA;      regBank.add(9);&#xD;&#xA;      regBank.add(10);&#xD;&#xA;      regBank.add(11);&#xD;&#xA;      regBank.add(12);&#xD;&#xA;      regBank.add(13);&#xD;&#xA;      regBank.add(14);&#xD;&#xA;      regBank.add(15);&#xD;&#xA;      regBank.add(16);&#xD;&#xA;    &#xD;&#xA;    //Add Digital Input registers 10001-10008 to the register bank&#xD;&#xA;      regBank.add(10001);  &#xD;&#xA;      regBank.add(10002);  &#xD;&#xA;      regBank.add(10003);  &#xD;&#xA;      regBank.add(10004);  &#xD;&#xA;      regBank.add(10005);  &#xD;&#xA;      regBank.add(10006);  &#xD;&#xA;      regBank.add(10007);  &#xD;&#xA;      regBank.add(10008);  &#xD;&#xA;    &#xD;&#xA;    //Add Analog Input registers 30001-10010 to the register bank&#xD;&#xA;      regBank.add(30001);  &#xD;&#xA;      regBank.add(30002);  &#xD;&#xA;      regBank.add(30003);  &#xD;&#xA;      regBank.add(30004);  &#xD;&#xA;      regBank.add(30005);  &#xD;&#xA;      regBank.add(30006);  &#xD;&#xA;      regBank.add(30007);  &#xD;&#xA;      regBank.add(30008);  &#xD;&#xA;      regBank.add(30009);  &#xD;&#xA;      regBank.add(30010);  &#xD;&#xA;    &#xD;&#xA;    //Add Analog Output registers 40001-40020 to the register bank&#xD;&#xA;      regBank.add(40001);  &#xD;&#xA;      regBank.add(40002);  &#xD;&#xA;      regBank.add(40003);  &#xD;&#xA;      regBank.add(40004);  &#xD;&#xA;      regBank.add(40005);  &#xD;&#xA;      regBank.add(40006);  &#xD;&#xA;      regBank.add(40007);  &#xD;&#xA;      regBank.add(40008);  &#xD;&#xA;      regBank.add(40009);  &#xD;&#xA;      regBank.add(40010);  &#xD;&#xA;      regBank.add(40011);  &#xD;&#xA;      regBank.add(40012);  &#xD;&#xA;      regBank.add(40013);  &#xD;&#xA;      regBank.add(40014);  &#xD;&#xA;      regBank.add(40015);  &#xD;&#xA;      regBank.add(40016);  &#xD;&#xA;      regBank.add(40017);  &#xD;&#xA;      regBank.add(40018);  &#xD;&#xA;      regBank.add(40019);  &#xD;&#xA;      regBank.add(40020);  &#xD;&#xA;    &#xD;&#xA;    /*&#xD;&#xA;    Assign the modbus device object to the protocol handler&#xD;&#xA;    This is where the protocol handler will look to read and write&#xD;&#xA;    register data.  Currently, a modbus slave protocol handler may&#xD;&#xA;    only have one device assigned to it.&#xD;&#xA;    */&#xD;&#xA;      slave._device = &amp;regBank;  &#xD;&#xA;    &#xD;&#xA;    // Initialize the serial port for coms at 9600 baud  &#xD;&#xA;      slave.setBaud(9600);   &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    //put some data into the registers&#xD;&#xA;      regBank.set(1, 1);  &#xD;&#xA;      regBank.set(2, 1);  &#xD;&#xA;      regBank.set(3, 0);  &#xD;&#xA;      regBank.set(4, 1);  &#xD;&#xA;      regBank.set(5, 1);  &#xD;&#xA;      regBank.set(6, 0);  &#xD;&#xA;      regBank.set(7, 1);  &#xD;&#xA;      regBank.set(8, 0);  &#xD;&#xA;    &#xD;&#xA;      regBank.set(10001, 1);&#xD;&#xA;      regBank.set(10002, 1);  &#xD;&#xA;      regBank.set(10003, 1);  &#xD;&#xA;      regBank.set(10004, 1);  &#xD;&#xA;      regBank.set(10005, 0);  &#xD;&#xA;      regBank.set(10006, 0);  &#xD;&#xA;      regBank.set(10007, 0);  &#xD;&#xA;      regBank.set(10008, 0);  &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      regBank.set(30001,1);&#xD;&#xA;      regBank.set(30002,2);&#xD;&#xA;      regBank.set(30003,3);&#xD;&#xA;      regBank.set(30004,4);&#xD;&#xA;      regBank.set(30005,5);&#xD;&#xA;      regBank.set(30006,6);&#xD;&#xA;      regBank.set(30007,7);&#xD;&#xA;      regBank.set(30008,8);&#xD;&#xA;      regBank.set(30009,9);&#xD;&#xA;      regBank.set(30010,10);&#xD;&#xA;    &#xD;&#xA;      regBank.set(40001,1);&#xD;&#xA;      regBank.set(40002,2);&#xD;&#xA;      regBank.set(40003,2);&#xD;&#xA;      regBank.set(40004,4);&#xD;&#xA;      regBank.set(40005,5);&#xD;&#xA;      regBank.set(40006,6);&#xD;&#xA;      regBank.set(40007,7);&#xD;&#xA;      regBank.set(40008,8);&#xD;&#xA;      regBank.set(40009,9);&#xD;&#xA;      regBank.set(40010,10);&#xD;&#xA;      &#xD;&#xA;     while(1)&#xD;&#xA;      {&#xD;&#xA;        //put a random number into registers 1, 10001, 30001 and 40001&#xD;&#xA;        regBank.set(1, (byte) random(0, 2));&#xD;&#xA;        regBank.set(10001, (byte) random(0, 2));&#xD;&#xA;        regBank.set(30001, (word) random(0, 32767));&#xD;&#xA;        regBank.set(40001, (word) random(0, 32767));&#xD;&#xA;        &#xD;&#xA;         slave.run();  &#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/PVKco.jpg" />
  <row Id="2995" PostHistoryTypeId="6" PostId="1069" RevisionGUID="5f348ecf-1c62-425b-a537-c426ce9dbee1" CreationDate="2014-04-03T06:18:13.220" UserId="11" Comment="grammar, tags" Text="&lt;programming&gt;&lt;modbus&gt;" />
  <row Id="2996" PostHistoryTypeId="5" PostId="1056" RevisionGUID="5f4c5bbc-7a4e-4b39-8236-ea7a951a3773" CreationDate="2014-04-03T06:27:16.693" UserId="904" Comment="added 70 characters in body" Text="I have Code for Mod bus Library as below. I have Gone through lots of forum. How to assign device ID, slave address, length using below library function:&#xD;&#xA;&#xD;&#xA;    #include &lt;SimpleModbusSlave.h&gt;&#xD;&#xA;    #define  LED 9  &#xD;&#xA;    enum &#xD;&#xA;    {     &#xD;&#xA;    &#xD;&#xA;      ADC_VAL,     &#xD;&#xA;      PWM_VAL,        &#xD;&#xA;      HOLDING_REGS_SIZE // leave this one&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    unsigned int holdingRegs[HOLDING_REGS_SIZE]; &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      modbus_configure(&amp;Serial, 9600, SERIAL_8N2, 1, 2, HOLDING_REGS_SIZE, holdingRegs);    &#xD;&#xA;      pinMode(LED, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      modbus_update();&#xD;&#xA;      holdingRegs[ADC_VAL] = analogRead(A0); // update data to be read by the master to adjust the PWM&#xD;&#xA;      analogWrite(LED, holdingRegs[PWM_VAL]&gt;&gt;2); // constrain adc value from the arduino master to 255&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I am getting Error has.&#xD;&#xA;&#xD;&#xA;    SimpleModbusSlaveArduino.cpp: In function 'void setup()':&#xD;&#xA;    SimpleModbusSlaveArduino:79: error: 'SERIAL_8N2' was not declared in this scope&#xD;&#xA;&#xD;&#xA;![Error message for IDE][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/rzaUD.jpg" />
  <row Id="2997" PostHistoryTypeId="6" PostId="1056" RevisionGUID="5f4c5bbc-7a4e-4b39-8236-ea7a951a3773" CreationDate="2014-04-03T06:27:16.693" UserId="904" Comment="added 70 characters in body" Text="&lt;arduino-uno&gt;&lt;programming&gt;&lt;arduino-mega&gt;&lt;arduino-ide&gt;&lt;networking&gt;" />
  <row Id="3002" PostHistoryTypeId="4" PostId="1056" RevisionGUID="ff255117-179b-49a9-baf7-c40c1d91d9eb" CreationDate="2014-04-03T08:57:35.423" UserId="904" Comment="edited title" Text="{Answer}Modbus Protocol Compile Error" />
  <row Id="3003" PostHistoryTypeId="4" PostId="1056" RevisionGUID="8e372ff0-6f7f-4173-b1eb-79d36cf4a31e" CreationDate="2014-04-03T09:21:45.060" UserId="42" Comment="Removed unnecessary text which had been added to the title" Text="Modbus Protocol Compile Error" />
  <row Id="3005" PostHistoryTypeId="2" PostId="1072" RevisionGUID="e29b0b02-579c-4e49-bab1-195c7a41a3ff" CreationDate="2014-04-03T13:43:27.917" UserId="765" Text="Using an Uno configured with an Adafruit RFID-NFC shield to send the UID values to a desktop game I am building.&#xD;&#xA;&#xD;&#xA;Works fine. However, in addition to just the UID, I need to send 1 additional value, lets call it 'game choice'. This can be one of 3 values. This is just the relevant code. Can any experts suggest how I might modify the following to send this additional value?&#xD;&#xA;&#xD;&#xA;    /**************************************************************************/&#xD;&#xA;    #include &lt;Wire.h&gt;&#xD;&#xA;    #include &lt;Adafruit_NFCShield_I2C.h&gt;&#xD;&#xA;    &#xD;&#xA;    #define IRQ   (2)&#xD;&#xA;    #define RESET (3)  // Not connected by default on the NFC Shield&#xD;&#xA;    &#xD;&#xA;    Adafruit_NFCShield_I2C nfc(IRQ, RESET);&#xD;&#xA;    &#xD;&#xA;    void setup(void) {&#xD;&#xA;      Serial.begin(115200);&#xD;&#xA;      Serial.println(&quot;Hello!&quot;);&#xD;&#xA;    &#xD;&#xA;      nfc.begin();&#xD;&#xA;    &#xD;&#xA;      uint32_t versiondata = nfc.getFirmwareVersion();&#xD;&#xA;      if (! versiondata) {&#xD;&#xA;        Serial.print(&quot;Didn't find PN53x board&quot;);&#xD;&#xA;        while (1); // halt&#xD;&#xA;      }&#xD;&#xA;      // Got ok data, print it out!&#xD;&#xA;      Serial.print(&quot;Found chip PN5&quot;); Serial.println((versiondata&gt;&gt;24) &amp; 0xFF, HEX); &#xD;&#xA;      Serial.print(&quot;Firmware ver. &quot;); Serial.print((versiondata&gt;&gt;16) &amp; 0xFF, DEC); &#xD;&#xA;      Serial.print('.'); Serial.println((versiondata&gt;&gt;8) &amp; 0xFF, DEC);&#xD;&#xA;      &#xD;&#xA;      // configure board to read RFID tags&#xD;&#xA;      nfc.SAMConfig();&#xD;&#xA;      &#xD;&#xA;      Serial.println(&quot;init&quot;);&#xD;&#xA;    }&#xD;&#xA;    void loop(void) {&#xD;&#xA;      uint8_t success;&#xD;&#xA;      uint8_t uid[] = { 0, 0, 0, 0, 0, 0, 0 };  // Buffer to store the returned UID&#xD;&#xA;      uint8_t uidLength;                        // Length of the UID (4 or 7 bytes depending on ISO14443A card type)&#xD;&#xA;      int nfcDEC;  &#xD;&#xA;      success = nfc.readPassiveTargetID(PN532_MIFARE_ISO14443A, uid, &amp;uidLength);&#xD;&#xA;      &#xD;&#xA;      if (success) {&#xD;&#xA;        &#xD;&#xA;        &#xD;&#xA;       nfc.PrintHex(uid, uidLength );&#xD;&#xA;    }&#xD;&#xA;    }" />
  <row Id="3006" PostHistoryTypeId="1" PostId="1072" RevisionGUID="e29b0b02-579c-4e49-bab1-195c7a41a3ff" CreationDate="2014-04-03T13:43:27.917" UserId="765" Text="Modifying serial message for Adafruit NFC/RFID card" />
  <row Id="3007" PostHistoryTypeId="3" PostId="1072" RevisionGUID="e29b0b02-579c-4e49-bab1-195c7a41a3ff" CreationDate="2014-04-03T13:43:27.917" UserId="765" Text="&lt;arduino-uno&gt;" />
  <row Id="3008" PostHistoryTypeId="5" PostId="1064" RevisionGUID="b3968f6a-6d61-40fd-b1a0-175875de1cf5" CreationDate="2014-04-03T13:46:39.803" UserId="600" Comment="added 534 characters in body" Text="I'm trying to understand how to fully use the COMPB vector ISR of Timer0 on the ATMega328 (standard Arduino core). I realize it will make delay() and millis() not work but that's ok by me. I've setup some test code that *should* output a 244Hz signal on D4 and 488Hz on D5 (note, this is running at 8MHz). But D5 (COMPB) is always what D4 (COMPA) is. Any thoughts? Code below:&#xD;&#xA;&#xD;&#xA;    #include &lt;avr/interrupt.h&gt;&#xD;&#xA;    &#xD;&#xA;    volatile bool stateA = false;&#xD;&#xA;    ISR(TIMER0_COMPA_vect)&#xD;&#xA;    {&#xD;&#xA;    	if (stateA)&#xD;&#xA;    		PORTD |= _BV(PIND4);&#xD;&#xA;    	else&#xD;&#xA;    		PORTD &amp;= ~(_BV(PIND4));&#xD;&#xA;    &#xD;&#xA;    	stateA = !stateA;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    volatile bool stateB = false;&#xD;&#xA;    ISR(TIMER0_COMPB_vect)&#xD;&#xA;    {&#xD;&#xA;    	if (stateB)&#xD;&#xA;    		PORTD |= _BV(PIND5);&#xD;&#xA;    	else&#xD;&#xA;    		PORTD &amp;= ~(_BV(PIND5));&#xD;&#xA;    &#xD;&#xA;    	stateB = !stateB;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    	DDRD |= _BV(PIND4) | _BV(PIND5); &#xD;&#xA;    &#xD;&#xA;    	//set timer0 interrupt at 2kHz&#xD;&#xA;    	TCCR0A = 0;// set entire TCCR2A register to 0&#xD;&#xA;    	TCCR0B = 0;// same for TCCR2B&#xD;&#xA;    	TCNT0 = 0;//initialize counter value to 0&#xD;&#xA;    	// set compare match register for 2khz increments&#xD;&#xA;    	OCR0A = 255;//244Hz&#xD;&#xA;    	OCR0B = 127;//488Hz&#xD;&#xA;    	// turn on CTC mode&#xD;&#xA;    	TCCR0A |= (1 &lt;&lt; WGM01);&#xD;&#xA;    	// Set CS01 and CS00 bits for 64 prescaler&#xD;&#xA;    	TCCR0B |= (1 &lt;&lt; CS01) | (1 &lt;&lt; CS00);&#xD;&#xA;    	// enable timer compare interrupt&#xD;&#xA;    	TIMSK0 |= (1 &lt;&lt; OCIE0B) | (1 &lt;&lt; OCIE0A);&#xD;&#xA;    &#xD;&#xA;    	interrupts();&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Update:** After thinking about it, I'm realizing that it's not that I need two separate frequencies (though I just kinda wanted to know how, so this is good stuff) but I just need two separate interrupts, only using Timer0 (1 &amp; 2 are already in use elsewhere). They can be the same frequency, most likely. I probably *could* put all the functionality I need in the same TIMER0_COMPA_vect, however I was trying to use that in a library I was writing and was trying to keep the functionality separate... this may not be possible." />
  <row Id="3009" PostHistoryTypeId="10" PostId="1067" RevisionGUID="65e37e81-b9e9-4dc1-9cae-41497e1da981" CreationDate="2014-04-03T15:28:03.723" UserId="42" Comment="102" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:65,&quot;DisplayName&quot;:&quot;AsheeshR&quot;},{&quot;Id&quot;:37,&quot;DisplayName&quot;:&quot;The Guy with The Hat&quot;},{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;}]}" />
  <row Id="3016" PostHistoryTypeId="2" PostId="1073" RevisionGUID="21edefc7-8064-41e1-9c9d-90120427edd0" CreationDate="2014-04-03T16:11:46.917" UserId="884" Text="Working on a code where I am able to manually enter the value in the url to let the php code save it in the database. But unsure how to it with a variable in a loop running. This is the URL:&#xD;&#xA;&#xD;&#xA;    student.cs.hioa.no/~s180343/updatedb.php?verdi=25&#xD;&#xA;&#xD;&#xA;Code:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      // Initialize Bridge&#xD;&#xA;      Bridge.begin();&#xD;&#xA;    &#xD;&#xA;      // Initialize Serial&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    &#xD;&#xA;      // Wait until a Serial Monitor is connected.&#xD;&#xA;      while (!Serial);&#xD;&#xA;      Serial.println(&quot;Ready&quot;);&#xD;&#xA;    &#xD;&#xA;      // run various example processes&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;       runCurl();&#xD;&#xA;       delay(10000);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void runCurl() {&#xD;&#xA;      // Launch &quot;curl&quot; command and get Arduino ascii art logo from the network&#xD;&#xA;      // curl is command line program for transferring data using different internet protocols&#xD;&#xA;      Process p;        // Create a process and call it &quot;p&quot;&#xD;&#xA;      p.begin(&quot;curl&quot;);  // Process that launch the &quot;curl&quot; command&#xD;&#xA;      p.addParameter(&quot;student.cs.hioa.no/~s180343/updatedb.php?verdi=25&quot;); // Add the URL parameter to &quot;curl&quot;&#xD;&#xA;      p.run();      // Run the process and wait for its termination&#xD;&#xA;    &#xD;&#xA;      // A process output can be read with the stream methods&#xD;&#xA;      while (p.available()&gt;0) {&#xD;&#xA;        char c = p.read();&#xD;&#xA;        Serial.print(c);&#xD;&#xA;      }&#xD;&#xA;      // Ensure the last bit of data is sent.&#xD;&#xA;      Serial.flush();&#xD;&#xA;    }" />
  <row Id="3017" PostHistoryTypeId="1" PostId="1073" RevisionGUID="21edefc7-8064-41e1-9c9d-90120427edd0" CreationDate="2014-04-03T16:11:46.917" UserId="884" Text="Pass variable in a url" />
  <row Id="3018" PostHistoryTypeId="3" PostId="1073" RevisionGUID="21edefc7-8064-41e1-9c9d-90120427edd0" CreationDate="2014-04-03T16:11:46.917" UserId="884" Text="&lt;arduino-uno&gt;&lt;programming&gt;&lt;variables&gt;" />
  <row Id="3021" PostHistoryTypeId="5" PostId="1067" RevisionGUID="ece719bb-4731-497d-a824-3be8373799df" CreationDate="2014-04-03T18:09:51.847" UserId="888" Comment="added 343 characters in body" Text="Hi I just bought a wifi shield and I cannot connect to my wireless network (WPA2). &#xD;&#xA;&#xD;&#xA;-I used the sketch from the arduino site (http://arduino.cc/en/Tutorial/ConnectWithWPA) for connecting to WPA network and put my SSID and password on but it doesn't connect (I know the credentials are correct as I used my phone to connect with these wifi credentials). &#xD;&#xA;&#xD;&#xA;-When I read the serial monitor it just keeps trying to connect. The wifi-shield board error light is red&#xD;&#xA;&#xD;&#xA;-I checked my network settings and my block level is at is lowest (NAT only).&#xD;&#xA;&#xD;&#xA;Help?&#xD;&#xA;" />
  <row Id="3022" PostHistoryTypeId="6" PostId="1073" RevisionGUID="5891cea9-4fcc-4ef0-acba-63756e9c75ba" CreationDate="2014-04-03T18:16:02.700" UserId="84" Comment="sample code is obviously not for UNO but for YUN" Text="&lt;programming&gt;&lt;arduino-yun&gt;&lt;variables&gt;" />
  <row Id="3023" PostHistoryTypeId="2" PostId="1074" RevisionGUID="54a7723f-c59a-4551-9427-b85e41950a68" CreationDate="2014-04-03T18:51:49.743" UserId="11" Text="You can pass in a variable into a function. Something like this:&#xD;&#xA;&#xD;&#xA;    void runCurl(int verdi) {&#xD;&#xA;        ...&#xD;&#xA;        String myUrl = &quot;student.cs.hioa.no/~s180343/updatedb.php?verdi=&quot; + verdi;&#xD;&#xA;        p.addParameter(myUrl);&#xD;&#xA;        ...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You call the function like this, now:&#xD;&#xA;&#xD;&#xA;    runCurl(1);&#xD;&#xA;    runCurl(2);&#xD;&#xA;    runCurl(someVar);&#xD;&#xA;&#xD;&#xA;and so on. Since it's already in your main `loop()` function, you just need to set pass in a different number based on whatever it is you're trying to do." />
  <row Id="3024" PostHistoryTypeId="2" PostId="1075" RevisionGUID="83a7205b-752c-484d-b1fb-cc338405b66d" CreationDate="2014-04-03T19:03:39.057" UserId="94" Text="I want to program an ATtiny through the Arduino IDE. I have a somehow strange programmer. But I can upload via avrdude by &#xD;&#xA;&#xD;&#xA;&gt;avrdude -p attiny13 -P /dev/cu.usbmodemfa131     -c stk500v2    -F -B20 -U flash:w:programm.hex &#xD;&#xA;&#xD;&#xA;It took a while to figure out that I had to slow the baud rate via the -B20 switch. If I try to upload via the arduino 1.0.5 IDE avrdude is executed as follows.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&gt; /Applications/Adafruit Arduino 1.0.5.app/Contents/Resources/Java/hardware/tools/avr/bin/avrdude -C/Applications/Adafruit Arduino 1.0.5.app/Contents/Resources/Java/hardware/tools/avr/etc/avrdude.conf -v -v -v -v -pattiny13 -cstk500v1 -P/dev/tty.usbmodemfa131 -Uflash:w:/var/folders/9t/5jldfq752fs1x74_rhn2plz80000gn/T/build7680201613426497544.tmp/attinytest.cpp.hex:i &#xD;&#xA;&#xD;&#xA;My question is, how can I change the preferences such that I have control over the avrdude parameters? Say I want to add a -B20 switch and change stk500v1 to stk500v2. " />
  <row Id="3025" PostHistoryTypeId="1" PostId="1075" RevisionGUID="83a7205b-752c-484d-b1fb-cc338405b66d" CreationDate="2014-04-03T19:03:39.057" UserId="94" Text="Change Options for the AVR Programmer via Arduino IDE" />
  <row Id="3026" PostHistoryTypeId="3" PostId="1075" RevisionGUID="83a7205b-752c-484d-b1fb-cc338405b66d" CreationDate="2014-04-03T19:03:39.057" UserId="94" Text="&lt;avrdude&gt;&lt;avr&gt;&lt;programmer&gt;" />
  <row Id="3027" PostHistoryTypeId="11" PostId="1067" RevisionGUID="78c7a51d-83d6-4e04-ae0f-b21335285d0e" CreationDate="2014-04-03T19:21:35.367" UserId="11" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="3028" PostHistoryTypeId="2" PostId="1076" RevisionGUID="d1770c1e-6a97-4c5f-8076-7f594a124ffc" CreationDate="2014-04-03T19:59:19.507" UserId="84" Text="**Short answer**: I'm afraid you can't do it with Arduino IDE.&#xD;&#xA;&#xD;&#xA;**Long answer**:&#xD;&#xA;&#xD;&#xA;First of all, be aware that `-B20` does not specify the baud rate but the bitclock period (in us); this is specific to `stk500v2` programmer.&#xD;&#xA;&#xD;&#xA;Normally, enabling your programmer should only be a matter of adding it to the list of programmers known by Arduino IDE; that list can be found in `hardware/arduino/programmers.txt`. You would then append the following lines at the end of this file:&#xD;&#xA;&#xD;&#xA;    strangeprogrammer.name=Somehow Strange Programmer&#xD;&#xA;    strangeprogrammer.communication=serial&#xD;&#xA;    strangeprogrammer.protocol=stk500v2&#xD;&#xA;    strangeprogrammer.force=true&#xD;&#xA;    strangeprogrammer.speed=?????&#xD;&#xA;&#xD;&#xA;However, the problem here is that Arduino IDE does not seem to be able to use flag `-B` (bitclock period) but only flag `-b` (baud rate) which value is set to whatever you will put to `strangeprogrammer.speed`. &#xD;&#xA;&#xD;&#xA;At least that's what I could find out by inspecting Arduino IDE source code: `AvrdudeUploader.java` never adds that flag to the `avrdude` command-line :-(&#xD;&#xA;&#xD;&#xA;That means your options are:&#xD;&#xA;&#xD;&#xA;1. Rebuild the Arduino IDE on your own after modifying `AvrdudeUploader.java` to support `-B` flag; code should be quite easy (about 2 more lines of Java code).&#xD;&#xA;&#xD;&#xA;2. Enter an issue to [Arduino project on github][1]; I'm not sure that would be the best option, considering the number of currently open issues there and how long they've been open for some of them.&#xD;&#xA;&#xD;&#xA;3. Use another IDE, something that deserves the **IDE** name. I use Eclipse with this [Arduino plugin][2] and it works fine for me. As a bonus, avrdude support seems better as you can see on the screenshot below:&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/arduino/Arduino/issues&#xD;&#xA;  [2]: http://eclipse.baeyens.it/UsethePlugin.html&#xD;&#xA;  [3]: http://i.stack.imgur.com/gUqsS.png" />
  <row Id="3030" PostHistoryTypeId="5" PostId="1076" RevisionGUID="1a5c3af2-ba9c-4467-9d7f-ec5026d09328" CreationDate="2014-04-03T20:24:31.653" UserId="84" Comment="Specified this is not possible with IDE 1.0 but possible with 1.5" Text="**Short answer**: I'm afraid you can't do it with Arduino IDE 1.0.5.&#xD;&#xA;&#xD;&#xA;**Long answer**:&#xD;&#xA;&#xD;&#xA;First of all, be aware that `-B20` does not specify the baud rate but the bitclock period (in us); this is specific to `stk500v2` programmer.&#xD;&#xA;&#xD;&#xA;Normally, enabling your programmer should only be a matter of adding it to the list of programmers known by Arduino IDE; that list can be found in `hardware/arduino/programmers.txt`. You would then append the following lines at the end of this file:&#xD;&#xA;&#xD;&#xA;    strangeprogrammer.name=Somehow Strange Programmer&#xD;&#xA;    strangeprogrammer.communication=serial&#xD;&#xA;    strangeprogrammer.protocol=stk500v2&#xD;&#xA;    strangeprogrammer.force=true&#xD;&#xA;    strangeprogrammer.speed=?????&#xD;&#xA;&#xD;&#xA;However, the problem here is that Arduino IDE does not seem to be able to use flag `-B` (bitclock period) but only flag `-b` (baud rate) which value is set to whatever you will put to `strangeprogrammer.speed`. &#xD;&#xA;&#xD;&#xA;At least that's what I could find out by inspecting Arduino IDE source code: `AvrdudeUploader.java` never adds that flag to the `avrdude` command-line :-(&#xD;&#xA;&#xD;&#xA;That means your options are:&#xD;&#xA;&#xD;&#xA;1. Rebuild the Arduino IDE 1.0 on your own after modifying `AvrdudeUploader.java` to support `-B` flag; code should be quite easy (about 2 more lines of Java code).&#xD;&#xA;&#xD;&#xA;2. Switch to Arduino IDE 1.5 and follow [Federico's answer][1] :-)&#xD;&#xA;&#xD;&#xA;3. Use another IDE, something that deserves the **IDE** name. I use Eclipse with this [Arduino plugin][2] and it works fine for me. As a bonus, avrdude support seems better as you can see on the screenshot below:&#xD;&#xA;&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/questions/1075/change-options-for-the-avr-programmer-via-arduino-ide/1077#1077&#xD;&#xA;  [2]: http://eclipse.baeyens.it/UsethePlugin.html&#xD;&#xA;  [3]: http://i.stack.imgur.com/gUqsS.png" />
  <row Id="3031" PostHistoryTypeId="5" PostId="1067" RevisionGUID="177fac06-cda4-4bba-b09f-3f43b45d10ad" CreationDate="2014-04-03T22:14:11.090" UserId="220" Comment="Please capitalize &quot;Arduino&quot;; Improved formatting and a few other minor issues" Text="I just bought a WiFi shield and I cannot connect to my wireless network (WPA2). &#xD;&#xA;&#xD;&#xA;- I used the [sketch from the Arduino site](http://arduino.cc/en/Tutorial/ConnectWithWPA) for connecting to WPA network and put my SSID and password on but it doesn't connect (I know the credentials are correct as I used my phone to connect with these WiFi credentials). &#xD;&#xA;- When I read the serial monitor it just keeps trying to connect. The WiFi-shield board error light is red&#xD;&#xA;- I checked my network settings and my block level is at is lowest (NAT only).&#xD;&#xA;&#xD;&#xA;**Why can't I connect?**" />
  <row Id="3033" PostHistoryTypeId="2" PostId="1078" RevisionGUID="c0b4c746-4051-4ceb-ba87-4d01edcc940d" CreationDate="2014-04-04T04:55:08.047" UserId="931" Text="I'm just exploring new features. I have a bluetooth module, and I have done quite a few projects using it. Is it possible to use an NFC Chip to do bluetooth pairing? For example, the user just has to touch his/her NFC enabled phone to the NFC chip on the arduino, and both of the devices get automatically paired. If it is possible, can you guide me on how to do this? I have no experience with NFC at all. Thanks in advance. " />
  <row Id="3034" PostHistoryTypeId="1" PostId="1078" RevisionGUID="c0b4c746-4051-4ceb-ba87-4d01edcc940d" CreationDate="2014-04-04T04:55:08.047" UserId="931" Text="One Touch Pairing" />
  <row Id="3035" PostHistoryTypeId="3" PostId="1078" RevisionGUID="c0b4c746-4051-4ceb-ba87-4d01edcc940d" CreationDate="2014-04-04T04:55:08.047" UserId="931" Text="&lt;arduino-uno&gt;&lt;bluetooth&gt;" />
  <row Id="3036" PostHistoryTypeId="2" PostId="1079" RevisionGUID="3327ecff-58ee-43fb-8f35-defcdc0241fa" CreationDate="2014-04-04T05:46:42.140" UserId="931" Text="I'm currently developing a Lego Robot, the mindstorm series to be specific. I want to replace the lego NXT brick with an arduino, maybe an intel galileo in the future. How do I establish connections from the arduino with the lego sensors? Also, I would like some input on any cool features that I can add to this robot. This robot is to be seen as a human companion. Thanks in advance " />
  <row Id="3037" PostHistoryTypeId="1" PostId="1079" RevisionGUID="3327ecff-58ee-43fb-8f35-defcdc0241fa" CreationDate="2014-04-04T05:46:42.140" UserId="931" Text="Arduino Lego Robot" />
  <row Id="3038" PostHistoryTypeId="3" PostId="1079" RevisionGUID="3327ecff-58ee-43fb-8f35-defcdc0241fa" CreationDate="2014-04-04T05:46:42.140" UserId="931" Text="&lt;arduino-uno&gt;&lt;robotics&gt;" />
  <row Id="3039" PostHistoryTypeId="5" PostId="1027" RevisionGUID="e9cbd4f1-64d0-4ace-b2d8-b4a3fd11b202" CreationDate="2014-04-04T05:55:38.513" UserId="304" Comment="added new driver chip" Text="I know it's not what you asked, but you're using a lot of pins, why not try streamlining them and go to an I2C backpack? [This one from adafruit][1] includes a single 4x7 segment display.&#xD;&#xA;&#xD;&#xA;given your comment, another option would be an [I2C/SPI 7 Segment driver][2]. ([datasheet][3]). &#xD;&#xA;&#xD;&#xA;new edit: Actually, when I posted the above 7 segment driver, this is the one I was thinking of. I don't know why I didn't find this the first time.&#xD;&#xA;&#xD;&#xA;[max7219/7221 datasheet][4] and [digikey source][5]:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.adafruit.com/products/879&#xD;&#xA;  [2]: http://uk.farnell.com/nxp/saa1064-n2/ic-led-driver-4dgt-i2c-24dip/dp/1627002&#xD;&#xA;  [3]: http://www.fortito.mx/wp-content/uploads/technical/SAA1064.pdf&#xD;&#xA;  [4]: http://www.maximintegrated.com/datasheet/index.mvp/id/1339&#xD;&#xA;  [5]: http://www.digikey.com.au/product-search/en?vendor=0&amp;keywords=max7219+%7C+max7221" />
  <row Id="3040" PostHistoryTypeId="10" PostId="1079" RevisionGUID="de3ac5aa-1fc0-442f-abe1-9b3895e45b9a" CreationDate="2014-04-04T05:58:38.123" UserId="11" Comment="103" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="3041" PostHistoryTypeId="5" PostId="1079" RevisionGUID="75714710-7120-43ec-b1bc-2516af3c7b21" CreationDate="2014-04-04T06:00:41.020" UserId="931" Comment="added 172 characters in body" Text="I'm currently developing a Lego Robot, the mindstorm series to be specific. I want to replace the lego NXT brick with an arduino, maybe an intel galileo in the future. How do I establish connections from the arduino with the lego sensors? Also, I would like some input on any cool features that I can add to this robot. This robot is to be seen as a human companion. Thanks in advance.&#xD;&#xA;&#xD;&#xA;An example of a sensor i would like to use is here : http://www.hitechnic.com/cgi-bin/commerce.cgi?preadd=action&amp;key=NIS1070&#xD;&#xA;&#xD;&#xA;How do I interface this with an arduino?" />
  <row Id="3042" PostHistoryTypeId="11" PostId="1079" RevisionGUID="5051b756-29f7-41dd-8adc-b04b4aa85472" CreationDate="2014-04-04T06:10:31.583" UserId="11" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="3043" PostHistoryTypeId="2" PostId="1080" RevisionGUID="c72a06e5-e1a0-43de-a91c-c196473a02c2" CreationDate="2014-04-04T06:31:39.580" UserId="754" Text="In the loop:&#xD;&#xA;&#xD;&#xA;    // attempt to connect to Wifi network:&#xD;&#xA;      while ( status != WL_CONNECTED) { &#xD;&#xA;        Serial.print(&quot;Attempting to connect to WPA SSID: &quot;);&#xD;&#xA;        Serial.println(ssid);&#xD;&#xA;        // Connect to WPA/WPA2 network:    &#xD;&#xA;        status = WiFi.begin(ssid, pass);&#xD;&#xA;    &#xD;&#xA;        // wait 10 seconds for connection:&#xD;&#xA;        delay(10000);&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;Can you add ``Serial.print(status);`` before the delay so you can see if any of these arise:&#xD;&#xA;&#xD;&#xA; * WL_IDLE_STATUS = 0&#xD;&#xA; * WL_NO_SSID_AVAIL &#xD;&#xA; * WL_CONNECT_FAILED &#xD;&#xA; * WL_CONNECTION_LOST&#xD;&#xA; * WL_DISCONNECTED&#xD;&#xA;&#xD;&#xA;They are defined in ``wl_definitions.h``&#xD;&#xA;" />
  <row Id="3044" PostHistoryTypeId="2" PostId="1081" RevisionGUID="d17bea80-08b3-4ccd-9c04-2a32b0c067ca" CreationDate="2014-04-04T06:50:34.037" UserId="754" Text="Doing a quick search on google you can find a couple of shields designed for that purpose:&#xD;&#xA;&#xD;&#xA; * [NXShield-Dx][1]&#xD;&#xA; * [Bricktronics shield][2]&#xD;&#xA;&#xD;&#xA;Second one is allows less motor connections but it's cheaper and has a [book][3] written by the designers&#xD;&#xA;&#xD;&#xA;  [1]: http://www.robotshop.com/en/arduino-lego-mindstorms-shield-nxshield-d.html&#xD;&#xA;  [2]: https://store.wayneandlayne.com/products/bricktronics-shield-kit.html&#xD;&#xA;  [3]: http://shop.oreilly.com/product/0636920024316.do" />
  <row Id="3047" PostHistoryTypeId="2" PostId="1082" RevisionGUID="af3403d5-314f-477b-b77b-b112c3508567" CreationDate="2014-04-04T07:08:21.227" UserId="168" Text="I'd like to mention an issue that doesn't come up very often but can cause long term issues. Memory Leaks and Heap Fragmentation. Almost nobody mallocs in embedded stuff, but if you do, do it right." />
  <row Id="3051" PostHistoryTypeId="2" PostId="1083" RevisionGUID="cff16970-16d7-4caa-8293-639d36d77de5" CreationDate="2014-04-04T09:21:24.980" UserId="904" Text="I have below code . This code is successfully compiled and uploaded, But i am not getting any response from Slave. Let me know what i need to do.&#xD;&#xA;&#xD;&#xA;![Error ,essage][1]&#xD;&#xA;![COnnection diagram][2]&#xD;&#xA;&#xD;&#xA;My main code&#xD;&#xA;    #define ID  1&#xD;&#xA;    /*static float ARDUINO_ANALOG_SCALING = 0.00488758;&#xD;&#xA;    static float Ydegree;&#xD;&#xA;    static int Sensor_Value;&#xD;&#xA;    float Yvoltage;&#xD;&#xA;    &#xD;&#xA;    */&#xD;&#xA;    &#xD;&#xA;    Modbus slave(ID, 0, 0);&#xD;&#xA;    boolean led;&#xD;&#xA;    int8_t state = 0;&#xD;&#xA;    unsigned long tempus;&#xD;&#xA;    // data array for modbus network sharing&#xD;&#xA;    uint16_t au16data[9];&#xD;&#xA;    float latitude=13.08;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      pinMode(13, OUTPUT);&#xD;&#xA;      slave.begin( 19200 );&#xD;&#xA;      tempus = millis() + 100;&#xD;&#xA;      digitalWrite(13, HIGH );&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      &#xD;&#xA;      state = slave.poll( au16data, 9 );&#xD;&#xA;      if (state &gt; 4) {&#xD;&#xA;        tempus = millis() + 50;&#xD;&#xA;        digitalWrite(13, HIGH);&#xD;&#xA;      }&#xD;&#xA;      if (millis() &gt; tempus) digitalWrite(13, LOW );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      au16data[4] = analogRead(0);&#xD;&#xA;      au16data[5] = analogRead(1);&#xD;&#xA;    &#xD;&#xA;      &#xD;&#xA;     &#xD;&#xA;      au16data[6] = slave.getInCnt();&#xD;&#xA;      au16data[7] = slave.getOutCnt();&#xD;&#xA;      au16data[8] = slave.getErrCnt();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Modbus code&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #define  MAX_BUFFER  64	&#xD;&#xA;    typedef struct {&#xD;&#xA;      uint8_t u8id;          /*!&lt; slave address between 1 and 247. 0 means broadcast */&#xD;&#xA;      uint8_t u8fct;         /*!&lt; function code: 1, 2, 3, 4, 5, 6, 15 or 16 */&#xD;&#xA;      uint16_t u16RegAdd;    /*!&lt; address of the first register to access at slave/s */&#xD;&#xA;      uint16_t u16CoilsNo;   /*!&lt; number of coils or registers to access */&#xD;&#xA;      uint16_t *au16reg;     /*!&lt; pointer to memory image in master */&#xD;&#xA;    }&#xD;&#xA;    modbus_t;&#xD;&#xA;    &#xD;&#xA;    enum {&#xD;&#xA;      RESPONSE_SIZE = 6,&#xD;&#xA;      EXCEPTION_SIZE = 3,&#xD;&#xA;      CHECKSUM_SIZE = 2&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum MESSAGE {&#xD;&#xA;      ID = 0,&#xD;&#xA;      FUNC,&#xD;&#xA;      ADD_HI,&#xD;&#xA;      ADD_LO,&#xD;&#xA;      NB_HI,&#xD;&#xA;      NB_LO,&#xD;&#xA;      BYTE_CNT&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum MB_FC {&#xD;&#xA;      MB_FC_NONE                     = 0,   /*!&lt; null operator */&#xD;&#xA;      MB_FC_READ_COILS               = 1,	/*!&lt; FCT=1 -&gt; read coils or digital outputs */&#xD;&#xA;      MB_FC_READ_DISCRETE_INPUT      = 2,	/*!&lt; FCT=2 -&gt; read digital inputs */&#xD;&#xA;      MB_FC_READ_REGISTERS           = 3,	/*!&lt; FCT=3 -&gt; read registers or analog outputs */&#xD;&#xA;      MB_FC_READ_INPUT_REGISTER      = 4,	/*!&lt; FCT=4 -&gt; read analog inputs */&#xD;&#xA;      MB_FC_WRITE_COIL               = 5,	/*!&lt; FCT=5 -&gt; write single coil or output */&#xD;&#xA;      MB_FC_WRITE_REGISTER           = 6,	/*!&lt; FCT=6 -&gt; write single register */&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_COILS     = 15,	/*!&lt; FCT=15 -&gt; write multiple coils or outputs */&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_REGISTERS = 16	/*!&lt; FCT=16 -&gt; write multiple registers */&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum COM_STATES {&#xD;&#xA;      COM_IDLE                     = 0,&#xD;&#xA;      COM_WAITING                  = 1&#xD;&#xA;    &#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum ERR_LIST {&#xD;&#xA;      ERR_NOT_MASTER                = -1,&#xD;&#xA;      ERR_POLLING                   = -2,&#xD;&#xA;      ERR_BUFF_OVERFLOW             = -3,&#xD;&#xA;      ERR_BAD_CRC                   = -4,&#xD;&#xA;      ERR_EXCEPTION                 = -5&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    enum {&#xD;&#xA;      NO_REPLY = 255, 			/*!&lt; */&#xD;&#xA;      EXC_FUNC_CODE = 1,		/*!&lt; Function code not available */&#xD;&#xA;      EXC_ADDR_RANGE = 2, 		/*!&lt; Address beyond available space for Modbus registers */&#xD;&#xA;      EXC_REGS_QUANT = 3,  		/*!&lt; Coils or registers number beyond the available space */&#xD;&#xA;      EXC_EXECUTE = 4 			/*!&lt; */&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    const unsigned char fctsupported[] = {&#xD;&#xA;      MB_FC_READ_COILS,&#xD;&#xA;      MB_FC_READ_DISCRETE_INPUT,&#xD;&#xA;      MB_FC_READ_REGISTERS,&#xD;&#xA;      MB_FC_READ_INPUT_REGISTER,&#xD;&#xA;      MB_FC_WRITE_COIL,&#xD;&#xA;      MB_FC_WRITE_REGISTER,&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_COILS,&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_REGISTERS&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    #define T35  5&#xD;&#xA;    &#xD;&#xA;    class Modbus {&#xD;&#xA;    private:&#xD;&#xA;      HardwareSerial *port; //!&lt; Pointer to Serial class object&#xD;&#xA;      uint8_t u8id; //!&lt;0=master, 1..247=slave number&#xD;&#xA;      uint8_t u8serno; //!&lt;serial port: 0-Serial, 1..3-Serial1..Serial3&#xD;&#xA;      uint8_t u8txenpin; //!&lt;flow control pin: 0=USB or RS-232 mode, &gt;0=RS-485 mode&#xD;&#xA;      uint8_t u8state;&#xD;&#xA;      uint8_t au8Buffer[MAX_BUFFER];&#xD;&#xA;      uint8_t u8BufferSize;&#xD;&#xA;      uint8_t u8lastRec;&#xD;&#xA;      uint16_t *au16regs;&#xD;&#xA;      uint16_t u16InCnt, u16OutCnt, u16errCnt;&#xD;&#xA;      uint16_t u16timeOut;&#xD;&#xA;      uint32_t u32time, u32timeOut;&#xD;&#xA;      uint8_t u8regsize;&#xD;&#xA;    &#xD;&#xA;      void init(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin);&#xD;&#xA;      void sendTxBuffer(); // transmit buffer to serial port&#xD;&#xA;      int8_t getRxBuffer(); // get serial buffer contents&#xD;&#xA;      uint16_t calcCRC(uint8_t u8length); // get CRC from au8Buffer until u8length&#xD;&#xA;      uint8_t validateAnswer();&#xD;&#xA;      uint8_t validateRequest(); // validate master request&#xD;&#xA;      void get_FC1(); // *** only master ***&#xD;&#xA;      void get_FC3(); // *** only master ***&#xD;&#xA;      int8_t process_FC1( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC3( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC5( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC6( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC15( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC16( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      void buildException( uint8_t u8exception ); // build exception message&#xD;&#xA;    &#xD;&#xA;    public:&#xD;&#xA;      Modbus(); // !&lt; Default Constructor&#xD;&#xA;      Modbus(uint8_t u8id, uint8_t u8serno); // !&lt; Constructor&#xD;&#xA;      Modbus(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin); // !&lt; Full Constructor&#xD;&#xA;      void begin(long u32speed);&#xD;&#xA;      void begin();&#xD;&#xA;      void setTimeOut( uint16_t u16timeout); //!&lt; write communication watch-dog timer&#xD;&#xA;      uint16_t getTimeOut(); //!&lt; get communication watch-dog timer value&#xD;&#xA;      boolean getTimeOutState(); //!&lt; get communication watch-dog timer state&#xD;&#xA;      int8_t query( modbus_t telegram ); //!&lt; only for master&#xD;&#xA;      int8_t poll(); //!&lt; cyclic poll for master&#xD;&#xA;      int8_t poll( uint16_t *regs, uint8_t u8size ); //!&lt; cyclic poll for slave&#xD;&#xA;      uint16_t getInCnt(); //!&lt; number of incoming messages&#xD;&#xA;      uint16_t getOutCnt(); //!&lt; number of outcoming messages&#xD;&#xA;      uint16_t getErrCnt(); //!&lt; error counter&#xD;&#xA;      uint8_t getID(); //!&lt; get slave ID between 1 and 247&#xD;&#xA;      uint8_t getState();&#xD;&#xA;      uint8_t getLastError(); //!&lt; get last error message&#xD;&#xA;      void setID( uint8_t u8id ); //!&lt; write new ID for the slave&#xD;&#xA;      void end(); //!&lt; finish any communication and release serial communication port&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus() {&#xD;&#xA;      init(0, 0, 0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus(uint8_t u8id, uint8_t u8serno) {&#xD;&#xA;      init(u8id, u8serno, 0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin) {&#xD;&#xA;      init(u8id, u8serno, u8txenpin);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::begin(long u32speed) {&#xD;&#xA;    &#xD;&#xA;      switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;      case 1:&#xD;&#xA;        port = &amp;Serial1;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;      case 2:&#xD;&#xA;        port = &amp;Serial2;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;      case 3:&#xD;&#xA;        port = &amp;Serial3;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;      case 0:&#xD;&#xA;      default:&#xD;&#xA;        port = &amp;Serial;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // port-&gt;begin(u32speed, u8config);&#xD;&#xA;      port-&gt;begin(u32speed);&#xD;&#xA;      if (u8txenpin &gt; 1) { // pin 0 &amp; pin 1 are reserved for RX/TX&#xD;&#xA;        // return RS485 transceiver to transmit mode&#xD;&#xA;        pinMode(u8txenpin, OUTPUT);&#xD;&#xA;        digitalWrite(u8txenpin, LOW);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      port-&gt;flush();&#xD;&#xA;      u8lastRec = u8BufferSize = 0;&#xD;&#xA;      u16InCnt = u16OutCnt = u16errCnt = 0;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::begin() {&#xD;&#xA;      begin(19200);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void Modbus::setID( uint8_t u8id) {&#xD;&#xA;      if (( u8id != 0) &amp;&amp; (u8id &lt;= 247)) {&#xD;&#xA;        this-&gt;u8id = u8id;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::getID() {&#xD;&#xA;      return this-&gt;u8id;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::setTimeOut( uint16_t u16timeOut) {&#xD;&#xA;      this-&gt;u16timeOut = u16timeOut;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    boolean Modbus::getTimeOutState() {&#xD;&#xA;      return (millis() &gt; u32timeOut);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getInCnt() {&#xD;&#xA;      return u16InCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getOutCnt() {&#xD;&#xA;      return u16OutCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getErrCnt() {&#xD;&#xA;      return u16errCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::getState() {&#xD;&#xA;      return u8state;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::query( modbus_t telegram ) {&#xD;&#xA;      uint8_t u8regsno, u8bytesno;&#xD;&#xA;      if (u8id != 0) return -2;&#xD;&#xA;      if (u8state != COM_IDLE) return -1;&#xD;&#xA;    &#xD;&#xA;      if ((telegram.u8id == 0) || (telegram.u8id &gt; 247)) return -3;&#xD;&#xA;    &#xD;&#xA;      au16regs = telegram.au16reg;&#xD;&#xA;    &#xD;&#xA;      // telegram header&#xD;&#xA;      au8Buffer[ ID ]         = telegram.u8id;&#xD;&#xA;      au8Buffer[ FUNC ]       = telegram.u8fct;&#xD;&#xA;      au8Buffer[ ADD_HI ]     = highByte(telegram.u16RegAdd );&#xD;&#xA;      au8Buffer[ ADD_LO ]     = lowByte( telegram.u16RegAdd );&#xD;&#xA;    &#xD;&#xA;      switch ( telegram.u8fct ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;      case MB_FC_READ_REGISTERS:&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        au8Buffer[ NB_HI ]      = ((au16regs[0] &gt; 0) ? 0xff : 0);&#xD;&#xA;        au8Buffer[ NB_LO ]      = 0;&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(au16regs[0]);&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte(au16regs[0]);&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        u8regsno = telegram.u16CoilsNo / 16;&#xD;&#xA;        u8bytesno = u8regsno * 2;&#xD;&#xA;        if ((telegram.u16CoilsNo % 16) != 0) {&#xD;&#xA;          u8bytesno++;&#xD;&#xA;          u8regsno++;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO + 1 ]    = u8bytesno;&#xD;&#xA;        u8BufferSize = 7;&#xD;&#xA;    &#xD;&#xA;        u8regsno = u8bytesno = 0; // now auxiliary registers&#xD;&#xA;        for (uint16_t i = 0; i &lt; telegram.u16CoilsNo; i++) {&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;        break;&#xD;&#xA;    &#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO + 1 ]    = (uint8_t) ( telegram.u16CoilsNo * 2 );&#xD;&#xA;        u8BufferSize = 7;&#xD;&#xA;    &#xD;&#xA;        for (uint16_t i = 0; i &lt; telegram.u16CoilsNo; i++) {&#xD;&#xA;          au8Buffer[ u8BufferSize ] = highByte( au16regs[ i ] );&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;          au8Buffer[ u8BufferSize ] = lowByte( au16regs[ i ] );&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;        }&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      u8state = COM_WAITING;&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::poll() {&#xD;&#xA;      // check if there is any incoming frame&#xD;&#xA;      uint8_t u8current = port-&gt;available();&#xD;&#xA;    &#xD;&#xA;      if (millis() &gt; u32timeOut) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      if (u8current == 0) return 0;&#xD;&#xA;    &#xD;&#xA;      // check T35 after frame end or still no frame end&#xD;&#xA;      if (u8current != u8lastRec) {&#xD;&#xA;        u8lastRec = u8current;&#xD;&#xA;        u32time = millis() + T35;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;      if (millis() &lt; u32time) return 0;&#xD;&#xA;    &#xD;&#xA;      // transfer Serial buffer frame to auBuffer&#xD;&#xA;      u8lastRec = 0;&#xD;&#xA;      int8_t i8state = getRxBuffer();&#xD;&#xA;      if (i8state &lt; 7) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return i8state;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // validate message: id, CRC, FCT, exception&#xD;&#xA;      uint8_t u8exception = validateAnswer();&#xD;&#xA;      if (u8exception != 0) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        return u8exception;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // process answer&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;        // call get_FC1 to transfer the incoming message to au16regs buffer&#xD;&#xA;        get_FC1( );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;        // call get_FC3 to transfer the incoming message to au16regs buffer&#xD;&#xA;        get_FC3( );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        // nothing to do&#xD;&#xA;        break;&#xD;&#xA;      default:&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      u8state = COM_IDLE;&#xD;&#xA;      return u8BufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::poll( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      au16regs = regs;&#xD;&#xA;      u8regsize = u8size;&#xD;&#xA;    &#xD;&#xA;      // check if there is any incoming frame&#xD;&#xA;      uint8_t u8current = port-&gt;available();&#xD;&#xA;      if (u8current == 0) return 0;&#xD;&#xA;    &#xD;&#xA;      // check T35 after frame end or still no frame end&#xD;&#xA;      if (u8current != u8lastRec) {&#xD;&#xA;        u8lastRec = u8current;&#xD;&#xA;        u32time = millis() + T35;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;      if (millis() &lt; u32time) return 0;&#xD;&#xA;    &#xD;&#xA;      u8lastRec = 0;&#xD;&#xA;      int8_t i8state = getRxBuffer();&#xD;&#xA;      if (i8state &lt; 7) return i8state;&#xD;&#xA;    &#xD;&#xA;      // check slave id&#xD;&#xA;      if (au8Buffer[ ID ] != u8id) return 0;&#xD;&#xA;    &#xD;&#xA;      // validate message: CRC, FCT, address and size&#xD;&#xA;      uint8_t u8exception = validateRequest();&#xD;&#xA;      if (u8exception &gt; 0) {&#xD;&#xA;        if (u8exception != NO_REPLY) {&#xD;&#xA;          buildException( u8exception );&#xD;&#xA;          sendTxBuffer();&#xD;&#xA;        }&#xD;&#xA;        return u8exception;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      u32timeOut = millis() + long(u16timeOut);&#xD;&#xA;    &#xD;&#xA;      // process message&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;        return process_FC1( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;        return process_FC3( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        return process_FC5( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;        return process_FC6( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        return process_FC15( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        return process_FC16( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      default:&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /* _____PRIVATE FUNCTIONS_____________________________________________________ */&#xD;&#xA;    &#xD;&#xA;    void Modbus::init(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin) {&#xD;&#xA;      this-&gt;u8id = u8id;&#xD;&#xA;      this-&gt;u8serno = (u8serno &gt; 3) ? 0 : u8serno;&#xD;&#xA;      this-&gt;u8txenpin = u8txenpin;&#xD;&#xA;      this-&gt;u16timeOut = 1000;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::getRxBuffer() {&#xD;&#xA;      boolean bBuffOverflow = false;&#xD;&#xA;    &#xD;&#xA;      if (u8txenpin &gt; 1) digitalWrite( u8txenpin, LOW );&#xD;&#xA;    &#xD;&#xA;      u8BufferSize = 0;&#xD;&#xA;      while ( port-&gt;available() ) {&#xD;&#xA;        au8Buffer[ u8BufferSize ] = port-&gt;read();&#xD;&#xA;        u8BufferSize ++;&#xD;&#xA;    &#xD;&#xA;        if (u8BufferSize &gt;= MAX_BUFFER) bBuffOverflow = true;&#xD;&#xA;      }&#xD;&#xA;      u16InCnt++;&#xD;&#xA;    &#xD;&#xA;      if (bBuffOverflow) {&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return ERR_BUFF_OVERFLOW;&#xD;&#xA;      }&#xD;&#xA;      return u8BufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::sendTxBuffer() {&#xD;&#xA;      uint8_t i = 0;&#xD;&#xA;    &#xD;&#xA;      // append CRC to message&#xD;&#xA;      uint16_t u16crc = calcCRC( u8BufferSize );&#xD;&#xA;      au8Buffer[ u8BufferSize ] = u16crc &gt;&gt; 8;&#xD;&#xA;      u8BufferSize++;&#xD;&#xA;      au8Buffer[ u8BufferSize ] = u16crc &amp; 0x00ff;&#xD;&#xA;      u8BufferSize++;&#xD;&#xA;    &#xD;&#xA;      // set RS485 transceiver to transmit mode&#xD;&#xA;      if (u8txenpin &gt; 1) {&#xD;&#xA;        switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;        case 1:&#xD;&#xA;          UCSR1A = UCSR1A | (1 &lt;&lt; TXC1);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;        case 2:&#xD;&#xA;          UCSR2A = UCSR2A | (1 &lt;&lt; TXC2);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;        case 3:&#xD;&#xA;          UCSR3A = UCSR3A | (1 &lt;&lt; TXC3);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;        case 0:&#xD;&#xA;        default:&#xD;&#xA;          UCSR0A = UCSR0A | (1 &lt;&lt; TXC0);&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;        digitalWrite( u8txenpin, HIGH );&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // transfer buffer to serial line&#xD;&#xA;      port-&gt;write( au8Buffer, u8BufferSize );&#xD;&#xA;    &#xD;&#xA;      // keep RS485 transceiver in transmit mode as long as sending&#xD;&#xA;      if (u8txenpin &gt; 1) {&#xD;&#xA;        switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;        case 1:&#xD;&#xA;          while (!(UCSR1A &amp; (1 &lt;&lt; TXC1)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;        case 2:&#xD;&#xA;          while (!(UCSR2A &amp; (1 &lt;&lt; TXC2)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;        case 3:&#xD;&#xA;          while (!(UCSR3A &amp; (1 &lt;&lt; TXC3)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;        case 0:&#xD;&#xA;        default:&#xD;&#xA;          while (!(UCSR0A &amp; (1 &lt;&lt; TXC0)));&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        // return RS485 transceiver to receive mode&#xD;&#xA;        digitalWrite( u8txenpin, LOW );&#xD;&#xA;      }&#xD;&#xA;      port-&gt;flush();&#xD;&#xA;      u8BufferSize = 0;&#xD;&#xA;    &#xD;&#xA;      // set time-out for master&#xD;&#xA;      u32timeOut = millis() + (unsigned long) u16timeOut;&#xD;&#xA;    &#xD;&#xA;      // increase message counter&#xD;&#xA;      u16OutCnt++;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /**&#xD;&#xA;     * @brief&#xD;&#xA;     * This method calculates CRC&#xD;&#xA;     *&#xD;&#xA;     * @return uint16_t calculated CRC value for the message&#xD;&#xA;     * @ingroup buffer&#xD;&#xA;     */&#xD;&#xA;    uint16_t Modbus::calcCRC(uint8_t u8length) {&#xD;&#xA;      unsigned int temp, temp2, flag;&#xD;&#xA;      temp = 0xFFFF;&#xD;&#xA;      for (unsigned char i = 0; i &lt; u8length; i++) {&#xD;&#xA;        temp = temp ^ au8Buffer[i];&#xD;&#xA;        for (unsigned char j = 1; j &lt;= 8; j++) {&#xD;&#xA;          flag = temp &amp; 0x0001;&#xD;&#xA;          temp &gt;&gt;= 1;&#xD;&#xA;          if (flag)&#xD;&#xA;            temp ^= 0xA001;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      // Reverse byte order.&#xD;&#xA;      temp2 = temp &gt;&gt; 8;&#xD;&#xA;      temp = (temp &lt;&lt; 8) | temp2;&#xD;&#xA;      temp &amp;= 0xFFFF;&#xD;&#xA;      // the returned value is already swapped&#xD;&#xA;      // crcLo byte is first &amp; crcHi byte is last&#xD;&#xA;      return temp;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::validateRequest() {&#xD;&#xA;      // check message crc vs calculated crc&#xD;&#xA;      uint16_t u16MsgCRC =&#xD;&#xA;        ((au8Buffer[u8BufferSize - 2] &lt;&lt; 8)&#xD;&#xA;        | au8Buffer[u8BufferSize - 1]); // combine the crc Low &amp; High bytes&#xD;&#xA;      if ( calcCRC( u8BufferSize - 2 ) != u16MsgCRC ) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return NO_REPLY;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check fct code&#xD;&#xA;      boolean isSupported = false;&#xD;&#xA;      for (uint8_t i = 0; i &lt; sizeof( fctsupported ); i++) {&#xD;&#xA;        if (fctsupported[i] == au8Buffer[FUNC]) {&#xD;&#xA;          isSupported = 1;&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      if (!isSupported) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return EXC_FUNC_CODE;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check start address &amp; nb range&#xD;&#xA;      uint16_t u16regs = 0;&#xD;&#xA;      uint8_t u8regs;&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]) / 16;&#xD;&#xA;        u16regs += word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ]) / 16;&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]) / 16;&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]);&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER :&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]);&#xD;&#xA;        u16regs += word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ]);&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      return 0; // OK, no exception code thrown&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::validateAnswer() {&#xD;&#xA;      // check message crc vs calculated crc&#xD;&#xA;      uint16_t u16MsgCRC =&#xD;&#xA;        ((au8Buffer[u8BufferSize - 2] &lt;&lt; 8)&#xD;&#xA;        | au8Buffer[u8BufferSize - 1]); // combine the crc Low &amp; High bytes&#xD;&#xA;      if ( calcCRC( u8BufferSize - 2 ) != u16MsgCRC ) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return NO_REPLY;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check exception&#xD;&#xA;      if ((au8Buffer[ FUNC ] &amp; 0x80) != 0) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return ERR_EXCEPTION;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check fct code&#xD;&#xA;      boolean isSupported = false;&#xD;&#xA;      for (uint8_t i = 0; i &lt; sizeof( fctsupported ); i++) {&#xD;&#xA;        if (fctsupported[i] == au8Buffer[FUNC]) {&#xD;&#xA;          isSupported = 1;&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      if (!isSupported) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return EXC_FUNC_CODE;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      return 0; // OK, no exception code thrown&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::buildException( uint8_t u8exception ) {&#xD;&#xA;      uint8_t u8func = au8Buffer[ FUNC ];  // get the original FUNC code&#xD;&#xA;    &#xD;&#xA;      au8Buffer[ ID ]      = u8id;&#xD;&#xA;      au8Buffer[ FUNC ]    = u8func + 0x80;&#xD;&#xA;      au8Buffer[ 2 ]       = u8exception;&#xD;&#xA;      u8BufferSize         = EXCEPTION_SIZE;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::get_FC1() {&#xD;&#xA;      uint8_t u8byte, i;&#xD;&#xA;      u8byte = 0;&#xD;&#xA;    &#xD;&#xA;      // check the answer length&#xD;&#xA;      boolean bEvenOdd =&#xD;&#xA;        ( au8Buffer[ ADD_HI ] % 2 == 0) ?&#xD;&#xA;      false :&#xD;&#xA;      true;&#xD;&#xA;    &#xD;&#xA;      uint8_t u8WordsNo =&#xD;&#xA;        ( !bEvenOdd ) ?&#xD;&#xA;      au8Buffer[ ADD_HI ] / 2 :&#xD;&#xA;      au8Buffer[ ADD_HI ] / 2 + 1;&#xD;&#xA;    &#xD;&#xA;      for (i = 0; i &lt; u8WordsNo; i++) {&#xD;&#xA;        au16regs[ i ] = word(&#xD;&#xA;        au8Buffer[ u8byte ],&#xD;&#xA;        au8Buffer[ u8byte + 1 ]);&#xD;&#xA;        u8byte += 2;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // cut last byte&#xD;&#xA;      if (bEvenOdd) {&#xD;&#xA;        au16regs[ u8WordsNo - 1 ] &amp;= 0xff00;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void Modbus::get_FC3() {&#xD;&#xA;      uint8_t u8byte, i;&#xD;&#xA;      u8byte = 3;&#xD;&#xA;    &#xD;&#xA;      for (i = 0; i &lt; au8Buffer[ 2 ] / 2; i++) {&#xD;&#xA;        au16regs[ i ] = word(&#xD;&#xA;        au8Buffer[ u8byte ],&#xD;&#xA;        au8Buffer[ u8byte + 1 ]);&#xD;&#xA;        u8byte += 2;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC1( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit, u8bytesno, u8bitsno;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16currentCoil, u16coil;&#xD;&#xA;    &#xD;&#xA;      // get the first and last coil from the message&#xD;&#xA;      uint16_t u16StartCoil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint16_t u16Coilno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;      // put the number of bytes in the outcoming message&#xD;&#xA;      u8bytesno = (uint8_t) (u16Coilno / 8);&#xD;&#xA;      if (u16Coilno % 8 != 0) u8bytesno ++;&#xD;&#xA;      au8Buffer[ ADD_HI ]  = u8bytesno;&#xD;&#xA;      u8BufferSize         = ADD_LO;&#xD;&#xA;    &#xD;&#xA;      // read each coil from the register map and put its value inside the outcoming message&#xD;&#xA;      u8bitsno = 0;&#xD;&#xA;    &#xD;&#xA;      for (u16currentCoil = 0; u16currentCoil &lt; u16Coilno; u16currentCoil++) {&#xD;&#xA;        u16coil = u16StartCoil + u16currentCoil;&#xD;&#xA;        u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;        u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;        bitWrite(&#xD;&#xA;        au8Buffer[ u8BufferSize ],&#xD;&#xA;        u8bitsno,&#xD;&#xA;        bitRead( regs[ u8currentRegister ], u8currentBit ) );&#xD;&#xA;        u8bitsno ++;&#xD;&#xA;    &#xD;&#xA;        if (u8bitsno &gt; 7) {&#xD;&#xA;          u8bitsno = 0;&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // send outcoming message&#xD;&#xA;      if (u16Coilno % 8 != 0) u8BufferSize ++;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC3( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      uint8_t u8StartAdd = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint8_t u8regsno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint8_t i;&#xD;&#xA;    &#xD;&#xA;      au8Buffer[ 2 ]       = u8regsno * 2;&#xD;&#xA;      u8BufferSize         = 3;&#xD;&#xA;    &#xD;&#xA;      for (i = u8StartAdd; i &lt; u8StartAdd + u8regsno; i++) {&#xD;&#xA;        au8Buffer[ u8BufferSize ] = highByte(regs[i]);&#xD;&#xA;        u8BufferSize++;&#xD;&#xA;        au8Buffer[ u8BufferSize ] = lowByte(regs[i]);&#xD;&#xA;        u8BufferSize++;&#xD;&#xA;      }&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC5( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16coil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;    &#xD;&#xA;      // point to the register and its bit&#xD;&#xA;      u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;      u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;      // write to coil&#xD;&#xA;      bitWrite(&#xD;&#xA;      regs[ u8currentRegister ],&#xD;&#xA;      u8currentBit,&#xD;&#xA;      au8Buffer[ NB_HI ] == 0xff );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // send answer to master&#xD;&#xA;      u8BufferSize = 6;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC6( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      uint8_t u8add = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16val = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;      regs[ u8add ] = u16val;&#xD;&#xA;    &#xD;&#xA;      // keep the same header&#xD;&#xA;      u8BufferSize         = RESPONSE_SIZE;&#xD;&#xA;    &#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC15( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit, u8frameByte, u8bitsno;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16currentCoil, u16coil;&#xD;&#xA;      boolean bTemp;&#xD;&#xA;    &#xD;&#xA;      // get the first and last coil from the message&#xD;&#xA;      uint16_t u16StartCoil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint16_t u16Coilno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // read each coil from the register map and put its value inside the outcoming message&#xD;&#xA;      u8bitsno = 0;&#xD;&#xA;      u8frameByte = 7;&#xD;&#xA;      for (u16currentCoil = 0; u16currentCoil &lt; u16Coilno; u16currentCoil++) {&#xD;&#xA;    &#xD;&#xA;        u16coil = u16StartCoil + u16currentCoil;&#xD;&#xA;        u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;        u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;        bTemp = bitRead(&#xD;&#xA;        au8Buffer[ u8frameByte ],&#xD;&#xA;        u8bitsno );&#xD;&#xA;    &#xD;&#xA;        bitWrite(&#xD;&#xA;        regs[ u8currentRegister ],&#xD;&#xA;        u8currentBit,&#xD;&#xA;        bTemp );&#xD;&#xA;    &#xD;&#xA;        u8bitsno ++;&#xD;&#xA;    &#xD;&#xA;        if (u8bitsno &gt; 7) {&#xD;&#xA;          u8bitsno = 0;&#xD;&#xA;          u8frameByte++;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // send outcoming message&#xD;&#xA;      // it's just a copy of the incomping frame until 6th byte&#xD;&#xA;      u8BufferSize         = 6;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC16( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8func = au8Buffer[ FUNC ];  // get the original FUNC code&#xD;&#xA;      uint8_t u8StartAdd = au8Buffer[ ADD_HI ] &lt;&lt; 8 | au8Buffer[ ADD_LO ];&#xD;&#xA;      uint8_t u8regsno = au8Buffer[ NB_HI ] &lt;&lt; 8 | au8Buffer[ NB_LO ];&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint8_t i;&#xD;&#xA;      uint16_t temp;&#xD;&#xA;    &#xD;&#xA;      // build header&#xD;&#xA;      au8Buffer[ NB_HI ]   = 0;&#xD;&#xA;      au8Buffer[ NB_LO ]   = u8regsno;&#xD;&#xA;      u8BufferSize         = RESPONSE_SIZE;&#xD;&#xA;    &#xD;&#xA;      // write registers&#xD;&#xA;      for (i = 0; i &lt; u8regsno; i++) {&#xD;&#xA;        temp = word(&#xD;&#xA;        au8Buffer[ (BYTE_CNT + 1) + i * 2 ],&#xD;&#xA;        au8Buffer[ (BYTE_CNT + 2) + i * 2 ]);&#xD;&#xA;    &#xD;&#xA;        regs[ u8StartAdd + i ] = temp;&#xD;&#xA;      }&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/eglU2.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/9ku4w.jpg" />
  <row Id="3052" PostHistoryTypeId="1" PostId="1083" RevisionGUID="cff16970-16d7-4caa-8293-639d36d77de5" CreationDate="2014-04-04T09:21:24.980" UserId="904" Text="Response of Modbus Protocol" />
  <row Id="3053" PostHistoryTypeId="3" PostId="1083" RevisionGUID="cff16970-16d7-4caa-8293-639d36d77de5" CreationDate="2014-04-04T09:21:24.980" UserId="904" Text="&lt;arduino-uno&gt;&lt;programming&gt;&lt;modbus&gt;" />
  <row Id="3054" PostHistoryTypeId="5" PostId="1083" RevisionGUID="a48db0fd-ebde-42c9-8a66-02a6db14ac84" CreationDate="2014-04-04T09:24:40.900" UserId="42" Comment="Fixed formatting and a couple of minor typos" Text="I have below code . This code is successfully compiled and uploaded, But i am not getting any response from Slave. Let me know what i need to do.&#xD;&#xA;&#xD;&#xA;![Error message][1]&#xD;&#xA;![Connection diagram][2]&#xD;&#xA;&#xD;&#xA;My main code&#xD;&#xA;&#xD;&#xA;    #define ID  1&#xD;&#xA;    /*static float ARDUINO_ANALOG_SCALING = 0.00488758;&#xD;&#xA;    static float Ydegree;&#xD;&#xA;    static int Sensor_Value;&#xD;&#xA;    float Yvoltage;&#xD;&#xA;    &#xD;&#xA;    */&#xD;&#xA;    &#xD;&#xA;    Modbus slave(ID, 0, 0);&#xD;&#xA;    boolean led;&#xD;&#xA;    int8_t state = 0;&#xD;&#xA;    unsigned long tempus;&#xD;&#xA;    // data array for modbus network sharing&#xD;&#xA;    uint16_t au16data[9];&#xD;&#xA;    float latitude=13.08;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      pinMode(13, OUTPUT);&#xD;&#xA;      slave.begin( 19200 );&#xD;&#xA;      tempus = millis() + 100;&#xD;&#xA;      digitalWrite(13, HIGH );&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      &#xD;&#xA;      state = slave.poll( au16data, 9 );&#xD;&#xA;      if (state &gt; 4) {&#xD;&#xA;        tempus = millis() + 50;&#xD;&#xA;        digitalWrite(13, HIGH);&#xD;&#xA;      }&#xD;&#xA;      if (millis() &gt; tempus) digitalWrite(13, LOW );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      au16data[4] = analogRead(0);&#xD;&#xA;      au16data[5] = analogRead(1);&#xD;&#xA;    &#xD;&#xA;      &#xD;&#xA;     &#xD;&#xA;      au16data[6] = slave.getInCnt();&#xD;&#xA;      au16data[7] = slave.getOutCnt();&#xD;&#xA;      au16data[8] = slave.getErrCnt();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Modbus code&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #define  MAX_BUFFER  64	&#xD;&#xA;    typedef struct {&#xD;&#xA;      uint8_t u8id;          /*!&lt; slave address between 1 and 247. 0 means broadcast */&#xD;&#xA;      uint8_t u8fct;         /*!&lt; function code: 1, 2, 3, 4, 5, 6, 15 or 16 */&#xD;&#xA;      uint16_t u16RegAdd;    /*!&lt; address of the first register to access at slave/s */&#xD;&#xA;      uint16_t u16CoilsNo;   /*!&lt; number of coils or registers to access */&#xD;&#xA;      uint16_t *au16reg;     /*!&lt; pointer to memory image in master */&#xD;&#xA;    }&#xD;&#xA;    modbus_t;&#xD;&#xA;    &#xD;&#xA;    enum {&#xD;&#xA;      RESPONSE_SIZE = 6,&#xD;&#xA;      EXCEPTION_SIZE = 3,&#xD;&#xA;      CHECKSUM_SIZE = 2&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum MESSAGE {&#xD;&#xA;      ID = 0,&#xD;&#xA;      FUNC,&#xD;&#xA;      ADD_HI,&#xD;&#xA;      ADD_LO,&#xD;&#xA;      NB_HI,&#xD;&#xA;      NB_LO,&#xD;&#xA;      BYTE_CNT&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum MB_FC {&#xD;&#xA;      MB_FC_NONE                     = 0,   /*!&lt; null operator */&#xD;&#xA;      MB_FC_READ_COILS               = 1,	/*!&lt; FCT=1 -&gt; read coils or digital outputs */&#xD;&#xA;      MB_FC_READ_DISCRETE_INPUT      = 2,	/*!&lt; FCT=2 -&gt; read digital inputs */&#xD;&#xA;      MB_FC_READ_REGISTERS           = 3,	/*!&lt; FCT=3 -&gt; read registers or analog outputs */&#xD;&#xA;      MB_FC_READ_INPUT_REGISTER      = 4,	/*!&lt; FCT=4 -&gt; read analog inputs */&#xD;&#xA;      MB_FC_WRITE_COIL               = 5,	/*!&lt; FCT=5 -&gt; write single coil or output */&#xD;&#xA;      MB_FC_WRITE_REGISTER           = 6,	/*!&lt; FCT=6 -&gt; write single register */&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_COILS     = 15,	/*!&lt; FCT=15 -&gt; write multiple coils or outputs */&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_REGISTERS = 16	/*!&lt; FCT=16 -&gt; write multiple registers */&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum COM_STATES {&#xD;&#xA;      COM_IDLE                     = 0,&#xD;&#xA;      COM_WAITING                  = 1&#xD;&#xA;    &#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum ERR_LIST {&#xD;&#xA;      ERR_NOT_MASTER                = -1,&#xD;&#xA;      ERR_POLLING                   = -2,&#xD;&#xA;      ERR_BUFF_OVERFLOW             = -3,&#xD;&#xA;      ERR_BAD_CRC                   = -4,&#xD;&#xA;      ERR_EXCEPTION                 = -5&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    enum {&#xD;&#xA;      NO_REPLY = 255, 			/*!&lt; */&#xD;&#xA;      EXC_FUNC_CODE = 1,		/*!&lt; Function code not available */&#xD;&#xA;      EXC_ADDR_RANGE = 2, 		/*!&lt; Address beyond available space for Modbus registers */&#xD;&#xA;      EXC_REGS_QUANT = 3,  		/*!&lt; Coils or registers number beyond the available space */&#xD;&#xA;      EXC_EXECUTE = 4 			/*!&lt; */&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    const unsigned char fctsupported[] = {&#xD;&#xA;      MB_FC_READ_COILS,&#xD;&#xA;      MB_FC_READ_DISCRETE_INPUT,&#xD;&#xA;      MB_FC_READ_REGISTERS,&#xD;&#xA;      MB_FC_READ_INPUT_REGISTER,&#xD;&#xA;      MB_FC_WRITE_COIL,&#xD;&#xA;      MB_FC_WRITE_REGISTER,&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_COILS,&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_REGISTERS&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    #define T35  5&#xD;&#xA;    &#xD;&#xA;    class Modbus {&#xD;&#xA;    private:&#xD;&#xA;      HardwareSerial *port; //!&lt; Pointer to Serial class object&#xD;&#xA;      uint8_t u8id; //!&lt;0=master, 1..247=slave number&#xD;&#xA;      uint8_t u8serno; //!&lt;serial port: 0-Serial, 1..3-Serial1..Serial3&#xD;&#xA;      uint8_t u8txenpin; //!&lt;flow control pin: 0=USB or RS-232 mode, &gt;0=RS-485 mode&#xD;&#xA;      uint8_t u8state;&#xD;&#xA;      uint8_t au8Buffer[MAX_BUFFER];&#xD;&#xA;      uint8_t u8BufferSize;&#xD;&#xA;      uint8_t u8lastRec;&#xD;&#xA;      uint16_t *au16regs;&#xD;&#xA;      uint16_t u16InCnt, u16OutCnt, u16errCnt;&#xD;&#xA;      uint16_t u16timeOut;&#xD;&#xA;      uint32_t u32time, u32timeOut;&#xD;&#xA;      uint8_t u8regsize;&#xD;&#xA;    &#xD;&#xA;      void init(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin);&#xD;&#xA;      void sendTxBuffer(); // transmit buffer to serial port&#xD;&#xA;      int8_t getRxBuffer(); // get serial buffer contents&#xD;&#xA;      uint16_t calcCRC(uint8_t u8length); // get CRC from au8Buffer until u8length&#xD;&#xA;      uint8_t validateAnswer();&#xD;&#xA;      uint8_t validateRequest(); // validate master request&#xD;&#xA;      void get_FC1(); // *** only master ***&#xD;&#xA;      void get_FC3(); // *** only master ***&#xD;&#xA;      int8_t process_FC1( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC3( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC5( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC6( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC15( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC16( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      void buildException( uint8_t u8exception ); // build exception message&#xD;&#xA;    &#xD;&#xA;    public:&#xD;&#xA;      Modbus(); // !&lt; Default Constructor&#xD;&#xA;      Modbus(uint8_t u8id, uint8_t u8serno); // !&lt; Constructor&#xD;&#xA;      Modbus(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin); // !&lt; Full Constructor&#xD;&#xA;      void begin(long u32speed);&#xD;&#xA;      void begin();&#xD;&#xA;      void setTimeOut( uint16_t u16timeout); //!&lt; write communication watch-dog timer&#xD;&#xA;      uint16_t getTimeOut(); //!&lt; get communication watch-dog timer value&#xD;&#xA;      boolean getTimeOutState(); //!&lt; get communication watch-dog timer state&#xD;&#xA;      int8_t query( modbus_t telegram ); //!&lt; only for master&#xD;&#xA;      int8_t poll(); //!&lt; cyclic poll for master&#xD;&#xA;      int8_t poll( uint16_t *regs, uint8_t u8size ); //!&lt; cyclic poll for slave&#xD;&#xA;      uint16_t getInCnt(); //!&lt; number of incoming messages&#xD;&#xA;      uint16_t getOutCnt(); //!&lt; number of outcoming messages&#xD;&#xA;      uint16_t getErrCnt(); //!&lt; error counter&#xD;&#xA;      uint8_t getID(); //!&lt; get slave ID between 1 and 247&#xD;&#xA;      uint8_t getState();&#xD;&#xA;      uint8_t getLastError(); //!&lt; get last error message&#xD;&#xA;      void setID( uint8_t u8id ); //!&lt; write new ID for the slave&#xD;&#xA;      void end(); //!&lt; finish any communication and release serial communication port&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus() {&#xD;&#xA;      init(0, 0, 0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus(uint8_t u8id, uint8_t u8serno) {&#xD;&#xA;      init(u8id, u8serno, 0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin) {&#xD;&#xA;      init(u8id, u8serno, u8txenpin);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::begin(long u32speed) {&#xD;&#xA;    &#xD;&#xA;      switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;      case 1:&#xD;&#xA;        port = &amp;Serial1;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;      case 2:&#xD;&#xA;        port = &amp;Serial2;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;      case 3:&#xD;&#xA;        port = &amp;Serial3;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;      case 0:&#xD;&#xA;      default:&#xD;&#xA;        port = &amp;Serial;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // port-&gt;begin(u32speed, u8config);&#xD;&#xA;      port-&gt;begin(u32speed);&#xD;&#xA;      if (u8txenpin &gt; 1) { // pin 0 &amp; pin 1 are reserved for RX/TX&#xD;&#xA;        // return RS485 transceiver to transmit mode&#xD;&#xA;        pinMode(u8txenpin, OUTPUT);&#xD;&#xA;        digitalWrite(u8txenpin, LOW);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      port-&gt;flush();&#xD;&#xA;      u8lastRec = u8BufferSize = 0;&#xD;&#xA;      u16InCnt = u16OutCnt = u16errCnt = 0;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::begin() {&#xD;&#xA;      begin(19200);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void Modbus::setID( uint8_t u8id) {&#xD;&#xA;      if (( u8id != 0) &amp;&amp; (u8id &lt;= 247)) {&#xD;&#xA;        this-&gt;u8id = u8id;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::getID() {&#xD;&#xA;      return this-&gt;u8id;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::setTimeOut( uint16_t u16timeOut) {&#xD;&#xA;      this-&gt;u16timeOut = u16timeOut;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    boolean Modbus::getTimeOutState() {&#xD;&#xA;      return (millis() &gt; u32timeOut);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getInCnt() {&#xD;&#xA;      return u16InCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getOutCnt() {&#xD;&#xA;      return u16OutCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getErrCnt() {&#xD;&#xA;      return u16errCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::getState() {&#xD;&#xA;      return u8state;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::query( modbus_t telegram ) {&#xD;&#xA;      uint8_t u8regsno, u8bytesno;&#xD;&#xA;      if (u8id != 0) return -2;&#xD;&#xA;      if (u8state != COM_IDLE) return -1;&#xD;&#xA;    &#xD;&#xA;      if ((telegram.u8id == 0) || (telegram.u8id &gt; 247)) return -3;&#xD;&#xA;    &#xD;&#xA;      au16regs = telegram.au16reg;&#xD;&#xA;    &#xD;&#xA;      // telegram header&#xD;&#xA;      au8Buffer[ ID ]         = telegram.u8id;&#xD;&#xA;      au8Buffer[ FUNC ]       = telegram.u8fct;&#xD;&#xA;      au8Buffer[ ADD_HI ]     = highByte(telegram.u16RegAdd );&#xD;&#xA;      au8Buffer[ ADD_LO ]     = lowByte( telegram.u16RegAdd );&#xD;&#xA;    &#xD;&#xA;      switch ( telegram.u8fct ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;      case MB_FC_READ_REGISTERS:&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        au8Buffer[ NB_HI ]      = ((au16regs[0] &gt; 0) ? 0xff : 0);&#xD;&#xA;        au8Buffer[ NB_LO ]      = 0;&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(au16regs[0]);&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte(au16regs[0]);&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        u8regsno = telegram.u16CoilsNo / 16;&#xD;&#xA;        u8bytesno = u8regsno * 2;&#xD;&#xA;        if ((telegram.u16CoilsNo % 16) != 0) {&#xD;&#xA;          u8bytesno++;&#xD;&#xA;          u8regsno++;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO + 1 ]    = u8bytesno;&#xD;&#xA;        u8BufferSize = 7;&#xD;&#xA;    &#xD;&#xA;        u8regsno = u8bytesno = 0; // now auxiliary registers&#xD;&#xA;        for (uint16_t i = 0; i &lt; telegram.u16CoilsNo; i++) {&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;        break;&#xD;&#xA;    &#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO + 1 ]    = (uint8_t) ( telegram.u16CoilsNo * 2 );&#xD;&#xA;        u8BufferSize = 7;&#xD;&#xA;    &#xD;&#xA;        for (uint16_t i = 0; i &lt; telegram.u16CoilsNo; i++) {&#xD;&#xA;          au8Buffer[ u8BufferSize ] = highByte( au16regs[ i ] );&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;          au8Buffer[ u8BufferSize ] = lowByte( au16regs[ i ] );&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;        }&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      u8state = COM_WAITING;&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::poll() {&#xD;&#xA;      // check if there is any incoming frame&#xD;&#xA;      uint8_t u8current = port-&gt;available();&#xD;&#xA;    &#xD;&#xA;      if (millis() &gt; u32timeOut) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      if (u8current == 0) return 0;&#xD;&#xA;    &#xD;&#xA;      // check T35 after frame end or still no frame end&#xD;&#xA;      if (u8current != u8lastRec) {&#xD;&#xA;        u8lastRec = u8current;&#xD;&#xA;        u32time = millis() + T35;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;      if (millis() &lt; u32time) return 0;&#xD;&#xA;    &#xD;&#xA;      // transfer Serial buffer frame to auBuffer&#xD;&#xA;      u8lastRec = 0;&#xD;&#xA;      int8_t i8state = getRxBuffer();&#xD;&#xA;      if (i8state &lt; 7) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return i8state;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // validate message: id, CRC, FCT, exception&#xD;&#xA;      uint8_t u8exception = validateAnswer();&#xD;&#xA;      if (u8exception != 0) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        return u8exception;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // process answer&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;        // call get_FC1 to transfer the incoming message to au16regs buffer&#xD;&#xA;        get_FC1( );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;        // call get_FC3 to transfer the incoming message to au16regs buffer&#xD;&#xA;        get_FC3( );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        // nothing to do&#xD;&#xA;        break;&#xD;&#xA;      default:&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      u8state = COM_IDLE;&#xD;&#xA;      return u8BufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::poll( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      au16regs = regs;&#xD;&#xA;      u8regsize = u8size;&#xD;&#xA;    &#xD;&#xA;      // check if there is any incoming frame&#xD;&#xA;      uint8_t u8current = port-&gt;available();&#xD;&#xA;      if (u8current == 0) return 0;&#xD;&#xA;    &#xD;&#xA;      // check T35 after frame end or still no frame end&#xD;&#xA;      if (u8current != u8lastRec) {&#xD;&#xA;        u8lastRec = u8current;&#xD;&#xA;        u32time = millis() + T35;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;      if (millis() &lt; u32time) return 0;&#xD;&#xA;    &#xD;&#xA;      u8lastRec = 0;&#xD;&#xA;      int8_t i8state = getRxBuffer();&#xD;&#xA;      if (i8state &lt; 7) return i8state;&#xD;&#xA;    &#xD;&#xA;      // check slave id&#xD;&#xA;      if (au8Buffer[ ID ] != u8id) return 0;&#xD;&#xA;    &#xD;&#xA;      // validate message: CRC, FCT, address and size&#xD;&#xA;      uint8_t u8exception = validateRequest();&#xD;&#xA;      if (u8exception &gt; 0) {&#xD;&#xA;        if (u8exception != NO_REPLY) {&#xD;&#xA;          buildException( u8exception );&#xD;&#xA;          sendTxBuffer();&#xD;&#xA;        }&#xD;&#xA;        return u8exception;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      u32timeOut = millis() + long(u16timeOut);&#xD;&#xA;    &#xD;&#xA;      // process message&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;        return process_FC1( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;        return process_FC3( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        return process_FC5( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;        return process_FC6( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        return process_FC15( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        return process_FC16( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      default:&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /* _____PRIVATE FUNCTIONS_____________________________________________________ */&#xD;&#xA;    &#xD;&#xA;    void Modbus::init(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin) {&#xD;&#xA;      this-&gt;u8id = u8id;&#xD;&#xA;      this-&gt;u8serno = (u8serno &gt; 3) ? 0 : u8serno;&#xD;&#xA;      this-&gt;u8txenpin = u8txenpin;&#xD;&#xA;      this-&gt;u16timeOut = 1000;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::getRxBuffer() {&#xD;&#xA;      boolean bBuffOverflow = false;&#xD;&#xA;    &#xD;&#xA;      if (u8txenpin &gt; 1) digitalWrite( u8txenpin, LOW );&#xD;&#xA;    &#xD;&#xA;      u8BufferSize = 0;&#xD;&#xA;      while ( port-&gt;available() ) {&#xD;&#xA;        au8Buffer[ u8BufferSize ] = port-&gt;read();&#xD;&#xA;        u8BufferSize ++;&#xD;&#xA;    &#xD;&#xA;        if (u8BufferSize &gt;= MAX_BUFFER) bBuffOverflow = true;&#xD;&#xA;      }&#xD;&#xA;      u16InCnt++;&#xD;&#xA;    &#xD;&#xA;      if (bBuffOverflow) {&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return ERR_BUFF_OVERFLOW;&#xD;&#xA;      }&#xD;&#xA;      return u8BufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::sendTxBuffer() {&#xD;&#xA;      uint8_t i = 0;&#xD;&#xA;    &#xD;&#xA;      // append CRC to message&#xD;&#xA;      uint16_t u16crc = calcCRC( u8BufferSize );&#xD;&#xA;      au8Buffer[ u8BufferSize ] = u16crc &gt;&gt; 8;&#xD;&#xA;      u8BufferSize++;&#xD;&#xA;      au8Buffer[ u8BufferSize ] = u16crc &amp; 0x00ff;&#xD;&#xA;      u8BufferSize++;&#xD;&#xA;    &#xD;&#xA;      // set RS485 transceiver to transmit mode&#xD;&#xA;      if (u8txenpin &gt; 1) {&#xD;&#xA;        switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;        case 1:&#xD;&#xA;          UCSR1A = UCSR1A | (1 &lt;&lt; TXC1);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;        case 2:&#xD;&#xA;          UCSR2A = UCSR2A | (1 &lt;&lt; TXC2);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;        case 3:&#xD;&#xA;          UCSR3A = UCSR3A | (1 &lt;&lt; TXC3);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;        case 0:&#xD;&#xA;        default:&#xD;&#xA;          UCSR0A = UCSR0A | (1 &lt;&lt; TXC0);&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;        digitalWrite( u8txenpin, HIGH );&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // transfer buffer to serial line&#xD;&#xA;      port-&gt;write( au8Buffer, u8BufferSize );&#xD;&#xA;    &#xD;&#xA;      // keep RS485 transceiver in transmit mode as long as sending&#xD;&#xA;      if (u8txenpin &gt; 1) {&#xD;&#xA;        switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;        case 1:&#xD;&#xA;          while (!(UCSR1A &amp; (1 &lt;&lt; TXC1)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;        case 2:&#xD;&#xA;          while (!(UCSR2A &amp; (1 &lt;&lt; TXC2)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;        case 3:&#xD;&#xA;          while (!(UCSR3A &amp; (1 &lt;&lt; TXC3)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;        case 0:&#xD;&#xA;        default:&#xD;&#xA;          while (!(UCSR0A &amp; (1 &lt;&lt; TXC0)));&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        // return RS485 transceiver to receive mode&#xD;&#xA;        digitalWrite( u8txenpin, LOW );&#xD;&#xA;      }&#xD;&#xA;      port-&gt;flush();&#xD;&#xA;      u8BufferSize = 0;&#xD;&#xA;    &#xD;&#xA;      // set time-out for master&#xD;&#xA;      u32timeOut = millis() + (unsigned long) u16timeOut;&#xD;&#xA;    &#xD;&#xA;      // increase message counter&#xD;&#xA;      u16OutCnt++;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /**&#xD;&#xA;     * @brief&#xD;&#xA;     * This method calculates CRC&#xD;&#xA;     *&#xD;&#xA;     * @return uint16_t calculated CRC value for the message&#xD;&#xA;     * @ingroup buffer&#xD;&#xA;     */&#xD;&#xA;    uint16_t Modbus::calcCRC(uint8_t u8length) {&#xD;&#xA;      unsigned int temp, temp2, flag;&#xD;&#xA;      temp = 0xFFFF;&#xD;&#xA;      for (unsigned char i = 0; i &lt; u8length; i++) {&#xD;&#xA;        temp = temp ^ au8Buffer[i];&#xD;&#xA;        for (unsigned char j = 1; j &lt;= 8; j++) {&#xD;&#xA;          flag = temp &amp; 0x0001;&#xD;&#xA;          temp &gt;&gt;= 1;&#xD;&#xA;          if (flag)&#xD;&#xA;            temp ^= 0xA001;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      // Reverse byte order.&#xD;&#xA;      temp2 = temp &gt;&gt; 8;&#xD;&#xA;      temp = (temp &lt;&lt; 8) | temp2;&#xD;&#xA;      temp &amp;= 0xFFFF;&#xD;&#xA;      // the returned value is already swapped&#xD;&#xA;      // crcLo byte is first &amp; crcHi byte is last&#xD;&#xA;      return temp;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::validateRequest() {&#xD;&#xA;      // check message crc vs calculated crc&#xD;&#xA;      uint16_t u16MsgCRC =&#xD;&#xA;        ((au8Buffer[u8BufferSize - 2] &lt;&lt; 8)&#xD;&#xA;        | au8Buffer[u8BufferSize - 1]); // combine the crc Low &amp; High bytes&#xD;&#xA;      if ( calcCRC( u8BufferSize - 2 ) != u16MsgCRC ) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return NO_REPLY;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check fct code&#xD;&#xA;      boolean isSupported = false;&#xD;&#xA;      for (uint8_t i = 0; i &lt; sizeof( fctsupported ); i++) {&#xD;&#xA;        if (fctsupported[i] == au8Buffer[FUNC]) {&#xD;&#xA;          isSupported = 1;&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      if (!isSupported) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return EXC_FUNC_CODE;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check start address &amp; nb range&#xD;&#xA;      uint16_t u16regs = 0;&#xD;&#xA;      uint8_t u8regs;&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]) / 16;&#xD;&#xA;        u16regs += word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ]) / 16;&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]) / 16;&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]);&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER :&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]);&#xD;&#xA;        u16regs += word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ]);&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      return 0; // OK, no exception code thrown&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::validateAnswer() {&#xD;&#xA;      // check message crc vs calculated crc&#xD;&#xA;      uint16_t u16MsgCRC =&#xD;&#xA;        ((au8Buffer[u8BufferSize - 2] &lt;&lt; 8)&#xD;&#xA;        | au8Buffer[u8BufferSize - 1]); // combine the crc Low &amp; High bytes&#xD;&#xA;      if ( calcCRC( u8BufferSize - 2 ) != u16MsgCRC ) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return NO_REPLY;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check exception&#xD;&#xA;      if ((au8Buffer[ FUNC ] &amp; 0x80) != 0) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return ERR_EXCEPTION;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check fct code&#xD;&#xA;      boolean isSupported = false;&#xD;&#xA;      for (uint8_t i = 0; i &lt; sizeof( fctsupported ); i++) {&#xD;&#xA;        if (fctsupported[i] == au8Buffer[FUNC]) {&#xD;&#xA;          isSupported = 1;&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      if (!isSupported) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return EXC_FUNC_CODE;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      return 0; // OK, no exception code thrown&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::buildException( uint8_t u8exception ) {&#xD;&#xA;      uint8_t u8func = au8Buffer[ FUNC ];  // get the original FUNC code&#xD;&#xA;    &#xD;&#xA;      au8Buffer[ ID ]      = u8id;&#xD;&#xA;      au8Buffer[ FUNC ]    = u8func + 0x80;&#xD;&#xA;      au8Buffer[ 2 ]       = u8exception;&#xD;&#xA;      u8BufferSize         = EXCEPTION_SIZE;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::get_FC1() {&#xD;&#xA;      uint8_t u8byte, i;&#xD;&#xA;      u8byte = 0;&#xD;&#xA;    &#xD;&#xA;      // check the answer length&#xD;&#xA;      boolean bEvenOdd =&#xD;&#xA;        ( au8Buffer[ ADD_HI ] % 2 == 0) ?&#xD;&#xA;      false :&#xD;&#xA;      true;&#xD;&#xA;    &#xD;&#xA;      uint8_t u8WordsNo =&#xD;&#xA;        ( !bEvenOdd ) ?&#xD;&#xA;      au8Buffer[ ADD_HI ] / 2 :&#xD;&#xA;      au8Buffer[ ADD_HI ] / 2 + 1;&#xD;&#xA;    &#xD;&#xA;      for (i = 0; i &lt; u8WordsNo; i++) {&#xD;&#xA;        au16regs[ i ] = word(&#xD;&#xA;        au8Buffer[ u8byte ],&#xD;&#xA;        au8Buffer[ u8byte + 1 ]);&#xD;&#xA;        u8byte += 2;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // cut last byte&#xD;&#xA;      if (bEvenOdd) {&#xD;&#xA;        au16regs[ u8WordsNo - 1 ] &amp;= 0xff00;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void Modbus::get_FC3() {&#xD;&#xA;      uint8_t u8byte, i;&#xD;&#xA;      u8byte = 3;&#xD;&#xA;    &#xD;&#xA;      for (i = 0; i &lt; au8Buffer[ 2 ] / 2; i++) {&#xD;&#xA;        au16regs[ i ] = word(&#xD;&#xA;        au8Buffer[ u8byte ],&#xD;&#xA;        au8Buffer[ u8byte + 1 ]);&#xD;&#xA;        u8byte += 2;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC1( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit, u8bytesno, u8bitsno;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16currentCoil, u16coil;&#xD;&#xA;    &#xD;&#xA;      // get the first and last coil from the message&#xD;&#xA;      uint16_t u16StartCoil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint16_t u16Coilno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;      // put the number of bytes in the outcoming message&#xD;&#xA;      u8bytesno = (uint8_t) (u16Coilno / 8);&#xD;&#xA;      if (u16Coilno % 8 != 0) u8bytesno ++;&#xD;&#xA;      au8Buffer[ ADD_HI ]  = u8bytesno;&#xD;&#xA;      u8BufferSize         = ADD_LO;&#xD;&#xA;    &#xD;&#xA;      // read each coil from the register map and put its value inside the outcoming message&#xD;&#xA;      u8bitsno = 0;&#xD;&#xA;    &#xD;&#xA;      for (u16currentCoil = 0; u16currentCoil &lt; u16Coilno; u16currentCoil++) {&#xD;&#xA;        u16coil = u16StartCoil + u16currentCoil;&#xD;&#xA;        u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;        u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;        bitWrite(&#xD;&#xA;        au8Buffer[ u8BufferSize ],&#xD;&#xA;        u8bitsno,&#xD;&#xA;        bitRead( regs[ u8currentRegister ], u8currentBit ) );&#xD;&#xA;        u8bitsno ++;&#xD;&#xA;    &#xD;&#xA;        if (u8bitsno &gt; 7) {&#xD;&#xA;          u8bitsno = 0;&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // send outcoming message&#xD;&#xA;      if (u16Coilno % 8 != 0) u8BufferSize ++;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC3( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      uint8_t u8StartAdd = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint8_t u8regsno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint8_t i;&#xD;&#xA;    &#xD;&#xA;      au8Buffer[ 2 ]       = u8regsno * 2;&#xD;&#xA;      u8BufferSize         = 3;&#xD;&#xA;    &#xD;&#xA;      for (i = u8StartAdd; i &lt; u8StartAdd + u8regsno; i++) {&#xD;&#xA;        au8Buffer[ u8BufferSize ] = highByte(regs[i]);&#xD;&#xA;        u8BufferSize++;&#xD;&#xA;        au8Buffer[ u8BufferSize ] = lowByte(regs[i]);&#xD;&#xA;        u8BufferSize++;&#xD;&#xA;      }&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC5( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16coil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;    &#xD;&#xA;      // point to the register and its bit&#xD;&#xA;      u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;      u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;      // write to coil&#xD;&#xA;      bitWrite(&#xD;&#xA;      regs[ u8currentRegister ],&#xD;&#xA;      u8currentBit,&#xD;&#xA;      au8Buffer[ NB_HI ] == 0xff );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // send answer to master&#xD;&#xA;      u8BufferSize = 6;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC6( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      uint8_t u8add = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16val = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;      regs[ u8add ] = u16val;&#xD;&#xA;    &#xD;&#xA;      // keep the same header&#xD;&#xA;      u8BufferSize         = RESPONSE_SIZE;&#xD;&#xA;    &#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC15( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit, u8frameByte, u8bitsno;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16currentCoil, u16coil;&#xD;&#xA;      boolean bTemp;&#xD;&#xA;    &#xD;&#xA;      // get the first and last coil from the message&#xD;&#xA;      uint16_t u16StartCoil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint16_t u16Coilno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // read each coil from the register map and put its value inside the outcoming message&#xD;&#xA;      u8bitsno = 0;&#xD;&#xA;      u8frameByte = 7;&#xD;&#xA;      for (u16currentCoil = 0; u16currentCoil &lt; u16Coilno; u16currentCoil++) {&#xD;&#xA;    &#xD;&#xA;        u16coil = u16StartCoil + u16currentCoil;&#xD;&#xA;        u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;        u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;        bTemp = bitRead(&#xD;&#xA;        au8Buffer[ u8frameByte ],&#xD;&#xA;        u8bitsno );&#xD;&#xA;    &#xD;&#xA;        bitWrite(&#xD;&#xA;        regs[ u8currentRegister ],&#xD;&#xA;        u8currentBit,&#xD;&#xA;        bTemp );&#xD;&#xA;    &#xD;&#xA;        u8bitsno ++;&#xD;&#xA;    &#xD;&#xA;        if (u8bitsno &gt; 7) {&#xD;&#xA;          u8bitsno = 0;&#xD;&#xA;          u8frameByte++;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // send outcoming message&#xD;&#xA;      // it's just a copy of the incomping frame until 6th byte&#xD;&#xA;      u8BufferSize         = 6;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC16( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8func = au8Buffer[ FUNC ];  // get the original FUNC code&#xD;&#xA;      uint8_t u8StartAdd = au8Buffer[ ADD_HI ] &lt;&lt; 8 | au8Buffer[ ADD_LO ];&#xD;&#xA;      uint8_t u8regsno = au8Buffer[ NB_HI ] &lt;&lt; 8 | au8Buffer[ NB_LO ];&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint8_t i;&#xD;&#xA;      uint16_t temp;&#xD;&#xA;    &#xD;&#xA;      // build header&#xD;&#xA;      au8Buffer[ NB_HI ]   = 0;&#xD;&#xA;      au8Buffer[ NB_LO ]   = u8regsno;&#xD;&#xA;      u8BufferSize         = RESPONSE_SIZE;&#xD;&#xA;    &#xD;&#xA;      // write registers&#xD;&#xA;      for (i = 0; i &lt; u8regsno; i++) {&#xD;&#xA;        temp = word(&#xD;&#xA;        au8Buffer[ (BYTE_CNT + 1) + i * 2 ],&#xD;&#xA;        au8Buffer[ (BYTE_CNT + 2) + i * 2 ]);&#xD;&#xA;    &#xD;&#xA;        regs[ u8StartAdd + i ] = temp;&#xD;&#xA;      }&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/eglU2.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/9ku4w.jpg" />
  <row Id="3055" PostHistoryTypeId="5" PostId="1083" RevisionGUID="29182e31-af6c-4108-8fe8-d8debb233a4e" CreationDate="2014-04-04T10:21:43.607" UserId="904" Comment="added 112 characters in body" Text="I have below code . This code is successfully compiled and uploaded, But i am not getting any response from Slave. Let me know what i need to do.&#xD;&#xA;&#xD;&#xA;![Error message][1]&#xD;&#xA;![Connection diagram][2]&#xD;&#xA;Some time data being received from slave i get this error![error2][3]&#xD;&#xA;My main code&#xD;&#xA;&#xD;&#xA;    #define ID  1&#xD;&#xA;    /*static float ARDUINO_ANALOG_SCALING = 0.00488758;&#xD;&#xA;    static float Ydegree;&#xD;&#xA;    static int Sensor_Value;&#xD;&#xA;    float Yvoltage;&#xD;&#xA;    &#xD;&#xA;    */&#xD;&#xA;    &#xD;&#xA;    Modbus slave(ID, 0, 0);&#xD;&#xA;    boolean led;&#xD;&#xA;    int8_t state = 0;&#xD;&#xA;    unsigned long tempus;&#xD;&#xA;    // data array for modbus network sharing&#xD;&#xA;    uint16_t au16data[9];&#xD;&#xA;    float latitude=13.08;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      pinMode(13, OUTPUT);&#xD;&#xA;      slave.begin( 19200 );&#xD;&#xA;      tempus = millis() + 100;&#xD;&#xA;      digitalWrite(13, HIGH );&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      &#xD;&#xA;      state = slave.poll( au16data, 9 );&#xD;&#xA;      if (state &gt; 4) {&#xD;&#xA;        tempus = millis() + 50;&#xD;&#xA;        digitalWrite(13, HIGH);&#xD;&#xA;      }&#xD;&#xA;      if (millis() &gt; tempus) digitalWrite(13, LOW );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      au16data[4] = analogRead(0);&#xD;&#xA;      au16data[5] = analogRead(1);&#xD;&#xA;    &#xD;&#xA;      &#xD;&#xA;     &#xD;&#xA;      au16data[6] = slave.getInCnt();&#xD;&#xA;      au16data[7] = slave.getOutCnt();&#xD;&#xA;      au16data[8] = slave.getErrCnt();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Modbus code&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #define  MAX_BUFFER  64	&#xD;&#xA;    typedef struct {&#xD;&#xA;      uint8_t u8id;          /*!&lt; slave address between 1 and 247. 0 means broadcast */&#xD;&#xA;      uint8_t u8fct;         /*!&lt; function code: 1, 2, 3, 4, 5, 6, 15 or 16 */&#xD;&#xA;      uint16_t u16RegAdd;    /*!&lt; address of the first register to access at slave/s */&#xD;&#xA;      uint16_t u16CoilsNo;   /*!&lt; number of coils or registers to access */&#xD;&#xA;      uint16_t *au16reg;     /*!&lt; pointer to memory image in master */&#xD;&#xA;    }&#xD;&#xA;    modbus_t;&#xD;&#xA;    &#xD;&#xA;    enum {&#xD;&#xA;      RESPONSE_SIZE = 6,&#xD;&#xA;      EXCEPTION_SIZE = 3,&#xD;&#xA;      CHECKSUM_SIZE = 2&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum MESSAGE {&#xD;&#xA;      ID = 0,&#xD;&#xA;      FUNC,&#xD;&#xA;      ADD_HI,&#xD;&#xA;      ADD_LO,&#xD;&#xA;      NB_HI,&#xD;&#xA;      NB_LO,&#xD;&#xA;      BYTE_CNT&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum MB_FC {&#xD;&#xA;      MB_FC_NONE                     = 0,   /*!&lt; null operator */&#xD;&#xA;      MB_FC_READ_COILS               = 1,	/*!&lt; FCT=1 -&gt; read coils or digital outputs */&#xD;&#xA;      MB_FC_READ_DISCRETE_INPUT      = 2,	/*!&lt; FCT=2 -&gt; read digital inputs */&#xD;&#xA;      MB_FC_READ_REGISTERS           = 3,	/*!&lt; FCT=3 -&gt; read registers or analog outputs */&#xD;&#xA;      MB_FC_READ_INPUT_REGISTER      = 4,	/*!&lt; FCT=4 -&gt; read analog inputs */&#xD;&#xA;      MB_FC_WRITE_COIL               = 5,	/*!&lt; FCT=5 -&gt; write single coil or output */&#xD;&#xA;      MB_FC_WRITE_REGISTER           = 6,	/*!&lt; FCT=6 -&gt; write single register */&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_COILS     = 15,	/*!&lt; FCT=15 -&gt; write multiple coils or outputs */&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_REGISTERS = 16	/*!&lt; FCT=16 -&gt; write multiple registers */&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum COM_STATES {&#xD;&#xA;      COM_IDLE                     = 0,&#xD;&#xA;      COM_WAITING                  = 1&#xD;&#xA;    &#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum ERR_LIST {&#xD;&#xA;      ERR_NOT_MASTER                = -1,&#xD;&#xA;      ERR_POLLING                   = -2,&#xD;&#xA;      ERR_BUFF_OVERFLOW             = -3,&#xD;&#xA;      ERR_BAD_CRC                   = -4,&#xD;&#xA;      ERR_EXCEPTION                 = -5&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    enum {&#xD;&#xA;      NO_REPLY = 255, 			/*!&lt; */&#xD;&#xA;      EXC_FUNC_CODE = 1,		/*!&lt; Function code not available */&#xD;&#xA;      EXC_ADDR_RANGE = 2, 		/*!&lt; Address beyond available space for Modbus registers */&#xD;&#xA;      EXC_REGS_QUANT = 3,  		/*!&lt; Coils or registers number beyond the available space */&#xD;&#xA;      EXC_EXECUTE = 4 			/*!&lt; */&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    const unsigned char fctsupported[] = {&#xD;&#xA;      MB_FC_READ_COILS,&#xD;&#xA;      MB_FC_READ_DISCRETE_INPUT,&#xD;&#xA;      MB_FC_READ_REGISTERS,&#xD;&#xA;      MB_FC_READ_INPUT_REGISTER,&#xD;&#xA;      MB_FC_WRITE_COIL,&#xD;&#xA;      MB_FC_WRITE_REGISTER,&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_COILS,&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_REGISTERS&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    #define T35  5&#xD;&#xA;    &#xD;&#xA;    class Modbus {&#xD;&#xA;    private:&#xD;&#xA;      HardwareSerial *port; //!&lt; Pointer to Serial class object&#xD;&#xA;      uint8_t u8id; //!&lt;0=master, 1..247=slave number&#xD;&#xA;      uint8_t u8serno; //!&lt;serial port: 0-Serial, 1..3-Serial1..Serial3&#xD;&#xA;      uint8_t u8txenpin; //!&lt;flow control pin: 0=USB or RS-232 mode, &gt;0=RS-485 mode&#xD;&#xA;      uint8_t u8state;&#xD;&#xA;      uint8_t au8Buffer[MAX_BUFFER];&#xD;&#xA;      uint8_t u8BufferSize;&#xD;&#xA;      uint8_t u8lastRec;&#xD;&#xA;      uint16_t *au16regs;&#xD;&#xA;      uint16_t u16InCnt, u16OutCnt, u16errCnt;&#xD;&#xA;      uint16_t u16timeOut;&#xD;&#xA;      uint32_t u32time, u32timeOut;&#xD;&#xA;      uint8_t u8regsize;&#xD;&#xA;    &#xD;&#xA;      void init(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin);&#xD;&#xA;      void sendTxBuffer(); // transmit buffer to serial port&#xD;&#xA;      int8_t getRxBuffer(); // get serial buffer contents&#xD;&#xA;      uint16_t calcCRC(uint8_t u8length); // get CRC from au8Buffer until u8length&#xD;&#xA;      uint8_t validateAnswer();&#xD;&#xA;      uint8_t validateRequest(); // validate master request&#xD;&#xA;      void get_FC1(); // *** only master ***&#xD;&#xA;      void get_FC3(); // *** only master ***&#xD;&#xA;      int8_t process_FC1( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC3( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC5( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC6( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC15( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC16( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      void buildException( uint8_t u8exception ); // build exception message&#xD;&#xA;    &#xD;&#xA;    public:&#xD;&#xA;      Modbus(); // !&lt; Default Constructor&#xD;&#xA;      Modbus(uint8_t u8id, uint8_t u8serno); // !&lt; Constructor&#xD;&#xA;      Modbus(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin); // !&lt; Full Constructor&#xD;&#xA;      void begin(long u32speed);&#xD;&#xA;      void begin();&#xD;&#xA;      void setTimeOut( uint16_t u16timeout); //!&lt; write communication watch-dog timer&#xD;&#xA;      uint16_t getTimeOut(); //!&lt; get communication watch-dog timer value&#xD;&#xA;      boolean getTimeOutState(); //!&lt; get communication watch-dog timer state&#xD;&#xA;      int8_t query( modbus_t telegram ); //!&lt; only for master&#xD;&#xA;      int8_t poll(); //!&lt; cyclic poll for master&#xD;&#xA;      int8_t poll( uint16_t *regs, uint8_t u8size ); //!&lt; cyclic poll for slave&#xD;&#xA;      uint16_t getInCnt(); //!&lt; number of incoming messages&#xD;&#xA;      uint16_t getOutCnt(); //!&lt; number of outcoming messages&#xD;&#xA;      uint16_t getErrCnt(); //!&lt; error counter&#xD;&#xA;      uint8_t getID(); //!&lt; get slave ID between 1 and 247&#xD;&#xA;      uint8_t getState();&#xD;&#xA;      uint8_t getLastError(); //!&lt; get last error message&#xD;&#xA;      void setID( uint8_t u8id ); //!&lt; write new ID for the slave&#xD;&#xA;      void end(); //!&lt; finish any communication and release serial communication port&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus() {&#xD;&#xA;      init(0, 0, 0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus(uint8_t u8id, uint8_t u8serno) {&#xD;&#xA;      init(u8id, u8serno, 0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin) {&#xD;&#xA;      init(u8id, u8serno, u8txenpin);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::begin(long u32speed) {&#xD;&#xA;    &#xD;&#xA;      switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;      case 1:&#xD;&#xA;        port = &amp;Serial1;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;      case 2:&#xD;&#xA;        port = &amp;Serial2;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;      case 3:&#xD;&#xA;        port = &amp;Serial3;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;      case 0:&#xD;&#xA;      default:&#xD;&#xA;        port = &amp;Serial;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // port-&gt;begin(u32speed, u8config);&#xD;&#xA;      port-&gt;begin(u32speed);&#xD;&#xA;      if (u8txenpin &gt; 1) { // pin 0 &amp; pin 1 are reserved for RX/TX&#xD;&#xA;        // return RS485 transceiver to transmit mode&#xD;&#xA;        pinMode(u8txenpin, OUTPUT);&#xD;&#xA;        digitalWrite(u8txenpin, LOW);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      port-&gt;flush();&#xD;&#xA;      u8lastRec = u8BufferSize = 0;&#xD;&#xA;      u16InCnt = u16OutCnt = u16errCnt = 0;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::begin() {&#xD;&#xA;      begin(19200);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void Modbus::setID( uint8_t u8id) {&#xD;&#xA;      if (( u8id != 0) &amp;&amp; (u8id &lt;= 247)) {&#xD;&#xA;        this-&gt;u8id = u8id;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::getID() {&#xD;&#xA;      return this-&gt;u8id;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::setTimeOut( uint16_t u16timeOut) {&#xD;&#xA;      this-&gt;u16timeOut = u16timeOut;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    boolean Modbus::getTimeOutState() {&#xD;&#xA;      return (millis() &gt; u32timeOut);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getInCnt() {&#xD;&#xA;      return u16InCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getOutCnt() {&#xD;&#xA;      return u16OutCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getErrCnt() {&#xD;&#xA;      return u16errCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::getState() {&#xD;&#xA;      return u8state;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::query( modbus_t telegram ) {&#xD;&#xA;      uint8_t u8regsno, u8bytesno;&#xD;&#xA;      if (u8id != 0) return -2;&#xD;&#xA;      if (u8state != COM_IDLE) return -1;&#xD;&#xA;    &#xD;&#xA;      if ((telegram.u8id == 0) || (telegram.u8id &gt; 247)) return -3;&#xD;&#xA;    &#xD;&#xA;      au16regs = telegram.au16reg;&#xD;&#xA;    &#xD;&#xA;      // telegram header&#xD;&#xA;      au8Buffer[ ID ]         = telegram.u8id;&#xD;&#xA;      au8Buffer[ FUNC ]       = telegram.u8fct;&#xD;&#xA;      au8Buffer[ ADD_HI ]     = highByte(telegram.u16RegAdd );&#xD;&#xA;      au8Buffer[ ADD_LO ]     = lowByte( telegram.u16RegAdd );&#xD;&#xA;    &#xD;&#xA;      switch ( telegram.u8fct ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;      case MB_FC_READ_REGISTERS:&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        au8Buffer[ NB_HI ]      = ((au16regs[0] &gt; 0) ? 0xff : 0);&#xD;&#xA;        au8Buffer[ NB_LO ]      = 0;&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(au16regs[0]);&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte(au16regs[0]);&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        u8regsno = telegram.u16CoilsNo / 16;&#xD;&#xA;        u8bytesno = u8regsno * 2;&#xD;&#xA;        if ((telegram.u16CoilsNo % 16) != 0) {&#xD;&#xA;          u8bytesno++;&#xD;&#xA;          u8regsno++;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO + 1 ]    = u8bytesno;&#xD;&#xA;        u8BufferSize = 7;&#xD;&#xA;    &#xD;&#xA;        u8regsno = u8bytesno = 0; // now auxiliary registers&#xD;&#xA;        for (uint16_t i = 0; i &lt; telegram.u16CoilsNo; i++) {&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;        break;&#xD;&#xA;    &#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO + 1 ]    = (uint8_t) ( telegram.u16CoilsNo * 2 );&#xD;&#xA;        u8BufferSize = 7;&#xD;&#xA;    &#xD;&#xA;        for (uint16_t i = 0; i &lt; telegram.u16CoilsNo; i++) {&#xD;&#xA;          au8Buffer[ u8BufferSize ] = highByte( au16regs[ i ] );&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;          au8Buffer[ u8BufferSize ] = lowByte( au16regs[ i ] );&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;        }&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      u8state = COM_WAITING;&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::poll() {&#xD;&#xA;      // check if there is any incoming frame&#xD;&#xA;      uint8_t u8current = port-&gt;available();&#xD;&#xA;    &#xD;&#xA;      if (millis() &gt; u32timeOut) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      if (u8current == 0) return 0;&#xD;&#xA;    &#xD;&#xA;      // check T35 after frame end or still no frame end&#xD;&#xA;      if (u8current != u8lastRec) {&#xD;&#xA;        u8lastRec = u8current;&#xD;&#xA;        u32time = millis() + T35;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;      if (millis() &lt; u32time) return 0;&#xD;&#xA;    &#xD;&#xA;      // transfer Serial buffer frame to auBuffer&#xD;&#xA;      u8lastRec = 0;&#xD;&#xA;      int8_t i8state = getRxBuffer();&#xD;&#xA;      if (i8state &lt; 7) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return i8state;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // validate message: id, CRC, FCT, exception&#xD;&#xA;      uint8_t u8exception = validateAnswer();&#xD;&#xA;      if (u8exception != 0) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        return u8exception;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // process answer&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;        // call get_FC1 to transfer the incoming message to au16regs buffer&#xD;&#xA;        get_FC1( );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;        // call get_FC3 to transfer the incoming message to au16regs buffer&#xD;&#xA;        get_FC3( );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        // nothing to do&#xD;&#xA;        break;&#xD;&#xA;      default:&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      u8state = COM_IDLE;&#xD;&#xA;      return u8BufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::poll( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      au16regs = regs;&#xD;&#xA;      u8regsize = u8size;&#xD;&#xA;    &#xD;&#xA;      // check if there is any incoming frame&#xD;&#xA;      uint8_t u8current = port-&gt;available();&#xD;&#xA;      if (u8current == 0) return 0;&#xD;&#xA;    &#xD;&#xA;      // check T35 after frame end or still no frame end&#xD;&#xA;      if (u8current != u8lastRec) {&#xD;&#xA;        u8lastRec = u8current;&#xD;&#xA;        u32time = millis() + T35;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;      if (millis() &lt; u32time) return 0;&#xD;&#xA;    &#xD;&#xA;      u8lastRec = 0;&#xD;&#xA;      int8_t i8state = getRxBuffer();&#xD;&#xA;      if (i8state &lt; 7) return i8state;&#xD;&#xA;    &#xD;&#xA;      // check slave id&#xD;&#xA;      if (au8Buffer[ ID ] != u8id) return 0;&#xD;&#xA;    &#xD;&#xA;      // validate message: CRC, FCT, address and size&#xD;&#xA;      uint8_t u8exception = validateRequest();&#xD;&#xA;      if (u8exception &gt; 0) {&#xD;&#xA;        if (u8exception != NO_REPLY) {&#xD;&#xA;          buildException( u8exception );&#xD;&#xA;          sendTxBuffer();&#xD;&#xA;        }&#xD;&#xA;        return u8exception;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      u32timeOut = millis() + long(u16timeOut);&#xD;&#xA;    &#xD;&#xA;      // process message&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;        return process_FC1( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;        return process_FC3( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        return process_FC5( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;        return process_FC6( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        return process_FC15( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        return process_FC16( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      default:&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /* _____PRIVATE FUNCTIONS_____________________________________________________ */&#xD;&#xA;    &#xD;&#xA;    void Modbus::init(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin) {&#xD;&#xA;      this-&gt;u8id = u8id;&#xD;&#xA;      this-&gt;u8serno = (u8serno &gt; 3) ? 0 : u8serno;&#xD;&#xA;      this-&gt;u8txenpin = u8txenpin;&#xD;&#xA;      this-&gt;u16timeOut = 1000;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::getRxBuffer() {&#xD;&#xA;      boolean bBuffOverflow = false;&#xD;&#xA;    &#xD;&#xA;      if (u8txenpin &gt; 1) digitalWrite( u8txenpin, LOW );&#xD;&#xA;    &#xD;&#xA;      u8BufferSize = 0;&#xD;&#xA;      while ( port-&gt;available() ) {&#xD;&#xA;        au8Buffer[ u8BufferSize ] = port-&gt;read();&#xD;&#xA;        u8BufferSize ++;&#xD;&#xA;    &#xD;&#xA;        if (u8BufferSize &gt;= MAX_BUFFER) bBuffOverflow = true;&#xD;&#xA;      }&#xD;&#xA;      u16InCnt++;&#xD;&#xA;    &#xD;&#xA;      if (bBuffOverflow) {&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return ERR_BUFF_OVERFLOW;&#xD;&#xA;      }&#xD;&#xA;      return u8BufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::sendTxBuffer() {&#xD;&#xA;      uint8_t i = 0;&#xD;&#xA;    &#xD;&#xA;      // append CRC to message&#xD;&#xA;      uint16_t u16crc = calcCRC( u8BufferSize );&#xD;&#xA;      au8Buffer[ u8BufferSize ] = u16crc &gt;&gt; 8;&#xD;&#xA;      u8BufferSize++;&#xD;&#xA;      au8Buffer[ u8BufferSize ] = u16crc &amp; 0x00ff;&#xD;&#xA;      u8BufferSize++;&#xD;&#xA;    &#xD;&#xA;      // set RS485 transceiver to transmit mode&#xD;&#xA;      if (u8txenpin &gt; 1) {&#xD;&#xA;        switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;        case 1:&#xD;&#xA;          UCSR1A = UCSR1A | (1 &lt;&lt; TXC1);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;        case 2:&#xD;&#xA;          UCSR2A = UCSR2A | (1 &lt;&lt; TXC2);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;        case 3:&#xD;&#xA;          UCSR3A = UCSR3A | (1 &lt;&lt; TXC3);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;        case 0:&#xD;&#xA;        default:&#xD;&#xA;          UCSR0A = UCSR0A | (1 &lt;&lt; TXC0);&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;        digitalWrite( u8txenpin, HIGH );&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // transfer buffer to serial line&#xD;&#xA;      port-&gt;write( au8Buffer, u8BufferSize );&#xD;&#xA;    &#xD;&#xA;      // keep RS485 transceiver in transmit mode as long as sending&#xD;&#xA;      if (u8txenpin &gt; 1) {&#xD;&#xA;        switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;        case 1:&#xD;&#xA;          while (!(UCSR1A &amp; (1 &lt;&lt; TXC1)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;        case 2:&#xD;&#xA;          while (!(UCSR2A &amp; (1 &lt;&lt; TXC2)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;        case 3:&#xD;&#xA;          while (!(UCSR3A &amp; (1 &lt;&lt; TXC3)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;        case 0:&#xD;&#xA;        default:&#xD;&#xA;          while (!(UCSR0A &amp; (1 &lt;&lt; TXC0)));&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        // return RS485 transceiver to receive mode&#xD;&#xA;        digitalWrite( u8txenpin, LOW );&#xD;&#xA;      }&#xD;&#xA;      port-&gt;flush();&#xD;&#xA;      u8BufferSize = 0;&#xD;&#xA;    &#xD;&#xA;      // set time-out for master&#xD;&#xA;      u32timeOut = millis() + (unsigned long) u16timeOut;&#xD;&#xA;    &#xD;&#xA;      // increase message counter&#xD;&#xA;      u16OutCnt++;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /**&#xD;&#xA;     * @brief&#xD;&#xA;     * This method calculates CRC&#xD;&#xA;     *&#xD;&#xA;     * @return uint16_t calculated CRC value for the message&#xD;&#xA;     * @ingroup buffer&#xD;&#xA;     */&#xD;&#xA;    uint16_t Modbus::calcCRC(uint8_t u8length) {&#xD;&#xA;      unsigned int temp, temp2, flag;&#xD;&#xA;      temp = 0xFFFF;&#xD;&#xA;      for (unsigned char i = 0; i &lt; u8length; i++) {&#xD;&#xA;        temp = temp ^ au8Buffer[i];&#xD;&#xA;        for (unsigned char j = 1; j &lt;= 8; j++) {&#xD;&#xA;          flag = temp &amp; 0x0001;&#xD;&#xA;          temp &gt;&gt;= 1;&#xD;&#xA;          if (flag)&#xD;&#xA;            temp ^= 0xA001;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      // Reverse byte order.&#xD;&#xA;      temp2 = temp &gt;&gt; 8;&#xD;&#xA;      temp = (temp &lt;&lt; 8) | temp2;&#xD;&#xA;      temp &amp;= 0xFFFF;&#xD;&#xA;      // the returned value is already swapped&#xD;&#xA;      // crcLo byte is first &amp; crcHi byte is last&#xD;&#xA;      return temp;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::validateRequest() {&#xD;&#xA;      // check message crc vs calculated crc&#xD;&#xA;      uint16_t u16MsgCRC =&#xD;&#xA;        ((au8Buffer[u8BufferSize - 2] &lt;&lt; 8)&#xD;&#xA;        | au8Buffer[u8BufferSize - 1]); // combine the crc Low &amp; High bytes&#xD;&#xA;      if ( calcCRC( u8BufferSize - 2 ) != u16MsgCRC ) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return NO_REPLY;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check fct code&#xD;&#xA;      boolean isSupported = false;&#xD;&#xA;      for (uint8_t i = 0; i &lt; sizeof( fctsupported ); i++) {&#xD;&#xA;        if (fctsupported[i] == au8Buffer[FUNC]) {&#xD;&#xA;          isSupported = 1;&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      if (!isSupported) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return EXC_FUNC_CODE;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check start address &amp; nb range&#xD;&#xA;      uint16_t u16regs = 0;&#xD;&#xA;      uint8_t u8regs;&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]) / 16;&#xD;&#xA;        u16regs += word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ]) / 16;&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]) / 16;&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]);&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER :&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]);&#xD;&#xA;        u16regs += word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ]);&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      return 0; // OK, no exception code thrown&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::validateAnswer() {&#xD;&#xA;      // check message crc vs calculated crc&#xD;&#xA;      uint16_t u16MsgCRC =&#xD;&#xA;        ((au8Buffer[u8BufferSize - 2] &lt;&lt; 8)&#xD;&#xA;        | au8Buffer[u8BufferSize - 1]); // combine the crc Low &amp; High bytes&#xD;&#xA;      if ( calcCRC( u8BufferSize - 2 ) != u16MsgCRC ) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return NO_REPLY;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check exception&#xD;&#xA;      if ((au8Buffer[ FUNC ] &amp; 0x80) != 0) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return ERR_EXCEPTION;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check fct code&#xD;&#xA;      boolean isSupported = false;&#xD;&#xA;      for (uint8_t i = 0; i &lt; sizeof( fctsupported ); i++) {&#xD;&#xA;        if (fctsupported[i] == au8Buffer[FUNC]) {&#xD;&#xA;          isSupported = 1;&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      if (!isSupported) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return EXC_FUNC_CODE;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      return 0; // OK, no exception code thrown&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::buildException( uint8_t u8exception ) {&#xD;&#xA;      uint8_t u8func = au8Buffer[ FUNC ];  // get the original FUNC code&#xD;&#xA;    &#xD;&#xA;      au8Buffer[ ID ]      = u8id;&#xD;&#xA;      au8Buffer[ FUNC ]    = u8func + 0x80;&#xD;&#xA;      au8Buffer[ 2 ]       = u8exception;&#xD;&#xA;      u8BufferSize         = EXCEPTION_SIZE;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::get_FC1() {&#xD;&#xA;      uint8_t u8byte, i;&#xD;&#xA;      u8byte = 0;&#xD;&#xA;    &#xD;&#xA;      // check the answer length&#xD;&#xA;      boolean bEvenOdd =&#xD;&#xA;        ( au8Buffer[ ADD_HI ] % 2 == 0) ?&#xD;&#xA;      false :&#xD;&#xA;      true;&#xD;&#xA;    &#xD;&#xA;      uint8_t u8WordsNo =&#xD;&#xA;        ( !bEvenOdd ) ?&#xD;&#xA;      au8Buffer[ ADD_HI ] / 2 :&#xD;&#xA;      au8Buffer[ ADD_HI ] / 2 + 1;&#xD;&#xA;    &#xD;&#xA;      for (i = 0; i &lt; u8WordsNo; i++) {&#xD;&#xA;        au16regs[ i ] = word(&#xD;&#xA;        au8Buffer[ u8byte ],&#xD;&#xA;        au8Buffer[ u8byte + 1 ]);&#xD;&#xA;        u8byte += 2;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // cut last byte&#xD;&#xA;      if (bEvenOdd) {&#xD;&#xA;        au16regs[ u8WordsNo - 1 ] &amp;= 0xff00;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void Modbus::get_FC3() {&#xD;&#xA;      uint8_t u8byte, i;&#xD;&#xA;      u8byte = 3;&#xD;&#xA;    &#xD;&#xA;      for (i = 0; i &lt; au8Buffer[ 2 ] / 2; i++) {&#xD;&#xA;        au16regs[ i ] = word(&#xD;&#xA;        au8Buffer[ u8byte ],&#xD;&#xA;        au8Buffer[ u8byte + 1 ]);&#xD;&#xA;        u8byte += 2;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC1( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit, u8bytesno, u8bitsno;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16currentCoil, u16coil;&#xD;&#xA;    &#xD;&#xA;      // get the first and last coil from the message&#xD;&#xA;      uint16_t u16StartCoil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint16_t u16Coilno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;      // put the number of bytes in the outcoming message&#xD;&#xA;      u8bytesno = (uint8_t) (u16Coilno / 8);&#xD;&#xA;      if (u16Coilno % 8 != 0) u8bytesno ++;&#xD;&#xA;      au8Buffer[ ADD_HI ]  = u8bytesno;&#xD;&#xA;      u8BufferSize         = ADD_LO;&#xD;&#xA;    &#xD;&#xA;      // read each coil from the register map and put its value inside the outcoming message&#xD;&#xA;      u8bitsno = 0;&#xD;&#xA;    &#xD;&#xA;      for (u16currentCoil = 0; u16currentCoil &lt; u16Coilno; u16currentCoil++) {&#xD;&#xA;        u16coil = u16StartCoil + u16currentCoil;&#xD;&#xA;        u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;        u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;        bitWrite(&#xD;&#xA;        au8Buffer[ u8BufferSize ],&#xD;&#xA;        u8bitsno,&#xD;&#xA;        bitRead( regs[ u8currentRegister ], u8currentBit ) );&#xD;&#xA;        u8bitsno ++;&#xD;&#xA;    &#xD;&#xA;        if (u8bitsno &gt; 7) {&#xD;&#xA;          u8bitsno = 0;&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // send outcoming message&#xD;&#xA;      if (u16Coilno % 8 != 0) u8BufferSize ++;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC3( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      uint8_t u8StartAdd = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint8_t u8regsno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint8_t i;&#xD;&#xA;    &#xD;&#xA;      au8Buffer[ 2 ]       = u8regsno * 2;&#xD;&#xA;      u8BufferSize         = 3;&#xD;&#xA;    &#xD;&#xA;      for (i = u8StartAdd; i &lt; u8StartAdd + u8regsno; i++) {&#xD;&#xA;        au8Buffer[ u8BufferSize ] = highByte(regs[i]);&#xD;&#xA;        u8BufferSize++;&#xD;&#xA;        au8Buffer[ u8BufferSize ] = lowByte(regs[i]);&#xD;&#xA;        u8BufferSize++;&#xD;&#xA;      }&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC5( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16coil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;    &#xD;&#xA;      // point to the register and its bit&#xD;&#xA;      u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;      u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;      // write to coil&#xD;&#xA;      bitWrite(&#xD;&#xA;      regs[ u8currentRegister ],&#xD;&#xA;      u8currentBit,&#xD;&#xA;      au8Buffer[ NB_HI ] == 0xff );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // send answer to master&#xD;&#xA;      u8BufferSize = 6;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC6( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      uint8_t u8add = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16val = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;      regs[ u8add ] = u16val;&#xD;&#xA;    &#xD;&#xA;      // keep the same header&#xD;&#xA;      u8BufferSize         = RESPONSE_SIZE;&#xD;&#xA;    &#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC15( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit, u8frameByte, u8bitsno;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16currentCoil, u16coil;&#xD;&#xA;      boolean bTemp;&#xD;&#xA;    &#xD;&#xA;      // get the first and last coil from the message&#xD;&#xA;      uint16_t u16StartCoil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint16_t u16Coilno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // read each coil from the register map and put its value inside the outcoming message&#xD;&#xA;      u8bitsno = 0;&#xD;&#xA;      u8frameByte = 7;&#xD;&#xA;      for (u16currentCoil = 0; u16currentCoil &lt; u16Coilno; u16currentCoil++) {&#xD;&#xA;    &#xD;&#xA;        u16coil = u16StartCoil + u16currentCoil;&#xD;&#xA;        u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;        u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;        bTemp = bitRead(&#xD;&#xA;        au8Buffer[ u8frameByte ],&#xD;&#xA;        u8bitsno );&#xD;&#xA;    &#xD;&#xA;        bitWrite(&#xD;&#xA;        regs[ u8currentRegister ],&#xD;&#xA;        u8currentBit,&#xD;&#xA;        bTemp );&#xD;&#xA;    &#xD;&#xA;        u8bitsno ++;&#xD;&#xA;    &#xD;&#xA;        if (u8bitsno &gt; 7) {&#xD;&#xA;          u8bitsno = 0;&#xD;&#xA;          u8frameByte++;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // send outcoming message&#xD;&#xA;      // it's just a copy of the incomping frame until 6th byte&#xD;&#xA;      u8BufferSize         = 6;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC16( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8func = au8Buffer[ FUNC ];  // get the original FUNC code&#xD;&#xA;      uint8_t u8StartAdd = au8Buffer[ ADD_HI ] &lt;&lt; 8 | au8Buffer[ ADD_LO ];&#xD;&#xA;      uint8_t u8regsno = au8Buffer[ NB_HI ] &lt;&lt; 8 | au8Buffer[ NB_LO ];&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint8_t i;&#xD;&#xA;      uint16_t temp;&#xD;&#xA;    &#xD;&#xA;      // build header&#xD;&#xA;      au8Buffer[ NB_HI ]   = 0;&#xD;&#xA;      au8Buffer[ NB_LO ]   = u8regsno;&#xD;&#xA;      u8BufferSize         = RESPONSE_SIZE;&#xD;&#xA;    &#xD;&#xA;      // write registers&#xD;&#xA;      for (i = 0; i &lt; u8regsno; i++) {&#xD;&#xA;        temp = word(&#xD;&#xA;        au8Buffer[ (BYTE_CNT + 1) + i * 2 ],&#xD;&#xA;        au8Buffer[ (BYTE_CNT + 2) + i * 2 ]);&#xD;&#xA;    &#xD;&#xA;        regs[ u8StartAdd + i ] = temp;&#xD;&#xA;      }&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/eglU2.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/9ku4w.jpg&#xD;&#xA;  [3]: http://i.stack.imgur.com/wwfhW.jpg" />
  <row Id="3056" PostHistoryTypeId="2" PostId="1084" RevisionGUID="c20538f0-f532-4cc7-8bf1-80a83ec000f0" CreationDate="2014-04-04T12:53:19.513" UserId="46" Text="Chris Stratton's comments helped me find a workaround for my problem. It looks like the version of optiboot I was working with (see [source-code here](http://pastebin.com/d8NUirfZ)) doesn't work properly at 57600 BAUD with Arduino Uno. So I compiled the bootloader with 76800 BAUD, configured the IDE accordingly, and all my boards started to work fine with it.&#xD;&#xA;&#xD;&#xA;It is still unclear to me the reason I one can't use 57600 BAUD, but I'm too pragmatic and too little knowledgeable to go after the true answer. So, I'll take Chris' word for it. He said this: &#xD;&#xA;&#xD;&#xA;&gt; Basically, 57600 does not divide in 16 MHz nicely when the 8x or 16x oversampling of the hardware UART is taken into account. My gut feeling is that different implementation are using different approximations. If they used the same approximation then even if &quot;wrong&quot; things would be basically fine (especially as the hardware design is similar), but if they are are off in opposite directions it could be unreliable. If you post the exact bootloader source you used we can see for sure - some optiboot source I just looked at seems to actually be using a software UART for 57600.&#xD;&#xA;&#xD;&#xA;That's the end of it for me.&#xD;&#xA;" />
  <row Id="3061" PostHistoryTypeId="2" PostId="1085" RevisionGUID="fbfae7aa-a3e8-4554-ac22-942cb866d28b" CreationDate="2014-04-04T16:24:38.833" UserId="83" Text="The seconds since (UNIX) epoch relies on a [database](https://en.wikipedia.org/wiki/Tz_database) with timezones and leap seconds. &#xD;&#xA;&#xD;&#xA;&gt; New editions of the database and code are published as changes warrant, usually several times per year.&#xD;&#xA;&#xD;&#xA;You can &#xD;&#xA;&#xD;&#xA;- reduce the timezone database to the timezone you are actually interested in;&#xD;&#xA;- don't forget about daylight savings time for you specific timezone;&#xD;&#xA;- the leap years are well known too and reasonably easy to program; &#xD;&#xA;- however the leap seconds are decided upon usually only couple months before they are introduced and therefore cannot be accounted for in an algorithm.&#xD;&#xA;&#xD;&#xA;Conclusion&#xD;&#xA;-&#xD;&#xA;- So can you convert epoch to a time/date format? Yes. &#xD;&#xA;- Will it be accurate? It'll drift away over time (months or years)&#xD;&#xA;&#xD;&#xA;Advise&#xD;&#xA;-&#xD;&#xA;If you retrieve epoch from an Internet service, why not use (another?) webserver that has the full timezone database available to convert it to accurate date/time?" />
  <row Id="3062" PostHistoryTypeId="5" PostId="1085" RevisionGUID="5907e4f8-0c39-4f01-81cd-26e63a694f22" CreationDate="2014-04-04T16:37:32.610" UserId="83" Comment="added 48 characters in body" Text="The seconds since (UNIX) epoch relies on a [database](https://en.wikipedia.org/wiki/Tz_database). &#xD;&#xA;&#xD;&#xA;&gt; New editions of the database and code are published as changes warrant, usually several times per year.&#xD;&#xA;&#xD;&#xA;Your options can: &#xD;&#xA;&#xD;&#xA;- Reduce the timezone database to the timezone you are actually interested in;&#xD;&#xA;- Don't forget about daylight savings time for you specific timezone;&#xD;&#xA;- The leap years are well known too and reasonably easy to program; &#xD;&#xA;- The leap seconds are decided upon usually only couple months before they are introduced and therefore cannot be accounted for in an algorithm.&#xD;&#xA;&#xD;&#xA;Conclusion&#xD;&#xA;-&#xD;&#xA;- So can you convert epoch to a time/date format? Yes. &#xD;&#xA;- Will it be accurate? It'll drift away over time (months or years)&#xD;&#xA;&#xD;&#xA;Advise&#xD;&#xA;-&#xD;&#xA;If you retrieve epoch from an Internet service, why not use (another?) webserver that has the full timezone database available to convert it to accurate date/time, or 'synchronize' against every once in a while?" />
  <row Id="3063" PostHistoryTypeId="5" PostId="1074" RevisionGUID="3f1975d9-01ec-42dc-9bdc-d060c033db31" CreationDate="2014-04-04T17:47:14.937" UserId="11" Comment="added 17 characters in body" Text="You can pass in a variable into a function. Something like this:&#xD;&#xA;&#xD;&#xA;    void runCurl(int verdi) {&#xD;&#xA;        ...&#xD;&#xA;        String myUrl = &quot;student.cs.hioa.no/~s180343/updatedb.php?verdi=&quot;;&#xD;&#xA;        myUrl += verdi;&#xD;&#xA;        p.addParameter(myUrl);&#xD;&#xA;        ...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You call the function like this, now:&#xD;&#xA;&#xD;&#xA;    runCurl(1);&#xD;&#xA;    runCurl(2);&#xD;&#xA;    runCurl(someVar);&#xD;&#xA;&#xD;&#xA;and so on. Since it's already in your main `loop()` function, you just need to set pass in a different number based on whatever it is you're trying to do." />
  <row Id="3066" PostHistoryTypeId="5" PostId="1056" RevisionGUID="99aefd2b-ab25-4877-b135-3fa11343ad5f" CreationDate="2014-04-04T18:13:23.337" UserId="11" Comment="added 755 characters in body" Text="I have Code for Mod bus Library as below. I have Gone through lots of forum. How to assign device ID, slave address, length using below library function:&#xD;&#xA;&#xD;&#xA;    #include &lt;SimpleModbusSlave.h&gt;&#xD;&#xA;    #define  LED 9  &#xD;&#xA;    enum &#xD;&#xA;    {     &#xD;&#xA;    &#xD;&#xA;      ADC_VAL,     &#xD;&#xA;      PWM_VAL,        &#xD;&#xA;      HOLDING_REGS_SIZE // leave this one&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    unsigned int holdingRegs[HOLDING_REGS_SIZE]; &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      modbus_configure(&amp;Serial, 9600, SERIAL_8N2, 1, 2, HOLDING_REGS_SIZE, holdingRegs);    &#xD;&#xA;      pinMode(LED, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      modbus_update();&#xD;&#xA;      holdingRegs[ADC_VAL] = analogRead(A0); // update data to be read by the master to adjust the PWM&#xD;&#xA;      analogWrite(LED, holdingRegs[PWM_VAL]&gt;&gt;2); // constrain adc value from the arduino master to 255&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I am getting Error has.&#xD;&#xA;&#xD;&#xA;    SimpleModbusSlaveArduino.cpp: In function 'void setup()':&#xD;&#xA;    SimpleModbusSlaveArduino:79: error: 'SERIAL_8N2' was not declared in this scope&#xD;&#xA;&#xD;&#xA;![Error message for IDE][1]&#xD;&#xA;&#xD;&#xA;I have  made changes in the lib as in forum. but I found no value read by my software.&#xD;&#xA;&#xD;&#xA;Master sending below request on read mode. But not receiving anything.&#xD;&#xA;&#xD;&#xA;    12:31:02.953: Com8, Baud Rate: 9600, Data Bits: 8 Bits, Parity: None, Stop Bits: 1 Stop Bit&#xD;&#xA;    12:31:02.953: Echoback: On, RTS Control: On, Transmit Delay: 5 ms, Response Delay: 1000 ms&#xD;&#xA;    12:31:02.953: Read Holding Register(s), Repeat Loop&#xD;&#xA;    12:31:02.953: Device Address: 01h, Register: 0000h&#xD;&#xA;    12:31:02.953: |-&gt; Read Register: 0000h&#xD;&#xA;    12:31:02.968: -&gt; [01h] [0Dh] [00h] [00h] [00h] [01h] [CBh] [EDh]&#xD;&#xA;&#xD;&#xA;![my softawre][2]&#xD;&#xA;[CHANGES MADE IN AS IN FORUM MENTIONED][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [2]: http://i.stack.imgur.com/rJSz8.jpg&#xD;&#xA;  [3]: http://forum.arduino.cc/index.php?topic=176142.0&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/rzaUD.jpg" />
  <row Id="3068" PostHistoryTypeId="2" PostId="1086" RevisionGUID="72576611-d1b3-45f8-9770-5e70dbe221b0" CreationDate="2014-04-04T19:37:38.583" UserId="765" Text="had to simply modify PrintHex in&#xD;&#xA;Adafruit_NFCShield_I2C.h&#xD;&#xA;&#xD;&#xA;to accept an additional argument" />
  <row Id="3069" PostHistoryTypeId="5" PostId="18" RevisionGUID="ccefcd61-4a70-4783-a0ea-6cf9665f8f48" CreationDate="2014-04-04T20:55:59.640" UserId="37" Comment="deleted 49 characters in body" Text="This is caused by a connection error between your computer and the Arduino, and can result from many different specific problems. Here are some things that can fix this error:&#xD;&#xA;&#xD;&#xA; - Disconnect and reconnect the USB cable.&#xD;&#xA; - Use a different USB cable.&#xD;&#xA; - Press the reset button on the board.&#xD;&#xA; - Restart the Arduino IDE.&#xD;&#xA; - Make sure you select the right board in `Tools ► Board ►`, e.g. If you are using the Duemilanove 328, select that instead of Duemilanove 128. The board should say what version it is on the microchip.&#xD;&#xA; - Make sure you selected the right port in `Tools ► Serial Port ►`. One way to figure out which port it is on is by following these steps:&#xD;&#xA; 1. Disconnect the USB cable.&#xD;&#xA; 2. Go to `Tools ► Serial Port ►` and see which ports are listed (e.g. COM4 COM5 COM14).&#xD;&#xA; 3. Reconnect the USB cable.&#xD;&#xA; 4. Go back to `Tools ► Serial Port ►`, and see which port appeared that wasn't there before.&#xD;&#xA; - In extreme cases, you may need to [burn the bootloader][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/a/474/37" />
  <row Id="3070" PostHistoryTypeId="5" PostId="970" RevisionGUID="237e4c5f-3bde-4524-a923-d8e7c0f0438a" CreationDate="2014-04-04T20:57:31.690" UserId="37" Comment="added 56 characters in body" Text="As with any communication error, try these:&#xD;&#xA;&#xD;&#xA; - Disconnect and reconnect the USB cable.&#xD;&#xA; - Use a different USB cable.&#xD;&#xA; - Press the reset button on the board.&#xD;&#xA; - Restart the Arduino IDE.&#xD;&#xA; - Make sure you select the right board in `Tools ► Board ►`, e.g. If you are using the Duemilanove 328, select that instead of Duemilanove 128. The board should say what version it is on the microchip.&#xD;&#xA; - Make sure you selected the right port in `Tools ► Serial Port ►`. One way to figure out which port it is on is by following these steps:&#xD;&#xA; 1. Disconnect the USB cable.&#xD;&#xA; 2. Go to `Tools ► Serial Port ►` and see which ports are listed (e.g. COM4 COM5 COM14).&#xD;&#xA; 3. Reconnect the USB cable.&#xD;&#xA; 4. Go back to `Tools ► Serial Port ►`, and see which port appeared that wasn't there before.&#xD;&#xA; - In extreme cases, you may need to [burn the bootloader][1].&#xD;&#xA;&#xD;&#xA;&lt;sup&gt;&lt;sub&gt;Answer adapted from [here][2].&lt;/sub&gt;&lt;/sup&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/a/474/37&#xD;&#xA;  [2]: http://arduino.stackexchange.com/a/18/37" />
  <row Id="3072" PostHistoryTypeId="5" PostId="1069" RevisionGUID="a2c936fa-822c-47e2-bdcd-fa755bb31e52" CreationDate="2014-04-04T21:50:30.397" UserId="220" Comment="Please crop your images" Text="I am not able to receive data. I am able to send data from master but am not getting any response. This program uploaded successfully. I have below setup to monitor data from Modbus.&#xD;&#xA;&#xD;&#xA;I have included code for Modbus protocol below.&#xD;&#xA;&#xD;&#xA;Also, can someone suggest me the link to download modbus slave config library without any error along with wiring diagram&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    11:42:17.000: Device Address: 01h, Register: 000Dh&#xD;&#xA;    11:42:17.000: |-&gt; Read Register: 000Dh&#xD;&#xA;    11:42:17.015: -&gt; [01h] [0Dh] [00h] [0Dh] [00h] [01h] [08h] [7Ch] &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![MYsetup][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &lt;modbus.h&gt;&#xD;&#xA;    #include &lt;modbusDevice.h&gt;&#xD;&#xA;    #include &lt;modbusRegBank.h&gt;&#xD;&#xA;    #include &lt;modbusSlave.h&gt;&#xD;&#xA;    &#xD;&#xA;    /*&#xD;&#xA;    This example code shows a quick and dirty way to get an&#xD;&#xA;    arduino to talk to a modbus master device with a&#xD;&#xA;    device ID of 1 at 9600 baud.&#xD;&#xA;    */&#xD;&#xA;    &#xD;&#xA;    //Setup the brewtrollers register bank&#xD;&#xA;    //All of the data accumulated will be stored here&#xD;&#xA;    modbusDevice regBank;&#xD;&#xA;    //Create the modbus slave protocol handler&#xD;&#xA;    modbusSlave slave;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {   &#xD;&#xA;    &#xD;&#xA;    //Assign the modbus device ID.  &#xD;&#xA;      regBank.setId(1);&#xD;&#xA;    &#xD;&#xA;    /*&#xD;&#xA;    modbus registers follow the following format&#xD;&#xA;    00001-09999  Digital Outputs, A master device can read and write to these registers&#xD;&#xA;    10001-19999  Digital Inputs, A master device can only read the values from these registers&#xD;&#xA;    30001-39999  Analog Inputs, A master device can only read the values from these registers&#xD;&#xA;    40001-49999  Analog Outputs, A master device can read and write to these registers &#xD;&#xA;    &#xD;&#xA;    Analog values are 16 bit unsigned words stored with a range of 0-32767&#xD;&#xA;    Digital values are stored as bytes, a zero value is OFF and any nonzer value is ON&#xD;&#xA;    &#xD;&#xA;    It is best to configure registers of like type into contiguous blocks.  this&#xD;&#xA;    allows for more efficient register lookup and and reduces the number of messages&#xD;&#xA;    required by the master to retrieve the data&#xD;&#xA;    */&#xD;&#xA;    &#xD;&#xA;    //Add Digital Output registers 00001-00016 to the register bank&#xD;&#xA;      regBank.add(1);&#xD;&#xA;      regBank.add(2);&#xD;&#xA;      regBank.add(3);&#xD;&#xA;      regBank.add(4);&#xD;&#xA;      regBank.add(5);&#xD;&#xA;      regBank.add(6);&#xD;&#xA;      regBank.add(7);&#xD;&#xA;      regBank.add(8);&#xD;&#xA;      regBank.add(9);&#xD;&#xA;      regBank.add(10);&#xD;&#xA;      regBank.add(11);&#xD;&#xA;      regBank.add(12);&#xD;&#xA;      regBank.add(13);&#xD;&#xA;      regBank.add(14);&#xD;&#xA;      regBank.add(15);&#xD;&#xA;      regBank.add(16);&#xD;&#xA;    &#xD;&#xA;    //Add Digital Input registers 10001-10008 to the register bank&#xD;&#xA;      regBank.add(10001);  &#xD;&#xA;      regBank.add(10002);  &#xD;&#xA;      regBank.add(10003);  &#xD;&#xA;      regBank.add(10004);  &#xD;&#xA;      regBank.add(10005);  &#xD;&#xA;      regBank.add(10006);  &#xD;&#xA;      regBank.add(10007);  &#xD;&#xA;      regBank.add(10008);  &#xD;&#xA;    &#xD;&#xA;    //Add Analog Input registers 30001-10010 to the register bank&#xD;&#xA;      regBank.add(30001);  &#xD;&#xA;      regBank.add(30002);  &#xD;&#xA;      regBank.add(30003);  &#xD;&#xA;      regBank.add(30004);  &#xD;&#xA;      regBank.add(30005);  &#xD;&#xA;      regBank.add(30006);  &#xD;&#xA;      regBank.add(30007);  &#xD;&#xA;      regBank.add(30008);  &#xD;&#xA;      regBank.add(30009);  &#xD;&#xA;      regBank.add(30010);  &#xD;&#xA;    &#xD;&#xA;    //Add Analog Output registers 40001-40020 to the register bank&#xD;&#xA;      regBank.add(40001);  &#xD;&#xA;      regBank.add(40002);  &#xD;&#xA;      regBank.add(40003);  &#xD;&#xA;      regBank.add(40004);  &#xD;&#xA;      regBank.add(40005);  &#xD;&#xA;      regBank.add(40006);  &#xD;&#xA;      regBank.add(40007);  &#xD;&#xA;      regBank.add(40008);  &#xD;&#xA;      regBank.add(40009);  &#xD;&#xA;      regBank.add(40010);  &#xD;&#xA;      regBank.add(40011);  &#xD;&#xA;      regBank.add(40012);  &#xD;&#xA;      regBank.add(40013);  &#xD;&#xA;      regBank.add(40014);  &#xD;&#xA;      regBank.add(40015);  &#xD;&#xA;      regBank.add(40016);  &#xD;&#xA;      regBank.add(40017);  &#xD;&#xA;      regBank.add(40018);  &#xD;&#xA;      regBank.add(40019);  &#xD;&#xA;      regBank.add(40020);  &#xD;&#xA;    &#xD;&#xA;    /*&#xD;&#xA;    Assign the modbus device object to the protocol handler&#xD;&#xA;    This is where the protocol handler will look to read and write&#xD;&#xA;    register data.  Currently, a modbus slave protocol handler may&#xD;&#xA;    only have one device assigned to it.&#xD;&#xA;    */&#xD;&#xA;      slave._device = &amp;regBank;  &#xD;&#xA;    &#xD;&#xA;    // Initialize the serial port for coms at 9600 baud  &#xD;&#xA;      slave.setBaud(9600);   &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    //put some data into the registers&#xD;&#xA;      regBank.set(1, 1);  &#xD;&#xA;      regBank.set(2, 1);  &#xD;&#xA;      regBank.set(3, 0);  &#xD;&#xA;      regBank.set(4, 1);  &#xD;&#xA;      regBank.set(5, 1);  &#xD;&#xA;      regBank.set(6, 0);  &#xD;&#xA;      regBank.set(7, 1);  &#xD;&#xA;      regBank.set(8, 0);  &#xD;&#xA;    &#xD;&#xA;      regBank.set(10001, 1);&#xD;&#xA;      regBank.set(10002, 1);  &#xD;&#xA;      regBank.set(10003, 1);  &#xD;&#xA;      regBank.set(10004, 1);  &#xD;&#xA;      regBank.set(10005, 0);  &#xD;&#xA;      regBank.set(10006, 0);  &#xD;&#xA;      regBank.set(10007, 0);  &#xD;&#xA;      regBank.set(10008, 0);  &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      regBank.set(30001,1);&#xD;&#xA;      regBank.set(30002,2);&#xD;&#xA;      regBank.set(30003,3);&#xD;&#xA;      regBank.set(30004,4);&#xD;&#xA;      regBank.set(30005,5);&#xD;&#xA;      regBank.set(30006,6);&#xD;&#xA;      regBank.set(30007,7);&#xD;&#xA;      regBank.set(30008,8);&#xD;&#xA;      regBank.set(30009,9);&#xD;&#xA;      regBank.set(30010,10);&#xD;&#xA;    &#xD;&#xA;      regBank.set(40001,1);&#xD;&#xA;      regBank.set(40002,2);&#xD;&#xA;      regBank.set(40003,2);&#xD;&#xA;      regBank.set(40004,4);&#xD;&#xA;      regBank.set(40005,5);&#xD;&#xA;      regBank.set(40006,6);&#xD;&#xA;      regBank.set(40007,7);&#xD;&#xA;      regBank.set(40008,8);&#xD;&#xA;      regBank.set(40009,9);&#xD;&#xA;      regBank.set(40010,10);&#xD;&#xA;      &#xD;&#xA;     while(1)&#xD;&#xA;      {&#xD;&#xA;        //put a random number into registers 1, 10001, 30001 and 40001&#xD;&#xA;        regBank.set(1, (byte) random(0, 2));&#xD;&#xA;        regBank.set(10001, (byte) random(0, 2));&#xD;&#xA;        regBank.set(30001, (word) random(0, 32767));&#xD;&#xA;        regBank.set(40001, (word) random(0, 32767));&#xD;&#xA;        &#xD;&#xA;         slave.run();  &#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/h72Bw.png" />
  <row Id="3073" PostHistoryTypeId="5" PostId="1083" RevisionGUID="91e4e806-93e3-4f09-9aef-337f50620014" CreationDate="2014-04-04T21:54:21.263" UserId="220" Comment="Please crop your images" Text="I have the below code. This code is successfully compiling and uploading, but I am not getting any response from Slave. What do I need to do?&#xD;&#xA;&#xD;&#xA;![Error message][1]&#xD;&#xA;&#xD;&#xA;![Connection diagram][2]&#xD;&#xA;&#xD;&#xA;Some time data being received from Slave (I get this error):&#xD;&#xA;![error2][3]&#xD;&#xA;&#xD;&#xA;My main code:&#xD;&#xA;&#xD;&#xA;    #define ID  1&#xD;&#xA;    /*static float ARDUINO_ANALOG_SCALING = 0.00488758;&#xD;&#xA;    static float Ydegree;&#xD;&#xA;    static int Sensor_Value;&#xD;&#xA;    float Yvoltage;&#xD;&#xA;    &#xD;&#xA;    */&#xD;&#xA;    &#xD;&#xA;    Modbus slave(ID, 0, 0);&#xD;&#xA;    boolean led;&#xD;&#xA;    int8_t state = 0;&#xD;&#xA;    unsigned long tempus;&#xD;&#xA;    // data array for modbus network sharing&#xD;&#xA;    uint16_t au16data[9];&#xD;&#xA;    float latitude=13.08;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      pinMode(13, OUTPUT);&#xD;&#xA;      slave.begin( 19200 );&#xD;&#xA;      tempus = millis() + 100;&#xD;&#xA;      digitalWrite(13, HIGH );&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      &#xD;&#xA;      state = slave.poll( au16data, 9 );&#xD;&#xA;      if (state &gt; 4) {&#xD;&#xA;        tempus = millis() + 50;&#xD;&#xA;        digitalWrite(13, HIGH);&#xD;&#xA;      }&#xD;&#xA;      if (millis() &gt; tempus) digitalWrite(13, LOW );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      au16data[4] = analogRead(0);&#xD;&#xA;      au16data[5] = analogRead(1);&#xD;&#xA;    &#xD;&#xA;      &#xD;&#xA;     &#xD;&#xA;      au16data[6] = slave.getInCnt();&#xD;&#xA;      au16data[7] = slave.getOutCnt();&#xD;&#xA;      au16data[8] = slave.getErrCnt();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Modbus code:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #define  MAX_BUFFER  64	&#xD;&#xA;    typedef struct {&#xD;&#xA;      uint8_t u8id;          /*!&lt; slave address between 1 and 247. 0 means broadcast */&#xD;&#xA;      uint8_t u8fct;         /*!&lt; function code: 1, 2, 3, 4, 5, 6, 15 or 16 */&#xD;&#xA;      uint16_t u16RegAdd;    /*!&lt; address of the first register to access at slave/s */&#xD;&#xA;      uint16_t u16CoilsNo;   /*!&lt; number of coils or registers to access */&#xD;&#xA;      uint16_t *au16reg;     /*!&lt; pointer to memory image in master */&#xD;&#xA;    }&#xD;&#xA;    modbus_t;&#xD;&#xA;    &#xD;&#xA;    enum {&#xD;&#xA;      RESPONSE_SIZE = 6,&#xD;&#xA;      EXCEPTION_SIZE = 3,&#xD;&#xA;      CHECKSUM_SIZE = 2&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum MESSAGE {&#xD;&#xA;      ID = 0,&#xD;&#xA;      FUNC,&#xD;&#xA;      ADD_HI,&#xD;&#xA;      ADD_LO,&#xD;&#xA;      NB_HI,&#xD;&#xA;      NB_LO,&#xD;&#xA;      BYTE_CNT&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum MB_FC {&#xD;&#xA;      MB_FC_NONE                     = 0,   /*!&lt; null operator */&#xD;&#xA;      MB_FC_READ_COILS               = 1,	/*!&lt; FCT=1 -&gt; read coils or digital outputs */&#xD;&#xA;      MB_FC_READ_DISCRETE_INPUT      = 2,	/*!&lt; FCT=2 -&gt; read digital inputs */&#xD;&#xA;      MB_FC_READ_REGISTERS           = 3,	/*!&lt; FCT=3 -&gt; read registers or analog outputs */&#xD;&#xA;      MB_FC_READ_INPUT_REGISTER      = 4,	/*!&lt; FCT=4 -&gt; read analog inputs */&#xD;&#xA;      MB_FC_WRITE_COIL               = 5,	/*!&lt; FCT=5 -&gt; write single coil or output */&#xD;&#xA;      MB_FC_WRITE_REGISTER           = 6,	/*!&lt; FCT=6 -&gt; write single register */&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_COILS     = 15,	/*!&lt; FCT=15 -&gt; write multiple coils or outputs */&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_REGISTERS = 16	/*!&lt; FCT=16 -&gt; write multiple registers */&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum COM_STATES {&#xD;&#xA;      COM_IDLE                     = 0,&#xD;&#xA;      COM_WAITING                  = 1&#xD;&#xA;    &#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum ERR_LIST {&#xD;&#xA;      ERR_NOT_MASTER                = -1,&#xD;&#xA;      ERR_POLLING                   = -2,&#xD;&#xA;      ERR_BUFF_OVERFLOW             = -3,&#xD;&#xA;      ERR_BAD_CRC                   = -4,&#xD;&#xA;      ERR_EXCEPTION                 = -5&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    enum {&#xD;&#xA;      NO_REPLY = 255, 			/*!&lt; */&#xD;&#xA;      EXC_FUNC_CODE = 1,		/*!&lt; Function code not available */&#xD;&#xA;      EXC_ADDR_RANGE = 2, 		/*!&lt; Address beyond available space for Modbus registers */&#xD;&#xA;      EXC_REGS_QUANT = 3,  		/*!&lt; Coils or registers number beyond the available space */&#xD;&#xA;      EXC_EXECUTE = 4 			/*!&lt; */&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    const unsigned char fctsupported[] = {&#xD;&#xA;      MB_FC_READ_COILS,&#xD;&#xA;      MB_FC_READ_DISCRETE_INPUT,&#xD;&#xA;      MB_FC_READ_REGISTERS,&#xD;&#xA;      MB_FC_READ_INPUT_REGISTER,&#xD;&#xA;      MB_FC_WRITE_COIL,&#xD;&#xA;      MB_FC_WRITE_REGISTER,&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_COILS,&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_REGISTERS&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    #define T35  5&#xD;&#xA;    &#xD;&#xA;    class Modbus {&#xD;&#xA;    private:&#xD;&#xA;      HardwareSerial *port; //!&lt; Pointer to Serial class object&#xD;&#xA;      uint8_t u8id; //!&lt;0=master, 1..247=slave number&#xD;&#xA;      uint8_t u8serno; //!&lt;serial port: 0-Serial, 1..3-Serial1..Serial3&#xD;&#xA;      uint8_t u8txenpin; //!&lt;flow control pin: 0=USB or RS-232 mode, &gt;0=RS-485 mode&#xD;&#xA;      uint8_t u8state;&#xD;&#xA;      uint8_t au8Buffer[MAX_BUFFER];&#xD;&#xA;      uint8_t u8BufferSize;&#xD;&#xA;      uint8_t u8lastRec;&#xD;&#xA;      uint16_t *au16regs;&#xD;&#xA;      uint16_t u16InCnt, u16OutCnt, u16errCnt;&#xD;&#xA;      uint16_t u16timeOut;&#xD;&#xA;      uint32_t u32time, u32timeOut;&#xD;&#xA;      uint8_t u8regsize;&#xD;&#xA;    &#xD;&#xA;      void init(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin);&#xD;&#xA;      void sendTxBuffer(); // transmit buffer to serial port&#xD;&#xA;      int8_t getRxBuffer(); // get serial buffer contents&#xD;&#xA;      uint16_t calcCRC(uint8_t u8length); // get CRC from au8Buffer until u8length&#xD;&#xA;      uint8_t validateAnswer();&#xD;&#xA;      uint8_t validateRequest(); // validate master request&#xD;&#xA;      void get_FC1(); // *** only master ***&#xD;&#xA;      void get_FC3(); // *** only master ***&#xD;&#xA;      int8_t process_FC1( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC3( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC5( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC6( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC15( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC16( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      void buildException( uint8_t u8exception ); // build exception message&#xD;&#xA;    &#xD;&#xA;    public:&#xD;&#xA;      Modbus(); // !&lt; Default Constructor&#xD;&#xA;      Modbus(uint8_t u8id, uint8_t u8serno); // !&lt; Constructor&#xD;&#xA;      Modbus(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin); // !&lt; Full Constructor&#xD;&#xA;      void begin(long u32speed);&#xD;&#xA;      void begin();&#xD;&#xA;      void setTimeOut( uint16_t u16timeout); //!&lt; write communication watch-dog timer&#xD;&#xA;      uint16_t getTimeOut(); //!&lt; get communication watch-dog timer value&#xD;&#xA;      boolean getTimeOutState(); //!&lt; get communication watch-dog timer state&#xD;&#xA;      int8_t query( modbus_t telegram ); //!&lt; only for master&#xD;&#xA;      int8_t poll(); //!&lt; cyclic poll for master&#xD;&#xA;      int8_t poll( uint16_t *regs, uint8_t u8size ); //!&lt; cyclic poll for slave&#xD;&#xA;      uint16_t getInCnt(); //!&lt; number of incoming messages&#xD;&#xA;      uint16_t getOutCnt(); //!&lt; number of outcoming messages&#xD;&#xA;      uint16_t getErrCnt(); //!&lt; error counter&#xD;&#xA;      uint8_t getID(); //!&lt; get slave ID between 1 and 247&#xD;&#xA;      uint8_t getState();&#xD;&#xA;      uint8_t getLastError(); //!&lt; get last error message&#xD;&#xA;      void setID( uint8_t u8id ); //!&lt; write new ID for the slave&#xD;&#xA;      void end(); //!&lt; finish any communication and release serial communication port&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus() {&#xD;&#xA;      init(0, 0, 0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus(uint8_t u8id, uint8_t u8serno) {&#xD;&#xA;      init(u8id, u8serno, 0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin) {&#xD;&#xA;      init(u8id, u8serno, u8txenpin);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::begin(long u32speed) {&#xD;&#xA;    &#xD;&#xA;      switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;      case 1:&#xD;&#xA;        port = &amp;Serial1;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;      case 2:&#xD;&#xA;        port = &amp;Serial2;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;      case 3:&#xD;&#xA;        port = &amp;Serial3;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;      case 0:&#xD;&#xA;      default:&#xD;&#xA;        port = &amp;Serial;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // port-&gt;begin(u32speed, u8config);&#xD;&#xA;      port-&gt;begin(u32speed);&#xD;&#xA;      if (u8txenpin &gt; 1) { // pin 0 &amp; pin 1 are reserved for RX/TX&#xD;&#xA;        // return RS485 transceiver to transmit mode&#xD;&#xA;        pinMode(u8txenpin, OUTPUT);&#xD;&#xA;        digitalWrite(u8txenpin, LOW);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      port-&gt;flush();&#xD;&#xA;      u8lastRec = u8BufferSize = 0;&#xD;&#xA;      u16InCnt = u16OutCnt = u16errCnt = 0;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::begin() {&#xD;&#xA;      begin(19200);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void Modbus::setID( uint8_t u8id) {&#xD;&#xA;      if (( u8id != 0) &amp;&amp; (u8id &lt;= 247)) {&#xD;&#xA;        this-&gt;u8id = u8id;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::getID() {&#xD;&#xA;      return this-&gt;u8id;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::setTimeOut( uint16_t u16timeOut) {&#xD;&#xA;      this-&gt;u16timeOut = u16timeOut;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    boolean Modbus::getTimeOutState() {&#xD;&#xA;      return (millis() &gt; u32timeOut);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getInCnt() {&#xD;&#xA;      return u16InCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getOutCnt() {&#xD;&#xA;      return u16OutCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getErrCnt() {&#xD;&#xA;      return u16errCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::getState() {&#xD;&#xA;      return u8state;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::query( modbus_t telegram ) {&#xD;&#xA;      uint8_t u8regsno, u8bytesno;&#xD;&#xA;      if (u8id != 0) return -2;&#xD;&#xA;      if (u8state != COM_IDLE) return -1;&#xD;&#xA;    &#xD;&#xA;      if ((telegram.u8id == 0) || (telegram.u8id &gt; 247)) return -3;&#xD;&#xA;    &#xD;&#xA;      au16regs = telegram.au16reg;&#xD;&#xA;    &#xD;&#xA;      // telegram header&#xD;&#xA;      au8Buffer[ ID ]         = telegram.u8id;&#xD;&#xA;      au8Buffer[ FUNC ]       = telegram.u8fct;&#xD;&#xA;      au8Buffer[ ADD_HI ]     = highByte(telegram.u16RegAdd );&#xD;&#xA;      au8Buffer[ ADD_LO ]     = lowByte( telegram.u16RegAdd );&#xD;&#xA;    &#xD;&#xA;      switch ( telegram.u8fct ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;      case MB_FC_READ_REGISTERS:&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        au8Buffer[ NB_HI ]      = ((au16regs[0] &gt; 0) ? 0xff : 0);&#xD;&#xA;        au8Buffer[ NB_LO ]      = 0;&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(au16regs[0]);&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte(au16regs[0]);&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        u8regsno = telegram.u16CoilsNo / 16;&#xD;&#xA;        u8bytesno = u8regsno * 2;&#xD;&#xA;        if ((telegram.u16CoilsNo % 16) != 0) {&#xD;&#xA;          u8bytesno++;&#xD;&#xA;          u8regsno++;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO + 1 ]    = u8bytesno;&#xD;&#xA;        u8BufferSize = 7;&#xD;&#xA;    &#xD;&#xA;        u8regsno = u8bytesno = 0; // now auxiliary registers&#xD;&#xA;        for (uint16_t i = 0; i &lt; telegram.u16CoilsNo; i++) {&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;        break;&#xD;&#xA;    &#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO + 1 ]    = (uint8_t) ( telegram.u16CoilsNo * 2 );&#xD;&#xA;        u8BufferSize = 7;&#xD;&#xA;    &#xD;&#xA;        for (uint16_t i = 0; i &lt; telegram.u16CoilsNo; i++) {&#xD;&#xA;          au8Buffer[ u8BufferSize ] = highByte( au16regs[ i ] );&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;          au8Buffer[ u8BufferSize ] = lowByte( au16regs[ i ] );&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;        }&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      u8state = COM_WAITING;&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::poll() {&#xD;&#xA;      // check if there is any incoming frame&#xD;&#xA;      uint8_t u8current = port-&gt;available();&#xD;&#xA;    &#xD;&#xA;      if (millis() &gt; u32timeOut) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      if (u8current == 0) return 0;&#xD;&#xA;    &#xD;&#xA;      // check T35 after frame end or still no frame end&#xD;&#xA;      if (u8current != u8lastRec) {&#xD;&#xA;        u8lastRec = u8current;&#xD;&#xA;        u32time = millis() + T35;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;      if (millis() &lt; u32time) return 0;&#xD;&#xA;    &#xD;&#xA;      // transfer Serial buffer frame to auBuffer&#xD;&#xA;      u8lastRec = 0;&#xD;&#xA;      int8_t i8state = getRxBuffer();&#xD;&#xA;      if (i8state &lt; 7) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return i8state;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // validate message: id, CRC, FCT, exception&#xD;&#xA;      uint8_t u8exception = validateAnswer();&#xD;&#xA;      if (u8exception != 0) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        return u8exception;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // process answer&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;        // call get_FC1 to transfer the incoming message to au16regs buffer&#xD;&#xA;        get_FC1( );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;        // call get_FC3 to transfer the incoming message to au16regs buffer&#xD;&#xA;        get_FC3( );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        // nothing to do&#xD;&#xA;        break;&#xD;&#xA;      default:&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      u8state = COM_IDLE;&#xD;&#xA;      return u8BufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::poll( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      au16regs = regs;&#xD;&#xA;      u8regsize = u8size;&#xD;&#xA;    &#xD;&#xA;      // check if there is any incoming frame&#xD;&#xA;      uint8_t u8current = port-&gt;available();&#xD;&#xA;      if (u8current == 0) return 0;&#xD;&#xA;    &#xD;&#xA;      // check T35 after frame end or still no frame end&#xD;&#xA;      if (u8current != u8lastRec) {&#xD;&#xA;        u8lastRec = u8current;&#xD;&#xA;        u32time = millis() + T35;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;      if (millis() &lt; u32time) return 0;&#xD;&#xA;    &#xD;&#xA;      u8lastRec = 0;&#xD;&#xA;      int8_t i8state = getRxBuffer();&#xD;&#xA;      if (i8state &lt; 7) return i8state;&#xD;&#xA;    &#xD;&#xA;      // check slave id&#xD;&#xA;      if (au8Buffer[ ID ] != u8id) return 0;&#xD;&#xA;    &#xD;&#xA;      // validate message: CRC, FCT, address and size&#xD;&#xA;      uint8_t u8exception = validateRequest();&#xD;&#xA;      if (u8exception &gt; 0) {&#xD;&#xA;        if (u8exception != NO_REPLY) {&#xD;&#xA;          buildException( u8exception );&#xD;&#xA;          sendTxBuffer();&#xD;&#xA;        }&#xD;&#xA;        return u8exception;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      u32timeOut = millis() + long(u16timeOut);&#xD;&#xA;    &#xD;&#xA;      // process message&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;        return process_FC1( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;        return process_FC3( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        return process_FC5( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;        return process_FC6( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        return process_FC15( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        return process_FC16( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      default:&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /* _____PRIVATE FUNCTIONS_____________________________________________________ */&#xD;&#xA;    &#xD;&#xA;    void Modbus::init(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin) {&#xD;&#xA;      this-&gt;u8id = u8id;&#xD;&#xA;      this-&gt;u8serno = (u8serno &gt; 3) ? 0 : u8serno;&#xD;&#xA;      this-&gt;u8txenpin = u8txenpin;&#xD;&#xA;      this-&gt;u16timeOut = 1000;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::getRxBuffer() {&#xD;&#xA;      boolean bBuffOverflow = false;&#xD;&#xA;    &#xD;&#xA;      if (u8txenpin &gt; 1) digitalWrite( u8txenpin, LOW );&#xD;&#xA;    &#xD;&#xA;      u8BufferSize = 0;&#xD;&#xA;      while ( port-&gt;available() ) {&#xD;&#xA;        au8Buffer[ u8BufferSize ] = port-&gt;read();&#xD;&#xA;        u8BufferSize ++;&#xD;&#xA;    &#xD;&#xA;        if (u8BufferSize &gt;= MAX_BUFFER) bBuffOverflow = true;&#xD;&#xA;      }&#xD;&#xA;      u16InCnt++;&#xD;&#xA;    &#xD;&#xA;      if (bBuffOverflow) {&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return ERR_BUFF_OVERFLOW;&#xD;&#xA;      }&#xD;&#xA;      return u8BufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::sendTxBuffer() {&#xD;&#xA;      uint8_t i = 0;&#xD;&#xA;    &#xD;&#xA;      // append CRC to message&#xD;&#xA;      uint16_t u16crc = calcCRC( u8BufferSize );&#xD;&#xA;      au8Buffer[ u8BufferSize ] = u16crc &gt;&gt; 8;&#xD;&#xA;      u8BufferSize++;&#xD;&#xA;      au8Buffer[ u8BufferSize ] = u16crc &amp; 0x00ff;&#xD;&#xA;      u8BufferSize++;&#xD;&#xA;    &#xD;&#xA;      // set RS485 transceiver to transmit mode&#xD;&#xA;      if (u8txenpin &gt; 1) {&#xD;&#xA;        switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;        case 1:&#xD;&#xA;          UCSR1A = UCSR1A | (1 &lt;&lt; TXC1);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;        case 2:&#xD;&#xA;          UCSR2A = UCSR2A | (1 &lt;&lt; TXC2);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;        case 3:&#xD;&#xA;          UCSR3A = UCSR3A | (1 &lt;&lt; TXC3);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;        case 0:&#xD;&#xA;        default:&#xD;&#xA;          UCSR0A = UCSR0A | (1 &lt;&lt; TXC0);&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;        digitalWrite( u8txenpin, HIGH );&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // transfer buffer to serial line&#xD;&#xA;      port-&gt;write( au8Buffer, u8BufferSize );&#xD;&#xA;    &#xD;&#xA;      // keep RS485 transceiver in transmit mode as long as sending&#xD;&#xA;      if (u8txenpin &gt; 1) {&#xD;&#xA;        switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;        case 1:&#xD;&#xA;          while (!(UCSR1A &amp; (1 &lt;&lt; TXC1)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;        case 2:&#xD;&#xA;          while (!(UCSR2A &amp; (1 &lt;&lt; TXC2)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;        case 3:&#xD;&#xA;          while (!(UCSR3A &amp; (1 &lt;&lt; TXC3)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;        case 0:&#xD;&#xA;        default:&#xD;&#xA;          while (!(UCSR0A &amp; (1 &lt;&lt; TXC0)));&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        // return RS485 transceiver to receive mode&#xD;&#xA;        digitalWrite( u8txenpin, LOW );&#xD;&#xA;      }&#xD;&#xA;      port-&gt;flush();&#xD;&#xA;      u8BufferSize = 0;&#xD;&#xA;    &#xD;&#xA;      // set time-out for master&#xD;&#xA;      u32timeOut = millis() + (unsigned long) u16timeOut;&#xD;&#xA;    &#xD;&#xA;      // increase message counter&#xD;&#xA;      u16OutCnt++;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /**&#xD;&#xA;     * @brief&#xD;&#xA;     * This method calculates CRC&#xD;&#xA;     *&#xD;&#xA;     * @return uint16_t calculated CRC value for the message&#xD;&#xA;     * @ingroup buffer&#xD;&#xA;     */&#xD;&#xA;    uint16_t Modbus::calcCRC(uint8_t u8length) {&#xD;&#xA;      unsigned int temp, temp2, flag;&#xD;&#xA;      temp = 0xFFFF;&#xD;&#xA;      for (unsigned char i = 0; i &lt; u8length; i++) {&#xD;&#xA;        temp = temp ^ au8Buffer[i];&#xD;&#xA;        for (unsigned char j = 1; j &lt;= 8; j++) {&#xD;&#xA;          flag = temp &amp; 0x0001;&#xD;&#xA;          temp &gt;&gt;= 1;&#xD;&#xA;          if (flag)&#xD;&#xA;            temp ^= 0xA001;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      // Reverse byte order.&#xD;&#xA;      temp2 = temp &gt;&gt; 8;&#xD;&#xA;      temp = (temp &lt;&lt; 8) | temp2;&#xD;&#xA;      temp &amp;= 0xFFFF;&#xD;&#xA;      // the returned value is already swapped&#xD;&#xA;      // crcLo byte is first &amp; crcHi byte is last&#xD;&#xA;      return temp;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::validateRequest() {&#xD;&#xA;      // check message crc vs calculated crc&#xD;&#xA;      uint16_t u16MsgCRC =&#xD;&#xA;        ((au8Buffer[u8BufferSize - 2] &lt;&lt; 8)&#xD;&#xA;        | au8Buffer[u8BufferSize - 1]); // combine the crc Low &amp; High bytes&#xD;&#xA;      if ( calcCRC( u8BufferSize - 2 ) != u16MsgCRC ) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return NO_REPLY;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check fct code&#xD;&#xA;      boolean isSupported = false;&#xD;&#xA;      for (uint8_t i = 0; i &lt; sizeof( fctsupported ); i++) {&#xD;&#xA;        if (fctsupported[i] == au8Buffer[FUNC]) {&#xD;&#xA;          isSupported = 1;&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      if (!isSupported) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return EXC_FUNC_CODE;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check start address &amp; nb range&#xD;&#xA;      uint16_t u16regs = 0;&#xD;&#xA;      uint8_t u8regs;&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]) / 16;&#xD;&#xA;        u16regs += word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ]) / 16;&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]) / 16;&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]);&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER :&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]);&#xD;&#xA;        u16regs += word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ]);&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      return 0; // OK, no exception code thrown&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::validateAnswer() {&#xD;&#xA;      // check message crc vs calculated crc&#xD;&#xA;      uint16_t u16MsgCRC =&#xD;&#xA;        ((au8Buffer[u8BufferSize - 2] &lt;&lt; 8)&#xD;&#xA;        | au8Buffer[u8BufferSize - 1]); // combine the crc Low &amp; High bytes&#xD;&#xA;      if ( calcCRC( u8BufferSize - 2 ) != u16MsgCRC ) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return NO_REPLY;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check exception&#xD;&#xA;      if ((au8Buffer[ FUNC ] &amp; 0x80) != 0) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return ERR_EXCEPTION;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check fct code&#xD;&#xA;      boolean isSupported = false;&#xD;&#xA;      for (uint8_t i = 0; i &lt; sizeof( fctsupported ); i++) {&#xD;&#xA;        if (fctsupported[i] == au8Buffer[FUNC]) {&#xD;&#xA;          isSupported = 1;&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      if (!isSupported) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return EXC_FUNC_CODE;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      return 0; // OK, no exception code thrown&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::buildException( uint8_t u8exception ) {&#xD;&#xA;      uint8_t u8func = au8Buffer[ FUNC ];  // get the original FUNC code&#xD;&#xA;    &#xD;&#xA;      au8Buffer[ ID ]      = u8id;&#xD;&#xA;      au8Buffer[ FUNC ]    = u8func + 0x80;&#xD;&#xA;      au8Buffer[ 2 ]       = u8exception;&#xD;&#xA;      u8BufferSize         = EXCEPTION_SIZE;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::get_FC1() {&#xD;&#xA;      uint8_t u8byte, i;&#xD;&#xA;      u8byte = 0;&#xD;&#xA;    &#xD;&#xA;      // check the answer length&#xD;&#xA;      boolean bEvenOdd =&#xD;&#xA;        ( au8Buffer[ ADD_HI ] % 2 == 0) ?&#xD;&#xA;      false :&#xD;&#xA;      true;&#xD;&#xA;    &#xD;&#xA;      uint8_t u8WordsNo =&#xD;&#xA;        ( !bEvenOdd ) ?&#xD;&#xA;      au8Buffer[ ADD_HI ] / 2 :&#xD;&#xA;      au8Buffer[ ADD_HI ] / 2 + 1;&#xD;&#xA;    &#xD;&#xA;      for (i = 0; i &lt; u8WordsNo; i++) {&#xD;&#xA;        au16regs[ i ] = word(&#xD;&#xA;        au8Buffer[ u8byte ],&#xD;&#xA;        au8Buffer[ u8byte + 1 ]);&#xD;&#xA;        u8byte += 2;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // cut last byte&#xD;&#xA;      if (bEvenOdd) {&#xD;&#xA;        au16regs[ u8WordsNo - 1 ] &amp;= 0xff00;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void Modbus::get_FC3() {&#xD;&#xA;      uint8_t u8byte, i;&#xD;&#xA;      u8byte = 3;&#xD;&#xA;    &#xD;&#xA;      for (i = 0; i &lt; au8Buffer[ 2 ] / 2; i++) {&#xD;&#xA;        au16regs[ i ] = word(&#xD;&#xA;        au8Buffer[ u8byte ],&#xD;&#xA;        au8Buffer[ u8byte + 1 ]);&#xD;&#xA;        u8byte += 2;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC1( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit, u8bytesno, u8bitsno;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16currentCoil, u16coil;&#xD;&#xA;    &#xD;&#xA;      // get the first and last coil from the message&#xD;&#xA;      uint16_t u16StartCoil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint16_t u16Coilno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;      // put the number of bytes in the outcoming message&#xD;&#xA;      u8bytesno = (uint8_t) (u16Coilno / 8);&#xD;&#xA;      if (u16Coilno % 8 != 0) u8bytesno ++;&#xD;&#xA;      au8Buffer[ ADD_HI ]  = u8bytesno;&#xD;&#xA;      u8BufferSize         = ADD_LO;&#xD;&#xA;    &#xD;&#xA;      // read each coil from the register map and put its value inside the outcoming message&#xD;&#xA;      u8bitsno = 0;&#xD;&#xA;    &#xD;&#xA;      for (u16currentCoil = 0; u16currentCoil &lt; u16Coilno; u16currentCoil++) {&#xD;&#xA;        u16coil = u16StartCoil + u16currentCoil;&#xD;&#xA;        u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;        u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;        bitWrite(&#xD;&#xA;        au8Buffer[ u8BufferSize ],&#xD;&#xA;        u8bitsno,&#xD;&#xA;        bitRead( regs[ u8currentRegister ], u8currentBit ) );&#xD;&#xA;        u8bitsno ++;&#xD;&#xA;    &#xD;&#xA;        if (u8bitsno &gt; 7) {&#xD;&#xA;          u8bitsno = 0;&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // send outcoming message&#xD;&#xA;      if (u16Coilno % 8 != 0) u8BufferSize ++;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC3( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      uint8_t u8StartAdd = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint8_t u8regsno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint8_t i;&#xD;&#xA;    &#xD;&#xA;      au8Buffer[ 2 ]       = u8regsno * 2;&#xD;&#xA;      u8BufferSize         = 3;&#xD;&#xA;    &#xD;&#xA;      for (i = u8StartAdd; i &lt; u8StartAdd + u8regsno; i++) {&#xD;&#xA;        au8Buffer[ u8BufferSize ] = highByte(regs[i]);&#xD;&#xA;        u8BufferSize++;&#xD;&#xA;        au8Buffer[ u8BufferSize ] = lowByte(regs[i]);&#xD;&#xA;        u8BufferSize++;&#xD;&#xA;      }&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC5( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16coil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;    &#xD;&#xA;      // point to the register and its bit&#xD;&#xA;      u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;      u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;      // write to coil&#xD;&#xA;      bitWrite(&#xD;&#xA;      regs[ u8currentRegister ],&#xD;&#xA;      u8currentBit,&#xD;&#xA;      au8Buffer[ NB_HI ] == 0xff );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // send answer to master&#xD;&#xA;      u8BufferSize = 6;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC6( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      uint8_t u8add = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16val = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;      regs[ u8add ] = u16val;&#xD;&#xA;    &#xD;&#xA;      // keep the same header&#xD;&#xA;      u8BufferSize         = RESPONSE_SIZE;&#xD;&#xA;    &#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC15( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit, u8frameByte, u8bitsno;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16currentCoil, u16coil;&#xD;&#xA;      boolean bTemp;&#xD;&#xA;    &#xD;&#xA;      // get the first and last coil from the message&#xD;&#xA;      uint16_t u16StartCoil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint16_t u16Coilno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // read each coil from the register map and put its value inside the outcoming message&#xD;&#xA;      u8bitsno = 0;&#xD;&#xA;      u8frameByte = 7;&#xD;&#xA;      for (u16currentCoil = 0; u16currentCoil &lt; u16Coilno; u16currentCoil++) {&#xD;&#xA;    &#xD;&#xA;        u16coil = u16StartCoil + u16currentCoil;&#xD;&#xA;        u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;        u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;        bTemp = bitRead(&#xD;&#xA;        au8Buffer[ u8frameByte ],&#xD;&#xA;        u8bitsno );&#xD;&#xA;    &#xD;&#xA;        bitWrite(&#xD;&#xA;        regs[ u8currentRegister ],&#xD;&#xA;        u8currentBit,&#xD;&#xA;        bTemp );&#xD;&#xA;    &#xD;&#xA;        u8bitsno ++;&#xD;&#xA;    &#xD;&#xA;        if (u8bitsno &gt; 7) {&#xD;&#xA;          u8bitsno = 0;&#xD;&#xA;          u8frameByte++;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // send outcoming message&#xD;&#xA;      // it's just a copy of the incomping frame until 6th byte&#xD;&#xA;      u8BufferSize         = 6;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC16( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8func = au8Buffer[ FUNC ];  // get the original FUNC code&#xD;&#xA;      uint8_t u8StartAdd = au8Buffer[ ADD_HI ] &lt;&lt; 8 | au8Buffer[ ADD_LO ];&#xD;&#xA;      uint8_t u8regsno = au8Buffer[ NB_HI ] &lt;&lt; 8 | au8Buffer[ NB_LO ];&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint8_t i;&#xD;&#xA;      uint16_t temp;&#xD;&#xA;    &#xD;&#xA;      // build header&#xD;&#xA;      au8Buffer[ NB_HI ]   = 0;&#xD;&#xA;      au8Buffer[ NB_LO ]   = u8regsno;&#xD;&#xA;      u8BufferSize         = RESPONSE_SIZE;&#xD;&#xA;    &#xD;&#xA;      // write registers&#xD;&#xA;      for (i = 0; i &lt; u8regsno; i++) {&#xD;&#xA;        temp = word(&#xD;&#xA;        au8Buffer[ (BYTE_CNT + 1) + i * 2 ],&#xD;&#xA;        au8Buffer[ (BYTE_CNT + 2) + i * 2 ]);&#xD;&#xA;    &#xD;&#xA;        regs[ u8StartAdd + i ] = temp;&#xD;&#xA;      }&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/eglU2.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/bphiY.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/wwfhW.jpg" />
  <row Id="3074" PostHistoryTypeId="2" PostId="1087" RevisionGUID="b3291351-8043-4384-810e-457b86094aaa" CreationDate="2014-04-05T00:04:48.990" UserId="938" Text="I am new to arduino, however I have experience in web development, lately I have been using, meteor js and the mean stack for different projects. I am open to trying any language though.&#xD;&#xA;&#xD;&#xA;What I am trying to do is build a simple application to control the led on the arduino over the web.&#xD;&#xA;&#xD;&#xA;I am working with another person and the arduino will be behind a firewall so I am not sure how to access it via the internet. I do have access to a arduino yun that I can use for testing at home which does have linio connected via bridge, which I dont quite understand what that does.&#xD;&#xA;&#xD;&#xA;Ive also heard of this, https://www.yaler.net/ but would like to stay away from third party builds as much as possible if I can do it myself.&#xD;&#xA;&#xD;&#xA;Whats the common way to do this with a arduino behind a firewall. and how do i do this with a arduino yun, is it easier with a yun?" />
  <row Id="3075" PostHistoryTypeId="1" PostId="1087" RevisionGUID="b3291351-8043-4384-810e-457b86094aaa" CreationDate="2014-04-05T00:04:48.990" UserId="938" Text="arduino and node.js" />
  <row Id="3076" PostHistoryTypeId="3" PostId="1087" RevisionGUID="b3291351-8043-4384-810e-457b86094aaa" CreationDate="2014-04-05T00:04:48.990" UserId="938" Text="&lt;arduino-yun&gt;&lt;web-server&gt;" />
  <row Id="3077" PostHistoryTypeId="5" PostId="1087" RevisionGUID="5bd3f299-67a8-468e-afc4-d229aa33e7b9" CreationDate="2014-04-05T00:36:32.660" UserId="220" Comment="Improved formatting" Text="I am new to Arduino, however I have experience in web development, lately I have been using, meteor js and the mean stack for different projects. However, I am open to trying any language for development.&#xD;&#xA;&#xD;&#xA;What I am trying to do is build a simple application to control the LED on the Arduino over the web.&#xD;&#xA;&#xD;&#xA;I am working with another person, and the Arduino will be behind a firewall so I am not sure how to access it via the internet. I do have access to an Arduino Uun that I can use for testing at home which does have linio connected via bridge, which I don't quite understand what that does.&#xD;&#xA;&#xD;&#xA;I've also heard of [this](https://www.yaler.net/), but would like to stay away from third party builds as much as possible if I can do it myself.&#xD;&#xA;&#xD;&#xA;Whats the common way to do this with an Arduino behind a firewall? How do I do this with a Arduino Yun? Is it easier with a Yun?" />
  <row Id="3078" PostHistoryTypeId="4" PostId="1087" RevisionGUID="5bd3f299-67a8-468e-afc4-d229aa33e7b9" CreationDate="2014-04-05T00:36:32.660" UserId="220" Comment="Improved formatting" Text="How do I use Arduino and node.js?" />
  <row Id="3079" PostHistoryTypeId="2" PostId="1088" RevisionGUID="4b9dd43d-b652-4ff4-84ce-3bcdcea10d48" CreationDate="2014-04-05T01:35:48.523" UserId="643" Text="first of all you need to have clear what you need to do.&#xD;&#xA;Arduino UNO is just a microcontroller with a serial (over USB) connection.&#xD;&#xA;To make your arduino accessible from the internet, it need to be connected with the internet, or to have something that act like a bridge.&#xD;&#xA;You can use an ethernet shield, a wifi shiled, or a YUN witch is an arduino UNO + a micro linux with has ethernet and wifi (programmable in phyton, or the chip can command the linux sending command to bash shell using the special bridge library)&#xD;&#xA;You can even connect arduin on the pc by usb and create a bridge program, or, if your firewall/router is a unlocked linux/similar, you can use it.&#xD;&#xA;&#xD;&#xA;How many option, and we event startint to decide how o talk with it. As you want to use node.sj, you can use socket or get/post.&#xD;&#xA;Using socket is faster, lighter, and can create a pull connection, and js wil be a requisite. With get/post you don't even need js, pure html form will do.&#xD;&#xA;&#xD;&#xA;then, after you decided witch sistem you like (arduino as http server or plain socket) you can open the corresponding port on the firewall/nat. but is just the last part" />
  <row Id="3080" PostHistoryTypeId="2" PostId="1089" RevisionGUID="6520e15a-c55d-43d9-b3dd-e2b758b8cf6e" CreationDate="2014-04-05T10:20:51.800" UserId="939" Text="I am working on similar project that uses internet to communicate with external device (mobile). I am reading data from sensors and passing them over the web with web sockets. I am using Arduino Yun for this project and Spacebrew (for web sockets communication). It's very interesting approach but quite a challenge in some cases. You will probably run into asynchronous/synchronous problem, which then lead me to running some python scripts on Yun triggered from Processing code. I am currently running Spacebrew server on my VPN, so I can connect my Yun left at home and use my iphone from everywhere to get the readings.&#xD;&#xA;&#xD;&#xA;Check out these links:&#xD;&#xA;&#xD;&#xA;     - docs.spacebrew.cc/&#xD;&#xA;     - github.com/Spacebrew/pySpacebrew&#xD;&#xA;     - github.com/julioterra/yunSpacebrew&#xD;&#xA;&#xD;&#xA;Yun has also build in Temboo library, it's a great way to start experimenting, once you prove the concept you can start narrowing your environment and moving away if you don't want to use 3rd parties software.&#xD;&#xA;&#xD;&#xA;     - www.temboo.com/arduino&#xD;&#xA;&#xD;&#xA;You can also run node.js on the Yun itself, here's good article and some packager ready to install:&#xD;&#xA;&#xD;&#xA;     - giorgiocefaro.com/blog/installing-node-js-on-arduino-yun&#xD;&#xA;&#xD;&#xA;You also asked about Bridge library. As you know Yun has two processors on board, one is running your Processing code, the other one has Linux on it (Linino). Bridge basically simplifies communication between them so they can &quot;talk&quot; to eachother, more here:&#xD;&#xA;&#xD;&#xA;     - arduino.cc/en/Reference/YunBridgeLibrary&#xD;&#xA;&#xD;&#xA;Hope that this helps. I would start with Temboo if I were you, it's a great learning curve and quite simple step to start. You will also learn and understand how the board works and how you can communicate with &quot;external world&quot;. Once you have proof of concept, start experimenting with different libraries and improving the approach.&#xD;&#xA;&#xD;&#xA;(PS. Sorry for not clickable links but I don't have enough reputation to post more than 2 urls)" />
  <row Id="3081" PostHistoryTypeId="2" PostId="1090" RevisionGUID="f5a6e47b-d94e-499d-b8e9-951f3af41d6e" CreationDate="2014-04-05T10:31:35.223" UserId="939" Text="I am using Yun as well for my projects. I don't boot from SD card, but I store a lot of Python code there and it works for me. I've also seen this article that might be interesting for you. I haven't tried to do it on my Yun but I think it should work... This is example how to install node.js on the Yun (SD card), so in theory you could use the same approach for all additional software you want to run.&#xD;&#xA;&#xD;&#xA;[http://linino.org/doku.php?id=wiki:nodejs][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://linino.org/doku.php?id=wiki:nodejs" />
  <row Id="3085" PostHistoryTypeId="5" PostId="1089" RevisionGUID="49e6a2d6-0157-4173-912d-58aac72e882f" CreationDate="2014-04-05T14:11:31.807" UserId="939" Comment="typo" Text="I am working on similar project that uses internet to communicate with external device (mobile). I am reading data from sensors and passing them over the web with web sockets. I am using Arduino Yun for this project and Spacebrew (for web sockets communication). It's very interesting approach but quite a challenge in some cases. You will probably run into asynchronous/synchronous problem, which then lead me to running some python scripts on Yun triggered from Processing code. I am currently running Spacebrew server on my VPN, so I can connect my Yun left at home and use my iphone from everywhere to get the readings.&#xD;&#xA;&#xD;&#xA;Check out these links:&#xD;&#xA;&#xD;&#xA;     - docs.spacebrew.cc/&#xD;&#xA;     - github.com/Spacebrew/pySpacebrew&#xD;&#xA;     - github.com/julioterra/yunSpacebrew&#xD;&#xA;&#xD;&#xA;Yun has also build in Temboo library, it's a great way to start experimenting, once you prove the concept you can start narrowing your environment and moving away if you don't want to use 3rd parties software.&#xD;&#xA;&#xD;&#xA;     - www.temboo.com/arduino&#xD;&#xA;&#xD;&#xA;You can also run node.js on the Yun itself, here's good article and some packages ready to install:&#xD;&#xA;&#xD;&#xA;     - giorgiocefaro.com/blog/installing-node-js-on-arduino-yun&#xD;&#xA;&#xD;&#xA;You also asked about Bridge library. As you know Yun has two processors on board, one is running your Processing code, the other one has Linux on it (Linino). Bridge basically simplifies communication between them so they can &quot;talk&quot; to eachother, more here:&#xD;&#xA;&#xD;&#xA;     - arduino.cc/en/Reference/YunBridgeLibrary&#xD;&#xA;&#xD;&#xA;Hope that this helps. I would start with Temboo if I were you, it's a great learning curve and quite simple step to start. You will also learn and understand how the board works and how you can communicate with &quot;external world&quot;. Once you have proof of concept, start experimenting with different libraries and improving the approach.&#xD;&#xA;&#xD;&#xA;(PS. Sorry for not clickable links but I don't have enough reputation to post more than 2 urls)" />
  <row Id="3086" PostHistoryTypeId="5" PostId="1089" RevisionGUID="c505f66b-0d7a-4455-9dab-bee94b805b88" CreationDate="2014-04-05T15:12:21.880" UserId="220" Comment="Linked links because OP doesn't have enough repuation" Text="I am working on similar project that uses internet to communicate with external device (mobile). I am reading data from sensors and passing them over the web with web sockets. I am using Arduino Yun for this project and Spacebrew (for web sockets communication). It's very interesting approach but quite a challenge in some cases. You will probably run into asynchronous/synchronous problem, which then lead me to running some python scripts on Yun triggered from Processing code. I am currently running Spacebrew server on my VPN, so I can connect my Yun left at home and use my iphone from everywhere to get the readings.&#xD;&#xA;&#xD;&#xA;Check out these links:&#xD;&#xA;&#xD;&#xA; - &lt;http://docs.spacebrew.cc/&gt;&#xD;&#xA; - &lt;http://github.com/Spacebrew/pySpacebrew&gt;&#xD;&#xA; - &lt;http://github.com/julioterra/yunSpacebrew&gt;&#xD;&#xA;&#xD;&#xA;Yun has also build in Temboo library, it's a great way to start experimenting, once you prove the concept you can start narrowing your environment and moving away if you don't want to use 3rd parties software.&#xD;&#xA;&#xD;&#xA; - &lt;http://www.temboo.com/arduino&gt;&#xD;&#xA;&#xD;&#xA;You can also run node.js on the Yun itself, here's good article and some packages ready to install:&#xD;&#xA;&#xD;&#xA; - &lt;http://giorgiocefaro.com/blog/installing-node-js-on-arduino-yun&gt;&#xD;&#xA;&#xD;&#xA;You also asked about Bridge library. As you know Yun has two processors on board, one is running your Processing code, the other one has Linux on it (Linino). Bridge basically simplifies communication between them so they can &quot;talk&quot; to eachother, more here:&#xD;&#xA;&#xD;&#xA; - &lt;http://arduino.cc/en/Reference/YunBridgeLibrary&gt;&#xD;&#xA;&#xD;&#xA;I would start with Temboo if I were you, it's a great learning curve and quite simple step to start. You will also learn and understand how the board works and how you can communicate with &quot;external world&quot;. Once you have proof of concept, start experimenting with different libraries and improving the approach." />
  <row Id="3087" PostHistoryTypeId="5" PostId="1089" RevisionGUID="275599af-a386-44a7-8ccb-1780ad6fefed" CreationDate="2014-04-05T19:04:01.747" UserId="939" Comment="extended answer to provide more information in one place instead of links (as advised in the comment)" Text="I am working on similar project that uses internet to communicate with external device (mobile). I am reading data from sensors and passing them over the web with web sockets. I am using Arduino Yun for this project and Spacebrew (for web sockets communication). It's very interesting approach but quite a challenge in some cases. You will probably run into asynchronous/synchronous problem, which in my case lead me to running some Python scripts on Yun triggered from Processing code. I am currently running Spacebrew server on my VPN, so I can connect my Yun left at home and use my iphone from everywhere to get the readings.&#xD;&#xA;&#xD;&#xA;It's also worth mentioning Yun comes with pre-installed Temboo library, which is great starting point for web communication. The configuration is really easy and quick. You will also find official documentation very handy and easy to understand. It's really great starting point for experimenting with web-like applications integrated with Arduino Yun.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;### Spacebrew ###&#xD;&#xA;&#xD;&#xA; - &lt;http://docs.spacebrew.cc/&gt;&#xD;&#xA;&#xD;&#xA;   Spacebrew is an open, dynamically re-routable software toolkit for choreographing interactive spaces. Or, in other words, a simple way to connect interactive things to one another. Every element you hook up to the system can subscribe to, and publish data feeds.&#xD;&#xA;&#xD;&#xA; - &lt;http://github.com/Spacebrew/pySpacebrew&gt;&#xD;&#xA;&#xD;&#xA;   This repo contains the Spacebrew Library for Python along with documentation and example apps.&#xD;&#xA;&#xD;&#xA; - &lt;http://github.com/julioterra/yunSpacebrew&gt;&#xD;&#xA;&#xD;&#xA;   The Spacebrew Yun library features two main components - a set of python scripts that run on the linino, and a library that runs on the atmel chip. You find there information how to install both of these components so that you can connect to Spacebrew from an Arduino sketch.&#xD;&#xA;&#xD;&#xA;### Teboo ###&#xD;&#xA;&#xD;&#xA;Yun has also build in Temboo library, it's a great way to start experimenting, once you prove the concept you can start narrowing your environment and moving away if you don't want to use 3rd parties software.&#xD;&#xA;&#xD;&#xA; - &lt;http://www.temboo.com/arduino&gt;&#xD;&#xA;&#xD;&#xA;   The Temboo Library makes it easy to connect to over 100 web-based resources and services with Processing. Currently you can find libraries for Android, Arduino, iOS, Java, Node.js, PHP, Processing, Python, REST API, Ruby, Twyla&#xD;&#xA;&#xD;&#xA;### Node.js ###&#xD;&#xA;&#xD;&#xA;You can also run node.js on the Yun itself, here's good article and some packages ready to install:&#xD;&#xA;&#xD;&#xA; - &lt;http://giorgiocefaro.com/blog/installing-node-js-on-arduino-yun&gt;&#xD;&#xA; - &lt;https://github.com/giorrrgio/nodejs-linino&gt;&#xD;&#xA;&#xD;&#xA;   This is an openwrt package for node. It probably only works on mips (not mipsel, or arm). It runs an outdated v8 as well.&#xD;&#xA;&#xD;&#xA;### What is Bridge library for Arduino Yun? ###&#xD;&#xA;&#xD;&#xA;You also asked about Bridge library. As you know Yun has two processors on board, one is running your Processing code, the other one has Linux on it (Linino). Bridge basically simplifies communication between them so they can &quot;talk&quot; to eachother, more information here:&#xD;&#xA;&#xD;&#xA; - &lt;http://arduino.cc/en/Reference/YunBridgeLibrary&gt;&#xD;&#xA;&#xD;&#xA;   (Taken from arduino.cc documentation:)&#xD;&#xA;&#xD;&#xA;   The Arduino Yún has two processors on board. One is an ATmega32U4 like on the Arduino Leonardo. The other is an Atheros 9331, running Linux and the OpenWRT wireless stack, which enables the board to connect to WiFi and Ethernet networks. It is possible to call programs or custom scripts on the Linux system through the Arduino to connect with various internet services.&#xD;&#xA;&#xD;&#xA;   The Bridge library simplifies communication between the ATmega32U4 and the AR9331. It inherits from Stream, and many of the methods should be familiar from Serial and other derivatives of Stream.&#xD;&#xA;&#xD;&#xA;   Bridge commands from the 32U4 are interpreted by Python on the AR9331. Its role is to execute programs on the GNU/Linux side when asked by Arduino, provide a shared storage space for sharing data like sensor readings between the Arduino and the Internet, and receiving commands from the Internet and passing them directly to the Arduino.&#xD;&#xA;&#xD;&#xA;   Bridge allows communication in both directions, acting as an interface to the the Linino command line. &#xD;&#xA;&#xD;&#xA;### Where to start? ###&#xD;&#xA;&#xD;&#xA;I would start with Temboo if I were you, it's a great learning curve and quite simple step to start. You will also learn and understand how the board works and how you can communicate with &quot;external world&quot;. Once you have proof of concept, start experimenting with different libraries and improving the approach. Perhaps you will find Spacebrew more handy later or even discover different solutions." />
  <row Id="3090" PostHistoryTypeId="2" PostId="1092" RevisionGUID="fa378035-6caa-4ad3-aae0-536d6698ece8" CreationDate="2014-04-06T00:41:43.590" UserId="888" Text="Hi i'm trying to parse JSON resposne from webserver in my arduino in order to turn on and off a LED light. I'm using the wifi client repeating example to make a get request to my server:&#xD;&#xA;&#xD;&#xA;http://arduino.cc/en/Tutorial/WiFiWebClientRepeating&#xD;&#xA;&#xD;&#xA;Here is the portion where I make the GET request and it prints the JSON resposne to the serial port:&#xD;&#xA;&#xD;&#xA;       client.println(&quot;GET /abc/bze/ HTTP/1.1&quot;);&#xD;&#xA;        client.println(&quot;Host: www.abc.ca&quot;);&#xD;&#xA;        client.println(&quot;User-Agent: ArduinoWiFi/1.1&quot;);&#xD;&#xA;        client.println(&quot;Connection: close&quot;);&#xD;&#xA;        client.println();&#xD;&#xA;&#xD;&#xA;My JSON looks like this&#xD;&#xA;&#xD;&#xA;    {&quot;lightstatus&quot;:&quot;on&quot;}&#xD;&#xA;&#xD;&#xA;However, how do i parse the JSON response only so that I can use it to control my LED?&#xD;&#xA;&#xD;&#xA;Thanks&#xD;&#xA;" />
  <row Id="3091" PostHistoryTypeId="1" PostId="1092" RevisionGUID="fa378035-6caa-4ad3-aae0-536d6698ece8" CreationDate="2014-04-06T00:41:43.590" UserId="888" Text="Parse JSON with arduino to turn on LED" />
  <row Id="3092" PostHistoryTypeId="3" PostId="1092" RevisionGUID="fa378035-6caa-4ad3-aae0-536d6698ece8" CreationDate="2014-04-06T00:41:43.590" UserId="888" Text="&lt;arduino-uno&gt;&lt;shields&gt;&lt;wifi&gt;" />
  <row Id="3093" PostHistoryTypeId="5" PostId="1092" RevisionGUID="90e094c4-b7cc-44b4-9692-e4af09cd7f73" CreationDate="2014-04-06T00:56:02.997" UserId="11" Comment="deleted 19 characters in body" Text="Hi i'm trying to parse JSON resposne from webserver in my arduino in order to turn on and off a LED light. I'm using the wifi client repeating example to make a get request to my server:&#xD;&#xA;&#xD;&#xA;http://arduino.cc/en/Tutorial/WiFiWebClientRepeating&#xD;&#xA;&#xD;&#xA;Here is the portion where I make the GET request and it prints the JSON resposne to the serial port:&#xD;&#xA;&#xD;&#xA;    client.println(&quot;GET /abc/bze/ HTTP/1.1&quot;);&#xD;&#xA;    client.println(&quot;Host: www.abc.ca&quot;);&#xD;&#xA;    client.println(&quot;User-Agent: ArduinoWiFi/1.1&quot;);&#xD;&#xA;    client.println(&quot;Connection: close&quot;);&#xD;&#xA;    client.println();&#xD;&#xA;&#xD;&#xA;My JSON looks like this&#xD;&#xA;&#xD;&#xA;    {&quot;lightstatus&quot;:&quot;on&quot;}&#xD;&#xA;&#xD;&#xA;However, how do i parse the JSON response only so that I can use it to control my LED?&#xD;&#xA;&#xD;&#xA;Thanks&#xD;&#xA;" />
  <row Id="3094" PostHistoryTypeId="5" PostId="1084" RevisionGUID="695cc74f-f9a0-4fb5-98bc-15e381a3c730" CreationDate="2014-04-06T01:25:44.340" UserId="46" Comment="added 60 characters in body" Text="Chris Stratton's comments helped me find a workaround for my problem. It looks like the version of optiboot I was working with (see [source-code here](http://pastebin.com/d8NUirfZ)) doesn't work properly at 57600 BAUD with Arduino Uno without modifications (that I don't know how to make). So I compiled the bootloader with 76800 BAUD, configured the IDE accordingly, and all my boards started to work fine with it.&#xD;&#xA;&#xD;&#xA;It is still unclear to me the reason I one can't use 57600 BAUD, but I'm too pragmatic and too little knowledgeable to go after the true answer. So, I'll take Chris' word for it. He said this: &#xD;&#xA;&#xD;&#xA;&gt; Basically, 57600 does not divide in 16 MHz nicely when the 8x or 16x oversampling of the hardware UART is taken into account. My gut feeling is that different implementation are using different approximations. If they used the same approximation then even if &quot;wrong&quot; things would be basically fine (especially as the hardware design is similar), but if they are are off in opposite directions it could be unreliable. If you post the exact bootloader source you used we can see for sure - some optiboot source I just looked at seems to actually be using a software UART for 57600.&#xD;&#xA;&#xD;&#xA;That's the end of it for me.&#xD;&#xA;" />
  <row Id="3095" PostHistoryTypeId="5" PostId="1092" RevisionGUID="f5d7c41a-c3f9-45ca-8092-e08c3f709856" CreationDate="2014-04-06T01:36:10.597" UserId="888" Comment="added 61 characters in body" Text="Hi i'm trying to parse JSON resposne from webserver in my arduino in order to turn on and off a LED light. I'm using the wifi client repeating example to make a get request to my server:&#xD;&#xA;&#xD;&#xA;http://arduino.cc/en/Tutorial/WiFiWebClientRepeating&#xD;&#xA;&#xD;&#xA;Here is what I get printed back from the serial port&#xD;&#xA;&#xD;&#xA;    connecting...&#xD;&#xA;    HTTP/1.1 200 OK&#xD;&#xA;    Date: Sun, 06 Apr 2014 01:14:37 GMT&#xD;&#xA;    Server: Apache&#xD;&#xA;    X-Powered-By: PHP/5.5.10&#xD;&#xA;    Cache-Control: no-cache&#xD;&#xA;    X-Frame-Options: SAMEORIGIN&#xD;&#xA;    Set-Cookie: expires=Sun, 06-Apr-2014 03:14:37 GMT; Max-Age=7200; path=/; httponly&#xD;&#xA;    Connection: close&#xD;&#xA;    Transfer-Encoding: chunked&#xD;&#xA;    Content-Type: application/json&#xD;&#xA;    &#xD;&#xA;    19&#xD;&#xA;    {&quot;lightstatus&quot;:&quot;on&quot;}&#xD;&#xA;    0&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;How do i parse the JSON portion of this response only so that I can use it to control my LED?&#xD;&#xA;&#xD;&#xA;Thanks&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3096" PostHistoryTypeId="2" PostId="1093" RevisionGUID="6d7e0edc-de49-4b50-8547-c42146310ed2" CreationDate="2014-04-06T05:12:47.630" UserId="11" Text="I'm aware of a few JSON parsing libraries for Arduino.&#xD;&#xA;&#xD;&#xA;* [aJSON][1]&#xD;&#xA;* [Arduino JSON Parser][2]&#xD;&#xA;* [JSON Arduino][3]&#xD;&#xA;&#xD;&#xA;I've never used any of these but I did do some simple JSON parsing in a project I'm working on so I'll show you how I did that.&#xD;&#xA;&#xD;&#xA;NOTE: I'm reading serial data using the software serial library. You'll need to change this code to work for you. This will only work on very simple JSON strings. It's *very* limited but if that's all you're parsing then it'll work.&#xD;&#xA;&#xD;&#xA;Example of JSON response from server:&#xD;&#xA;&#xD;&#xA;    {&quot;id&quot;:&quot;TEST1&quot;,&quot;lat&quot;:&quot;38.56050207&quot;,&quot;lng&quot;:&quot;-121.42158374&quot;,&quot;total&quot;:&quot;3&quot;,&quot;available&quot;:&quot;2&quot;}&#xD;&#xA;&#xD;&#xA;First, only read data between curly braces.&#xD;&#xA;&#xD;&#xA;    String response = &quot;&quot;;&#xD;&#xA;    bool begin = false;&#xD;&#xA;    while (SIM900.available() || !begin) {&#xD;&#xA;        &#xD;&#xA;        char in = SIM900.read();&#xD;&#xA;&#xD;&#xA;        if (in == '{') {&#xD;&#xA;            begin = true;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        if (begin) response += (in);&#xD;&#xA;        &#xD;&#xA;        if (in == '}') {&#xD;&#xA;            break;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        delay(1);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This code reads data one byte at a time and once it gets an open brace, it starts saving it into `response`. When it gets a closing brace, it ends it. So here's a clear limitation, you can only have one set of opening/closing braces in your string.&#xD;&#xA;&#xD;&#xA;Once I have the string, I use `indexOf` and `substring` to extract relevant information:&#xD;&#xA;&#xD;&#xA;    start = response.indexOf(&quot;id\&quot;:\&quot;&quot;) + 5;&#xD;&#xA;    end = start + 5;&#xD;&#xA;    nodeId = response.substring(start, end);&#xD;&#xA;&#xD;&#xA;This code sets `start` to the beginning of `id&quot;:&quot;` + 5 characters in the string. It's +5 because that's how long `id&quot;:&quot;` is. So `start` points to `TEST1` in the JSON string. In my system, the ID is always going to be 5 characters long so end is `start + 5`. I then use `substring` to extract that.&#xD;&#xA;&#xD;&#xA;Again, before anyone starts down voting me for this horrible solution: if you know exactly what you're working with, and understand the limitations of this code, then this is not a bad solution. It's a solution that gets the job done.&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/interactive-matter/aJson&#xD;&#xA;  [2]: https://github.com/bblanchon/ArduinoJsonParser&#xD;&#xA;  [3]: https://github.com/not404/json-arduino" />
  <row Id="3097" PostHistoryTypeId="2" PostId="1094" RevisionGUID="a8a22fb5-1b2c-4a34-a9f6-5f7ba6d6e5a1" CreationDate="2014-04-06T07:56:37.890" UserId="655" Text="I have programmed a Class that will receive char by char the JSON document. It only will store in memory a few bytes for know JSON structure using a state machine and the results you need. So you can query the class for the results you want and will process the JSON.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Its ideal for your purpose. I have used for connect to a weather service that returns a json:&#xD;&#xA;&#xD;&#xA;    static const char* queries[] = { &quot;list.0.deg&quot;, &quot;list.0.weather.0.main&quot;};&#xD;&#xA;    StreamJsonReader jsonreader(queries, 2); // 2 queries    &#xD;&#xA;    while(char c  =  read()){&#xD;&#xA;               jsonreader.process_char(json[i]);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    cout &lt;&lt; jsonreader.results[0] &lt;&lt; endl;&#xD;&#xA;    cout &lt;&lt; jsonreader.results[1] &lt;&lt; endl;&#xD;&#xA;&#xD;&#xA;Check this blog post i just write: http://web.biicode.com/blog/big-json-on-arduino.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Code is in Biicode, [here][1]. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.biicode.com/lasote/blocks/lasote/stream_json_reader/branches/master" />
  <row Id="3098" PostHistoryTypeId="5" PostId="1094" RevisionGUID="23d23747-a4df-48ad-b9cb-0a1075263e06" CreationDate="2014-04-06T09:08:34.267" UserId="655" Comment="added 8 characters in body" Text="I have programmed a Class that will receive char by char the JSON document. It only will store in memory a few bytes for know JSON structure using a state machine and the results you need. So you can query the class for the results you want and will process the JSON.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Its ideal for your purpose. I have used for connecting to a weather service that returns a json:&#xD;&#xA;&#xD;&#xA;    static const char* queries[] = { &quot;list.0.deg&quot;, &quot;list.0.weather.0.main&quot;};&#xD;&#xA;    StreamJsonReader jsonreader(queries, 2); // 2 queries    &#xD;&#xA;    while(char c  =  read()){&#xD;&#xA;               jsonreader.process_char(json[i]);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    cout &lt;&lt; jsonreader.results[0] &lt;&lt; endl;&#xD;&#xA;    cout &lt;&lt; jsonreader.results[1] &lt;&lt; endl;&#xD;&#xA;&#xD;&#xA;Check this blog post i just write: http://web.biicode.com/blog/big-json-on-arduino.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Source code is [here][1] in Biicode.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.biicode.com/lasote/blocks/lasote/stream_json_reader/branches/master" />
  <row Id="3100" PostHistoryTypeId="2" PostId="1095" RevisionGUID="e2ff91e7-651a-42dc-8514-a04281e390ad" CreationDate="2014-04-06T12:52:40.383" UserId="168" Text="I wrote a parser for the PIC that has very low ram use because it works directly with char pointers and does not build a tree structure. If you ask to get item N of a list, it gives you an actual pointer into the direct JSON file right at the start of item N of the list. Then you can ask what type of object the pointer represents, etc. It's buggy and doesn't support floats and I think has a few other limitations(twas a long time ago) but it's all on github:https://github.com/EternityForest/OpenFortune-fortune-like-text-generator&#xD;&#xA;You'll need to look in libfortune which is part of the C version." />
  <row Id="3103" PostHistoryTypeId="2" PostId="1096" RevisionGUID="065ca29a-8f55-4360-bb21-bb0c1d6bc016" CreationDate="2014-04-06T16:50:03.683" UserId="943" Text="&lt;b&gt;[This article][1]&lt;/b&gt; describes a method to extend the battery life: use a low-power controller to switch on the Arduino only when needed. The author states that this method uses considerably less power than using Arduino's sleep mode.&#xD;&#xA;&#xD;&#xA;&lt;b&gt;Are there downsides to this approach? How would the schematic look if I used eg. the TPS61240 chip, as suggested in the article?&lt;/b&gt;&#xD;&#xA;&#xD;&#xA;Background: I'm building a sensor device that's in an environment with no mains power supply. The sensor should wake up eg. hourly, read eg. a temperature sensor, possibly send an SMS and then go back to sleep.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://alanbmitchell.wordpress.com/2011/10/09/design-of-the-extended-battery-life-power-controller-for-the-arduino/" />
  <row Id="3104" PostHistoryTypeId="1" PostId="1096" RevisionGUID="065ca29a-8f55-4360-bb21-bb0c1d6bc016" CreationDate="2014-04-06T16:50:03.683" UserId="943" Text="Extend battery life with a power-controlling microcontroller?" />
  <row Id="3105" PostHistoryTypeId="3" PostId="1096" RevisionGUID="065ca29a-8f55-4360-bb21-bb0c1d6bc016" CreationDate="2014-04-06T16:50:03.683" UserId="943" Text="&lt;battery&gt;" />
  <row Id="3106" PostHistoryTypeId="5" PostId="834" RevisionGUID="bbf2cf19-b4c2-4d67-948f-46ecd5ecf1f0" CreationDate="2014-04-06T17:06:12.347" UserId="723" Comment="added 2 characters in body" Text="Your refactor should be done simply because it's better code, not because it's smaller. The advantage is that it's easier to modify.&#xD;&#xA;&#xD;&#xA;If making the code size smaller results in a loss of clarity (not so in your case), then you should probably view it as a [premature optimization](http://c2.com/cgi/wiki?PrematureOptimization).&#xD;&#xA;" />
  <row Id="3107" PostHistoryTypeId="5" PostId="1096" RevisionGUID="3c8beae9-f0c6-4f75-b127-afaa96d5aea0" CreationDate="2014-04-06T17:21:12.890" UserId="943" Comment="added 224 characters in body" Text="&lt;b&gt;[This article][1]&lt;/b&gt; describes a method to extend the battery life: use a low-power controller to switch on the Arduino only when needed. The author states that this method uses considerably less power than using Arduino's sleep mode.&#xD;&#xA;&#xD;&#xA;&lt;b&gt;Are there downsides to this approach? Which variant should I build?&lt;/b&gt;(The [TPS61240 variant][2] seems to use something from Circuits@Home that's not available anymore.) **I'd appreciate schematics or links to detailed instructions.**&#xD;&#xA;&#xD;&#xA;Background: I'm building a sensor device that's in an environment with no mains power supply. The sensor should wake up eg. hourly, read eg. a temperature sensor, possibly send an SMS and then go back to sleep.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://alanbmitchell.wordpress.com/2011/10/09/design-of-the-extended-battery-life-power-controller-for-the-arduino/&#xD;&#xA;  [2]: http://alanbmitchell.wordpress.com/2011/11/07/arduino-power-controller-with-texas-instruments%E2%80%99-tps61240/" />
  <row Id="3108" PostHistoryTypeId="2" PostId="1097" RevisionGUID="89509fc2-db7f-41aa-a2bb-3b8c61342717" CreationDate="2014-04-06T18:08:26.387" UserId="368" Text="Switching off power to the board only makes sense if you're using a full Arduino. Once you strip the Arduino down to the bare MCU and decoupling capacitors (or start with a &lt;a href=&quot;https://www.sparkfun.com/products/11117&quot;&gt;basic breakout board&lt;/a&gt; instead), disabling unused peripherals and sleeping the CPU has &lt;a href=&quot;http://www.atmel.com/Images/doc8349.pdf&quot;&gt;much more of an effect&lt;/a&gt; since you no longer need to supply power to an external monitor chip.&#xD;&#xA;&#xD;&#xA;Naturally this may involve creating your own board for the MCU. Fortunately Atmel &lt;a href=&quot;http://www.atmel.com/Images/Atmel-2521-AVR-Hardware-Design-Considerations_Application-Note_AVR042.pdf&quot;&gt;has the basics of that covered&lt;/a&gt;." />
  <row Id="3113" PostHistoryTypeId="2" PostId="1099" RevisionGUID="db0648d5-af6c-4a8f-b3ed-9c1ebce2d36c" CreationDate="2014-04-06T20:13:31.893" UserId="949" Text="I built a simple power monitor with my first Arduino. It is powered via USB from a web-server that in turn is powered via a quite substantial battery backup (which  does not have notification abilities).&#xD;&#xA;&#xD;&#xA;It is also connected to a mobile phone charger plugged into a non-UPS power socket.&#xD;&#xA;&#xD;&#xA;So if the power dies the Arduino sends a message to a little program running on the server. The server program in turn sends me an email notification.&#xD;&#xA;&#xD;&#xA;It was installed in late September 2013, on the 23rd March 2014 - I got my first email!&#xD;&#xA;&#xD;&#xA;So I have not seen a problem (it does not use millis() ) but it does sample the power every 5 seconds." />
  <row Id="3115" PostHistoryTypeId="5" PostId="1094" RevisionGUID="9ecf2eef-a4dc-4445-9469-4a6d0bbe7e8b" CreationDate="2014-04-06T21:29:58.723" UserId="666" Comment="some minor grammar fixes" Text="I have programmed a class that will receive char by char the JSON document. It only will store in memory a few bytes for known JSON structure using a state machine and the results you need. So you can query the class for the results you want and will process the JSON.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Its ideal for your purpose. I have used for connecting to a weather service that returns a json:&#xD;&#xA;&#xD;&#xA;    static const char* queries[] = { &quot;list.0.deg&quot;, &quot;list.0.weather.0.main&quot;};&#xD;&#xA;    StreamJsonReader jsonreader(queries, 2); // 2 queries    &#xD;&#xA;    while(char c  =  read()){&#xD;&#xA;          jsonreader.process_char(c);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    cout &lt;&lt; jsonreader.results[0] &lt;&lt; endl;&#xD;&#xA;    cout &lt;&lt; jsonreader.results[1] &lt;&lt; endl;&#xD;&#xA;&#xD;&#xA;Check this blog post I just wrote: http://web.biicode.com/blog/big-json-on-arduino.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Source code is [here][1] in Biicode.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.biicode.com/lasote/blocks/lasote/stream_json_reader/branches/master" />
  <row Id="3116" PostHistoryTypeId="24" PostId="1094" RevisionGUID="9ecf2eef-a4dc-4445-9469-4a6d0bbe7e8b" CreationDate="2014-04-06T21:29:58.723" Comment="Proposed by 666 approved by 46, 220 edit id of 271" />
  <row Id="3117" PostHistoryTypeId="2" PostId="1100" RevisionGUID="a6be53ab-e65e-48cb-b850-feccd2d99a45" CreationDate="2014-04-07T00:40:00.430" UserId="313" Text="When your time has more worth more than the gains to be had, stop optimizing.&#xD;&#xA;&#xD;&#xA;Are you writing for someone for pay? Then this should be their call. But in this case, readability and clarity of your code is paramount; someday, someone else will have to modify your code in your absence. If you deliver working, high performance code that someone else can't read and get a handle on, you will not have fulfilled your obligation (unless this was specifically agreed to)." />
  <row Id="3118" PostHistoryTypeId="2" PostId="1101" RevisionGUID="4cf0be50-1844-4c8e-ad0b-88c86afbefd1" CreationDate="2014-04-07T00:43:55.483" UserId="346" Text="How would I measure resistance over a certain length? In this case the resistance is variable.&#xD;&#xA;&#xD;&#xA;What I have in my head is that you would output a certain amount of current from one pin, and measure how much comes back from the other.&#xD;&#xA;&#xD;&#xA;I'm not sure if this would work, or how to implement it in code.&#xD;&#xA;&#xD;&#xA;I've seen [this forum post](http://forum.arduino.cc/index.php/topic,21614.0.html), but it's not making much sense to me.&#xD;&#xA;&#xD;&#xA;How can I measure resistance?&#xD;&#xA;&#xD;&#xA;Thanks!&#xD;&#xA;&#xD;&#xA;evamvid" />
  <row Id="3119" PostHistoryTypeId="1" PostId="1101" RevisionGUID="4cf0be50-1844-4c8e-ad0b-88c86afbefd1" CreationDate="2014-04-07T00:43:55.483" UserId="346" Text="Measuring resistance conceptually and in code?" />
  <row Id="3120" PostHistoryTypeId="3" PostId="1101" RevisionGUID="4cf0be50-1844-4c8e-ad0b-88c86afbefd1" CreationDate="2014-04-07T00:43:55.483" UserId="346" Text="&lt;current&gt;" />
  <row Id="3121" PostHistoryTypeId="2" PostId="1102" RevisionGUID="30f75fec-8b4f-4fab-b10f-1d8613f2377e" CreationDate="2014-04-07T00:45:52.293" UserId="-1" Text="" />
  <row Id="3122" PostHistoryTypeId="2" PostId="1103" RevisionGUID="a043e948-5fb3-4eaf-ab01-7c1e5b8ff4a4" CreationDate="2014-04-07T00:45:52.293" UserId="-1" Text="" />
  <row Id="3123" PostHistoryTypeId="5" PostId="1103" RevisionGUID="7e046b59-f748-459f-99e6-3014609abc0f" CreationDate="2014-04-07T00:47:25.343" UserId="346" Comment="added 81 characters in body" Text="An Arduino board based on the ATmega32u4 chip with built in USB HID functionality" />
  <row Id="3124" PostHistoryTypeId="24" PostId="1103" RevisionGUID="7e046b59-f748-459f-99e6-3014609abc0f" CreationDate="2014-04-07T00:47:25.343" Comment="Proposed by 346 approved by 11 edit id of 272" />
  <row Id="3125" PostHistoryTypeId="5" PostId="1101" RevisionGUID="5399f9de-2219-4b92-8068-ad6cc416fbc5" CreationDate="2014-04-07T00:53:08.673" UserId="11" Comment="Please don't add signatures to posts." Text="How would I measure resistance over a certain length? In this case the resistance is variable.&#xD;&#xA;&#xD;&#xA;What I have in my head is that you would output a certain amount of current from one pin, and measure how much comes back from the other.&#xD;&#xA;&#xD;&#xA;I'm not sure if this would work, or how to implement it in code.&#xD;&#xA;&#xD;&#xA;I've seen [this forum post](http://forum.arduino.cc/index.php/topic,21614.0.html), but it's not making much sense to me.&#xD;&#xA;&#xD;&#xA;How can I measure resistance?" />
  <row Id="3126" PostHistoryTypeId="2" PostId="1104" RevisionGUID="e8afc5bb-13ef-4162-90b4-87dab0c0c92e" CreationDate="2014-04-07T01:57:08.037" UserId="952" Text="My high school is entering an ROV competition and for next year's competition we want to try and set it up so that we can control it using a PS4 controller. I have done research and found [this][1] shield for Arduino and [this][2] library that allows you to connect it to an Arduino. I plan to then connect the Arduino to a computer via USB and then send each button press to a Processing program via serial. Would it then be possible to send this from Processing to another Arduino out of the laptop? I'm just wondering how feasible this project is.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.circuitsathome.com/products-page/arduino-shields/usb-host-shield-2-0-for-arduino-assembled&#xD;&#xA;  [2]: https://github.com/felis/USB_Host_Shield_2.0" />
  <row Id="3127" PostHistoryTypeId="1" PostId="1104" RevisionGUID="e8afc5bb-13ef-4162-90b4-87dab0c0c92e" CreationDate="2014-04-07T01:57:08.037" UserId="952" Text="Connecting PS4 connected Arduino to laptop to another Arduino?" />
  <row Id="3128" PostHistoryTypeId="3" PostId="1104" RevisionGUID="e8afc5bb-13ef-4162-90b4-87dab0c0c92e" CreationDate="2014-04-07T01:57:08.037" UserId="952" Text="&lt;library&gt;" />
  <row Id="3129" PostHistoryTypeId="2" PostId="1105" RevisionGUID="5ea8c912-b2b6-4a97-8ef2-d45b11965d48" CreationDate="2014-04-07T06:11:31.823" UserId="888" Text="Hi I have a led attached to my arduino wifi shield that I want to control from my php web server.  In terms of communication, should I &#xD;&#xA;&#xD;&#xA;1.) Make my arduino a web server and then communicate with PHP web server via HTTP&#xD;&#xA;&#xD;&#xA;2.) Make my arduino a web client and receive commands from my php web service.  I would parse the JSON response&#xD;&#xA;&#xD;&#xA;Also my other quesiton is should I communicate with JSON between my php web server or is there a better way to send commands to my LED light? &#xD;&#xA;&#xD;&#xA;Thanks&#xD;&#xA;" />
  <row Id="3130" PostHistoryTypeId="1" PostId="1105" RevisionGUID="5ea8c912-b2b6-4a97-8ef2-d45b11965d48" CreationDate="2014-04-07T06:11:31.823" UserId="888" Text="Controlling LED from web server" />
  <row Id="3131" PostHistoryTypeId="3" PostId="1105" RevisionGUID="5ea8c912-b2b6-4a97-8ef2-d45b11965d48" CreationDate="2014-04-07T06:11:31.823" UserId="888" Text="&lt;arduino-uno&gt;&lt;shields&gt;&lt;wifi&gt;" />
  <row Id="3132" PostHistoryTypeId="2" PostId="1106" RevisionGUID="093307e7-0463-4d14-8e2d-fca1486b4162" CreationDate="2014-04-07T06:20:02.043" UserId="368" Text="There's no need for either PHP or JSON. Simply detect when one of two URLs (say, `/led/on` and `/led/off`) has been accessed on the Arduino's web server, change the LED state, and return a &lt;a href=&quot;http://en.wikipedia.org/wiki/List_of_HTTP_status_codes#2xx_Success&quot;&gt;204 response&lt;/a&gt;." />
  <row Id="3133" PostHistoryTypeId="2" PostId="1107" RevisionGUID="bee674d4-21fd-4d4a-92dc-0e92431c9482" CreationDate="2014-04-07T13:08:56.583" UserId="643" Text="this is possible, but the processig bridge can add a lot of delay if not correctly handled, also wifi has a low range, almost 100m by default hardware.&#xD;&#xA;&#xD;&#xA;zigbee module has better range (xbee pro are up to 1km) and are microcontroller friendly, you use the as you are using a serial, they will hide their complexity once you set them up, and this can be done by PC.&#xD;&#xA;&#xD;&#xA;That mens less code, that mena less error and more ram/flash/cpu so you can do a smarter robot :)" />
  <row Id="3134" PostHistoryTypeId="2" PostId="1108" RevisionGUID="accb0e76-1138-4d81-b05b-481b4c587a33" CreationDate="2014-04-07T13:14:14.377" UserId="643" Text="you cant control current output to a pin BUT you know a pin output 5V (if using a 5V a arduino, 3.3v in other case).&#xD;&#xA;&#xD;&#xA;Then what you need is a know resistence resitor, so you can set up a [voltage divider][1] and then read the resulting voltage with an analogRead. That give you a 10bit precision value that you can easily translate to a voltage, and then use the formula on the linked page to find R1 or R2 (depends on how you wired up your know resistor)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Voltage_divider" />
  <row Id="3135" PostHistoryTypeId="2" PostId="1109" RevisionGUID="65010117-d65a-40d8-90d1-f886d90d85ed" CreationDate="2014-04-07T15:51:16.317" UserId="666" Text="As I didn't get any answer, and further search for an existing solution failed, I decided to roll my own. The class header is very straightforward, I decided to go for single inheritance and composition of Adafruit_CC3000_Client:&#xD;&#xA;&#xD;&#xA;    class CC3000Client: public WiFiClient {&#xD;&#xA;    public:&#xD;&#xA;        CC3000Client(Adafruit_CC3000&amp; cc, Stream&amp; stream=Serial);&#xD;&#xA;        virtual ~CC3000Client();&#xD;&#xA;    &#xD;&#xA;        virtual int connect(IPAddress ip, uint16_t port);&#xD;&#xA;        virtual int connect(const char *host, uint16_t port);&#xD;&#xA;        virtual uint8_t connected();&#xD;&#xA;        virtual int available();&#xD;&#xA;        virtual void stop();&#xD;&#xA;        virtual void flush();&#xD;&#xA;        virtual int peek();&#xD;&#xA;        virtual int read();&#xD;&#xA;        virtual size_t write(uint8_t v);&#xD;&#xA;        virtual size_t write(const uint8_t *buf, size_t size);&#xD;&#xA;        virtual int read(uint8_t *buf, size_t size);&#xD;&#xA;        virtual operator bool();&#xD;&#xA;    &#xD;&#xA;    private:&#xD;&#xA;        Adafruit_CC3000&amp; cc3000;&#xD;&#xA;        Adafruit_CC3000_Client client;&#xD;&#xA;        bool peeked;&#xD;&#xA;        int peeked_byte;&#xD;&#xA;        Stream&amp; stream;&#xD;&#xA;    };&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The implementation is a bit tricky (or I didn't manage to find a better way), as the Adafruit client does not have peek() functionality, so this wrapper class have to implement it.&#xD;&#xA;&#xD;&#xA;    CC3000Client::CC3000Client(Adafruit_CC3000&amp; cc, Stream&amp; stre) :&#xD;&#xA;            cc3000(cc), peeked(false), stream(stre), peeked_byte(0) {&#xD;&#xA;    }&#xD;&#xA;    CC3000Client::~CC3000Client() {&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int CC3000Client::connect(IPAddress ip, uint16_t port) {&#xD;&#xA;        client = cc3000.connectTCP((uint32_t) ip, port);&#xD;&#xA;        peeked = false;&#xD;&#xA;        if (client.connected())&#xD;&#xA;            return 1;&#xD;&#xA;        return 0;&#xD;&#xA;    }&#xD;&#xA;    int CC3000Client::connect(const char *host, uint16_t port) {&#xD;&#xA;        uint32_t ip = 0;&#xD;&#xA;        if (!cc3000.getHostByName((char*) host, &amp;ip)) {&#xD;&#xA;            stream.println(F(&quot;Couldn't resolve!&quot;));&#xD;&#xA;            return 0;&#xD;&#xA;        }&#xD;&#xA;        client = cc3000.connectTCP(ip, port);&#xD;&#xA;        peeked = false;&#xD;&#xA;        if (client.connected()) {&#xD;&#xA;            return 1;&#xD;&#xA;        }&#xD;&#xA;        return 0;&#xD;&#xA;    }&#xD;&#xA;    uint8_t CC3000Client::connected() {&#xD;&#xA;        return (uint8_t) client.connected();&#xD;&#xA;    }&#xD;&#xA;    int CC3000Client::available() {&#xD;&#xA;        if(peeked)&#xD;&#xA;            return 1;&#xD;&#xA;        return (int) client.available();&#xD;&#xA;    }&#xD;&#xA;    void CC3000Client::stop() {&#xD;&#xA;        peeked = false;&#xD;&#xA;        flush();&#xD;&#xA;        while (client.connected()){&#xD;&#xA;            client.close();&#xD;&#xA;            delay(10);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    void CC3000Client::flush() {&#xD;&#xA;        peeked = false;&#xD;&#xA;        while (connected() &amp;&amp; available())&#xD;&#xA;            read();&#xD;&#xA;    }&#xD;&#xA;    int CC3000Client::peek() {&#xD;&#xA;        if (!peeked) {&#xD;&#xA;            if (available()) {&#xD;&#xA;                peeked_byte = read();&#xD;&#xA;                peeked = true;&#xD;&#xA;            } else&#xD;&#xA;                return -1;&#xD;&#xA;        }&#xD;&#xA;        return peeked_byte;&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    int CC3000Client::read() {&#xD;&#xA;        if (peeked) {&#xD;&#xA;            peeked = false;&#xD;&#xA;            return peeked_byte;&#xD;&#xA;        }&#xD;&#xA;        return (int) client.read();&#xD;&#xA;    }&#xD;&#xA;    size_t CC3000Client::write(uint8_t v) {&#xD;&#xA;        return (size_t) client.write(v);&#xD;&#xA;    }&#xD;&#xA;    size_t CC3000Client::write(const uint8_t *buf, size_t size) {&#xD;&#xA;        return client.write(buf, size);&#xD;&#xA;    }&#xD;&#xA;    int CC3000Client::read(uint8_t *buf, size_t size) {&#xD;&#xA;        if(peeked){&#xD;&#xA;            buf[0]=peeked_byte;&#xD;&#xA;            peeked=false;&#xD;&#xA;            return client.read(buf+1, size-1);&#xD;&#xA;        }&#xD;&#xA;        return client.read(buf, size);&#xD;&#xA;    }&#xD;&#xA;    CC3000Client::operator bool() {&#xD;&#xA;        stream.println(&quot;Error, bool() not implemented&quot;);&#xD;&#xA;        return true;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Both files are available [here][1], if you are using [biicode][2] all you have to do in your code is to put an include like the following and run &quot;bii find&quot;, that will also retrieve and install the cc3000 library:&#xD;&#xA;&#xD;&#xA;    #include &quot;diego/ardunet/cc3000client.h&quot;&#xD;&#xA;&#xD;&#xA;I have used and tested it with a simple http_get call (also [here][1]) and with the [temboo][3] service, and it has worked OK for sending emails from a Gmail account from an Arduino Mega2560 connected to the CC3000. This temboo service uses via the SDK Client interface most methods of this wrapper, but the bool() operator and the CC3000Client::write(const uint8_t *buf, size_t size) method. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.biicode.com/diego/blocks/diego/ardunet/branches/master&#xD;&#xA;  [2]: http://www.biicode.com&#xD;&#xA;  [3]: http://www.temboo.com" />
  <row Id="3136" PostHistoryTypeId="36" PostId="1110" RevisionGUID="069267a2-2413-453f-a047-dc95a4236140" CreationDate="2014-04-07T16:14:12.547" UserId="-1" Comment="from http://stackoverflow.com/questions/22839337/sending-variable-in-url" />
  <row Id="3137" PostHistoryTypeId="36" PostId="1111" RevisionGUID="5ceca0e1-882c-4193-b610-b3a217133b07" CreationDate="2014-04-07T16:14:12.547" UserId="-1" Comment="from http://stackoverflow.com/questions/22839337/sending-variable-in-url/22892598#22892598" />
  <row Id="3138" PostHistoryTypeId="2" PostId="1111" RevisionGUID="fe5f1562-e4e8-4959-a1eb-6d42ea297eae" CreationDate="2014-04-06T10:09:39.557" UserId="379" Text="first of all, you declare your `buffer` as a string of 50 characters, but&#xD;&#xA;&#xD;&#xA;    student.cs.hioa.no/~s180343/updatedb.php?verdi=&#xD;&#xA;&#xD;&#xA;is already 48, and you start your value at 1200 and increments over that, so basically&#xD;&#xA;&#xD;&#xA;    sprintf (buffer, &quot;student.cs.hioa.no/~s180343/updatedb.php?verdi=%d&quot;, val)&#xD;&#xA;&#xD;&#xA;will create a buffer of 53 characters (52 characters + `\0`).&#xD;&#xA;&#xD;&#xA;Secondly, it's always a better idea to give the *full* URL to a program such as curl, as it might work but may give unexpected results as well if you do not provide the protocol… `curl` could legally assume you want `ftp` or `gopher` to access that address! &#xD;&#xA;&#xD;&#xA;    http://student.cs.hioa.no/~s180343/updatedb.php?verdi=%d&#xD;&#xA;&#xD;&#xA;Third, here's how you setup and use your `val` variable:&#xD;&#xA;&#xD;&#xA;    int val=1200;&#xD;&#xA;    sprintf (…, &quot;…&quot;, val);  &#xD;&#xA;    val++;&#xD;&#xA;&#xD;&#xA;so once you've reached `32767` your int is overflowing, getting back to `-32,768`.&#xD;&#xA;&#xD;&#xA;Oh, and by the way, it is good practice on a Q&amp;A site such as Stack Overflow to actually *ask* a question and say what your problem is. All my hints here are insights based on reading your flawed code.&#xD;&#xA;&#xD;&#xA;HTH" />
  <row Id="3139" PostHistoryTypeId="2" PostId="1110" RevisionGUID="eb8a2d8e-588f-4e60-aa8b-71a1d055b8ca" CreationDate="2014-04-03T13:31:46.257" UserId="884" Text="Working on a arduino code, but its C code. Having the problem that I want a variable with int to increase in a loop to run with the url:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    student.cs.hioa.no/~s180343/updatedb.php?verdi=%d&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;The updatedb.php files takes the parameter and saves it to the database.    &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &lt;Process.h&gt;&#xD;&#xA;    char buffer[50];&#xD;&#xA;    int val=1200;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      // Initialize Bridge&#xD;&#xA;      Bridge.begin();&#xD;&#xA;      &#xD;&#xA;      // Initialize Serial&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      &#xD;&#xA;      // Wait until a Serial Monitor is connected.&#xD;&#xA;      while (!Serial);&#xD;&#xA;    &#xD;&#xA;      // run various example processes&#xD;&#xA;      //runCurl(val);&#xD;&#xA;      //runCpuInfo();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      Serial.println(&quot;Starting&quot;);&#xD;&#xA;      sprintf (buffer, &quot;student.cs.hioa.no/~s180343/updatedb.php?verdi=%d&quot;, val);  &#xD;&#xA;       val++;&#xD;&#xA;       Serial.println(buffer);&#xD;&#xA;       runCurl();&#xD;&#xA;       delay(5000);&#xD;&#xA;      // Do nothing here.&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void runCurl() {&#xD;&#xA;    &#xD;&#xA;      // curl is command line program for transferring data using different internet protocols&#xD;&#xA;      Process p;		// Create a process and call it &quot;p&quot;&#xD;&#xA;      p.begin(&quot;curl&quot;);	// Process that launch the &quot;curl&quot; command&#xD;&#xA;      p.addParameter(buffer); // Add the URL parameter to &quot;curl&quot;&#xD;&#xA;    &#xD;&#xA;      p.run();		// Run the process and wait for its termination&#xD;&#xA;    &#xD;&#xA;      // A process output can be read with the stream methods&#xD;&#xA;      while (p.available()&gt;0) {&#xD;&#xA;        char c = p.read();&#xD;&#xA;        Serial.print(c);&#xD;&#xA;      }&#xD;&#xA;      // Ensure the last bit of data is sent.&#xD;&#xA;      Serial.flush();&#xD;&#xA;    }" />
  <row Id="3140" PostHistoryTypeId="1" PostId="1110" RevisionGUID="eb8a2d8e-588f-4e60-aa8b-71a1d055b8ca" CreationDate="2014-04-03T13:31:46.257" UserId="884" Text="Sending variable in url" />
  <row Id="3141" PostHistoryTypeId="3" PostId="1110" RevisionGUID="eb8a2d8e-588f-4e60-aa8b-71a1d055b8ca" CreationDate="2014-04-03T13:31:46.257" UserId="884" Text="&lt;c&gt;" />
  <row Id="3142" PostHistoryTypeId="36" PostId="1112" RevisionGUID="1d62def8-776a-4dce-bf96-36f5928d0e6e" CreationDate="2014-04-07T16:14:22.260" UserId="-1" Comment="from http://stackoverflow.com/questions/22839721/passing-variable-in-url" />
  <row Id="3143" PostHistoryTypeId="36" PostId="1113" RevisionGUID="da041c05-98e4-42b7-aa17-cc3bbc94eac1" CreationDate="2014-04-07T16:14:22.260" UserId="-1" Comment="from http://stackoverflow.com/questions/22839721/passing-variable-in-url/22894899#22894899" />
  <row Id="3144" PostHistoryTypeId="2" PostId="1113" RevisionGUID="7a040904-a85d-4467-9c63-77aab24cd308" CreationDate="2014-04-06T13:48:29.593" UserDisplayName="aspiring_sarge" Text="Alright. I'm assuming you mean that you need the last part of the url varied from, say 1 to 100. Like Java, Processing, and, by extension, Arduino, allow you to add an integer to a String to get a String. I haven't tested this out, but it should work:   &#xD;&#xA;&#xD;&#xA;    &#xD;&#xA;    #include &lt;Process.h&gt;&#xD;&#xA;    #define MIN 0&#xD;&#xA;    #define MAX 100&#xD;&#xA;&#xD;&#xA;    int i;&#xD;&#xA; &#xD;&#xA;    void setup() {&#xD;&#xA;      i = MIN;&#xD;&#xA;&#xD;&#xA;      // Initialize Bridge&#xD;&#xA;      Bridge.begin();&#xD;&#xA;    &#xD;&#xA;      // Initialize Serial&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    &#xD;&#xA;      // Wait until a Serial Monitor is connected.&#xD;&#xA;      while (!Serial);&#xD;&#xA;      Serial.println(&quot;Ready&quot;);&#xD;&#xA;    &#xD;&#xA;      // run various example processes&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;       if (i&lt;=MAX) {&#xD;&#xA;         runCurl();  &#xD;&#xA;         i = i+1; &#xD;&#xA;       }&#xD;&#xA;       delay(10000);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void runCurl() {&#xD;&#xA;      // Launch &quot;curl&quot; command and get Arduino ascii art logo from the network&#xD;&#xA;      // curl is command line program for transferring data using different internet protocols&#xD;&#xA;      Process p;        // Create a process and call it &quot;p&quot;&#xD;&#xA;      p.begin(&quot;curl&quot;);  // Process that launch the &quot;curl&quot; command&#xD;&#xA;      String myUrl = &quot;student.cs.hioa.no/~s180343/updatedb.php?verdi=&quot;;&#xD;&#xA;      p.addParameter(myUrl+i); // Add the URL parameter to &quot;curl&quot;&#xD;&#xA;      p.run();      // Run the process and wait for its termination&#xD;&#xA;    &#xD;&#xA;      // A process output can be read with the stream methods&#xD;&#xA;      while (p.available()&gt;0) {&#xD;&#xA;        char c = p.read();&#xD;&#xA;        Serial.print(c);&#xD;&#xA;      }&#xD;&#xA;      // Ensure the last bit of data is sent.&#xD;&#xA;      Serial.flush();&#xD;&#xA;    }" />
  <row Id="3145" PostHistoryTypeId="2" PostId="1112" RevisionGUID="f7481128-c44a-4f93-8f16-8d8ad1273a8f" CreationDate="2014-04-03T13:46:16.157" UserDisplayName="user3185936" Text="Working on a arduino script where I am right now entering manually the value with the URL, but wondering how to do it with a int in a loop. &#xD;&#xA;&#xD;&#xA;This is the url and how it works now:&#xD;&#xA;&#xD;&#xA;    student.cs.hioa.no/~s180343/updatedb.php?verdi=25&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Code:&#xD;&#xA;&#xD;&#xA;    #include &lt;Process.h&gt;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      // Initialize Bridge&#xD;&#xA;      Bridge.begin();&#xD;&#xA;    &#xD;&#xA;      // Initialize Serial&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    &#xD;&#xA;      // Wait until a Serial Monitor is connected.&#xD;&#xA;      while (!Serial);&#xD;&#xA;      Serial.println(&quot;Ready&quot;);&#xD;&#xA;    &#xD;&#xA;      // run various example processes&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;       runCurl();&#xD;&#xA;       delay(10000);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void runCurl() {&#xD;&#xA;      // Launch &quot;curl&quot; command and get Arduino ascii art logo from the network&#xD;&#xA;      // curl is command line program for transferring data using different internet protocols&#xD;&#xA;      Process p;        // Create a process and call it &quot;p&quot;&#xD;&#xA;      p.begin(&quot;curl&quot;);  // Process that launch the &quot;curl&quot; command&#xD;&#xA;      p.addParameter(&quot;student.cs.hioa.no/~s180343/updatedb.php?verdi=25&quot;); // Add the URL parameter to &quot;curl&quot;&#xD;&#xA;      p.run();      // Run the process and wait for its termination&#xD;&#xA;    &#xD;&#xA;      // A process output can be read with the stream methods&#xD;&#xA;      while (p.available()&gt;0) {&#xD;&#xA;        char c = p.read();&#xD;&#xA;        Serial.print(c);&#xD;&#xA;      }&#xD;&#xA;      // Ensure the last bit of data is sent.&#xD;&#xA;      Serial.flush();&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="3146" PostHistoryTypeId="1" PostId="1112" RevisionGUID="f7481128-c44a-4f93-8f16-8d8ad1273a8f" CreationDate="2014-04-03T13:46:16.157" UserDisplayName="user3185936" Text="Passing variable in url" />
  <row Id="3147" PostHistoryTypeId="3" PostId="1112" RevisionGUID="f7481128-c44a-4f93-8f16-8d8ad1273a8f" CreationDate="2014-04-03T13:46:16.157" UserDisplayName="user3185936" Text="&lt;c++&gt;&lt;variables&gt;" />
  <row Id="3148" PostHistoryTypeId="10" PostId="1110" RevisionGUID="dd5d9269-c18b-498a-b46b-e6db70748a3f" CreationDate="2014-04-07T16:16:53.293" UserId="42" Comment="101" Text="{&quot;OriginalQuestionIds&quot;:[1112],&quot;Voters&quot;:[{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;}]}" />
  <row Id="3149" PostHistoryTypeId="37" PostId="1110" RevisionGUID="f056329b-b0a5-4b02-a77f-7d18ca890711" CreationDate="2014-04-07T16:17:14.080" UserId="42" Comment="to http://arduino.stackexchange.com/questions/1112/passing-variable-in-url" />
  <row Id="3150" PostHistoryTypeId="38" PostId="1111" RevisionGUID="f056329b-b0a5-4b02-a77f-7d18ca890711" CreationDate="2014-04-07T16:17:14.080" UserId="42" Comment="from http://arduino.stackexchange.com/questions/1110/sending-variable-in-url" />
  <row Id="3151" PostHistoryTypeId="38" PostId="1112" RevisionGUID="f056329b-b0a5-4b02-a77f-7d18ca890711" CreationDate="2014-04-07T16:17:14.080" UserId="42" Comment="from http://arduino.stackexchange.com/questions/1110/sending-variable-in-url" />
  <row Id="3152" PostHistoryTypeId="14" PostId="1110" RevisionGUID="98a6b5d2-201a-4bfb-9ef6-e5c90acc0de2" CreationDate="2014-04-07T16:17:14.080" UserId="42" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;}]}" />
  <row Id="3153" PostHistoryTypeId="10" PostId="1112" RevisionGUID="dedc03fd-d3f2-4027-a751-b64630e9c3ce" CreationDate="2014-04-07T16:18:41.260" UserId="42" Comment="101" Text="{&quot;OriginalQuestionIds&quot;:[1073],&quot;Voters&quot;:[{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;}]}" />
  <row Id="3154" PostHistoryTypeId="37" PostId="1112" RevisionGUID="a8beab8e-8c53-44c7-8ee5-9c85d0cfe6e1" CreationDate="2014-04-07T16:19:01.923" UserId="42" Comment="to http://arduino.stackexchange.com/questions/1073/pass-variable-in-a-url" />
  <row Id="3155" PostHistoryTypeId="38" PostId="1111" RevisionGUID="a8beab8e-8c53-44c7-8ee5-9c85d0cfe6e1" CreationDate="2014-04-07T16:19:01.923" UserId="42" Comment="from http://arduino.stackexchange.com/questions/1112/passing-variable-in-url" />
  <row Id="3156" PostHistoryTypeId="38" PostId="1113" RevisionGUID="a8beab8e-8c53-44c7-8ee5-9c85d0cfe6e1" CreationDate="2014-04-07T16:19:01.923" UserId="42" Comment="from http://arduino.stackexchange.com/questions/1112/passing-variable-in-url" />
  <row Id="3157" PostHistoryTypeId="38" PostId="1073" RevisionGUID="a8beab8e-8c53-44c7-8ee5-9c85d0cfe6e1" CreationDate="2014-04-07T16:19:01.923" UserId="42" Comment="from http://arduino.stackexchange.com/questions/1112/passing-variable-in-url" />
  <row Id="3158" PostHistoryTypeId="14" PostId="1112" RevisionGUID="2cbb0a73-516c-4828-949c-598c3882fc8e" CreationDate="2014-04-07T16:19:01.923" UserId="42" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:42,&quot;DisplayName&quot;:&quot;Peter R. Bloomfield&quot;}]}" />
  <row Id="3159" PostHistoryTypeId="36" PostId="1114" RevisionGUID="91077c70-22af-4b6b-93f6-63632269faea" CreationDate="2014-04-07T21:56:49.770" UserId="-1" Comment="from http://stackoverflow.com/questions/22898134/how-to-send-an-email-with-arduino-and-a-wifi-shield" />
  <row Id="3160" PostHistoryTypeId="2" PostId="1114" RevisionGUID="c505f140-cd88-4b40-93d3-a8bf93e01db4" CreationDate="2014-04-06T18:30:18.623" UserId="980" UserDisplayName="user3504192" Text="Is there a library or a function that sends the email ?&#xD;&#xA;&#xD;&#xA;I want to make my arduino conect via wifi and then send an email, the idea is very simple but the problem is that i've never worked with those protocols and stuffs, i just wanted something that's already premade, so i would just change the information.(if someone help me to understand, so i can make it myself, would be even greater).&#xD;&#xA;&#xD;&#xA;P.S. IT'S A WIFI SHIELD AND NOT THE ETHERNET ONE." />
  <row Id="3161" PostHistoryTypeId="1" PostId="1114" RevisionGUID="c505f140-cd88-4b40-93d3-a8bf93e01db4" CreationDate="2014-04-06T18:30:18.623" UserId="980" UserDisplayName="user3504192" Text="How to send an email with arduino and a wifi shield?" />
  <row Id="3162" PostHistoryTypeId="3" PostId="1114" RevisionGUID="c505f140-cd88-4b40-93d3-a8bf93e01db4" CreationDate="2014-04-06T18:30:18.623" UserId="980" UserDisplayName="user3504192" Text="&lt;wifi&gt;" />
  <row Id="3163" PostHistoryTypeId="36" PostId="1115" RevisionGUID="45e015a6-6643-479c-92be-ad91ac905208" CreationDate="2014-04-07T21:57:17.160" UserId="-1" Comment="from http://stackoverflow.com/questions/22887435/how-can-i-communicate-raspberry-pi-and-arduino-in-both-ways-using-a-10-15m-dis" />
  <row Id="3164" PostHistoryTypeId="36" PostId="1116" RevisionGUID="4d520868-5e18-4894-ad9e-00fbe5d12e4a" CreationDate="2014-04-07T21:57:17.160" UserId="-1" Comment="from http://stackoverflow.com/questions/22887435/how-can-i-communicate-raspberry-pi-and-arduino-in-both-ways-using-a-10-15m-dis/22893304#22893304" />
  <row Id="3165" PostHistoryTypeId="2" PostId="1116" RevisionGUID="83ca0419-c6c5-4662-b208-bda796efd037" CreationDate="2014-04-06T11:20:16.370" UserId="379" Text="for length such as this, you should be using protocols that are designed for length, such as:&#xD;&#xA;&#xD;&#xA; * UART,&#xD;&#xA; * CAN,&#xD;&#xA; * Ethernet&#xD;&#xA;&#xD;&#xA;for UART, you can't of course use a direct connection between the two boards, you need to upgrade the connection and wiring to either rs232 or rs485, using a driver between the arduino pins and the cable.&#xD;&#xA;&#xD;&#xA;Though, the simplest solution would be to plug the Arduino on the Raspberry Pi using a lengthy USB cable (or more likely 3 five meters cable), which should work fine as long as you only do serial communication. The USB 2.0 limitation of 5 meters are for &quot;hi-speed&quot; connections, which is not our concern for simple serial data communication.&#xD;&#xA;&#xD;&#xA;HTH" />
  <row Id="3166" PostHistoryTypeId="2" PostId="1115" RevisionGUID="5f95fda0-1a2d-4385-b3dd-2e2a6b41b7d4" CreationDate="2014-04-05T22:03:34.517" UserId="963" UserDisplayName="thiagoh" Text="I am starting a personal project of home automation and I have a raspberry pi and an arduino Uno board.&#xD;&#xA;&#xD;&#xA;I want communicate raspberry pi and my arduino where my raspberry should be able to write and read signals to and from arduino.&#xD;&#xA;&#xD;&#xA;The distance between them I think its going to be something around 10 to 15 meters.&#xD;&#xA;&#xD;&#xA;What do I need for it? what kind of wires or other components I'll need to achieve my goal? I repeat: I do not want to communicate raspberry pi and arduino wirelessly.&#xD;&#xA;&#xD;&#xA;Thanks!" />
  <row Id="3167" PostHistoryTypeId="1" PostId="1115" RevisionGUID="5f95fda0-1a2d-4385-b3dd-2e2a6b41b7d4" CreationDate="2014-04-05T22:03:34.517" UserId="963" UserDisplayName="thiagoh" Text="How can I communicate Raspberry Pi and Arduino (in both ways) using a 10-15m distance wires?" />
  <row Id="3168" PostHistoryTypeId="3" PostId="1115" RevisionGUID="5f95fda0-1a2d-4385-b3dd-2e2a6b41b7d4" CreationDate="2014-04-05T22:03:34.517" UserId="963" UserDisplayName="thiagoh" Text="&lt;untagged&gt;" />
  <row Id="3169" PostHistoryTypeId="2" PostId="1117" RevisionGUID="e0cba0d4-5d3d-46e7-be7f-8bdab0f60a7e" CreationDate="2014-04-07T22:44:50.037" UserId="368" Text="What you're looking for is a **SMTP (Simple Mail Transport Protocol) library**. A Google search finds 2 for the Arduino:&#xD;&#xA;&#xD;&#xA;- &lt;a href=&quot;https://github.com/gregington/SMTPClient&quot;&gt;SMTPClient&lt;/a&gt;&#xD;&#xA;&#xD;&#xA; This seems to be a minimal-capability SMTP-only library that piggybacks on top of a connection library.&#xD;&#xA;&#xD;&#xA;- &lt;a href=&quot;https://github.com/bibi21000/arduino-fullip&quot;&gt;FullIP&lt;/a&gt;&#xD;&#xA;&#xD;&#xA; This seems to be a full IP package for the Arduino that works with select network devices which includes SMTP capability." />
  <row Id="3170" PostHistoryTypeId="2" PostId="1118" RevisionGUID="58ed430d-bdc4-40b5-b15f-e7c46b1b7776" CreationDate="2014-04-07T23:11:25.913" UserId="755" Text="I am trying to connect a MPL3115A2 Altitude/Pressure/Temp Sensor Breakout which I bought from Hobbytronics to my Arduino Mega. What I had in mind was (Breakout -&gt; Arduino):&#xD;&#xA;&#xD;&#xA;`3.3V -&gt; 3.3 V`&#xD;&#xA;`GND -&gt; GND`&#xD;&#xA;`SDA -&gt; A4`&#xD;&#xA;`SCL -&gt; A5`&#xD;&#xA;&#xD;&#xA;The information which I've found so far is very conflicting and I'm not sure whether or not I should be using pull-up or in-line resistors, and if so, what value? &#xD;&#xA;&#xD;&#xA;The code which the product page links to also differs, with one stating that the Wire library is unsafe to use with a 3.3V rated sensor due to the internal pull-ups, but the other code uses the Wire library? &#xD;&#xA;&#xD;&#xA;If anyone could advise me on how best to use this sensor without frying it, it would be much appreciated!&#xD;&#xA;&#xD;&#xA; - The link to the product information:&#xD;&#xA;   [http://www.hobbytronics.co.uk/mpl3115a2-pressure-temp-sensor?utm_source=google&amp;utm_medium=googleshopping&amp;utm_campaign=googlebase&amp;gclid=CPrU6qqEub0CFa-WtAod_U0AfQ][1]&#xD;&#xA; - The link to the code: [https://github.com/sparkfun/MPL3115A2_Breakout/tree/master/firmware][2]&#xD;&#xA;&#xD;&#xA;  [1]: http://www.hobbytronics.co.uk/mpl3115a2-pressure-temp-sensor?utm_source=google&amp;utm_medium=googleshopping&amp;utm_campaign=googlebase&amp;gclid=CPrU6qqEub0CFa-WtAod_U0AfQ&#xD;&#xA;  [2]: https://github.com/sparkfun/MPL3115A2_Breakout/tree/master/firmware" />
  <row Id="3171" PostHistoryTypeId="1" PostId="1118" RevisionGUID="58ed430d-bdc4-40b5-b15f-e7c46b1b7776" CreationDate="2014-04-07T23:11:25.913" UserId="755" Text="Can anyone explain how to use MPL sensor with Arduino MEGA?" />
  <row Id="3172" PostHistoryTypeId="3" PostId="1118" RevisionGUID="58ed430d-bdc4-40b5-b15f-e7c46b1b7776" CreationDate="2014-04-07T23:11:25.913" UserId="755" Text="&lt;sensors&gt;&lt;arduino-mega&gt;" />
  <row Id="3173" PostHistoryTypeId="5" PostId="1118" RevisionGUID="991749b1-625b-4521-aaa1-9322fa9be2fa" CreationDate="2014-04-07T23:14:40.257" UserId="368" Comment="Fix web links" Text="I am trying to connect a MPL3115A2 Altitude/Pressure/Temp Sensor Breakout which I bought from Hobbytronics to my Arduino Mega. What I had in mind was (Breakout -&gt; Arduino):&#xD;&#xA;&#xD;&#xA;`3.3V -&gt; 3.3 V`&#xD;&#xA;`GND -&gt; GND`&#xD;&#xA;`SDA -&gt; A4`&#xD;&#xA;`SCL -&gt; A5`&#xD;&#xA;&#xD;&#xA;The information which I've found so far is very conflicting and I'm not sure whether or not I should be using pull-up or in-line resistors, and if so, what value? &#xD;&#xA;&#xD;&#xA;The code which the product page links to also differs, with one stating that the Wire library is unsafe to use with a 3.3V rated sensor due to the internal pull-ups, but the other code uses the Wire library? &#xD;&#xA;&#xD;&#xA;If anyone could advise me on how best to use this sensor without frying it, it would be much appreciated!&#xD;&#xA;&#xD;&#xA; - &lt;a href=&quot;http://www.hobbytronics.co.uk/mpl3115a2-pressure-temp-sensor&quot;&gt;Product information&lt;/a&gt;&#xD;&#xA; - &lt;a href=&quot;https://github.com/sparkfun/MPL3115A2_Breakout/tree/master/firmware&quot;&gt;Code&lt;/a&gt;&#xD;&#xA;" />
  <row Id="3174" PostHistoryTypeId="24" PostId="1118" RevisionGUID="991749b1-625b-4521-aaa1-9322fa9be2fa" CreationDate="2014-04-07T23:14:40.257" Comment="Proposed by 368 approved by 755 edit id of 273" />
  <row Id="3177" PostHistoryTypeId="2" PostId="1120" RevisionGUID="819bee76-8420-4363-ba69-22d67d358e7a" CreationDate="2014-04-07T23:48:49.630" UserId="368" Text="Since the device is 3.3V and the Arduino is 5V, you *will* need a I&lt;sup&gt;2&lt;/sup&gt;C level converter such as the &lt;a href=&quot;http://www.ti.com/product/tca9517&quot;&gt;TCA9517&lt;/a&gt;. Simply supply the Mega side with 5V and the device side with 3.3V and attach 4.7kohm pull-ups to 5V on the Mega side, and it will convert both SDA and SCL for you. You won't need pull-ups on the device side since it includes pull-ups on the board.&#xD;&#xA;&#xD;&#xA;For I1 and I2 (push-pull outputs) you can use either normal level converters or you can use a &lt;a href=&quot;http://www.ti.com/product/sn74lvc2g07&quot;&gt;SN74LVC2G07&lt;/a&gt; along with the pull-ups found on the Mega inputs." />
  <row Id="3178" PostHistoryTypeId="2" PostId="1121" RevisionGUID="928a5e00-9b19-467c-a436-dccd6e5545df" CreationDate="2014-04-08T01:06:07.723" UserId="220" Text="**This project is very simple.** As I understand it, this is your setup:&#xD;&#xA;&#xD;&#xA;    +–––––––––––––––––––––––––––––––––––––––––+             &#xD;&#xA;    |                                         |             &#xD;&#xA;    |  Arduino 1-––––––––––-PS4 Controller    |             &#xD;&#xA;    |  |                 (W. Shield attached) |             &#xD;&#xA;    |  |USB                                   |             &#xD;&#xA;    |  |                                      |             &#xD;&#xA;    |  Computer                               |             &#xD;&#xA;    |  |                                      |             &#xD;&#xA;    |  |[Wireless]                            |             &#xD;&#xA;    |  |                                      |             &#xD;&#xA;    |  Arduino 2                              |             &#xD;&#xA;    |                                         |             &#xD;&#xA;    +–––––––––––––––––––––––––––––––––––––––––+             &#xD;&#xA;*[Made with ASCIIFlow](http://asciiflow.com)*&#xD;&#xA;&#xD;&#xA;If you have a very small range (I'd say 10-20 feet max), I recommend using Bluetooth. The [HC 06 Bluetooth module looks like a good choice](http://www.amazon.com/Arduino-Wireless-Bluetooth-Transceiver-Module/dp/B0093XAV4U/ref=sr_1_1?ie=UTF8&amp;qid=1396918346&amp;sr=8-1&amp;keywords=hc+06+bluetooth+arduino). There's also a less powerful HC05 if I remember correctly. I had one once but accidentally destroyed it before I could connect with a bad soldering job :). The one linked on Amazon luckily comes with a &quot;backplane&quot; already soldered so you just need to attach 5V, GND, and the TX/RX pins to the Arduino, accordingly. Then, you can select the BT module (wherever it appears on your OS; search online for this) and then you can connect to it and add the password 1234. After that, it should function like a normal COM port.&#xD;&#xA;&#xD;&#xA;You would connect this to the HC06 to Arduino 2, and wirelessly the HC06 to the computer. The computer would then be connected to Arduino 1, who would receive the PS4 signals, with the shield. You would use Processing to receive the PS4 signals and to send data to the second Arduino board. I'm not an expert on Processing, but I found [this serial library](https://www.processing.org/reference/libraries/serial/Serial.html).&#xD;&#xA;&#xD;&#xA;I ***do not*** recommend using Xbee because one Arduino needs to talk to the computer and the other at the same time. That's not practical with the way it's set up on most boards. The OP would need another UART connection, even so the Xbee and the USB to UART chip use the same pins on all standard boards. " />
  <row Id="3179" PostHistoryTypeId="2" PostId="1122" RevisionGUID="97e0ede8-39e0-4ffb-8edb-6bbac4a23507" CreationDate="2014-04-08T11:14:13.833" UserId="113" Text="The REST protocol is ideal for this and there's a nice Sketch already written, called RESTduino on Github:&#xD;&#xA;[https://github.com/jjg/RESTduino][1]&#xD;&#xA;&#xD;&#xA;Basically (and loosely) REST treats a URL as a command.  Quoting from the RESTduino doc's:&#xD;&#xA;&#xD;&#xA;&quot;To turn on the LED attached to pin #9 (currently case sensitive!):&#xD;&#xA;&#xD;&#xA;    http://192.168.1.177/9/HIGH&#xD;&#xA;&#xD;&#xA;This will set the pin to the HIGH state and the LED should light. Next try this:&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     http://192.168.1.177/100&#xD;&#xA;&#xD;&#xA;This will use PWM to illuminate the LED at around 50% brightness (valid PWM values are 0-255).&quot;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/jjg/RESTduino" />
  <row Id="3180" PostHistoryTypeId="5" PostId="701" RevisionGUID="3d00dddb-7ed6-4c56-b1df-91ff6822e722" CreationDate="2014-04-08T18:45:05.207" UserId="510" Comment="Copy edited." Text="The Arduino ADC clock speed is set in ..arduino-1.5.5\hardware\arduino\avr\cores\arduino\wiring.c&#xD;&#xA;&#xD;&#xA;Here is the relevant part&#xD;&#xA;&#xD;&#xA;    #if defined(ADCSRA)&#xD;&#xA;    	// Set A/D prescale factor to 128&#xD;&#xA;    	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.&#xD;&#xA;    	// XXX: this will not work properly for other clock speeds, and&#xD;&#xA;    	// this code should use F_CPU to determine the prescale factor.&#xD;&#xA;    	sbi(ADCSRA, ADPS2);&#xD;&#xA;    	sbi(ADCSRA, ADPS1);&#xD;&#xA;    	sbi(ADCSRA, ADPS0);&#xD;&#xA;    &#xD;&#xA;    	// Enable A/D conversions&#xD;&#xA;    	sbi(ADCSRA, ADEN);&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;For a 16&amp;nbsp;MHz Arduino the ADC clock is set to 16&amp;nbsp;MHz/128 = 125&amp;nbsp;KHz. Each conversion in AVR takes 13 ADC clocks so 125&amp;nbsp;KHz /13 = 9615&amp;nbsp;Hz.&#xD;&#xA;&#xD;&#xA;That is the maximum possible sampling rate, but the actual sampling rate in your application depends on the interval between successive conversions calls.  &#xD;&#xA;Since you read the result and send it through the serial port, you are getting a delay that increases as the baud rate decreases. The lower the baud rate the longer it will take to send the same length of data and the longer it will take to call the next ADC conversion.&#xD;&#xA;&#xD;&#xA;The actual sampling rate in your application can be determined with the use of a debugger or a simulator, but an easier solution is to toggle a digital pin every time you execute a conversion and measure the frequency that the digital pin toggles at.&#xD;&#xA;" />
  <row Id="3181" PostHistoryTypeId="24" PostId="701" RevisionGUID="3d00dddb-7ed6-4c56-b1df-91ff6822e722" CreationDate="2014-04-08T18:45:05.207" Comment="Proposed by 510 approved by 84, 11 edit id of 276" />
  <row Id="3182" PostHistoryTypeId="5" PostId="880" RevisionGUID="0952e457-d9be-48d0-b268-58da313bf4f3" CreationDate="2014-04-08T18:45:31.453" UserId="510" Comment="Copy edited. Added some context." Text="# Energy saver for the absent-minded PC user&#xD;&#xA;**This device switches on/off my desk lights when it is dark(ish) and in sync with my PC screensaver.**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;The project is little more than an combination of a light sensitive sensor, a relay and some smart code that monitors the screensaver on my PC. When it is dusk and when screen saver is not active, it switches on the lights over my desk. When I subsequently leave my desk the screensaver will activate, which will in turn trigger the desk light to be turned off. When there is enough light during day time, the lights are not switched on at all. The problem solved is to reduce the waste of energy due to the lighting in my office being switched on when I have left the room.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;Because the power of microcontrollers / Arduino only a little extra hardware is required to create a useful project. The same goes for this project where the hardware is little more than:&#xD;&#xA;&#xD;&#xA;- An Arduino&#xD;&#xA;- A couple of screw shields to connect the external components&#xD;&#xA;- An [LDR][1] in series with a resistor to measure ambient light&#xD;&#xA;- A relay card to switch on and off the mains powered lights&#xD;&#xA;- A 10&amp;nbsp;μF capacitor from GND to RST to prevent the board from being reset and accidentally being programmed.&#xD;&#xA;&#xD;&#xA;&lt;!-- Begin schematic: In order to preserve an editable schematic, please&#xD;&#xA;     don't edit this section directly.&#xD;&#xA;     Click the &quot;edit&quot; link below the image in the preview instead. --&gt;&#xD;&#xA;&#xD;&#xA;![schematic](http://i.stack.imgur.com/cQlSi.png)&#xD;&#xA;&#xD;&#xA;&lt;!-- End schematic --&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;I learned how to interface the PC over the USB serial link with Arduino and how to read current state of the screensaver on my PC. If I would start over, I'd use a much smaller controller as I really only need a single digital output and a single analog input. Probably base the project on [V-USB][2]. Arduino however is excellent for the quick and easy proof of concept (PoC). (The PoC has been on my desk for at least two years already).&#xD;&#xA;&#xD;&#xA;  [1]: https://en.wikipedia.org/wiki/Photoresistor&#xD;&#xA;  [2]: http://www.obdev.at/products/vusb/index.html&#xD;&#xA;" />
  <row Id="3183" PostHistoryTypeId="24" PostId="880" RevisionGUID="0952e457-d9be-48d0-b268-58da313bf4f3" CreationDate="2014-04-08T18:45:31.453" Comment="Proposed by 510 approved by 11 edit id of 274" />
  <row Id="3184" PostHistoryTypeId="5" PostId="915" RevisionGUID="25a9e9ba-6e9d-4698-9170-b5a07b7b9ae1" CreationDate="2014-04-08T18:45:43.877" UserId="510" Comment="Copy edited." Text="# Stateful questbox&#xD;&#xA;**A [GPS][1] powered box that makes you visit a few spots before opening**&#xD;&#xA;&#xD;&#xA;# Description&#xD;&#xA;It is similar to [questbox][2], but it stores a small amount state of information in [EEPROM][3], so you have to visit two or three different places before it opens.&#xD;&#xA;&#xD;&#xA;# Design&#xD;&#xA;&#xD;&#xA;Needed hardware:&#xD;&#xA;&#xD;&#xA;* [Arduino Uno][4]&#xD;&#xA;* Reverse Geocache Version 2 (or a protoshield)&#xD;&#xA;* GlobalSat EM-406A GPS module&#xD;&#xA;* 2×8 blue LCD with connector header and cable&#xD;&#xA;* Hitec HS-55 servo motor&#xD;&#xA;* 4-40 push rod and clevis for latch (some versions provide a Z-bend rod instead)&#xD;&#xA;* 2 AA battery holder&#xD;&#xA;* Metallic push button with embedded blue LED and 4-pin cable&#xD;&#xA;* Pololu low voltage switch&#xD;&#xA;* Pololu 5&amp;nbsp;V boost regulator&#xD;&#xA;* JST connector for EM-406A GPS module&#xD;&#xA;* Straight and right-angle header pins for the display, servo, and pushbutton connectors&#xD;&#xA;* Two resistors for current limiting and display contrast adjustment&#xD;&#xA;* Two small capacitors for power smoothing&#xD;&#xA;* larger capacitor for display contrast circuit&#xD;&#xA;&#xD;&#xA;Total hardware cost: **137$ + shipping**&#xD;&#xA;&#xD;&#xA;Aditional materials:&#xD;&#xA;&#xD;&#xA;* A nice box&#xD;&#xA;* Epoxy glue, wood to cover pieces, tools&#xD;&#xA;&#xD;&#xA;You can find assembling instructions in [sundial page][5] (you can buy most materials from them)&#xD;&#xA;&#xD;&#xA;I will upload stateful code and post a link here, unfortunately I wont get all need hardware on time, so this is just an idea :)&#xD;&#xA;&#xD;&#xA;**Code written so far**:&#xD;&#xA;&#xD;&#xA;* [Persistent state machine library][6]&#xD;&#xA;&#xD;&#xA;Inspiration:![Original questbox][7]&#xD;&#xA;&#xD;&#xA;# Conclusion&#xD;&#xA;Learned how to integrate many components and libraries all toghether, I'll have to travel a bit to test it :)&#xD;&#xA;&#xD;&#xA;Budget can be cut quite a bit changing the concept a bit:&#xD;&#xA;&#xD;&#xA;* Change GPS with a numerical keypad: the 'player' has to guess/obtain a code instead of traveling to a location&#xD;&#xA;* Polulu switch and regulator can be exchanged for a [latching relay with capacitance coupling](http://forum.arduino.cc/index.php/topic,64596.0.html)&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Global_Positioning_System&#xD;&#xA;  [2]: https://www.sundial.com/&#xD;&#xA;  [3]: http://en.wikipedia.org/wiki/EEPROM&#xD;&#xA;  [4]: http://arduino.cc/en/Main/ArduinoBoardUno&#xD;&#xA;  [5]: https://www.sundial.com/quest-box/notes-for-builders/&#xD;&#xA;  [6]: https://www.biicode.com/hithwen/blocks/hithwen/statemachine/branches/master#.UzSTlmR5NUk&#xD;&#xA;  [7]: http://i.stack.imgur.com/864pF.jpg&#xD;&#xA;" />
  <row Id="3185" PostHistoryTypeId="24" PostId="915" RevisionGUID="25a9e9ba-6e9d-4698-9170-b5a07b7b9ae1" CreationDate="2014-04-08T18:45:43.877" Comment="Proposed by 510 approved by 11 edit id of 275" />
  <row Id="3186" PostHistoryTypeId="4" PostId="1104" RevisionGUID="7d5a34c5-7c22-4692-9b60-56afff8d5e3b" CreationDate="2014-04-08T21:42:57.973" UserId="220" Comment="Improved title" Text="How do I connect a PS4 controller connected to an Arduino that's connected to a laptop to another Arduino?" />
  <row Id="3187" PostHistoryTypeId="2" PostId="1123" RevisionGUID="0b86cd91-d743-4ff7-a459-a0ed684a7867" CreationDate="2014-04-08T22:34:59.453" UserId="973" Text="&quot;I tried same setup with arduino uno and the problem is gone. It also works on micro as long as gnd and 5v pin is connected to uno. Uno measured voltage is 4.88V and micro 4.60V could a voltage difference this small cause this? What else could this be?&quot;&#xD;&#xA;&#xD;&#xA;Looks to me like the problem is with the micro's 5V supply then. I suspect that the transducer output is fluctuating in a way that's too rapid to be seen by your meter, but which is sampled by the micro, giving your varying result numbers.&#xD;&#xA;&#xD;&#xA;Either the &quot;4.6V&quot; is inadequate to run the transducer, causing erratic transducer output, or the 4.6V itself is fluctuating, with similar results at the trans output. " />
  <row Id="3188" PostHistoryTypeId="5" PostId="1123" RevisionGUID="a5adc51f-40e6-41df-b02a-4a18afaa67db" CreationDate="2014-04-08T22:46:46.590" UserId="973" Comment="Added more detail on regulator and ground" Text="&quot;I tried same setup with arduino uno and the problem is gone. It also works on micro as long as gnd and 5v pin is connected to uno. Uno measured voltage is 4.88V and micro 4.60V could a voltage difference this small cause this? What else could this be?&quot;&#xD;&#xA;&#xD;&#xA;Looks to me like the problem is with the micro's 5V supply then. 4.6V indicates that the 5V regulator on the micro is not operating within its expected range. (Or if you are powering from USB, the regulator is not in play, but the 4.6V would indicate a problem with the USB's 5V supply.) &#xD;&#xA;&#xD;&#xA;Likely possibilities:, either the upstream supply is inadequate, or the micros and whatever is attached to it is drawing too much current.&#xD;&#xA;&#xD;&#xA;I suspect that the transducer output is fluctuating in a way that's too rapid to be seen by your meter, but which is sampled by the micro, giving your varying result numbers.&#xD;&#xA;&#xD;&#xA;Either the &quot;4.6V&quot; is inadequate to run the transducer, causing erratic transducer output, or the 4.6V itself is fluctuating, with similar results at the trans output. &#xD;&#xA;&#xD;&#xA;And you might also check the ground between micro and transducer -- are you sure that's wired correctly?" />
  <row Id="3189" PostHistoryTypeId="5" PostId="1123" RevisionGUID="42b6b294-0065-4c87-8638-fd3031cf4ca6" CreationDate="2014-04-08T23:41:50.420" UserId="220" Comment="Improved formatting" Text="&gt; I tried same setup with arduino uno and the problem is gone. It also works on micro as long as gnd and 5v pin is connected to uno. Uno measured voltage is 4.88V and micro 4.60V could a voltage difference this small cause this? What else could this be?&#xD;&#xA;&#xD;&#xA;Looks to me like the problem is with the board's 5V supply. 4.6V indicates that the 5V regulator on the board is not operating within its expected range. Also, your computer/USB power source could be providing less than 5V to your board.&#xD;&#xA;&#xD;&#xA;Here are some likely possibilities:&#xD;&#xA;&#xD;&#xA; - Your power supply is inadequate: not producing enough voltage.&#xD;&#xA; - Your board or whatever is attached to it is drawing too much current. This causes a drop in voltage.&#xD;&#xA;&#xD;&#xA;I suspect that the transducer output is fluctuating in a way that's too rapid to be seen by your multimeter, but which is sampled by the microproccessor, giving your varying result numbers.&#xD;&#xA;&#xD;&#xA;Either the &quot;4.6V&quot; is inadequate to run the transducer, causing erratic transducer output, or the 4.6V itself is fluctuating, with similar results at the transducer output. &#xD;&#xA;&#xD;&#xA;And you might also check the ground between micro and transducer: are you sure that's wired correctly?" />
  <row Id="3190" PostHistoryTypeId="2" PostId="1124" RevisionGUID="b525f591-08b8-4022-9ee7-b3e6ebf1148b" CreationDate="2014-04-09T00:19:33.763" UserId="977" Text="My project is to control car windows using voice recognition. I have successfully controlled some LED's using the EasyVR arduino shield using and arduino MEGA. Now I want to take control of the windows using the CAN-BUS arduino shield.&#xD;&#xA;&#xD;&#xA;Because the car that I own doesn't have an OBD-II connector, I am using two arduinos with two CAN-BUS arduino shields making one a sender and the other a receiver. Now I don't know how to program the CAN-BUS arduino shield to make a simulation of the car's windows ?" />
  <row Id="3191" PostHistoryTypeId="1" PostId="1124" RevisionGUID="b525f591-08b8-4022-9ee7-b3e6ebf1148b" CreationDate="2014-04-09T00:19:33.763" UserId="977" Text="How to program a CAN-BUS arduino shield to control car windows?" />
  <row Id="3192" PostHistoryTypeId="3" PostId="1124" RevisionGUID="b525f591-08b8-4022-9ee7-b3e6ebf1148b" CreationDate="2014-04-09T00:19:33.763" UserId="977" Text="&lt;arduino-uno&gt;&lt;arduino-mega&gt;" />
  <row Id="3193" PostHistoryTypeId="2" PostId="1125" RevisionGUID="d673aa58-3e24-4495-919b-a188f8bf6e7a" CreationDate="2014-04-09T00:24:57.757" UserId="666" Text="You actually present 2 issues here, which can be handled separately:&#xD;&#xA;&#xD;&#xA;- You are concerned about having a WiFi, not an Ethernet shield. This doesnt affect at all for sending emails or any other network stuff. When you have internet connection, it is almost transparent from the programming side. So I recommend first to try your wifi shield connection and configuration as a separate problem, with a more simple task, as a simple HTTP_GET to a known web page. A function like this might help, assuming that you have an instance of WiFiClient (which is a Client), that has been connected (with connect) to the URL and port 80:&#xD;&#xA;&#xD;&#xA;        void http_get(Client&amp; www, char website[], char webpage[], int timeout, Stream&amp; stream) {&#xD;&#xA;            if (www.connected()) {&#xD;&#xA;                int n = www.print(&quot;GET &quot;);&#xD;&#xA;                www.print(webpage);&#xD;&#xA;                www.print(&quot; HTTP/1.1\r\n&quot;);&#xD;&#xA;                www.print(&quot;Host: &quot;);&#xD;&#xA;                www.print(website);&#xD;&#xA;                www.print(&quot;\r\n&quot;);&#xD;&#xA;                www.print(&quot;\r\n&quot;);&#xD;&#xA;            } else {&#xD;&#xA;                stream.println(F(&quot;Connection failed get&quot;));&#xD;&#xA;                return;&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            /* Read data until either the connection is closed, or the idle timeout is reached. */&#xD;&#xA;            unsigned long lastRead = millis();&#xD;&#xA;            while (www.connected() &amp;&amp; (millis() - lastRead &lt; timeout)) {&#xD;&#xA;                while (www.available()) {&#xD;&#xA;                    char c = www.read();&#xD;&#xA;                    stream.print(c);&#xD;&#xA;                    lastRead = millis();&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;- The second problem is that you want to send an email. One you have a connection, it doesnt matter if it is wifi or wired. The above recommended libraries (SMTPClient, FullIP) will directly connect to your provider (e.g. gmail) and will request your gmail password, something that is not secure over non secure connections (and those libraries do not seem to provide secure layer), so personally I am not comfortable with that option. I have been using the [temboo][1] service, that allows to send emails, and I have found it to be quite convenient and simple. Furthermore, they also have many other services. The service stores your gmail or whatever provider credentials, and you access the service via a Secret Key and App Password they provide. While this keys might not be fully secure to be sent via non secure layers, at least it only compromises your app in the cloud application, which you might simply manage, and not your full email account. (Disclaimer: I have no relation with temboo, and there might be other similar services for this task, e.g. [Carriots][2], I simply say that I have used them with success for this task and feel it is relatively simple). Your code using temboo, could be something like:&#xD;&#xA;&#xD;&#xA;		&#xD;&#xA;&#xD;&#xA;		TembooChoreo choreo(client); // your WiFiClient object&#xD;&#xA;&#xD;&#xA;		// Set Temboo account credentials&#xD;&#xA;		choreo.setAccountName(temboo_account);&#xD;&#xA;		choreo.setAppKeyName(temboo_app);&#xD;&#xA;		choreo.setAppKey(temboo_app_key);&#xD;&#xA;&#xD;&#xA;		// credential is the name of your gmail profile in temboo&#xD;&#xA;		choreo.setCredential(credential);&#xD;&#xA;		choreo.addInput(&quot;MessageBody&quot;, body);&#xD;&#xA;		choreo.addInput(&quot;Subject&quot;, subject);&#xD;&#xA;		choreo.addInput(&quot;ToAddress&quot;, address);&#xD;&#xA;&#xD;&#xA;		//Identify the Choreo to run&#xD;&#xA;		choreo.setChoreo(&quot;/Library/Google/Gmail/SendEmail&quot;);&#xD;&#xA;&#xD;&#xA;		choreo.run();&#xD;&#xA;		choreo.close();&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.temboo.com&#xD;&#xA;  [2]: https://www.carriots.com/documentation/arduino" />
  <row Id="3194" PostHistoryTypeId="2" PostId="1126" RevisionGUID="0588a491-4494-46f9-926e-5a4e63b88cb2" CreationDate="2014-04-09T00:44:17.830" UserId="979" Text="I am trying to create a wireless remote control to control a servo motor via Bluetooth. What all do I need to establish this? I did some research and found the following:&#xD;&#xA;&#xD;&#xA;[Tinyduino][1]&#xD;&#xA;&#xD;&#xA;[Bluetooth low energy shield][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://tiny-circuits.com/products/tinyduino/&#xD;&#xA;  [2]: https://tiny-circuits.com/shop/tinyshield-bluetooth-le/&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Would these be enough (in addition to the servo motor) to establish my needs? Any advice on how I would go about coding this? I can research on the specifics but hints on functions to use would be greatly appreciated. Thanks!" />
  <row Id="3195" PostHistoryTypeId="1" PostId="1126" RevisionGUID="0588a491-4494-46f9-926e-5a4e63b88cb2" CreationDate="2014-04-09T00:44:17.830" UserId="979" Text="Creating a wireless remote" />
  <row Id="3196" PostHistoryTypeId="3" PostId="1126" RevisionGUID="0588a491-4494-46f9-926e-5a4e63b88cb2" CreationDate="2014-04-09T00:44:17.830" UserId="979" Text="&lt;bluetooth&gt;&lt;remote-control&gt;" />
  <row Id="3197" PostHistoryTypeId="5" PostId="1123" RevisionGUID="2139cf14-9544-46e3-9e2b-e8cf63cdbc6b" CreationDate="2014-04-09T01:03:08.310" UserId="973" Comment="Undid erroneous edits by Annonymous Person" Text="&gt; I tried same setup with arduino uno and the problem is gone. It also works on micro as long as gnd and 5v pin is connected to uno. Uno measured voltage is 4.88V and micro 4.60V could a voltage difference this small cause this? What else could this be?&#xD;&#xA;&#xD;&#xA;Reinstatement of incorrect edits by Annonymous Person&#xD;&#xA;(AP: Please do not edit answers in such a way that you entirely change their meaning. In the current discussion &quot;the board&quot; is meaningless. We are trying to distinguish between symptoms seen in two different 'boards', an Arduino Uno, and an Arduino Micro.)&#xD;&#xA;&#xD;&#xA;Looks to me like the problem is with the Arduino Micro's 5V supply then. &#xD;&#xA;&#xD;&#xA;If you are powering the Micro from an external supply (not USB), then 4.6V on the Micro's &quot;5V&quot; output would indicate that the 5V regulator is not operating within its expected range. &#xD;&#xA;&#xD;&#xA;If you _are_ powering from USB, then the regulator is not in play. The 4.6V would indicate a problem with the USB's 5V supply.&#xD;&#xA;&#xD;&#xA;Likely possibilities:, either the upstream supply is inadequate, or the micros and whatever is attached to it is drawing too much current.&#xD;&#xA;&#xD;&#xA;I suspect that the transducer output is fluctuating in a way that's too rapid to be seen by your meter, but which is sampled by the Arduino Micro, giving your varying result numbers.&#xD;&#xA;&#xD;&#xA;Either the &quot;4.6V&quot; is inadequate to run the transducer, causing erratic transducer output, or the 4.6V itself is fluctuating, with similar results at the trans output.&#xD;&#xA;&#xD;&#xA;And you might also check the ground between micro and transducer -- are you sure that's wired correctly?" />
  <row Id="3198" PostHistoryTypeId="10" PostId="1124" RevisionGUID="14270a00-6934-4d68-8849-587265898cf6" CreationDate="2014-04-09T01:06:17.907" UserId="220" Comment="104" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:220,&quot;DisplayName&quot;:&quot;Annonomus Person&quot;}]}" />
  <row Id="3199" PostHistoryTypeId="5" PostId="1123" RevisionGUID="2754dc4a-08c2-4234-80c2-2b2f0c8962fa" CreationDate="2014-04-09T01:16:33.127" UserId="973" Comment="Typo" Text="&gt; I tried same setup with arduino uno and the problem is gone. It also works on micro as long as gnd and 5v pin is connected to uno. Uno measured voltage is 4.88V and micro 4.60V could a voltage difference this small cause this? What else could this be?&#xD;&#xA;&#xD;&#xA;Reinstatement of incorrect edits by Annonomus Person&#xD;&#xA;(AP: Please do not edit answers in such a way that you entirely change their meaning. In the current discussion &quot;the board&quot; is meaningless. We are trying to distinguish between symptoms seen in two different 'boards', an Arduino Uno, and an Arduino Micro.)&#xD;&#xA;&#xD;&#xA;Looks to me like the problem is with the Arduino Micro's 5V supply then. &#xD;&#xA;&#xD;&#xA;If you are powering the Micro from an external supply (not USB), then 4.6V on the Micro's &quot;5V&quot; output would indicate that the 5V regulator is not operating within its expected range. &#xD;&#xA;&#xD;&#xA;If you _are_ powering from USB, then the regulator is not in play. The 4.6V would indicate a problem with the USB's 5V supply.&#xD;&#xA;&#xD;&#xA;Likely possibilities:, either the upstream supply is inadequate, or the micros and whatever is attached to it is drawing too much current.&#xD;&#xA;&#xD;&#xA;I suspect that the transducer output is fluctuating in a way that's too rapid to be seen by your meter, but which is sampled by the Arduino Micro, giving your varying result numbers.&#xD;&#xA;&#xD;&#xA;Either the &quot;4.6V&quot; is inadequate to run the transducer, causing erratic transducer output, or the 4.6V itself is fluctuating, with similar results at the trans output.&#xD;&#xA;&#xD;&#xA;And you might also check the ground between micro and transducer -- are you sure that's wired correctly?" />
  <row Id="3200" PostHistoryTypeId="2" PostId="1127" RevisionGUID="304b7c15-ac50-4b3f-b5b6-ac0b82cf3060" CreationDate="2014-04-09T03:22:53.033" UserId="973" Text="Adding some references to already-written libraries and examples, to enable comparison between different approaches, and experiences with speed versus susceptibility to missing steps.&#xD;&#xA;&#xD;&#xA;Reading rotary encoders:&#xD;&#xA;http://playground.arduino.cc/Main/RotaryEncoders&#xD;&#xA;&#xD;&#xA;Quadrature Encoder too Fast for Arduino (with Solution): http://www.hessmer.org/blog/2011/01/30/quadrature-encoder-too-fast-for-arduino/&#xD;&#xA;&#xD;&#xA;Teensy Encoder library: https://www.pjrc.com/teensy/td_libs_Encoder.html&#xD;&#xA;&#xD;&#xA;Reading rotary encoder on Arduino:&#xD;&#xA;http://www.circuitsathome.com/mcu/reading-rotary-encoder-on-arduino/" />
  <row Id="3201" PostHistoryTypeId="2" PostId="1128" RevisionGUID="79b17767-a872-4705-8574-1ad3926049a5" CreationDate="2014-04-09T03:31:11.847" UserId="600" Text="Is there any good way to calibrate the watchdog timer? I'm trying to use it as a time source, even when asleep, but it's woefully inaccurate. Some simple testing showed it loosing 2 minutes every *hour*!" />
  <row Id="3202" PostHistoryTypeId="1" PostId="1128" RevisionGUID="79b17767-a872-4705-8574-1ad3926049a5" CreationDate="2014-04-09T03:31:11.847" UserId="600" Text="Calibrate Watchdog Timer" />
  <row Id="3203" PostHistoryTypeId="3" PostId="1128" RevisionGUID="79b17767-a872-4705-8574-1ad3926049a5" CreationDate="2014-04-09T03:31:11.847" UserId="600" Text="&lt;timers&gt;" />
  <row Id="3204" PostHistoryTypeId="2" PostId="1129" RevisionGUID="c5d0595e-d126-4c41-8e70-9382ccf6ab10" CreationDate="2014-04-09T03:42:30.483" UserId="368" Text="Not only is it uncalibrateable, but it's actually pretty rubbish (as you've discovered). If you check the datasheet you'll see that it can vary between about 109kHz and 119kHz, even though its nominal frequency is 128kHz. If you need accuracy then you should consider moving up to an AVR family that has a separate asynchronous timer that can be supplied with a watch crystal, such as the ATmegaXX4P (Sanguino) or ATmegaXXX0 (Mega/Mega 2560)." />
  <row Id="3205" PostHistoryTypeId="5" PostId="1129" RevisionGUID="11b99835-8763-4a31-b4f0-d6addabb7f3a" CreationDate="2014-04-09T03:58:58.360" UserId="368" Comment="added 494 characters in body" Text="Not only is it uncalibrateable, but it's actually pretty rubbish (as you've discovered). If you check the datasheet you'll see that it can vary between about 109kHz and 119kHz, even though its nominal frequency is 128kHz.&#xD;&#xA;&#xD;&#xA;With the ATmegaXX8(A/P) you can reconfigure the system to run its CPU off the internal RC oscillator and timer 2 from a crystal across TOSC1/TOSC2 (pins 9/10 [DIP] or 7/8 [TQFP]) by setting ASSR[6:5] to 0b01 and changing the CKSEL[3:0] fuse bits to 0b0010. Take careful note of the warning on AS2 in the datasheet though. If you want to use a watch crystal instead of prescaling the existing crystal on an Arduino board then you'll need some soldering skill as well.&#xD;&#xA;&#xD;&#xA;If you need crystal accuracy for the CPU as well then you'll need to move up to an AVR family that has a separate asynchronous timer that can be supplied with a watch crystal, such as the ATmegaXX4(P) (Sanguino) or ATmegaXXX0 (Mega/Mega 2560)." />
  <row Id="3206" PostHistoryTypeId="2" PostId="1130" RevisionGUID="ba660bb1-6ed1-41e7-be73-16277fb40239" CreationDate="2014-04-09T04:32:39.923" UserId="983" Text="I would also check out [RFDuino][1].&#xD;&#xA;&#xD;&#xA;Basically it's a finger-tip sized, Arduino compatible, wireless enabled microcontroller, low cost enough to leave in all of your projects.&#xD;&#xA;&#xD;&#xA;The RFduino runs Arduino code and can do everything an Arduino can.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.rfduino.com/" />
  <row Id="3207" PostHistoryTypeId="2" PostId="1131" RevisionGUID="43136834-9992-4368-9077-e786e4a65e8a" CreationDate="2014-04-09T05:08:12.353" UserId="904" Text="I have run this code  successfully on arduino. Let me know how to set my own address to analog output port for slave. I have 3 analog output . i wanted to read values from these values. How to set these value. &#xD;&#xA;2) i have format date/time  format from A4 and A5 , These value has to be stored in word format how to store  result in word format.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &lt;modbus.h&gt;&#xD;&#xA;    #include &lt;modbusDevice.h&gt;&#xD;&#xA;    #include &lt;modbusRegBank.h&gt;&#xD;&#xA;    #include &lt;modbusSlave.h&gt;&#xD;&#xA;    modbusDevice regBank;&#xD;&#xA;    modbusSlave slave;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {   &#xD;&#xA;      regBank.setId(1);&#xD;&#xA;      //Add Digital Output registers 00001-00016 to the register bank&#xD;&#xA;      regBank.add(1);&#xD;&#xA;      regBank.add(2);&#xD;&#xA;      regBank.add(3);&#xD;&#xA;      regBank.add(4);&#xD;&#xA;      regBank.add(5);&#xD;&#xA;      regBank.add(6);&#xD;&#xA;      regBank.add(7);&#xD;&#xA;      regBank.add(8);&#xD;&#xA;      regBank.add(9);&#xD;&#xA;      regBank.add(10);&#xD;&#xA;      regBank.add(11);&#xD;&#xA;      regBank.add(12);&#xD;&#xA;      regBank.add(13);&#xD;&#xA;      regBank.add(14);&#xD;&#xA;      regBank.add(15);&#xD;&#xA;      regBank.add(16);&#xD;&#xA;    &#xD;&#xA;      //Add Digital Input registers 10001-10008 to the register bank&#xD;&#xA;      regBank.add(10001);  &#xD;&#xA;      regBank.add(10002);  &#xD;&#xA;      regBank.add(10003);  &#xD;&#xA;      regBank.add(10004);  &#xD;&#xA;      regBank.add(10005);  &#xD;&#xA;      regBank.add(10006);  &#xD;&#xA;      regBank.add(10007);  &#xD;&#xA;      regBank.add(10008);  &#xD;&#xA;    &#xD;&#xA;      //Add Analog Input registers 30001-10010 to the register bank&#xD;&#xA;      regBank.add(30001);  &#xD;&#xA;      regBank.add(30002);  &#xD;&#xA;      regBank.add(30003);  &#xD;&#xA;      regBank.add(30004);  &#xD;&#xA;      regBank.add(30005);  &#xD;&#xA;      regBank.add(30006);  &#xD;&#xA;      regBank.add(30007);  &#xD;&#xA;      regBank.add(30008);  &#xD;&#xA;      regBank.add(30009);  &#xD;&#xA;      regBank.add(30010);  &#xD;&#xA;    &#xD;&#xA;      //Add Analog Output registers 40001-40020 to the register bank&#xD;&#xA;      regBank.add(40001);  &#xD;&#xA;      regBank.add(40002);  &#xD;&#xA;      regBank.add(40003);  &#xD;&#xA;      regBank.add(40004);  &#xD;&#xA;      regBank.add(40005);  &#xD;&#xA;      regBank.add(40006);  &#xD;&#xA;      regBank.add(40007);  &#xD;&#xA;      regBank.add(40008);  &#xD;&#xA;      regBank.add(40009);  &#xD;&#xA;      regBank.add(40010);  &#xD;&#xA;      regBank.add(40011);  &#xD;&#xA;      regBank.add(40012);  &#xD;&#xA;      regBank.add(40013);  &#xD;&#xA;      regBank.add(40014);  &#xD;&#xA;      regBank.add(40015);  &#xD;&#xA;      regBank.add(40016);  &#xD;&#xA;      regBank.add(40017);  &#xD;&#xA;      regBank.add(40018);  &#xD;&#xA;      regBank.add(40019);  &#xD;&#xA;      regBank.add(40020);  &#xD;&#xA;      slave._device = &amp;regBank;  &#xD;&#xA;    &#xD;&#xA;      // Initialize the serial port for coms at 9600 baud  &#xD;&#xA;      slave.setBaud(9600);   &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      //put some data into the registers&#xD;&#xA;      regBank.set(1, 1);  &#xD;&#xA;      regBank.set(2, 1);  &#xD;&#xA;      regBank.set(3, 0);  &#xD;&#xA;      regBank.set(4, 1);  &#xD;&#xA;      regBank.set(5, 1);  &#xD;&#xA;      regBank.set(6, 0);  &#xD;&#xA;      regBank.set(7, 1);  &#xD;&#xA;      regBank.set(8, 0);  &#xD;&#xA;    &#xD;&#xA;      regBank.set(10001, 1);&#xD;&#xA;      regBank.set(10002, 1);  &#xD;&#xA;      regBank.set(10003, 1);  &#xD;&#xA;      regBank.set(10004, 1);  &#xD;&#xA;      regBank.set(10005, 0);  &#xD;&#xA;      regBank.set(10006, 0);  &#xD;&#xA;      regBank.set(10007, 0);  &#xD;&#xA;      regBank.set(10008, 0);  &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      regBank.set(30001,1);&#xD;&#xA;      regBank.set(30002,2);&#xD;&#xA;      regBank.set(30003,3);&#xD;&#xA;      regBank.set(30004,4);&#xD;&#xA;      regBank.set(30005,5);&#xD;&#xA;      regBank.set(30006,6);&#xD;&#xA;      regBank.set(30007,7);&#xD;&#xA;      regBank.set(30008,8);&#xD;&#xA;      regBank.set(30009,9);&#xD;&#xA;      regBank.set(30010,10);&#xD;&#xA;    &#xD;&#xA;      regBank.set(40001,1);&#xD;&#xA;      regBank.set(40002,2);&#xD;&#xA;      regBank.set(40003,2);&#xD;&#xA;      regBank.set(40004,4);&#xD;&#xA;      regBank.set(40005,5);&#xD;&#xA;      regBank.set(40006,6);&#xD;&#xA;      regBank.set(40007,7);&#xD;&#xA;      regBank.set(40008,8);&#xD;&#xA;      regBank.set(40009,9);&#xD;&#xA;      regBank.set(40010,10);&#xD;&#xA;    &#xD;&#xA;      while(1)&#xD;&#xA;      {&#xD;&#xA;        //put a random number into registers 1, 10001, 30001 and 40001&#xD;&#xA;        regBank.set(1, (byte) random(0, 2));&#xD;&#xA;        regBank.set(10001, (byte) random(0, 2));&#xD;&#xA;        regBank.set(30001, (word) random(0, 32767));&#xD;&#xA;        regBank.set(40001, (word) random(0, 32767));&#xD;&#xA;    &#xD;&#xA;        slave.run();  &#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I have also below code running successfully.&#xD;&#xA;&#xD;&#xA;    #define ID   3&#xD;&#xA;    &#xD;&#xA;    Modbus slave(ID, 0, 0);&#xD;&#xA;    boolean led;&#xD;&#xA;    int8_t state = 0;&#xD;&#xA;    unsigned long tempus;&#xD;&#xA;    // data array for modbus network sharing&#xD;&#xA;    uint16_t au16data[9];&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      // define i/o&#xD;&#xA;      pinMode(2, INPUT);&#xD;&#xA;      pinMode(3, INPUT);&#xD;&#xA;      pinMode(4, INPUT);&#xD;&#xA;      pinMode(5, INPUT);&#xD;&#xA;      pinMode(6, OUTPUT);&#xD;&#xA;      pinMode(7, OUTPUT);&#xD;&#xA;      pinMode(8, OUTPUT);&#xD;&#xA;      pinMode(9, OUTPUT);&#xD;&#xA;      pinMode(10, OUTPUT);&#xD;&#xA;      pinMode(11, OUTPUT);&#xD;&#xA;      pinMode(13, OUTPUT);&#xD;&#xA;    &#xD;&#xA;      digitalWrite(6, LOW );&#xD;&#xA;      digitalWrite(7, LOW );&#xD;&#xA;      digitalWrite(8, LOW );&#xD;&#xA;      digitalWrite(9, LOW );&#xD;&#xA;      digitalWrite(13, HIGH );&#xD;&#xA;      analogWrite(10, 0 );&#xD;&#xA;      analogWrite(11, 0 );&#xD;&#xA;    &#xD;&#xA;      // start communication&#xD;&#xA;      slave.begin( 19200 );&#xD;&#xA;      tempus = millis() + 100;&#xD;&#xA;      digitalWrite(13, HIGH );&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      // poll messages&#xD;&#xA;      // blink led pin on each valid message&#xD;&#xA;      state = slave.poll( au16data, 9 );&#xD;&#xA;      if (state &gt; 4) {&#xD;&#xA;        tempus = millis() + 50;&#xD;&#xA;        digitalWrite(13, HIGH);&#xD;&#xA;      }&#xD;&#xA;      if (millis() &gt; tempus) digitalWrite(13, LOW );&#xD;&#xA;    &#xD;&#xA;      // get digital inputs -&gt; au16data[0]&#xD;&#xA;      bitWrite( au16data[0], 0, digitalRead( 2 ));&#xD;&#xA;      bitWrite( au16data[0], 1, digitalRead( 3 ));&#xD;&#xA;      bitWrite( au16data[0], 2, digitalRead( 4 ));&#xD;&#xA;      bitWrite( au16data[0], 3, digitalRead( 5 ));&#xD;&#xA;    &#xD;&#xA;      // set digital outputs -&gt; au16data[1]&#xD;&#xA;      digitalWrite( 6, bitRead( au16data[1], 0 ));&#xD;&#xA;      digitalWrite( 7, bitRead( au16data[1], 1 ));&#xD;&#xA;      digitalWrite( 8, bitRead( au16data[1], 2 ));&#xD;&#xA;      digitalWrite( 9, bitRead( au16data[1], 3 ));&#xD;&#xA;    &#xD;&#xA;      // set analog outputs&#xD;&#xA;      analogWrite( 10, au16data[2] );&#xD;&#xA;      analogWrite( 11, au16data[3] );&#xD;&#xA;    &#xD;&#xA;      // read analog inputs&#xD;&#xA;      au16data[4] = analogRead( 0 );&#xD;&#xA;      au16data[5] = analogRead( 1 );&#xD;&#xA;    &#xD;&#xA;      // diagnose communication&#xD;&#xA;      au16data[6] = slave.getInCnt();&#xD;&#xA;      au16data[7] = slave.getOutCnt();&#xD;&#xA;      au16data[8] = slave.getErrCnt();&#xD;&#xA;    } &#xD;&#xA;     " />
  <row Id="3208" PostHistoryTypeId="1" PostId="1131" RevisionGUID="43136834-9992-4368-9077-e786e4a65e8a" CreationDate="2014-04-09T05:08:12.353" UserId="904" Text="Modbus setting address" />
  <row Id="3209" PostHistoryTypeId="3" PostId="1131" RevisionGUID="43136834-9992-4368-9077-e786e4a65e8a" CreationDate="2014-04-09T05:08:12.353" UserId="904" Text="&lt;arduino-uno&gt;&lt;arduino-mega&gt;&lt;networking&gt;&lt;modbus&gt;" />
  <row Id="3210" PostHistoryTypeId="5" PostId="1131" RevisionGUID="8e5e1962-736e-487f-b5da-46227850f321" CreationDate="2014-04-09T05:53:07.993" UserId="904" Comment="problem explained properly" Text="I have 2 code . Which are running properly on arduino. I am QMODBUS software to see result which acts as master.I am newbie to modbus lib implementation.&#xD;&#xA;&#xD;&#xA;Question are &#xD;&#xA;&#xD;&#xA; - **In code , is it possible to assign our own slave address. if yes how i can assign it??&#xD;&#xA; - I am reading value in the form dd/mm/sec hh/mm/sec. In two below code how to assign to particular address&#xD;&#xA; - I have parameter name say example latitude=15.08 now how to assign 15 in to lower byte of word and 08 into higher byte address.&#xD;&#xA; -i have analog sensor which read value from -75 deg to 75 degree. when i converted qmodbus read +ve value properly 0-75 degree properly , but when it reading -ve value it represent 65558 some value . Is it possible to read -ve value, if yes how to read it.** &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;        #include &lt;modbus.h&gt;&#xD;&#xA;        #include &lt;modbusDevice.h&gt;&#xD;&#xA;        #include &lt;modbusRegBank.h&gt;&#xD;&#xA;        #include &lt;modbusSlave.h&gt;&#xD;&#xA;        modbusDevice regBank;&#xD;&#xA;        modbusSlave slave;&#xD;&#xA;        &#xD;&#xA;        void setup()&#xD;&#xA;        {   &#xD;&#xA;          regBank.setId(1);&#xD;&#xA;          //Add Digital Output registers 00001-00016 to the register bank&#xD;&#xA;          regBank.add(1);&#xD;&#xA;          regBank.add(2);&#xD;&#xA;          regBank.add(3);&#xD;&#xA;          regBank.add(4);&#xD;&#xA;          regBank.add(5);&#xD;&#xA;          regBank.add(6);&#xD;&#xA;          regBank.add(7);&#xD;&#xA;          regBank.add(8);&#xD;&#xA;          regBank.add(9);&#xD;&#xA;          regBank.add(10);&#xD;&#xA;          regBank.add(11);&#xD;&#xA;          regBank.add(12);&#xD;&#xA;          regBank.add(13);&#xD;&#xA;          regBank.add(14);&#xD;&#xA;          regBank.add(15);&#xD;&#xA;          regBank.add(16);&#xD;&#xA;        &#xD;&#xA;          //Add Digital Input registers 10001-10008 to the register bank&#xD;&#xA;          regBank.add(10001);  &#xD;&#xA;          regBank.add(10002);  &#xD;&#xA;          regBank.add(10003);  &#xD;&#xA;          regBank.add(10004);  &#xD;&#xA;          regBank.add(10005);  &#xD;&#xA;          regBank.add(10006);  &#xD;&#xA;          regBank.add(10007);  &#xD;&#xA;          regBank.add(10008);  &#xD;&#xA;        &#xD;&#xA;          //Add Analog Input registers 30001-10010 to the register bank&#xD;&#xA;          regBank.add(30001);  &#xD;&#xA;          regBank.add(30002);  &#xD;&#xA;          regBank.add(30003);  &#xD;&#xA;          regBank.add(30004);  &#xD;&#xA;          regBank.add(30005);  &#xD;&#xA;          regBank.add(30006);  &#xD;&#xA;          regBank.add(30007);  &#xD;&#xA;          regBank.add(30008);  &#xD;&#xA;          regBank.add(30009);  &#xD;&#xA;          regBank.add(30010);  &#xD;&#xA;        &#xD;&#xA;          //Add Analog Output registers 40001-40020 to the register bank&#xD;&#xA;          regBank.add(40001);  &#xD;&#xA;          regBank.add(40002);  &#xD;&#xA;          regBank.add(40003);  &#xD;&#xA;          regBank.add(40004);  &#xD;&#xA;          regBank.add(40005);  &#xD;&#xA;          regBank.add(40006);  &#xD;&#xA;          regBank.add(40007);  &#xD;&#xA;          regBank.add(40008);  &#xD;&#xA;          regBank.add(40009);  &#xD;&#xA;          regBank.add(40010);  &#xD;&#xA;          regBank.add(40011);  &#xD;&#xA;          regBank.add(40012);  &#xD;&#xA;          regBank.add(40013);  &#xD;&#xA;          regBank.add(40014);  &#xD;&#xA;          regBank.add(40015);  &#xD;&#xA;          regBank.add(40016);  &#xD;&#xA;          regBank.add(40017);  &#xD;&#xA;          regBank.add(40018);  &#xD;&#xA;          regBank.add(40019);  &#xD;&#xA;          regBank.add(40020);  &#xD;&#xA;          slave._device = &amp;regBank;  &#xD;&#xA;        &#xD;&#xA;          // Initialize the serial port for coms at 9600 baud  &#xD;&#xA;          slave.setBaud(9600);   &#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        void loop()&#xD;&#xA;        {&#xD;&#xA;          //put some data into the registers&#xD;&#xA;          regBank.set(1, 1);  &#xD;&#xA;          regBank.set(2, 1);  &#xD;&#xA;          regBank.set(3, 0);  &#xD;&#xA;          regBank.set(4, 1);  &#xD;&#xA;          regBank.set(5, 1);  &#xD;&#xA;          regBank.set(6, 0);  &#xD;&#xA;          regBank.set(7, 1);  &#xD;&#xA;          regBank.set(8, 0);  &#xD;&#xA;        &#xD;&#xA;          regBank.set(10001, 1);&#xD;&#xA;          regBank.set(10002, 1);  &#xD;&#xA;          regBank.set(10003, 1);  &#xD;&#xA;          regBank.set(10004, 1);  &#xD;&#xA;          regBank.set(10005, 0);  &#xD;&#xA;          regBank.set(10006, 0);  &#xD;&#xA;          regBank.set(10007, 0);  &#xD;&#xA;          regBank.set(10008, 0);  &#xD;&#xA;        &#xD;&#xA;        &#xD;&#xA;          regBank.set(30001,1);&#xD;&#xA;          regBank.set(30002,2);&#xD;&#xA;          regBank.set(30003,3);&#xD;&#xA;          regBank.set(30004,4);&#xD;&#xA;          regBank.set(30005,5);&#xD;&#xA;          regBank.set(30006,6);&#xD;&#xA;          regBank.set(30007,7);&#xD;&#xA;          regBank.set(30008,8);&#xD;&#xA;          regBank.set(30009,9);&#xD;&#xA;          regBank.set(30010,10);&#xD;&#xA;        &#xD;&#xA;          regBank.set(40001,1);&#xD;&#xA;          regBank.set(40002,2);&#xD;&#xA;          regBank.set(40003,2);&#xD;&#xA;          regBank.set(40004,4);&#xD;&#xA;          regBank.set(40005,5);&#xD;&#xA;          regBank.set(40006,6);&#xD;&#xA;          regBank.set(40007,7);&#xD;&#xA;          regBank.set(40008,8);&#xD;&#xA;          regBank.set(40009,9);&#xD;&#xA;          regBank.set(40010,10);&#xD;&#xA;        &#xD;&#xA;          while(1)&#xD;&#xA;          {&#xD;&#xA;            //put a random number into registers 1, 10001, 30001 and 40001&#xD;&#xA;            regBank.set(1, (byte) random(0, 2));&#xD;&#xA;            regBank.set(10001, (byte) random(0, 2));&#xD;&#xA;            regBank.set(30001, (word) random(0, 32767));&#xD;&#xA;            regBank.set(40001, (word) random(0, 32767));&#xD;&#xA;        &#xD;&#xA;            slave.run();  &#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    I have also below code running successfully.&#xD;&#xA;    &#xD;&#xA;        #define ID   3&#xD;&#xA;        &#xD;&#xA;        Modbus slave(ID, 0, 0);&#xD;&#xA;        boolean led;&#xD;&#xA;        int8_t state = 0;&#xD;&#xA;        unsigned long tempus;&#xD;&#xA;        // data array for modbus network sharing&#xD;&#xA;        uint16_t au16data[9];&#xD;&#xA;        &#xD;&#xA;        &#xD;&#xA;        void setup() {&#xD;&#xA;          // define i/o&#xD;&#xA;          pinMode(2, INPUT);&#xD;&#xA;          pinMode(3, INPUT);&#xD;&#xA;          pinMode(4, INPUT);&#xD;&#xA;          pinMode(5, INPUT);&#xD;&#xA;          pinMode(6, OUTPUT);&#xD;&#xA;          pinMode(7, OUTPUT);&#xD;&#xA;          pinMode(8, OUTPUT);&#xD;&#xA;          pinMode(9, OUTPUT);&#xD;&#xA;          pinMode(10, OUTPUT);&#xD;&#xA;          pinMode(11, OUTPUT);&#xD;&#xA;          pinMode(13, OUTPUT);&#xD;&#xA;        &#xD;&#xA;          digitalWrite(6, LOW );&#xD;&#xA;          digitalWrite(7, LOW );&#xD;&#xA;          digitalWrite(8, LOW );&#xD;&#xA;          digitalWrite(9, LOW );&#xD;&#xA;          digitalWrite(13, HIGH );&#xD;&#xA;          analogWrite(10, 0 );&#xD;&#xA;          analogWrite(11, 0 );&#xD;&#xA;        &#xD;&#xA;          // start communication&#xD;&#xA;          slave.begin( 19200 );&#xD;&#xA;          tempus = millis() + 100;&#xD;&#xA;          digitalWrite(13, HIGH );&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        &#xD;&#xA;        void loop() {&#xD;&#xA;          // poll messages&#xD;&#xA;          // blink led pin on each valid message&#xD;&#xA;          state = slave.poll( au16data, 9 );&#xD;&#xA;          if (state &gt; 4) {&#xD;&#xA;            tempus = millis() + 50;&#xD;&#xA;            digitalWrite(13, HIGH);&#xD;&#xA;          }&#xD;&#xA;          if (millis() &gt; tempus) digitalWrite(13, LOW );&#xD;&#xA;        &#xD;&#xA;          // get digital inputs -&gt; au16data[0]&#xD;&#xA;          bitWrite( au16data[0], 0, digitalRead( 2 ));&#xD;&#xA;          bitWrite( au16data[0], 1, digitalRead( 3 ));&#xD;&#xA;          bitWrite( au16data[0], 2, digitalRead( 4 ));&#xD;&#xA;          bitWrite( au16data[0], 3, digitalRead( 5 ));&#xD;&#xA;        &#xD;&#xA;          // set digital outputs -&gt; au16data[1]&#xD;&#xA;          digitalWrite( 6, bitRead( au16data[1], 0 ));&#xD;&#xA;          digitalWrite( 7, bitRead( au16data[1], 1 ));&#xD;&#xA;          digitalWrite( 8, bitRead( au16data[1], 2 ));&#xD;&#xA;          digitalWrite( 9, bitRead( au16data[1], 3 ));&#xD;&#xA;        &#xD;&#xA;          // set analog outputs&#xD;&#xA;          analogWrite( 10, au16data[2] );&#xD;&#xA;          analogWrite( 11, au16data[3] );&#xD;&#xA;        &#xD;&#xA;          // read analog inputs&#xD;&#xA;          au16data[4] = analogRead( 0 );&#xD;&#xA;          au16data[5] = analogRead( 1 );&#xD;&#xA;        &#xD;&#xA;          // diagnose communication&#xD;&#xA;          au16data[6] = slave.getInCnt();&#xD;&#xA;          au16data[7] = slave.getOutCnt();&#xD;&#xA;          au16data[8] = slave.getErrCnt();&#xD;&#xA;        } &#xD;&#xA;         " />
  <row Id="3211" PostHistoryTypeId="5" PostId="1124" RevisionGUID="d291816c-c9ea-4101-a9f8-21e01964a29f" CreationDate="2014-04-09T21:50:47.113" UserId="977" Comment="added 132 characters in body" Text="My project is to control car windows using voice recognition. I have successfully controlled some LED's using the EasyVR arduino shield using and arduino MEGA. Now I want to take control of the windows using the CAN-BUS arduino shield.&#xD;&#xA;&#xD;&#xA;Because the car that I own doesn't have an OBD-II connector, I am using two arduinos with two CAN-BUS arduino shields making one a sender and the other a receiver. Now I don't know how to program the CAN-BUS arduino shield to make a simulation of the car's windows ?&#xD;&#xA;&#xD;&#xA;CAN-BUS shield that I am using : https://www.sparkfun.com/products/10039&#xD;&#xA;&#xD;&#xA;Arduino mega : https://www.sparkfun.com/products/11061" />
  <row Id="3212" PostHistoryTypeId="5" PostId="1104" RevisionGUID="d8422328-5ab7-484d-adbc-7963c1a18753" CreationDate="2014-04-09T22:13:16.847" UserId="220" Comment="Added new information" Text="My high school is entering an ROV competition and for next year's competition we want to try and set it up so that we can control it using a PS4 controller. I have done research and found [this][1] shield for Arduino and [this][2] library that allows you to connect it to an Arduino. I plan to then connect the Arduino to a computer via USB and then send each button press to a Processing program via serial. Would it then be possible to send this from Processing to another Arduino out of the laptop? I'm just wondering how feasible this project is.&#xD;&#xA;&#xD;&#xA;We initially had just a single Arduino at the top with the Ethernet shield and took inputs from standard joystick potentiometers. We want to add in using the PS4 controller this year for easier control. We found the USB Host Shield that gives us that capability, but uses the same pins as the Ethernet shield. So we added another Arduino, connecting the laptop as the bridge also allows to have a GUI. The Ethernet is wired, by the way. We need the laptop, it's not just for a bridge.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.circuitsathome.com/products-page/arduino-shields/usb-host-shield-2-0-for-arduino-assembled&#xD;&#xA;  [2]: https://github.com/felis/USB_Host_Shield_2.0" />
  <row Id="3213" PostHistoryTypeId="11" PostId="1124" RevisionGUID="07571378-c976-459a-aafd-39fe4e2f3494" CreationDate="2014-04-09T22:15:49.180" UserId="220" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:220,&quot;DisplayName&quot;:&quot;Annonomus Person&quot;}]}" />
  <row Id="3214" PostHistoryTypeId="5" PostId="1107" RevisionGUID="0bf5ed7b-fb9a-4fb3-b507-2d654e24873f" CreationDate="2014-04-09T22:33:36.070" UserId="643" Comment="added 574 characters in body" Text="this is possible, but the processig bridge can add a lot of delay if not correctly handled, also wifi has a low range, almost 100m by default hardware.&#xD;&#xA;&#xD;&#xA;zigbee module has better range (xbee pro are up to 1km) and are microcontroller friendly, you use the as you are using a serial, they will hide their complexity once you set them up, and this can be done by PC.&#xD;&#xA;&#xD;&#xA;That mens less code, that mena less error and more ram/flash/cpu so you can do a smarter robot :)&#xA;&#xA; zigbee use the serial protocol to communicate, exactly as you do with the pc. Also arduino can use, with the library SoftSerial, any pin as Serial. So you can keep the HardwareSerial to communicate with pc, and any 2 free pin to communicate with the xbee. So you can use the arduino stand alone, only with the controller, and when needed connect the pc. Then arduino can act as a bridge between xbee and pc, so pc can excange data with the rover. But even without pc your project will be fun.&#xA;The same apply for bluetoot or 400/800mhz rxtx module, but not for wifi shield" />
  <row Id="3215" PostHistoryTypeId="2" PostId="1132" RevisionGUID="6276b047-5e76-4f87-a99f-b27e83973f10" CreationDate="2014-04-09T23:31:56.213" UserId="993" Text="I really hope somebody can help me.&#xD;&#xA;&#xD;&#xA;I need help making my code receive updates faster to the parser...I need the received GPS coordinates (Latitude and Longitude) to update 5 or more times a second, currently it locks when stationary. Can somebody help? &#xD;&#xA;&#xD;&#xA;code: &#xD;&#xA;&#xD;&#xA;    #include &lt;TinyGPS.h&gt;&#xD;&#xA;    &#xD;&#xA;    /* This sample code demonstrates the normal use of a TinyGPS object.&#xD;&#xA;       It requires the use of SoftwareSerial, and assumes that you have a&#xD;&#xA;       4800-baud serial GPS device hooked up on pins 4(rx) and 3(tx).&#xD;&#xA;    */&#xD;&#xA;    &#xD;&#xA;    TinyGPS gps;&#xD;&#xA;    //SoftwareSerial ss(4, 3);&#xD;&#xA;    &#xD;&#xA;    static void smartdelay(unsigned long ms);&#xD;&#xA;    static void print_float(float val, float invalid, int len, int prec);&#xD;&#xA;    static void print_int(unsigned long val, unsigned long invalid, int len);&#xD;&#xA;    static void print_date(TinyGPS &amp;gps);&#xD;&#xA;    static void print_str(const char *str, int len);&#xD;&#xA;    //double getCurrentLatitude();&#xD;&#xA;    //double getCurrentLongitude();&#xD;&#xA;    &#xD;&#xA;    //double cLatitude = 0.0;&#xD;&#xA;    //double cLongitude = 0.0;&#xD;&#xA;    //&#xD;&#xA;    //double getCurrentLatitude(){&#xD;&#xA;    //  return cLatitude;&#xD;&#xA;    //}&#xD;&#xA;    //&#xD;&#xA;    //double getCurrentLongitude(){&#xD;&#xA;    //  return cLongitude;  &#xD;&#xA;    //}&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      Serial.begin(115200);&#xD;&#xA;      &#xD;&#xA;    //  Serial.print(&quot;Testing TinyGPS library v. &quot;); Serial.println(TinyGPS::library_version());&#xD;&#xA;    //  Serial.println();&#xD;&#xA;    //  Serial.println(&quot;Sats HDOP Latitude      Longitude   Fix  Date       Time     Date Alt    Course Speed Card  Distance Course Card  Chars Sentences Checksum&quot;);&#xD;&#xA;    //  Serial.println(&quot;          (deg)         (deg)       Age                      Age  (m)    --- from GPS ----  ---- to London  ----  RX    RX        Fail&quot;);&#xD;&#xA;    //  Serial.println(&quot;------------------------------------------------------------------------------------------------------------------------------------------&quot;);&#xD;&#xA;    &#xD;&#xA;      Serial1.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      double flat, flon = 0.0000000000000;&#xD;&#xA;      unsigned long age, date, time, chars = 0;&#xD;&#xA;      unsigned short sentences = 0, failed = 0;&#xD;&#xA;      //static const double LONDON_LAT = 51.508131, LONDON_LON = -0.128002;&#xD;&#xA;      &#xD;&#xA;    //  print_int(gps.satellites(), TinyGPS::GPS_INVALID_SATELLITES, 5);&#xD;&#xA;    //  print_int(gps.hdop(), TinyGPS::GPS_INVALID_HDOP, 5);&#xD;&#xA;      gps.f_get_position(&amp;flat, &amp;flon, &amp;age);&#xD;&#xA;    //  gps.f_get_position(&amp;cLatitude,&amp;cLongitude, &amp;age);&#xD;&#xA;      &#xD;&#xA;      //print_float(flat, TinyGPS::GPS_INVALID_F_ANGLE, 13, 8);&#xD;&#xA;      //print_float(flon, TinyGPS::GPS_INVALID_F_ANGLE, 13, 8);&#xD;&#xA;      &#xD;&#xA;      float lati = (float)flat;&#xD;&#xA;      float longi = (float)flon;&#xD;&#xA;      &#xD;&#xA;      Serial.print(&quot;     &quot;);&#xD;&#xA;      Serial.print(lati, 8);&#xD;&#xA;      Serial.print(&quot; &quot;);&#xD;&#xA;      Serial.print(longi, 8);&#xD;&#xA;      smartdelay(0);&#xD;&#xA;      //cLatitude = flat;&#xD;&#xA;      //cLongitude = flon;&#xD;&#xA;    //  print_float(getCurrentLatitude(), TinyGPS::GPS_INVALID_F_ANGLE, 13, 8);&#xD;&#xA;    //  print_float(getCurrentLongitude(), TinyGPS::GPS_INVALID_F_ANGLE, 13, 8);&#xD;&#xA;      &#xD;&#xA;      &#xD;&#xA;    //  print_int(age, TinyGPS::GPS_INVALID_AGE, 5);&#xD;&#xA;    //  print_date(gps);&#xD;&#xA;    //  print_float(gps.f_altitude(), TinyGPS::GPS_INVALID_F_ALTITUDE, 7, 2);&#xD;&#xA;    //  print_float(gps.f_course(), TinyGPS::GPS_INVALID_F_ANGLE, 7, 2);&#xD;&#xA;    //  print_float(gps.f_speed_kmph(), TinyGPS::GPS_INVALID_F_SPEED, 6, 2);&#xD;&#xA;    //  print_str(gps.f_course() == TinyGPS::GPS_INVALID_F_ANGLE ? &quot;*** &quot; : TinyGPS::cardinal(gps.f_course()), 6);&#xD;&#xA;    //  print_int(flat == TinyGPS::GPS_INVALID_F_ANGLE ? 0xFFFFFFFF : (unsigned long)TinyGPS::distance_between(flat, flon, LONDON_LAT, LONDON_LON) / 1000, 0xFFFFFFFF, 9);&#xD;&#xA;    //  print_float(flat == TinyGPS::GPS_INVALID_F_ANGLE ? TinyGPS::GPS_INVALID_F_ANGLE : TinyGPS::course_to(flat, flon, LONDON_LAT, LONDON_LON), TinyGPS::GPS_INVALID_F_ANGLE, 7, 2);&#xD;&#xA;    //  print_str(flat == TinyGPS::GPS_INVALID_F_ANGLE ? &quot;*** &quot; : TinyGPS::cardinal(TinyGPS::course_to(flat, flon, LONDON_LAT, LONDON_LON)), 6);&#xD;&#xA;    //&#xD;&#xA;    //  gps.stats(&amp;chars, &amp;sentences, &amp;failed);&#xD;&#xA;    //  print_int(chars, 0xFFFFFFFF, 6);&#xD;&#xA;    //  print_int(sentences, 0xFFFFFFFF, 10);&#xD;&#xA;    //  print_int(failed, 0xFFFFFFFF, 9);&#xD;&#xA;    &#xD;&#xA;      Serial.println();&#xD;&#xA;      &#xD;&#xA;      smartdelay(1000);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    static void smartdelay(unsigned long ms)&#xD;&#xA;    {&#xD;&#xA;      unsigned long start = millis();&#xD;&#xA;      do &#xD;&#xA;      {&#xD;&#xA;        while (Serial1.available())&#xD;&#xA;          gps.encode(Serial1.read());&#xD;&#xA;      } while (millis() - start &lt; ms);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    static void print_float(float val, float invalid, int len, int prec)&#xD;&#xA;    {&#xD;&#xA;      if (val == invalid)&#xD;&#xA;      {&#xD;&#xA;        while (len-- &gt; 1)&#xD;&#xA;          Serial.print('*');&#xD;&#xA;        Serial.print(' ');&#xD;&#xA;      }&#xD;&#xA;      else&#xD;&#xA;      {&#xD;&#xA;        Serial.print(val, prec);&#xD;&#xA;        int vi = abs((int)val);&#xD;&#xA;        int flen = prec + (val &lt; 0.0 ? 2 : 1); // . and -&#xD;&#xA;        flen += vi &gt;= 1000 ? 4 : vi &gt;= 100 ? 3 : vi &gt;= 10 ? 2 : 1;&#xD;&#xA;        for (int i=flen; i&lt;len; ++i)&#xD;&#xA;          Serial.print(' ');&#xD;&#xA;      }&#xD;&#xA;      smartdelay(0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    /*&#xD;&#xA;        If data is invalid, print out *******&#xD;&#xA;        otherwise print out buffer&#xD;&#xA;    */&#xD;&#xA;    static void print_int(unsigned long val, unsigned long invalid, int len)&#xD;&#xA;    {&#xD;&#xA;      char sz[32];&#xD;&#xA;      if (val == invalid)&#xD;&#xA;        strcpy(sz, &quot;*******&quot;);&#xD;&#xA;      else&#xD;&#xA;        sprintf(sz, &quot;%ld&quot;, val);&#xD;&#xA;      sz[len] = 0;&#xD;&#xA;      for (int i=strlen(sz); i&lt;len; ++i)&#xD;&#xA;        sz[i] = ' ';&#xD;&#xA;      if (len &gt; 0) &#xD;&#xA;        sz[len-1] = ' ';&#xD;&#xA;      Serial.print(sz);&#xD;&#xA;      smartdelay(0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    static void print_date(TinyGPS &amp;gps)&#xD;&#xA;    {&#xD;&#xA;      int year;&#xD;&#xA;      byte month, day, hour, minute, second, hundredths;&#xD;&#xA;      unsigned long age;&#xD;&#xA;      gps.crack_datetime(&amp;year, &amp;month, &amp;day, &amp;hour, &amp;minute, &amp;second, &amp;hundredths, &amp;age);&#xD;&#xA;      if (age == TinyGPS::GPS_INVALID_AGE)&#xD;&#xA;        Serial.print(&quot;********** ******** &quot;);&#xD;&#xA;      else&#xD;&#xA;      {&#xD;&#xA;        char sz[32];&#xD;&#xA;        sprintf(sz, &quot;%02d/%02d/%02d %02d:%02d:%02d &quot;,&#xD;&#xA;            month, day, year, hour, minute, second);&#xD;&#xA;        Serial.print(sz);&#xD;&#xA;      }&#xD;&#xA;      print_int(age, TinyGPS::GPS_INVALID_AGE, 5);&#xD;&#xA;      smartdelay(0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    static void print_str(const char *str, int len)&#xD;&#xA;    {&#xD;&#xA;      int slen = strlen(str);&#xD;&#xA;      for (int i=0; i&lt;len; ++i)&#xD;&#xA;        Serial.print(i&lt;slen ? str[i] : ' ');&#xD;&#xA;      smartdelay(0);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3216" PostHistoryTypeId="1" PostId="1132" RevisionGUID="6276b047-5e76-4f87-a99f-b27e83973f10" CreationDate="2014-04-09T23:31:56.213" UserId="993" Text="Faster GPS update rate for parser" />
  <row Id="3217" PostHistoryTypeId="3" PostId="1132" RevisionGUID="6276b047-5e76-4f87-a99f-b27e83973f10" CreationDate="2014-04-09T23:31:56.213" UserId="993" Text="&lt;arduino-due&gt;" />
  <row Id="3219" PostHistoryTypeId="2" PostId="1133" RevisionGUID="4dbac2ac-e1ed-4e73-aa45-29f3013e3fd4" CreationDate="2014-04-10T03:55:45.807" UserId="996" Text="I have a seeedstudio SD card shield (V3) that I am trying to use on my arduino due. I am having trouble using the SD examples that come with the Arduino IDE.&#xD;&#xA;&#xD;&#xA;They worked fine on my Arduino Uno by setting chipSelect to &quot;SS&quot;. Below is the code I used for the Arduino Uno. It is the same as the CardInfo.ino in the examples section under SD (except for the chipSelect).&#xD;&#xA;&#xD;&#xA;CardInfo.ino&#xD;&#xA;&#xD;&#xA;        /*&#xD;&#xA;      SD card test&#xD;&#xA;    &#xD;&#xA;     This example shows how use the utility libraries on which the'&#xD;&#xA;     SD library is based in order to get info about your SD card.&#xD;&#xA;     Very useful for testing a card when you're not sure whether its working or not.&#xD;&#xA;    &#xD;&#xA;     The circuit:&#xD;&#xA;      * SD card attached to SPI bus as follows:&#xD;&#xA;     ** MOSI - pin 11 on Arduino Uno/Duemilanove/Diecimila&#xD;&#xA;     ** MISO - pin 12 on Arduino Uno/Duemilanove/Diecimila&#xD;&#xA;     ** CLK - pin 13 on Arduino Uno/Duemilanove/Diecimila&#xD;&#xA;     ** CS - depends on your SD card shield or module.&#xD;&#xA;     		Pin 4 used here for consistency with other Arduino examples&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;     created  28 Mar 2011&#xD;&#xA;     by Limor Fried&#xD;&#xA;     modified 9 Apr 2012&#xD;&#xA;     by Tom Igoe&#xD;&#xA;     */&#xD;&#xA;    // include the SD library:&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;SD.h&gt;&#xD;&#xA;    &#xD;&#xA;    // set up variables using the SD utility library functions:&#xD;&#xA;    Sd2Card card;&#xD;&#xA;    SdVolume volume;&#xD;&#xA;    SdFile root;&#xD;&#xA;    &#xD;&#xA;    // change this to match your SD shield or module;&#xD;&#xA;    // Arduino Ethernet shield: pin 4&#xD;&#xA;    // Adafruit SD shields and modules: pin 10&#xD;&#xA;    // Sparkfun SD shield: pin 8&#xD;&#xA;    const int chipSelect = SS; //CHANGE HERE!!!!!!!!&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      // Open serial communications and wait for port to open:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      while (!Serial) {&#xD;&#xA;        ; // wait for serial port to connect. Needed for Leonardo only&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      Serial.print(&quot;\nInitializing SD card...&quot;);&#xD;&#xA;      // On the Ethernet Shield, CS is pin 4. It's set as an output by default.&#xD;&#xA;      // Note that even if it's not used as the CS pin, the hardware SS pin&#xD;&#xA;      // (10 on most Arduino boards, 53 on the Mega) must be left as an output&#xD;&#xA;      // or the SD library functions will not work.&#xD;&#xA;      pinMode(10, OUTPUT);     // change this to 53 on a mega&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // we'll use the initialization code from the utility libraries&#xD;&#xA;      // since we're just testing if the card is working!&#xD;&#xA;      if (!card.init(SPI_HALF_SPEED, chipSelect)) {&#xD;&#xA;        Serial.println(&quot;initialization failed. Things to check:&quot;);&#xD;&#xA;        Serial.println(&quot;* is a card is inserted?&quot;);&#xD;&#xA;        Serial.println(&quot;* Is your wiring correct?&quot;);&#xD;&#xA;        Serial.println(&quot;* did you change the chipSelect pin to match your shield or module?&quot;);&#xD;&#xA;        return;&#xD;&#xA;      } else {&#xD;&#xA;        Serial.println(&quot;Wiring is correct and a card is present.&quot;);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // print the type of card&#xD;&#xA;      Serial.print(&quot;\nCard type: &quot;);&#xD;&#xA;      switch (card.type()) {&#xD;&#xA;        case SD_CARD_TYPE_SD1:&#xD;&#xA;          Serial.println(&quot;SD1&quot;);&#xD;&#xA;          break;&#xD;&#xA;        case SD_CARD_TYPE_SD2:&#xD;&#xA;          Serial.println(&quot;SD2&quot;);&#xD;&#xA;          break;&#xD;&#xA;        case SD_CARD_TYPE_SDHC:&#xD;&#xA;          Serial.println(&quot;SDHC&quot;);&#xD;&#xA;          break;&#xD;&#xA;        default:&#xD;&#xA;          Serial.println(&quot;Unknown&quot;);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // Now we will try to open the 'volume'/'partition' - it should be FAT16 or FAT32&#xD;&#xA;      if (!volume.init(card)) {&#xD;&#xA;        Serial.println(&quot;Could not find FAT16/FAT32 partition.\nMake sure you've formatted the card&quot;);&#xD;&#xA;        return;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // print the type and size of the first FAT-type volume&#xD;&#xA;      uint32_t volumesize;&#xD;&#xA;      Serial.print(&quot;\nVolume type is FAT&quot;);&#xD;&#xA;      Serial.println(volume.fatType(), DEC);&#xD;&#xA;      Serial.println();&#xD;&#xA;    &#xD;&#xA;      volumesize = volume.blocksPerCluster();    // clusters are collections of blocks&#xD;&#xA;      volumesize *= volume.clusterCount();       // we'll have a lot of clusters&#xD;&#xA;      volumesize *= 512;                            // SD card blocks are always 512 bytes&#xD;&#xA;      Serial.print(&quot;Volume size (bytes): &quot;);&#xD;&#xA;      Serial.println(volumesize);&#xD;&#xA;      Serial.print(&quot;Volume size (Kbytes): &quot;);&#xD;&#xA;      volumesize /= 1024;&#xD;&#xA;      Serial.println(volumesize);&#xD;&#xA;      Serial.print(&quot;Volume size (Mbytes): &quot;);&#xD;&#xA;      volumesize /= 1024;&#xD;&#xA;      Serial.println(volumesize);&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      Serial.println(&quot;\nFiles found on the card (name, date and size in bytes): &quot;);&#xD;&#xA;      root.openRoot(volume);&#xD;&#xA;    &#xD;&#xA;      // list all files in the card with date and size&#xD;&#xA;      root.ls(LS_R | LS_DATE | LS_SIZE);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop(void) {&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;here is a picture of my setup:&#xD;&#xA;![Due with SD card shield][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/nZ6f9.jpg" />
  <row Id="3220" PostHistoryTypeId="1" PostId="1133" RevisionGUID="4dbac2ac-e1ed-4e73-aa45-29f3013e3fd4" CreationDate="2014-04-10T03:55:45.807" UserId="996" Text="Using SD card shield on Arduino Due" />
  <row Id="3221" PostHistoryTypeId="3" PostId="1133" RevisionGUID="4dbac2ac-e1ed-4e73-aa45-29f3013e3fd4" CreationDate="2014-04-10T03:55:45.807" UserId="996" Text="&lt;serial&gt;&lt;shields&gt;&lt;arduino-due&gt;&lt;sd-card&gt;&lt;spi&gt;" />
  <row Id="3222" PostHistoryTypeId="5" PostId="1133" RevisionGUID="d65cd2d2-6174-4104-badd-2442c9f6aba8" CreationDate="2014-04-10T04:05:35.140" UserId="996" Comment="added 52 characters in body" Text="I have a seeedstudio SD card shield (V3) that I am trying to use on my arduino due. I am having trouble using the SD examples that come with the Arduino IDE.&#xD;&#xA;&#xD;&#xA;They worked fine on my Arduino Uno by setting chipSelect to &quot;SS&quot;. Below is the code I used for the Arduino Uno. It is the same as the CardInfo.ino in the examples section under SD (except for the chipSelect).&#xD;&#xA;&#xD;&#xA;CardInfo.ino&#xD;&#xA;&#xD;&#xA;        /*&#xD;&#xA;      SD card test&#xD;&#xA;    &#xD;&#xA;     This example shows how use the utility libraries on which the'&#xD;&#xA;     SD library is based in order to get info about your SD card.&#xD;&#xA;     Very useful for testing a card when you're not sure whether its working or not.&#xD;&#xA;    &#xD;&#xA;     The circuit:&#xD;&#xA;      * SD card attached to SPI bus as follows:&#xD;&#xA;     ** MOSI - pin 11 on Arduino Uno/Duemilanove/Diecimila&#xD;&#xA;     ** MISO - pin 12 on Arduino Uno/Duemilanove/Diecimila&#xD;&#xA;     ** CLK - pin 13 on Arduino Uno/Duemilanove/Diecimila&#xD;&#xA;     ** CS - depends on your SD card shield or module.&#xD;&#xA;     		Pin 4 used here for consistency with other Arduino examples&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;     created  28 Mar 2011&#xD;&#xA;     by Limor Fried&#xD;&#xA;     modified 9 Apr 2012&#xD;&#xA;     by Tom Igoe&#xD;&#xA;     */&#xD;&#xA;    // include the SD library:&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;SD.h&gt;&#xD;&#xA;    &#xD;&#xA;    // set up variables using the SD utility library functions:&#xD;&#xA;    Sd2Card card;&#xD;&#xA;    SdVolume volume;&#xD;&#xA;    SdFile root;&#xD;&#xA;    &#xD;&#xA;    // change this to match your SD shield or module;&#xD;&#xA;    // Arduino Ethernet shield: pin 4&#xD;&#xA;    // Adafruit SD shields and modules: pin 10&#xD;&#xA;    // Sparkfun SD shield: pin 8&#xD;&#xA;    const int chipSelect = SS; //CHANGE HERE!!!!!!!!&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      // Open serial communications and wait for port to open:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      while (!Serial) {&#xD;&#xA;        ; // wait for serial port to connect. Needed for Leonardo only&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      Serial.print(&quot;\nInitializing SD card...&quot;);&#xD;&#xA;      // On the Ethernet Shield, CS is pin 4. It's set as an output by default.&#xD;&#xA;      // Note that even if it's not used as the CS pin, the hardware SS pin&#xD;&#xA;      // (10 on most Arduino boards, 53 on the Mega) must be left as an output&#xD;&#xA;      // or the SD library functions will not work.&#xD;&#xA;      pinMode(10, OUTPUT);     // change this to 53 on a mega&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // we'll use the initialization code from the utility libraries&#xD;&#xA;      // since we're just testing if the card is working!&#xD;&#xA;      if (!card.init(SPI_HALF_SPEED, chipSelect)) {&#xD;&#xA;        Serial.println(&quot;initialization failed. Things to check:&quot;);&#xD;&#xA;        Serial.println(&quot;* is a card is inserted?&quot;);&#xD;&#xA;        Serial.println(&quot;* Is your wiring correct?&quot;);&#xD;&#xA;        Serial.println(&quot;* did you change the chipSelect pin to match your shield or module?&quot;);&#xD;&#xA;        return;&#xD;&#xA;      } else {&#xD;&#xA;        Serial.println(&quot;Wiring is correct and a card is present.&quot;);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // print the type of card&#xD;&#xA;      Serial.print(&quot;\nCard type: &quot;);&#xD;&#xA;      switch (card.type()) {&#xD;&#xA;        case SD_CARD_TYPE_SD1:&#xD;&#xA;          Serial.println(&quot;SD1&quot;);&#xD;&#xA;          break;&#xD;&#xA;        case SD_CARD_TYPE_SD2:&#xD;&#xA;          Serial.println(&quot;SD2&quot;);&#xD;&#xA;          break;&#xD;&#xA;        case SD_CARD_TYPE_SDHC:&#xD;&#xA;          Serial.println(&quot;SDHC&quot;);&#xD;&#xA;          break;&#xD;&#xA;        default:&#xD;&#xA;          Serial.println(&quot;Unknown&quot;);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // Now we will try to open the 'volume'/'partition' - it should be FAT16 or FAT32&#xD;&#xA;      if (!volume.init(card)) {&#xD;&#xA;        Serial.println(&quot;Could not find FAT16/FAT32 partition.\nMake sure you've formatted the card&quot;);&#xD;&#xA;        return;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // print the type and size of the first FAT-type volume&#xD;&#xA;      uint32_t volumesize;&#xD;&#xA;      Serial.print(&quot;\nVolume type is FAT&quot;);&#xD;&#xA;      Serial.println(volume.fatType(), DEC);&#xD;&#xA;      Serial.println();&#xD;&#xA;    &#xD;&#xA;      volumesize = volume.blocksPerCluster();    // clusters are collections of blocks&#xD;&#xA;      volumesize *= volume.clusterCount();       // we'll have a lot of clusters&#xD;&#xA;      volumesize *= 512;                            // SD card blocks are always 512 bytes&#xD;&#xA;      Serial.print(&quot;Volume size (bytes): &quot;);&#xD;&#xA;      Serial.println(volumesize);&#xD;&#xA;      Serial.print(&quot;Volume size (Kbytes): &quot;);&#xD;&#xA;      volumesize /= 1024;&#xD;&#xA;      Serial.println(volumesize);&#xD;&#xA;      Serial.print(&quot;Volume size (Mbytes): &quot;);&#xD;&#xA;      volumesize /= 1024;&#xD;&#xA;      Serial.println(volumesize);&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      Serial.println(&quot;\nFiles found on the card (name, date and size in bytes): &quot;);&#xD;&#xA;      root.openRoot(volume);&#xD;&#xA;    &#xD;&#xA;      // list all files in the card with date and size&#xD;&#xA;      root.ls(LS_R | LS_DATE | LS_SIZE);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop(void) {&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;here is a picture of my setup:&#xD;&#xA;![Due with SD card shield][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/nZ6f9.jpg&#xD;&#xA;&#xD;&#xA;tl;dr&#xD;&#xA;How do I make this shield work on my Due?" />
  <row Id="3223" PostHistoryTypeId="6" PostId="1132" RevisionGUID="5dcf704e-c17b-4267-ad22-843c250416f3" CreationDate="2014-04-10T05:17:11.400" UserId="84" Comment="edited tags" Text="&lt;arduino-due&gt;&lt;tinygps&gt;" />
  <row Id="3224" PostHistoryTypeId="2" PostId="1134" RevisionGUID="21d6776e-f5ae-4208-9138-c5032a3fcb08" CreationDate="2014-04-10T10:08:02.490" UserId="904" Text="I have analog sensor.Which read value 0-5v i.e -75 deg to 75 degree . Now i have converted to +75 deg and -75 degree format depend on voltage. from 2.5v to 5v data is read properly i.e 0-75 degree.But 0-2.5v these are negative value -75 degree to 0. In below image array holding register is reading 65493 and 65491 which are negative value.How to make it readable format. Since my code is very big part of code is pasted.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #define ID   1&#xD;&#xA;    &#xD;&#xA;    int Wind_Speed=30;&#xD;&#xA;    int Wind_Kmph=67;&#xD;&#xA;    signed int tracker_des_angle=-45;&#xD;&#xA;    signed int tracker_actual_pos=-43;&#xD;&#xA;    Modbus slave(ID, 0, 0);&#xD;&#xA;    boolean led;&#xD;&#xA;    int8_t state = 0;&#xD;&#xA;    unsigned long tempus;&#xD;&#xA;    // data array for modbus network sharing&#xD;&#xA;    uint16_t au16data[14];&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;    &#xD;&#xA;      // start communication&#xD;&#xA;      slave.begin( 9600 );&#xD;&#xA;      rtcSetup();&#xD;&#xA;    &#xD;&#xA;      tempus = millis() + 100;&#xD;&#xA;      digitalWrite(13, HIGH );&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      // poll messages&#xD;&#xA;      // blink led pin on each valid message&#xD;&#xA;      state = slave.poll( au16data, 14);&#xD;&#xA;      if (state &gt; 4) {&#xD;&#xA;        tempus = millis() + 50;&#xD;&#xA;        digitalWrite(13, HIGH);&#xD;&#xA;      }&#xD;&#xA;      if (millis() &gt; tempus) digitalWrite(13, LOW ); &#xD;&#xA;      calcTime();&#xD;&#xA;      convertUTCtoLocal();&#xD;&#xA;    &#xD;&#xA;      au16data[0]=local_year;&#xD;&#xA;      au16data[1]=local_month;&#xD;&#xA;      au16data[2]=local_day;&#xD;&#xA;      au16data[3]=wkDay;&#xD;&#xA;      au16data[4]=local_h;&#xD;&#xA;      au16data[5]=local_m;&#xD;&#xA;      au16data[6]=local_s;&#xD;&#xA;      au16data[7]=Wind_Speed;&#xD;&#xA;      au16data[8]=Wind_Kmph;&#xD;&#xA;      au16data[9]=tracker_des_angle;&#xD;&#xA;      au16data[10]=tracker_actual_pos;&#xD;&#xA;    &#xD;&#xA;      au16data[11] = slave.getInCnt();&#xD;&#xA;      au16data[12] = slave.getOutCnt();&#xD;&#xA;      au16data[13] = slave.getErrCnt();&#xD;&#xA;    } &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![Negtive value read][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/ynsrT.png" />
  <row Id="3225" PostHistoryTypeId="1" PostId="1134" RevisionGUID="21d6776e-f5ae-4208-9138-c5032a3fcb08" CreationDate="2014-04-10T10:08:02.490" UserId="904" Text="Negative value conversion for modbus slave" />
  <row Id="3226" PostHistoryTypeId="3" PostId="1134" RevisionGUID="21d6776e-f5ae-4208-9138-c5032a3fcb08" CreationDate="2014-04-10T10:08:02.490" UserId="904" Text="&lt;arduino-uno&gt;&lt;arduino-mega&gt;&lt;c&gt;&lt;modbus&gt;" />
  <row Id="3227" PostHistoryTypeId="2" PostId="1135" RevisionGUID="e0e680c4-8fa6-499c-a861-e3e9940348c8" CreationDate="2014-04-10T18:22:17.600" UserId="1004" Text="&#xD;&#xA;&#xD;&#xA;I am trying to make a small project. Firstly, I want to record voice using a small microphone(electret) for the time button is pressed and on releasing the button, the speaker of my laptop should output the recorded voice or a speaker attached to the arduino should output.&#xD;&#xA;&#xD;&#xA;**Note: I don't want to use any shield to do so. Simply Arduino**&#xD;&#xA;" />
  <row Id="3228" PostHistoryTypeId="1" PostId="1135" RevisionGUID="e0e680c4-8fa6-499c-a861-e3e9940348c8" CreationDate="2014-04-10T18:22:17.600" UserId="1004" Text="Mic input and Speaker output using arduino" />
  <row Id="3229" PostHistoryTypeId="3" PostId="1135" RevisionGUID="e0e680c4-8fa6-499c-a861-e3e9940348c8" CreationDate="2014-04-10T18:22:17.600" UserId="1004" Text="&lt;interrupt&gt;" />
  <row Id="3230" PostHistoryTypeId="2" PostId="1136" RevisionGUID="6e74031a-a408-42e8-a351-8682adcaf0be" CreationDate="2014-04-10T18:29:06.040" UserId="368" Text="Microphone input is easy (ADC). Speaker output is easy (PWM). Both have many, many examples strewn across the Internet.&#xD;&#xA;&#xD;&#xA;What happens in between is *not*, and will require external components. You will need at the very least somewhere to store the samples between record and playback. Investigate SPI SRAM large enough to store all the required samples at your chosen sample rate (8 kS/s should be high enough for human speech)." />
  <row Id="3231" PostHistoryTypeId="2" PostId="1137" RevisionGUID="63a0a2ff-4712-44cd-bc40-f9e209c08455" CreationDate="2014-04-10T20:01:56.483" UserId="993" Text="So I downloaded the Adafruit_GPS library from Adafruit and I'm trying to compile the example code (due_parsing) but I can't seem to get past this silly error:&#xD;&#xA;      &#xD;&#xA;    In file included from due_parsing.ino:15:&#xD;&#xA;&#xD;&#xA;    /Users/haddad/Documents/Arduino/libraries/Adafruit_GPS/Adafruit_GPS.h:24: fatal error: SoftwareSerial.h: No such file or directory&#xD;&#xA;    compilation terminated.&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;This is the location in the example Arduino Sketch where SoftwareSerial.h is even mentioned, let alone called:&#xD;&#xA;&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;      #include &lt;SoftwareSerial.h&gt;&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;Noticed it's around an ifdef guard, so this shouldn't even matter that I don't have this library?&#xD;&#xA;&#xD;&#xA;So I went into the .h and .cpp files and commented out the where it called SOftwareSerial.h, but I'm still getting that above error. &#xD;&#xA;&#xD;&#xA;Does anybody know how to fix this? Any help or suggestions will be much appreciated&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3232" PostHistoryTypeId="1" PostId="1137" RevisionGUID="63a0a2ff-4712-44cd-bc40-f9e209c08455" CreationDate="2014-04-10T20:01:56.483" UserId="993" Text="Why am I getting this error? fatal error: SoftwareSerial.h: No such file or directory" />
  <row Id="3233" PostHistoryTypeId="3" PostId="1137" RevisionGUID="63a0a2ff-4712-44cd-bc40-f9e209c08455" CreationDate="2014-04-10T20:01:56.483" UserId="993" Text="&lt;arduino-due&gt;" />
  <row Id="3234" PostHistoryTypeId="5" PostId="1137" RevisionGUID="210dbcca-eca2-4bab-a853-42a6b5fe868c" CreationDate="2014-04-10T20:50:58.763" UserId="993" Comment="add in environment details" Text="So I downloaded the Adafruit_GPS library from Adafruit and I'm trying to compile the example code (due_parsing) but I can't seem to get past this silly error:&#xD;&#xA;      &#xD;&#xA;    In file included from due_parsing.ino:15:&#xD;&#xA;&#xD;&#xA;    /Users/haddad/Documents/Arduino/libraries/Adafruit_GPS/Adafruit_GPS.h:24: fatal error: SoftwareSerial.h: No such file or directory&#xD;&#xA;    compilation terminated.&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;This is the location in the example Arduino Sketch where SoftwareSerial.h is even mentioned, let alone called:&#xD;&#xA;&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;      #include &lt;SoftwareSerial.h&gt;&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;Noticed it's around an ifdef guard, so this shouldn't even matter that I don't have this library?&#xD;&#xA;&#xD;&#xA;So I went into the .h and .cpp files and commented out the where it called SOftwareSerial.h, but I'm still getting that above error. &#xD;&#xA;&#xD;&#xA;Does anybody know how to fix this? Any help or suggestions will be much appreciated&#xD;&#xA;&#xD;&#xA;I am using Arduino IDE v1.5.5&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3235" PostHistoryTypeId="2" PostId="1138" RevisionGUID="d5c75c2b-8cbd-43f5-bdca-dd57fa440e48" CreationDate="2014-04-10T21:01:52.340" UserId="1006" Text="Even on ebay's [website][1] it is mentioned that I can't use 2.4&quot; TFT LCD Shield display on attach to Arduino Mega. The problem is that I bought this shield by mistake. I want to put this shield onto Arduino Mega 2560. Is there a way to combine Mega and 2.4&quot; Display Shield?&#xD;&#xA;&#xD;&#xA;note: I tried on my friend's Arduino Uno. Shield is working very good.&#xD;&#xA;&#xD;&#xA;note: The photo below is determining my question. The display not runs my Arduino's code. It only runs its LED.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.ebay.com/itm/2-4-TFT-LCD-Shield-Touch-Panel-Display-TF-Reader-For-Arduino-UNO-R2-R3-A137-/390631788477&#xD;&#xA;  [2]: http://i.stack.imgur.com/DGkHU.jpg" />
  <row Id="3236" PostHistoryTypeId="1" PostId="1138" RevisionGUID="d5c75c2b-8cbd-43f5-bdca-dd57fa440e48" CreationDate="2014-04-10T21:01:52.340" UserId="1006" Text="2.4&quot; TFT LCD Shield isn't working on Arduino Mega" />
  <row Id="3237" PostHistoryTypeId="3" PostId="1138" RevisionGUID="d5c75c2b-8cbd-43f5-bdca-dd57fa440e48" CreationDate="2014-04-10T21:01:52.340" UserId="1006" Text="&lt;arduino-mega&gt;&lt;shields&gt;&lt;lcd&gt;" />
  <row Id="3238" PostHistoryTypeId="5" PostId="1137" RevisionGUID="eaa1b713-63e8-4373-a59b-062d756a8309" CreationDate="2014-04-10T21:10:05.453" UserId="993" Comment="added 243 characters in body" Text="So I downloaded the Adafruit_GPS library from Adafruit and I'm trying to compile the example code (due_parsing) but I can't seem to get past this silly error:&#xD;&#xA;      &#xD;&#xA;    In file included from due_parsing.ino:15:&#xD;&#xA;&#xD;&#xA;    /Users/haddad/Documents/Arduino/libraries/Adafruit_GPS/Adafruit_GPS.h:24: fatal error: SoftwareSerial.h: No such file or directory&#xD;&#xA;    compilation terminated.&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;This is the location in the example Arduino Sketch where SoftwareSerial.h is even mentioned, let alone called:&#xD;&#xA;&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;      #include &lt;SoftwareSerial.h&gt;&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;Noticed it's around an ifdef guard, so this shouldn't even matter that I don't have this library?&#xD;&#xA;&#xD;&#xA;So I went into the .h and .cpp files and commented out the where it called SOftwareSerial.h, but I'm still getting that above error. &#xD;&#xA;&#xD;&#xA;Does anybody know how to fix this? Any help or suggestions will be much appreciated&#xD;&#xA;&#xD;&#xA;I am using Arduino IDE v1.5.5&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;***************Update***************&#xD;&#xA;&#xD;&#xA;So I didn't put the library in the library direct on my mac but I'm now getting tons of errors, all the errors are with SoftwareSerial.cpp, is anybody else having similar issues when you go to compile?" />
  <row Id="3240" PostHistoryTypeId="5" PostId="1138" RevisionGUID="026f201a-e596-4907-bb33-f7d0564d6f3f" CreationDate="2014-04-10T22:00:59.223" UserId="1006" Comment="I added the code I work on" Text="Even on ebay's [website][1] it is mentioned that I can't use 2.4&quot; TFT LCD Shield display on attach to Arduino Mega. The problem is that I bought this shield by mistake. I want to put this shield onto Arduino Mega 2560. Is there a way to combine Mega and 2.4&quot; Display Shield?&#xD;&#xA;&#xD;&#xA;note: I tried on my friend's Arduino Uno. Shield is working very good.&#xD;&#xA;&#xD;&#xA;note: The photo below is determining my question. The display not runs my Arduino's code. It only runs its LED.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.ebay.com/itm/2-4-TFT-LCD-Shield-Touch-Panel-Display-TF-Reader-For-Arduino-UNO-R2-R3-A137-/390631788477&#xD;&#xA;  [2]: http://i.stack.imgur.com/DGkHU.jpg&#xD;&#xA;&#xD;&#xA;        // UTFT_Demo_320x240 (C)2012 Henning Karlsen&#xD;&#xA;    // web: http://www.henningkarlsen.com/electronics&#xD;&#xA;    //&#xD;&#xA;    // This program is a demo of how to use most of the functions&#xD;&#xA;    // of the library with a supported display modules.&#xD;&#xA;    //&#xD;&#xA;    // This demo was made for modules with a screen resolution &#xD;&#xA;    // of 320x240 pixels.&#xD;&#xA;    //&#xD;&#xA;    // This program requires the UTFT library.&#xD;&#xA;    //&#xD;&#xA;    &#xD;&#xA;    #include &lt;UTFT.h&gt;&#xD;&#xA;    #define ILI9320_16 18&#xD;&#xA;    // Declare which fonts we will be using&#xD;&#xA;    extern uint8_t SmallFont[];&#xD;&#xA;    &#xD;&#xA;    // Uncomment the next line for Arduino 2009/Uno&#xD;&#xA;    //UTFT myGLCD(UNO_24,A2,A1,A3,A4);   // Remember to change the model parameter to suit your display module!&#xD;&#xA;    &#xD;&#xA;    // Uncomment the next line for Arduino Mega&#xD;&#xA;    UTFT myGLCD(ILI9320_16,38,39,40,41);   // Remember to change the model parameter to suit your display module!&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      randomSeed(analogRead(0));&#xD;&#xA;      &#xD;&#xA;    // Setup the LCD&#xD;&#xA;      pinMode(A0,OUTPUT);		// for the UNO_SHIELD_1IN1&#xD;&#xA;      digitalWrite(A0,HIGH);	// the RD pin must be set high&#xD;&#xA;      myGLCD.InitLCD();&#xD;&#xA;      myGLCD.setFont(SmallFont);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      int buf[318];&#xD;&#xA;      int x, x2;&#xD;&#xA;      int y, y2;&#xD;&#xA;      int r;&#xD;&#xA;    &#xD;&#xA;    // Clear the screen and draw the frame&#xD;&#xA;      myGLCD.clrScr();&#xD;&#xA;    &#xD;&#xA;      myGLCD.setColor(255, 0, 0);&#xD;&#xA;      myGLCD.fillRect(0, 0, 319, 13);&#xD;&#xA;      myGLCD.setColor(64, 64, 64);&#xD;&#xA;      myGLCD.fillRect(0, 226, 319, 239);&#xD;&#xA;      myGLCD.setColor(255, 255, 255);&#xD;&#xA;      myGLCD.setBackColor(255, 0, 0);&#xD;&#xA;      myGLCD.print(&quot;* Universal Color TFT Display Library *&quot;, CENTER, 1);&#xD;&#xA;      myGLCD.setBackColor(64, 64, 64);&#xD;&#xA;      myGLCD.setColor(255,255,0);&#xD;&#xA;      myGLCD.print(&quot;&lt;http://electronics.henningkarlsen.com&gt;&quot;, CENTER, 227);&#xD;&#xA;    &#xD;&#xA;      myGLCD.setColor(0, 0, 255);&#xD;&#xA;      myGLCD.drawRect(0, 14, 319, 225);&#xD;&#xA;    &#xD;&#xA;    // Draw crosshairs&#xD;&#xA;      myGLCD.setColor(0, 0, 255);&#xD;&#xA;      myGLCD.setBackColor(0, 0, 0);&#xD;&#xA;      myGLCD.drawLine(159, 15, 159, 224);&#xD;&#xA;      myGLCD.drawLine(1, 119, 318, 119);&#xD;&#xA;      for (int i=9; i&lt;310; i+=10)&#xD;&#xA;        myGLCD.drawLine(i, 117, i, 121);&#xD;&#xA;      for (int i=19; i&lt;220; i+=10)&#xD;&#xA;        myGLCD.drawLine(157, i, 161, i);&#xD;&#xA;    &#xD;&#xA;    // Draw sin-, cos- and tan-lines  &#xD;&#xA;      myGLCD.setColor(0,255,255);&#xD;&#xA;      myGLCD.print(&quot;Sin&quot;, 5, 15);&#xD;&#xA;      for (int i=1; i&lt;318; i++)&#xD;&#xA;      {&#xD;&#xA;        myGLCD.drawPixel(i,119+(sin(((i*1.13)*3.14)/180)*95));&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      myGLCD.setColor(255,0,0);&#xD;&#xA;      myGLCD.print(&quot;Cos&quot;, 5, 27);&#xD;&#xA;      for (int i=1; i&lt;318; i++)&#xD;&#xA;      {&#xD;&#xA;        myGLCD.drawPixel(i,119+(cos(((i*1.13)*3.14)/180)*95));&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      myGLCD.setColor(255,255,0);&#xD;&#xA;      myGLCD.print(&quot;Tan&quot;, 5, 39);&#xD;&#xA;      for (int i=1; i&lt;318; i++)&#xD;&#xA;      {&#xD;&#xA;        myGLCD.drawPixel(i,119+(tan(((i*1.13)*3.14)/180)));&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      delay(2000);&#xD;&#xA;    &#xD;&#xA;      myGLCD.setColor(0,0,0);&#xD;&#xA;      myGLCD.fillRect(1,15,318,224);&#xD;&#xA;      myGLCD.setColor(0, 0, 255);&#xD;&#xA;      myGLCD.setBackColor(0, 0, 0);&#xD;&#xA;      myGLCD.drawLine(159, 15, 159, 224);&#xD;&#xA;      myGLCD.drawLine(1, 119, 318, 119);&#xD;&#xA;    &#xD;&#xA;    // Draw a moving sinewave&#xD;&#xA;      x=1;&#xD;&#xA;      for (int i=1; i&lt;(318*20); i++) &#xD;&#xA;      {&#xD;&#xA;        x++;&#xD;&#xA;        if (x==319)&#xD;&#xA;          x=1;&#xD;&#xA;        if (i&gt;319)&#xD;&#xA;        {&#xD;&#xA;          if ((x==159)||(buf[x-1]==119))&#xD;&#xA;            myGLCD.setColor(0,0,255);&#xD;&#xA;          else&#xD;&#xA;            myGLCD.setColor(0,0,0);&#xD;&#xA;          myGLCD.drawPixel(x,buf[x-1]);&#xD;&#xA;        }&#xD;&#xA;        myGLCD.setColor(0,255,255);&#xD;&#xA;        y=119+(sin(((i*1.1)*3.14)/180)*(90-(i / 100)));&#xD;&#xA;        myGLCD.drawPixel(x,y);&#xD;&#xA;        buf[x-1]=y;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      delay(2000);&#xD;&#xA;      &#xD;&#xA;      myGLCD.setColor(0,0,0);&#xD;&#xA;      myGLCD.fillRect(1,15,318,224);&#xD;&#xA;    &#xD;&#xA;    // Draw some filled rectangles&#xD;&#xA;      for (int i=1; i&lt;6; i++)&#xD;&#xA;      {&#xD;&#xA;        switch (i)&#xD;&#xA;        {&#xD;&#xA;          case 1:&#xD;&#xA;            myGLCD.setColor(255,0,255);&#xD;&#xA;            break;&#xD;&#xA;          case 2:&#xD;&#xA;            myGLCD.setColor(255,0,0);&#xD;&#xA;            break;&#xD;&#xA;          case 3:&#xD;&#xA;            myGLCD.setColor(0,255,0);&#xD;&#xA;            break;&#xD;&#xA;          case 4:&#xD;&#xA;            myGLCD.setColor(0,0,255);&#xD;&#xA;            break;&#xD;&#xA;          case 5:&#xD;&#xA;            myGLCD.setColor(255,255,0);&#xD;&#xA;            break;&#xD;&#xA;        }&#xD;&#xA;        myGLCD.fillRect(70+(i*20), 30+(i*20), 130+(i*20), 90+(i*20));&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      delay(2000);&#xD;&#xA;      &#xD;&#xA;      myGLCD.setColor(0,0,0);&#xD;&#xA;      myGLCD.fillRect(1,15,318,224);&#xD;&#xA;    &#xD;&#xA;    // Draw some filled, rounded rectangles&#xD;&#xA;      for (int i=1; i&lt;6; i++)&#xD;&#xA;      {&#xD;&#xA;        switch (i)&#xD;&#xA;        {&#xD;&#xA;          case 1:&#xD;&#xA;            myGLCD.setColor(255,0,255);&#xD;&#xA;            break;&#xD;&#xA;          case 2:&#xD;&#xA;            myGLCD.setColor(255,0,0);&#xD;&#xA;            break;&#xD;&#xA;          case 3:&#xD;&#xA;            myGLCD.setColor(0,255,0);&#xD;&#xA;            break;&#xD;&#xA;          case 4:&#xD;&#xA;            myGLCD.setColor(0,0,255);&#xD;&#xA;            break;&#xD;&#xA;          case 5:&#xD;&#xA;            myGLCD.setColor(255,255,0);&#xD;&#xA;            break;&#xD;&#xA;        }&#xD;&#xA;        myGLCD.fillRoundRect(190-(i*20), 30+(i*20), 250-(i*20), 90+(i*20));&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      delay(2000);&#xD;&#xA;      &#xD;&#xA;      myGLCD.setColor(0,0,0);&#xD;&#xA;      myGLCD.fillRect(1,15,318,224);&#xD;&#xA;    &#xD;&#xA;    // Draw some filled circles&#xD;&#xA;      for (int i=1; i&lt;6; i++)&#xD;&#xA;      {&#xD;&#xA;        switch (i)&#xD;&#xA;        {&#xD;&#xA;          case 1:&#xD;&#xA;            myGLCD.setColor(255,0,255);&#xD;&#xA;            break;&#xD;&#xA;          case 2:&#xD;&#xA;            myGLCD.setColor(255,0,0);&#xD;&#xA;            break;&#xD;&#xA;          case 3:&#xD;&#xA;            myGLCD.setColor(0,255,0);&#xD;&#xA;            break;&#xD;&#xA;          case 4:&#xD;&#xA;            myGLCD.setColor(0,0,255);&#xD;&#xA;            break;&#xD;&#xA;          case 5:&#xD;&#xA;            myGLCD.setColor(255,255,0);&#xD;&#xA;            break;&#xD;&#xA;        }&#xD;&#xA;        myGLCD.fillCircle(100+(i*20),60+(i*20), 30);&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      delay(2000);&#xD;&#xA;      &#xD;&#xA;      myGLCD.setColor(0,0,0);&#xD;&#xA;      myGLCD.fillRect(1,15,318,224);&#xD;&#xA;    &#xD;&#xA;    // Draw some lines in a pattern&#xD;&#xA;      myGLCD.setColor (255,0,0);&#xD;&#xA;      for (int i=15; i&lt;224; i+=5)&#xD;&#xA;      {&#xD;&#xA;        myGLCD.drawLine(1, i, (i*1.44)-10, 224);&#xD;&#xA;      }&#xD;&#xA;      myGLCD.setColor (255,0,0);&#xD;&#xA;      for (int i=224; i&gt;15; i-=5)&#xD;&#xA;      {&#xD;&#xA;        myGLCD.drawLine(318, i, (i*1.44)-11, 15);&#xD;&#xA;      }&#xD;&#xA;      myGLCD.setColor (0,255,255);&#xD;&#xA;      for (int i=224; i&gt;15; i-=5)&#xD;&#xA;      {&#xD;&#xA;        myGLCD.drawLine(1, i, 331-(i*1.44), 15);&#xD;&#xA;      }&#xD;&#xA;      myGLCD.setColor (0,255,255);&#xD;&#xA;      for (int i=15; i&lt;224; i+=5)&#xD;&#xA;      {&#xD;&#xA;        myGLCD.drawLine(318, i, 330-(i*1.44), 224);&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      delay(2000);&#xD;&#xA;      &#xD;&#xA;      myGLCD.setColor(0,0,0);&#xD;&#xA;      myGLCD.fillRect(1,15,318,224);&#xD;&#xA;    &#xD;&#xA;    // Draw some random circles&#xD;&#xA;      for (int i=0; i&lt;100; i++)&#xD;&#xA;      {&#xD;&#xA;        myGLCD.setColor(random(255), random(255), random(255));&#xD;&#xA;        x=32+random(256);&#xD;&#xA;        y=45+random(146);&#xD;&#xA;        r=random(30);&#xD;&#xA;        myGLCD.drawCircle(x, y, r);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      delay(2000);&#xD;&#xA;      &#xD;&#xA;      myGLCD.setColor(0,0,0);&#xD;&#xA;      myGLCD.fillRect(1,15,318,224);&#xD;&#xA;    &#xD;&#xA;    // Draw some random rectangles&#xD;&#xA;      for (int i=0; i&lt;100; i++)&#xD;&#xA;      {&#xD;&#xA;        myGLCD.setColor(random(255), random(255), random(255));&#xD;&#xA;        x=2+random(316);&#xD;&#xA;        y=16+random(207);&#xD;&#xA;        x2=2+random(316);&#xD;&#xA;        y2=16+random(207);&#xD;&#xA;        myGLCD.drawRect(x, y, x2, y2);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      delay(2000);&#xD;&#xA;      &#xD;&#xA;      myGLCD.setColor(0,0,0);&#xD;&#xA;      myGLCD.fillRect(1,15,318,224);&#xD;&#xA;    &#xD;&#xA;    // Draw some random rounded rectangles&#xD;&#xA;      for (int i=0; i&lt;100; i++)&#xD;&#xA;      {&#xD;&#xA;        myGLCD.setColor(random(255), random(255), random(255));&#xD;&#xA;        x=2+random(316);&#xD;&#xA;        y=16+random(207);&#xD;&#xA;        x2=2+random(316);&#xD;&#xA;        y2=16+random(207);&#xD;&#xA;        myGLCD.drawRoundRect(x, y, x2, y2);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      delay(2000);&#xD;&#xA;      &#xD;&#xA;      myGLCD.setColor(0,0,0);&#xD;&#xA;      myGLCD.fillRect(1,15,318,224);&#xD;&#xA;    &#xD;&#xA;      for (int i=0; i&lt;100; i++)&#xD;&#xA;      {&#xD;&#xA;        myGLCD.setColor(random(255), random(255), random(255));&#xD;&#xA;        x=2+random(316);&#xD;&#xA;        y=16+random(209);&#xD;&#xA;        x2=2+random(316);&#xD;&#xA;        y2=16+random(209);&#xD;&#xA;        myGLCD.drawLine(x, y, x2, y2);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      delay(2000);&#xD;&#xA;      &#xD;&#xA;      myGLCD.setColor(0,0,0);&#xD;&#xA;      myGLCD.fillRect(1,15,318,224);&#xD;&#xA;    &#xD;&#xA;      for (int i=0; i&lt;10000; i++)&#xD;&#xA;      {&#xD;&#xA;        myGLCD.setColor(random(255), random(255), random(255));&#xD;&#xA;        myGLCD.drawPixel(2+random(316), 16+random(209));&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      delay(2000);&#xD;&#xA;    &#xD;&#xA;      myGLCD.fillScr(0, 0, 255);&#xD;&#xA;      myGLCD.setColor(255, 0, 0);&#xD;&#xA;      myGLCD.fillRoundRect(80, 70, 239, 169);&#xD;&#xA;      &#xD;&#xA;      myGLCD.setColor(255, 255, 255);&#xD;&#xA;      myGLCD.setBackColor(255, 0, 0);&#xD;&#xA;      myGLCD.print(&quot;That's it!&quot;, CENTER, 93);&#xD;&#xA;      myGLCD.print(&quot;Restarting in a&quot;, CENTER, 119);&#xD;&#xA;      myGLCD.print(&quot;few seconds...&quot;, CENTER, 132);&#xD;&#xA;      &#xD;&#xA;      myGLCD.setColor(0, 255, 0);&#xD;&#xA;      myGLCD.setBackColor(0, 0, 255);&#xD;&#xA;      myGLCD.print(&quot;Runtime: (msecs)&quot;, CENTER, 210);&#xD;&#xA;      myGLCD.printNumI(millis(), CENTER, 225);&#xD;&#xA;      &#xD;&#xA;      delay (10000);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3241" PostHistoryTypeId="5" PostId="1124" RevisionGUID="ac04bf87-ca2c-48ef-ae95-fc8048a5fa7b" CreationDate="2014-04-10T23:56:51.433" UserId="37" Comment="fixed grammar; improved formatting; edited tags" Text="My project is to control car windows using voice recognition. I have successfully controlled some LEDs using the EasyVR Arduino shield using and Arduino MEGA. Now I want to take control of the windows using the CAN-BUS arduino shield.&#xD;&#xA;&#xD;&#xA;Because the car that I own doesn't have an OBD-II connector, I am using two Arduinos with two CAN-BUS Arduino shields making one a sender and the other a receiver. How can I program the CAN-BUS Arduino shield to make a simulation of the car's windows?&#xD;&#xA;&#xD;&#xA;CAN-BUS shield that I am using: https://www.sparkfun.com/products/10039&#xD;&#xA;&#xD;&#xA;Arduino Mega: https://www.sparkfun.com/products/11061" />
  <row Id="3242" PostHistoryTypeId="4" PostId="1124" RevisionGUID="ac04bf87-ca2c-48ef-ae95-fc8048a5fa7b" CreationDate="2014-04-10T23:56:51.433" UserId="37" Comment="fixed grammar; improved formatting; edited tags" Text="How to program a CAN-BUS Arduino shield to control car windows?" />
  <row Id="3243" PostHistoryTypeId="6" PostId="1124" RevisionGUID="ac04bf87-ca2c-48ef-ae95-fc8048a5fa7b" CreationDate="2014-04-10T23:56:51.433" UserId="37" Comment="fixed grammar; improved formatting; edited tags" Text="&lt;programming&gt;&lt;arduino-mega&gt;" />
  <row Id="3244" PostHistoryTypeId="24" PostId="1124" RevisionGUID="ac04bf87-ca2c-48ef-ae95-fc8048a5fa7b" CreationDate="2014-04-10T23:56:51.433" Comment="Proposed by 37 approved by 220 edit id of 279" />
  <row Id="3245" PostHistoryTypeId="2" PostId="1140" RevisionGUID="0e73ebe4-9e64-4d90-a122-3fa827253aaf" CreationDate="2014-04-11T04:36:18.463" UserId="84" Text="According to your comment:&#xD;&#xA;&#xD;&#xA;&gt; after commenting out those ifdef guards, it worked&#xD;&#xA;&#xD;&#xA;I would say that is a bug in the **Adafruit_GPS** library.&#xD;&#xA;&#xD;&#xA;As a matter of fact, the **DUE** is not using the **AVR** architecture (it uses **ARM**), that explains why `#ifdef __AVR__` in `Adafruit_GPS.h` never passes; but then something else should be done specifically for the DUE (missing `#else` or `#elif`).&#xD;&#xA;&#xD;&#xA;After checking on *github*, there is an [issue][1] open for that; unfortunately, as of April 2014, it has not moved for 10 months.&#xD;&#xA;&#xD;&#xA;Your best guess would be to go there and try to &quot;reactivate&quot; this issue.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/adafruit/Adafruit-GPS-Library/issues/14" />
  <row Id="3246" PostHistoryTypeId="2" PostId="1141" RevisionGUID="b9fb3253-8c16-42ad-8fb2-5e9d2951e613" CreationDate="2014-04-11T05:39:10.613" UserId="562" Text="There may be a problem with sending Email from Arduino, but not where you are expecting it. SMTP protocol is super simple, even Arduino can handle it. But you will need SMTP server somewhere that will talk to your Arduino. SSL connections (as on Gmail) are out of consideration (code to handle the encryption would be too much for Arduino) so you'd have to find mail provider that provides plain SMTP - and there aren't many. If you will set up one yourself, say on your home PC with static IP address, it would be an invitation for spammers and a guaranteed way to get your IP blacklisted by Spamhaus. My advice would be to have Python, PHP or Perl script hosted somewhere that will handle HTTP POST requests from your Arduino and do Email sending. It is safer and simpler." />
  <row Id="3250" PostHistoryTypeId="5" PostId="1137" RevisionGUID="887d2325-d8ee-4b3c-9a21-0c69f34521c2" CreationDate="2014-04-11T15:22:42.703" UserId="37" Comment="fixed grammar; improved formatting; edited tags; improved title" Text="I downloaded the Adafruit_GPS library from Adafruit and I'm trying to compile the example code (due_parsing) but I can't seem to get past this silly error:&#xD;&#xA;      &#xD;&#xA;    In file included from due_parsing.ino:15:&#xD;&#xA;&#xD;&#xA;    /Users/haddad/Documents/Arduino/libraries/Adafruit_GPS/Adafruit_GPS.h:24: fatal error: SoftwareSerial.h: No such file or directory&#xD;&#xA;    compilation terminated.&#xD;&#xA;&#xD;&#xA;This is the location in the example Arduino Sketch where `SoftwareSerial.h` is mentioned:&#xD;&#xA;&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;      #include &lt;SoftwareSerial.h&gt;&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;I noticed it's around an `ifdef` guard, so shouldn't it not even matter that I don't have this library?&#xD;&#xA;&#xD;&#xA;I went into the .h and .cpp files and commented out the where it called `SoftwareSerial.h`, but I'm still getting that above error.&#xD;&#xA;&#xD;&#xA;Does anybody know how to fix this?&#xD;&#xA;I am using Arduino IDE v1.5.5&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Update:&#xD;&#xA;&#xD;&#xA;I didn't put the library in the library direct on my mac but I'm now getting tons of errors, all the errors are with `SoftwareSerial.cpp`. Is anybody else having similar issues when you go to compile?" />
  <row Id="3251" PostHistoryTypeId="4" PostId="1137" RevisionGUID="887d2325-d8ee-4b3c-9a21-0c69f34521c2" CreationDate="2014-04-11T15:22:42.703" UserId="37" Comment="fixed grammar; improved formatting; edited tags; improved title" Text="Why am I getting &quot;fatal error: SoftwareSerial.h: No such file or directory&quot;" />
  <row Id="3252" PostHistoryTypeId="6" PostId="1137" RevisionGUID="887d2325-d8ee-4b3c-9a21-0c69f34521c2" CreationDate="2014-04-11T15:22:42.703" UserId="37" Comment="fixed grammar; improved formatting; edited tags; improved title" Text="&lt;arduino-due&gt;&lt;softwareserial&gt;" />
  <row Id="3253" PostHistoryTypeId="24" PostId="1137" RevisionGUID="887d2325-d8ee-4b3c-9a21-0c69f34521c2" CreationDate="2014-04-11T15:22:42.703" Comment="Proposed by 37 approved by 136, 42 edit id of 281" />
  <row Id="3254" PostHistoryTypeId="5" PostId="1114" RevisionGUID="72e9f853-8671-485c-b0d0-cf18ea2b237f" CreationDate="2014-04-11T15:23:18.357" UserId="37" Comment="fixed grammar" Text="I want to make my Arduino connect via WiFi and then send an email. The idea is very simple, but the problem is that I've never worked with those protocols and other things before. I just wanted something that's already premade, so I would just change the information.&#xD;&#xA;&#xD;&#xA;Is there a library or a function that sends the email?&#xD;&#xA;&#xD;&#xA;If someone could help me to understand, so I can make it myself, that would be the best." />
  <row Id="3255" PostHistoryTypeId="4" PostId="1114" RevisionGUID="72e9f853-8671-485c-b0d0-cf18ea2b237f" CreationDate="2014-04-11T15:23:18.357" UserId="37" Comment="fixed grammar" Text="How to send an email with Arduino and a WiFi shield?" />
  <row Id="3256" PostHistoryTypeId="24" PostId="1114" RevisionGUID="72e9f853-8671-485c-b0d0-cf18ea2b237f" CreationDate="2014-04-11T15:23:18.357" Comment="Proposed by 37 approved by 136, 42 edit id of 280" />
  <row Id="3259" PostHistoryTypeId="2" PostId="1144" RevisionGUID="db6e3d7a-9a4c-4552-a080-1666ebe36046" CreationDate="2014-04-11T18:09:40.020" UserId="1015" Text="I am new to using Arduino Yun and I would like to know if it is possible to run a command from the Arduino sketch in order to make (probably, through the Bridge Library) Linino to execute a HTTP Request to a remote server. Then I would like to know if it is possible to use the returned values in that Arduino sketch.&#xD;&#xA;&#xD;&#xA;If it is possible, how to do that?" />
  <row Id="3260" PostHistoryTypeId="1" PostId="1144" RevisionGUID="db6e3d7a-9a4c-4552-a080-1666ebe36046" CreationDate="2014-04-11T18:09:40.020" UserId="1015" Text="It is possible to program Linino to send HTTP requests and then use the returned values in sketch?" />
  <row Id="3261" PostHistoryTypeId="3" PostId="1144" RevisionGUID="db6e3d7a-9a4c-4552-a080-1666ebe36046" CreationDate="2014-04-11T18:09:40.020" UserId="1015" Text="&lt;programming&gt;&lt;library&gt;&lt;sketch&gt;&lt;arduino-yun&gt;&lt;web&gt;" />
  <row Id="3262" PostHistoryTypeId="5" PostId="1144" RevisionGUID="9ddcbf37-c25f-42b4-b54e-dd678787cad7" CreationDate="2014-04-11T18:15:48.527" UserId="1015" Comment="added 155 characters in body" Text="I am new to using Arduino Yun and I would like to know if it is possible to run a command from the Arduino sketch in order to make (probably, through the Bridge Library) Linino to execute a HTTP Request to a remote server. Then I would like to know if it is possible to use the returned values in that Arduino sketch.&#xD;&#xA;&#xD;&#xA;In other words, I would like to delegate the task of retrieving values from the web to the Linux side and the usage of the retrieved data to the sketch.&#xD;&#xA;&#xD;&#xA;If it is possible, how to do that?" />
  <row Id="3263" PostHistoryTypeId="10" PostId="1126" RevisionGUID="217f5ae8-ec7b-4c35-b362-971779260019" CreationDate="2014-04-11T18:18:30.023" UserId="11" Comment="103" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:37,&quot;DisplayName&quot;:&quot;The Guy with The Hat&quot;},{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="3264" PostHistoryTypeId="2" PostId="1145" RevisionGUID="2de995ed-0521-419c-8df9-bd49c0837055" CreationDate="2014-04-11T19:03:36.213" UserId="27" Text="Take a look at [Bridge example][1] or [TemperatureWebPanel example][2]: you see you can receive kind of &quot;commands&quot; and react &quot;doing things&quot;.&#xD;&#xA;&#xD;&#xA;Then take a look at [HTTP Client example][3], where you delegate an HTTP call to the linux side.&#xD;&#xA;&#xD;&#xA;Now mix the two: you can make HTTP calls after receiving a command from outside your Yun.&#xD;&#xA;&#xD;&#xA;A short test can be done by cutting and pasting the examples above.&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Tutorial/Bridge&#xD;&#xA;  [2]: http://arduino.cc/en/Tutorial/TemperatureWebPanel&#xD;&#xA;  [3]: http://arduino.cc/en/Tutorial/HttpClient" />
  <row Id="3265" PostHistoryTypeId="2" PostId="1146" RevisionGUID="364b806e-81d8-44fc-8fc6-b27bbc1169b8" CreationDate="2014-04-11T19:48:47.153" UserId="1015" Text="I am new to using Arduino Yun and I would like to know if it is possible to run an entire script on the Linux side. In my case the script should execute a HTTP request to a remote server, parse the subsequent HTTP response and return some value that then can be used in the Arduino sketch.&#xD;&#xA;&#xD;&#xA;If it is possible, what I have to do? For example, how should I write and run script files? what programming language should I use? where I should put those script files on the Linux side?" />
  <row Id="3266" PostHistoryTypeId="1" PostId="1146" RevisionGUID="364b806e-81d8-44fc-8fc6-b27bbc1169b8" CreationDate="2014-04-11T19:48:47.153" UserId="1015" Text="It is possible to run an entire script on the Linux side? If so, how, what and where to do that?" />
  <row Id="3267" PostHistoryTypeId="3" PostId="1146" RevisionGUID="364b806e-81d8-44fc-8fc6-b27bbc1169b8" CreationDate="2014-04-11T19:48:47.153" UserId="1015" Text="&lt;programming&gt;&lt;sketch&gt;&lt;arduino-yun&gt;&lt;web&gt;" />
  <row Id="3270" PostHistoryTypeId="2" PostId="1147" RevisionGUID="25742fe6-0c53-4fc6-82fd-dc53e866bf3b" CreationDate="2014-04-11T23:22:13.890" UserId="993" Text="So I went into the interface file (.h) and removed all references to AVR and then went into (.cpp) and removed all references to AVR there as well. It now seems to be working, although sometimes it says &quot;Not supported Architecture ARM&quot; during compilation...very weird" />
  <row Id="3271" PostHistoryTypeId="36" PostId="1148" RevisionGUID="2f4d10eb-5fa0-454e-8e44-c712bb867fd3" CreationDate="2014-04-11T23:40:02.460" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/102270/use-an-arduino-as-a-user-interface-for-the-computer" />
  <row Id="3272" PostHistoryTypeId="36" PostId="1149" RevisionGUID="0cd54282-396e-4dd0-9f49-18c4bbc846b8" CreationDate="2014-04-11T23:40:02.460" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/102270/use-an-arduino-as-a-user-interface-for-the-computer/102275#102275" />
  <row Id="3273" PostHistoryTypeId="36" PostId="1150" RevisionGUID="5a66f25a-5cc9-4ad8-bd5a-a0ad51cd6ba0" CreationDate="2014-04-11T23:40:02.460" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/102270/use-an-arduino-as-a-user-interface-for-the-computer/102279#102279" />
  <row Id="3274" PostHistoryTypeId="2" PostId="1149" RevisionGUID="d898e12d-7afc-42c0-a183-1dbe595b532f" CreationDate="2014-03-08T20:22:37.537" UserDisplayName="mlemos" Text="You can do that easily with a few of the Arduino boards that have built-in USB communications support.&#xD;&#xA;&#xD;&#xA;You find that feature on Leonardo, Micro, Esplora and Due boards. You also find that on some Arduino compatible boards like the Adafruit Flora.&#xD;&#xA;&#xD;&#xA;Simply plug the Arduino USB port to your computer and the Arduino will behave like a keyboard. Then you can program your sketch to perform what you want with your buttons. Check the Arduino  [mouse and keyboard library][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/MouseKeyboard#.Uxt6yuddVTY" />
  <row Id="3275" PostHistoryTypeId="2" PostId="1150" RevisionGUID="01c5a61e-e096-4d5c-b44d-aadbde06a5aa" CreationDate="2014-03-08T20:39:11.033" UserId="113" Text="Arduino Yun, Leonardo, Esplora and Due have  the ability to appear as a native Mouse and/or Keyboard to a connected computer by use of the [Mouse and Keyboard libraries][1].&#xD;&#xA;&#xD;&#xA;Here's an example of how you would use SWITCH3 on the Esplora to active PAGE UP on your keyboard.&#xD;&#xA;&#xD;&#xA;    if (!Esplora.readButton(SWITCH_3)) {&#xD;&#xA;      Keyboard.press(KEY_PAGE_UP)&#xD;&#xA;      delay(100);&#xD;&#xA;      Keyboard.releaseAll();&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;[Here's an example][2] of using the Esplora to control the Keyboard and Mouse to control the Flight Simulator option of Google Earth.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;If you want to use the Uno it's more difficult but it can be done by sending data from the Uno to a Python program running on the PC. The Python program uses the pywin library to control windows.&#xD;&#xA;&#xD;&#xA;[Here's a fully worked out Instructable][3] on how to do it.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/MouseKeyboard#.Uxt-kIWzBzw&#xD;&#xA;  [2]: http://www.instructables.com/id/Arduino-Esplora-Flight-Simulator/&#xD;&#xA;  [3]: http://www.instructables.com/id/Flight-Simulator-with-Arduino-and-Python/" />
  <row Id="3276" PostHistoryTypeId="2" PostId="1148" RevisionGUID="687864c7-b60e-492c-a725-7b617013954b" CreationDate="2014-03-08T19:12:32.133" UserDisplayName="Jakub" Text="I wanted to use either Arduino Mega or Uno as a form of an interface between me and the computer. I want to apply it to the following scenario; if I press a button on a circuit board I want it to trigger an action on my computer, like scroll down.&#xD;&#xA;&#xD;&#xA;How can I achieve this? How would the code look like and what programs would I need to translate from Arduino to Windows?&#xD;&#xA;" />
  <row Id="3277" PostHistoryTypeId="1" PostId="1148" RevisionGUID="687864c7-b60e-492c-a725-7b617013954b" CreationDate="2014-03-08T19:12:32.133" UserDisplayName="Jakub" Text="Use an Arduino as a user interface for the computer" />
  <row Id="3278" PostHistoryTypeId="3" PostId="1148" RevisionGUID="687864c7-b60e-492c-a725-7b617013954b" CreationDate="2014-03-08T19:12:32.133" UserDisplayName="Jakub" Text="&lt;serial&gt;&lt;linux&gt;" />
  <row Id="3279" PostHistoryTypeId="36" PostId="1151" RevisionGUID="70275927-3658-4a8b-a6b7-d94cedd7ae31" CreationDate="2014-04-11T23:44:44.550" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/101059/accessing-arduino-yun-from-internet" />
  <row Id="3280" PostHistoryTypeId="2" PostId="1152" RevisionGUID="cf0aa67a-9442-4f5e-81d6-b7beec263ef9" CreationDate="2014-02-26T17:37:22.027" UserId="291" Text="Well, I'm not familiar with the Yun, but the first thing that stands out is the missing&#xD;&#xA;&#xD;&#xA;    Bridge.begin();&#xD;&#xA;&#xD;&#xA;line apparently needed to initialize the Bridge library that you use.&#xD;&#xA;&#xD;&#xA;And you do have something like&#xD;&#xA;&#xD;&#xA;    YunClient client = server.accept();&#xD;&#xA; &#xD;&#xA;and &quot;more&quot; in the main loop (or a function where applicable) of your code, right ?&#xD;&#xA;&#xD;&#xA;And yes, `noListenOnLocalhost()` is the correct function for serving external clients." />
  <row Id="3281" PostHistoryTypeId="2" PostId="1151" RevisionGUID="b3ce434f-a082-41f0-b5c7-eaf2ca361020" CreationDate="2014-02-26T17:18:22.927" UserId="306" Text="I am trying to access my Arduino Yun from the internet, and it's not quite working. I have correctly port forwarded the port 5555 from the router to the Yun (verified I am able to access my many other NAT'd resources). &#xD;&#xA;&#xD;&#xA;I can access the Yun from my internal network. &#xD;&#xA;&#xD;&#xA;In the Arduino sketch I have this (among many other things). Mainly taken from example sketches.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &lt;Bridge.h&gt;&#xD;&#xA;    #include &lt;HttpClient.h&gt;&#xD;&#xA;    #include &lt;YunServer.h&gt;&#xD;&#xA;    #include &lt;YunClient.h&gt;&#xD;&#xA;    &#xD;&#xA;    YunServer server;&#xD;&#xA;    &#xD;&#xA;    void setup {&#xD;&#xA;       // Listen for incoming connections on port 5555&#xD;&#xA;       server.noListenOnLocalhost();&#xD;&#xA;       server.begin();&#xD;&#xA;    }&#xD;&#xA;Is `server.noListenOnLocalhost();` the right one to use to access from the outside world?" />
  <row Id="3282" PostHistoryTypeId="1" PostId="1151" RevisionGUID="b3ce434f-a082-41f0-b5c7-eaf2ca361020" CreationDate="2014-02-26T17:18:22.927" UserId="306" Text="Accessing Arduino Yun from Internet" />
  <row Id="3283" PostHistoryTypeId="3" PostId="1151" RevisionGUID="b3ce434f-a082-41f0-b5c7-eaf2ca361020" CreationDate="2014-02-26T17:18:22.927" UserId="306" Text="&lt;untagged&gt;" />
  <row Id="3284" PostHistoryTypeId="36" PostId="1152" RevisionGUID="fcb5eb27-da19-4ae9-813a-f782e5f8eb65" CreationDate="2014-04-11T23:44:44.550" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/101059/accessing-arduino-yun-from-internet/101063#101063" />
  <row Id="3285" PostHistoryTypeId="6" PostId="1151" RevisionGUID="857f26cd-a5e5-43f4-887d-93fc1dd2f8ce" CreationDate="2014-04-11T23:45:37.760" UserId="11" Comment="edited tags" Text="&lt;arduino-yun&gt;" />
  <row Id="3286" PostHistoryTypeId="2" PostId="1153" RevisionGUID="348630b1-fc8f-428f-a61f-0948bcf38724" CreationDate="2014-04-12T09:53:26.167" UserId="643" Text="this is a &quot;bug&quot; in the arduino IDE pre-compilation process.&#xD;&#xA;If you turn on the compiling verbositi in thge precerences menu, you will see that arduino has copied all file (with a rater &quot;stupid&quot; code that just look for include) into a temp folder (wiring lib are not copied, but the below still aplly). Until here, ugly but still fine.&#xD;&#xA;&#xD;&#xA;Then, it will -force- compilation of every &quot;included&quot; file, one by one, the facto bypassing the #ifdef.. and this is why you get that problem.&#xD;&#xA;&#xD;&#xA;Solution is to heavy change the ide so it will force compilation only in the main, and let the compiler include and compile needed libraries.&#xD;&#xA;&#xD;&#xA;I still have no idea why every file is forced, but a change like this is really heavy and break-old-code prone..&#xD;&#xA;&#xD;&#xA;Newest IDE to bypass this problem (and also some other problem, like depeency) use a &quot;config&quot; file that will tell the IDE if use the AVR or ARM or x86 library, probabily this file is missing and the ide see te lib as only AVR by default.&#xD;&#xA;&#xD;&#xA;Double check if it is really usable on DUE" />
  <row Id="3290" PostHistoryTypeId="2" PostId="1155" RevisionGUID="363a26e0-00d7-4cde-9c66-3c141d3a8f9a" CreationDate="2014-04-12T11:10:41.193" UserId="1021" Text="the central lock system will close the car doors and close the windows, i think you should build your system with the same idea, dealing with windows motors as normal motor without special commands for the window" />
  <row Id="3292" PostHistoryTypeId="6" PostId="1115" RevisionGUID="86318a03-ec5f-458b-a25f-8c48a729c19e" CreationDate="2014-04-12T13:12:40.673" UserId="220" Comment="edited tags" Text="&lt;serial&gt;&lt;uart&gt;" />
  <row Id="3293" PostHistoryTypeId="2" PostId="1156" RevisionGUID="bec8e9f7-3fb1-43e6-97fc-81791e8745aa" CreationDate="2014-04-12T18:11:16.540" UserId="612" Text="For the sake of completeness, on the more traditional boards where the USB interface is not implemented from the main &quot;sketch&quot; processor, there are three other potential possibilities:&#xD;&#xA;&#xD;&#xA; - Use the (USB) serial data interface, and have software on the host computer which accepts commands over that.  Obviously, the downside is requiring installation of something on the host system - installation which may require admin privileges or even disabling code signing requirements in some cases (especially if it is to inject the data into the host operating system as if it came from a keyaboard)&#xD;&#xA;&#xD;&#xA; - On boards such as the Uno and comparable-generation Mega which use a secondary ATmega &quot;u&quot; series part as a USB-serial converter, this chip can be reprogrammed to act instead as a keyboard.  That could make loading sketches tricky - though it might be possible to come up with a dual-mode firmware that could switch roles under control of an external hardware or software signal.&#xD;&#xA;&#xD;&#xA; - The main ATmega &quot;sketch&quot; processor can generally implement a &quot;not quite compliant, but workable&quot; *approximation* of a low-speed USB interface *in software* on arbitrary I/O pins with some external matching/protection componenets.  A USB keyboard is a common demo application of that.&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3294" PostHistoryTypeId="2" PostId="1157" RevisionGUID="aee72197-126a-4166-9f40-b60a34fe3a77" CreationDate="2014-04-13T05:27:47.710" UserId="667" Text="I'm working with an Adafruit LSM303DLHC Accelerometer Sensor hooked up to an Arduino.  I've downloaded the appropriate libraries to make it work and uploaded the example sketch &quot;accelsensor.pde&quot;.  I then placed my sensor at rest on a flat surface and obtained the following acceleration vector values on average, in units of meters per second:&#xD;&#xA;&#xD;&#xA;    X: -0.24  Y: -0.71  Z: 10.47&#xD;&#xA;&#xD;&#xA;At rest, each of these three values fluctuate approximately +-0.04 on average.&#xD;&#xA;&#xD;&#xA;As I see it, the values are off a bit.  At rest, the X and Y components should hover closer to 0m/s^2 while the Z component should be closer to 9.8m/s^2.  &#xD;&#xA;&#xD;&#xA;What is the best way to compensate for this biased measurement?  Should I simply add back the average observed bias?  Or is there a more robust method to calibrate the sensor values? " />
  <row Id="3295" PostHistoryTypeId="1" PostId="1157" RevisionGUID="aee72197-126a-4166-9f40-b60a34fe3a77" CreationDate="2014-04-13T05:27:47.710" UserId="667" Text="Calibrating Accelerometer Sensor" />
  <row Id="3296" PostHistoryTypeId="3" PostId="1157" RevisionGUID="aee72197-126a-4166-9f40-b60a34fe3a77" CreationDate="2014-04-13T05:27:47.710" UserId="667" Text="&lt;sensors&gt;" />
  <row Id="3297" PostHistoryTypeId="2" PostId="1158" RevisionGUID="aa0c53a1-48d2-4ede-b956-83f341f9f1f8" CreationDate="2014-04-13T08:08:26.073" UserId="942" Text="I was playing with getting my servos to be on dedicated power, separate form the Arduino entirely, but obviously controlled by the Arduino. I originally had the ground of the Arduino joined with the `-` of the battery, but to my surprise my Arduino continued to control the servos when I remove the ground wire entirely from the Arduino. &#xD;&#xA;&#xD;&#xA;I was under the impression that all electricity must form a complete circuit, and be a closed loop. But my Arduino can obviously send a signal to a component that has no return path to itself.&#xD;&#xA;&#xD;&#xA;I feel like I'm missing something fundamental about a electricity. So my question is:&#xD;&#xA;&#xD;&#xA;**Why does this work?**&#xD;&#xA;&#xD;&#xA;![arduino setup][1]&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/n37I0.jpg" />
  <row Id="3298" PostHistoryTypeId="1" PostId="1158" RevisionGUID="aa0c53a1-48d2-4ede-b956-83f341f9f1f8" CreationDate="2014-04-13T08:08:26.073" UserId="942" Text="How can Arduino control with a servo with only one wire?" />
  <row Id="3299" PostHistoryTypeId="3" PostId="1158" RevisionGUID="aa0c53a1-48d2-4ede-b956-83f341f9f1f8" CreationDate="2014-04-13T08:08:26.073" UserId="942" Text="&lt;motor&gt;&lt;electricity&gt;" />
  <row Id="3300" PostHistoryTypeId="6" PostId="1158" RevisionGUID="109835c5-b8dc-4c40-aabb-f9704eb74a2d" CreationDate="2014-04-13T08:19:39.947" UserId="942" Comment="edited tags" Text="&lt;electricity&gt;" />
  <row Id="3301" PostHistoryTypeId="2" PostId="1159" RevisionGUID="e86fc260-ab35-407f-a8a2-638dd1926454" CreationDate="2014-04-13T08:31:35.377" UserId="83" Text="The return signal is probably the other wire's servo. This only works when the control pulses to both servos are not in sync. Pull one signal wire off the breadboard and both servos will stop working.&#xD;&#xA;&#xD;&#xA;You need to interconnect grounds or you will get strange effects sooner or later." />
  <row Id="3302" PostHistoryTypeId="2" PostId="1160" RevisionGUID="cee468ba-c1a8-4c5d-9992-ab21ccf6cd16" CreationDate="2014-04-13T12:32:51.317" UserId="693" Text="Running Ubuntu 12.04.4 LTS (64 bit) I try to upload my code to the Arduino Due through the Native port. I have tried both the `bossac.exe` that ships with the Arduino IDE (which is a modified version of BOSSA), and the master BOSSA branch.&#xD;&#xA;&#xD;&#xA;Running this command:&#xD;&#xA;&#xD;&#xA;    sudo ./bossac -p /dev/ttyACM0&#xD;&#xA;&#xD;&#xA;I get this error:&#xD;&#xA;&#xD;&#xA;    No device found on /dev/ttyACM0&#xD;&#xA;&#xD;&#xA;However, it works perfectly inside the Arduino IDE.&#xD;&#xA;&#xD;&#xA;What can the problem be?" />
  <row Id="3303" PostHistoryTypeId="1" PostId="1160" RevisionGUID="cee468ba-c1a8-4c5d-9992-ab21ccf6cd16" CreationDate="2014-04-13T12:32:51.317" UserId="693" Text="Why does command line BOSSA not recognize Arduino Due?" />
  <row Id="3304" PostHistoryTypeId="3" PostId="1160" RevisionGUID="cee468ba-c1a8-4c5d-9992-ab21ccf6cd16" CreationDate="2014-04-13T12:32:51.317" UserId="693" Text="&lt;arduino-due&gt;&lt;bossa&gt;&lt;ubuntu&gt;" />
  <row Id="3309" PostHistoryTypeId="5" PostId="140" RevisionGUID="d9abfda3-e1d9-4501-b324-9dc481ae1854" CreationDate="2014-04-13T16:58:53.837" UserId="510" Comment="Copy edited. Added some context." Text="I want to use sensors on an Arduino to control values in a [MATLAB][1] program. What are my options for communicating?&#xD;&#xA;&#xD;&#xA;I've used [Processing][2] to receive data sent via the serial cable, and that strategy has worked pretty well. Is there something similar I can do using MATLAB? I'm somewhat new to MATLAB, so gentle guidance would be great.&#xD;&#xA;&#xD;&#xA;I'm not really looking for something like the [ArduinoIO][3] package -- I want to have separate computation executing on the Arduino and occasionally informing my MATLAB program (which will occasionally poll the serial line, I suppose).&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/MATLAB&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Processing_%28programming_language%29&#xD;&#xA;  [3]: http://www.mathworks.com/matlabcentral/fileexchange/32374-matlab-support-package-for-arduino-aka-arduinoio-package&#xD;&#xA;" />
  <row Id="3310" PostHistoryTypeId="4" PostId="140" RevisionGUID="d9abfda3-e1d9-4501-b324-9dc481ae1854" CreationDate="2014-04-13T16:58:53.837" UserId="510" Comment="Copy edited. Added some context." Text="How can I communicate from Arduino to MATLAB" />
  <row Id="3311" PostHistoryTypeId="24" PostId="140" RevisionGUID="d9abfda3-e1d9-4501-b324-9dc481ae1854" CreationDate="2014-04-13T16:58:53.837" Comment="Proposed by 510 approved by 11 edit id of 282" />
  <row Id="3312" PostHistoryTypeId="5" PostId="165" RevisionGUID="9ad01148-8c89-4118-81d0-3625d1e852bb" CreationDate="2014-04-13T16:59:14.473" UserId="510" Comment="Copy edited. Dressed the naked link." Text="I don't know a whole lot about MATLAB, but I found some tutorials about reading and writing from the serial port:&#xD;&#xA;&#xD;&#xA;    s = serial('COM1');&#xD;&#xA;    fopen(s)&#xD;&#xA;    fprintf(s, 'Your serial data goes here')&#xD;&#xA;    out = fscanf(s)&#xD;&#xA;&#xD;&#xA;`out` is now your received data, and you can do whatever you want with it.&#xD;&#xA;&#xD;&#xA;To close:&#xD;&#xA;&#xD;&#xA;    fclose(s)&#xD;&#xA;    delete(s)&#xD;&#xA;    clear s&#xD;&#xA;&#xD;&#xA;It is from *[Writing and Reading Data][1]* (*MATLAB*/ *Data and File Management*/ *Serial Port Devices*).&#xD;&#xA;&#xD;&#xA;From your question I assume you know about the Arduino side of things (using `Serial`).&#xD;&#xA;&#xD;&#xA;  [1]: http://www.mathworks.com/help/matlab/matlab_external/writing-and-reading-data.html&#xD;&#xA;" />
  <row Id="3313" PostHistoryTypeId="24" PostId="165" RevisionGUID="9ad01148-8c89-4118-81d0-3625d1e852bb" CreationDate="2014-04-13T16:59:14.473" Comment="Proposed by 510 approved by 11 edit id of 283" />
  <row Id="3315" PostHistoryTypeId="2" PostId="1162" RevisionGUID="c3446491-21f7-480b-b364-af017546ac58" CreationDate="2014-04-13T20:21:35.167" UserId="1032" Text="any help would be appreciated and thank you&#xD;&#xA;&#xD;&#xA;This is my problem:&#xD;&#xA;&#xD;&#xA;I hooked up two ultrasonic sensors to my breadboard and I also got a 5v motor installed. I also got the diode installed and the usual set up. I can easily control the motor with one sensor. &#xD;&#xA;&#xD;&#xA;But what I'm trying to do is I want the motor to run at let's say 100 once I start it up&#xD;&#xA;- The first sensor should be used to slowly slow down the motor when an object is placed in front of it&#xD;&#xA;- The second sensor should be used to slowly speed up the motor when an object is placed in front of it&#xD;&#xA;&#xD;&#xA;I do not want the speed to return to 100 once the object is taken off. It should remain at the same speed according to which sensor was used.&#xD;&#xA;&#xD;&#xA;(makes sense? Don't know how to explain this in layman's terms)&#xD;&#xA;&#xD;&#xA;so far I got this code:&#xD;&#xA;&#xD;&#xA;    int motorPin = 9;&#xD;&#xA;    int trigPin = 13;&#xD;&#xA;    int echoPin = 12;&#xD;&#xA;    int trigPin2 = 5;&#xD;&#xA;    int echoPin2 = 4;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;    Serial.begin (9600);&#xD;&#xA;    pinMode(trigPin, OUTPUT);&#xD;&#xA;    pinMode(echoPin, INPUT);&#xD;&#xA;    pinMode(trigPin2, OUTPUT);&#xD;&#xA;    pinMode(echoPin2, INPUT);&#xD;&#xA;    pinMode(motorPin, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;    int duration, distance;&#xD;&#xA;    digitalWrite (trigPin, HIGH);&#xD;&#xA;    delayMicroseconds (1000);&#xD;&#xA;    digitalWrite (trigPin, LOW);&#xD;&#xA;    duration = pulseIn (echoPin, HIGH);&#xD;&#xA;    distance = (duration/2) / 29.1;&#xD;&#xA;    if (distance &lt; 20) {  // Distance from sensor&#xD;&#xA;    analogWrite (motorPin, 50);&#xD;&#xA;    }&#xD;&#xA;    else {&#xD;&#xA;    int duration, distance;&#xD;&#xA;    digitalWrite (trigPin2, HIGH);&#xD;&#xA;    delayMicroseconds (1000);&#xD;&#xA;    digitalWrite (trigPin2, LOW);&#xD;&#xA;    duration = pulseIn (echoPin2, HIGH);&#xD;&#xA;    distance = (duration/2) / 29.1;&#xD;&#xA;    if (distance &gt; 20) {  // Distance from sensor&#xD;&#xA;    analogWrite (motorPin, 150);&#xD;&#xA;    }&#xD;&#xA;     if  (distance &gt; 20) {  // Distance from sensor&#xD;&#xA;      Serial.println(&quot;Out of range&quot;);&#xD;&#xA;    }&#xD;&#xA;    else {&#xD;&#xA;    Serial.print(distance);&#xD;&#xA;    Serial.println(&quot; cm&quot;);&#xD;&#xA;    }&#xD;&#xA;    delay(500);&#xD;&#xA;    }&#xD;&#xA;    }" />
  <row Id="3316" PostHistoryTypeId="1" PostId="1162" RevisionGUID="c3446491-21f7-480b-b364-af017546ac58" CreationDate="2014-04-13T20:21:35.167" UserId="1032" Text="connecting 2 ultrasonic sensors to control a 5v motor" />
  <row Id="3317" PostHistoryTypeId="3" PostId="1162" RevisionGUID="c3446491-21f7-480b-b364-af017546ac58" CreationDate="2014-04-13T20:21:35.167" UserId="1032" Text="&lt;arduino-uno&gt;&lt;sensors&gt;" />
  <row Id="3318" PostHistoryTypeId="5" PostId="1162" RevisionGUID="6ac12c11-720d-4474-8116-ed80f9532127" CreationDate="2014-04-13T20:29:13.060" UserId="220" Comment="Corrected formatting issues" Text="I've hooked up two ultrasonic sensors to my breadboard and I also got a 5v motor installed. I also got the diode installed and the usual set up. I can easily control the motor with one sensor. &#xD;&#xA;&#xD;&#xA;But what I'm trying to do is I want the motor to run at let's say 100 once I start it up:&#xD;&#xA;&#xD;&#xA;- The first sensor should be used to slowly slow down the motor when an object is placed in front of it&#xD;&#xA;- The second sensor should be used to slowly speed up the motor when an object is placed in front of it&#xD;&#xA;&#xD;&#xA;**I do not want the speed to return to 100 once the object is removed.** It should remain at the same speed according to which sensor was used. (Tell me if I have to clarify anything in the comments)&#xD;&#xA;&#xD;&#xA;Code&#xD;&#xA;    int motorPin = 9;&#xD;&#xA;    int trigPin = 13;&#xD;&#xA;    int echoPin = 12;&#xD;&#xA;    int trigPin2 = 5;&#xD;&#xA;    int echoPin2 = 4;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin (9600);&#xD;&#xA;      pinMode(trigPin, OUTPUT);&#xD;&#xA;      pinMode(echoPin, INPUT);&#xD;&#xA;      pinMode(trigPin2, OUTPUT);&#xD;&#xA;      pinMode(echoPin2, INPUT);&#xD;&#xA;      pinMode(motorPin, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      int duration, distance;&#xD;&#xA;      digitalWrite (trigPin, HIGH);&#xD;&#xA;      delayMicroseconds (1000);&#xD;&#xA;      digitalWrite (trigPin, LOW);&#xD;&#xA;      duration = pulseIn (echoPin, HIGH);&#xD;&#xA;      distance = (duration/2) / 29.1;&#xD;&#xA;      if (distance &lt; 20) {  // Distance from sensor&#xD;&#xA;        analogWrite (motorPin, 50);&#xD;&#xA;      } else {&#xD;&#xA;        int duration, distance;&#xD;&#xA;        digitalWrite (trigPin2, HIGH);&#xD;&#xA;        delayMicroseconds (1000);&#xD;&#xA;        digitalWrite (trigPin2, LOW);&#xD;&#xA;        duration = pulseIn (echoPin2, HIGH);&#xD;&#xA;        distance = (duration/2) / 29.1;&#xD;&#xA;        if (distance &gt; 20) {  // Distance from sensor&#xD;&#xA;          analogWrite (motorPin, 150);&#xD;&#xA;        }&#xD;&#xA;        if  (distance &gt; 20) {  // Distance from sensor&#xD;&#xA;          Serial.println(&quot;Out of range&quot;);&#xD;&#xA;        } else {&#xD;&#xA;          Serial.print(distance);&#xD;&#xA;         Serial.println(&quot; cm&quot;);&#xD;&#xA;        }&#xD;&#xA;        delay(500);&#xD;&#xA;      }&#xD;&#xA;    }" />
  <row Id="3319" PostHistoryTypeId="4" PostId="1162" RevisionGUID="6ac12c11-720d-4474-8116-ed80f9532127" CreationDate="2014-04-13T20:29:13.060" UserId="220" Comment="Corrected formatting issues" Text="How do I use 2 ultrasonic sensors to control a 5v motor?" />
  <row Id="3320" PostHistoryTypeId="36" PostId="1163" RevisionGUID="eaf72cea-49e2-428c-920f-f2692becf189" CreationDate="2014-04-13T21:33:15.763" UserId="-1" Comment="from http://stackoverflow.com/questions/22213231/replicate-a-waveform-exactly-with-an-arduino-uno" />
  <row Id="3321" PostHistoryTypeId="2" PostId="1163" RevisionGUID="6d622073-8300-4c60-9cef-a7e2aba3a4a2" CreationDate="2014-03-06T01:47:30.947" UserId="514" Text="So I've got a waveform that's high for 16ms and low for 2ms repeating forever. I need to recreate that and offsets of that waveform time exactly on a different pin. Right now, I've got an interrupt on the rising edge for the 16ms low/high transistion, and delayMicroseconds() that determines the offset and duration of the high and low pulses. Trouble is, I'm not sure the code I have is as fast and accurate as it could be. And the replicated waveform seems to shift through the full period of the original one. I need it to be locked in.Any suggestions?&#xD;&#xA;Here is the code:&#xD;&#xA;&#xD;&#xA;   &#xD;&#xA;&#xD;&#xA;     //3 is interrupt for Timing&#xD;&#xA;    //4 through 11 are Time dependent receivers&#xD;&#xA;    //3-11 Pins 12-19&#xD;&#xA;    char incomingByte = 0;&#xD;&#xA;    &#xD;&#xA;    int pins[9] =&#xD;&#xA;    {&#xD;&#xA;      3,4,5,6,7,8,9,10,11&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    void timing()&#xD;&#xA;    {&#xD;&#xA;      //Serial.println(&quot;This is a 0ms Event&quot;);&#xD;&#xA;     // if(Serial.available() &gt; 0)&#xD;&#xA;     // {&#xD;&#xA;        incomingByte = Serial.read();&#xD;&#xA;        Serial.print(&quot;I received&quot;);&#xD;&#xA;        Serial.println(incomingByte);&#xD;&#xA;    &#xD;&#xA;         pinMode(10, OUTPUT);&#xD;&#xA;         digitalWrite(10, HIGH);&#xD;&#xA;         delayMicroseconds(16000);&#xD;&#xA;          digitalWrite(10, LOW);&#xD;&#xA;          delayMicroseconds(2000);&#xD;&#xA;          digitalWrite(10, HIGH);&#xD;&#xA;     }&#xD;&#xA;    //}&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      // put your setup code here, to run once:&#xD;&#xA;    &#xD;&#xA;    for(int i=0;i&lt;8;i++)&#xD;&#xA;    {&#xD;&#xA;      pinMode(pins[i], INPUT);&#xD;&#xA;    }&#xD;&#xA;    pinMode(3,INPUT);&#xD;&#xA;    attachInterrupt(1,timing,RISING);&#xD;&#xA;    &#xD;&#xA;    //Begins Serial&#xD;&#xA;    Serial.begin(115200);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      // put your main code here, to run repeatedly:&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Here's the waveform I'm trying to duplicate:&#xD;&#xA;&#xD;&#xA;![Desired Waveform][1]&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/dkxhW.png" />
  <row Id="3322" PostHistoryTypeId="1" PostId="1163" RevisionGUID="6d622073-8300-4c60-9cef-a7e2aba3a4a2" CreationDate="2014-03-06T01:47:30.947" UserId="514" Text="Replicate a Waveform Exactly with An Arduino Uno" />
  <row Id="3323" PostHistoryTypeId="3" PostId="1163" RevisionGUID="6d622073-8300-4c60-9cef-a7e2aba3a4a2" CreationDate="2014-03-06T01:47:30.947" UserId="514" Text="&lt;c++&gt;&lt;c&gt;&lt;timing&gt;" />
  <row Id="3324" PostHistoryTypeId="5" PostId="1162" RevisionGUID="2cfa2aea-f38f-4599-a999-370ed22c22e8" CreationDate="2014-04-13T21:45:11.517" UserId="84" Comment="added 2 characters in body" Text="I've hooked up two ultrasonic sensors to my breadboard and I also got a 5v motor installed. I also got the diode installed and the usual set up. I can easily control the motor with one sensor. &#xD;&#xA;&#xD;&#xA;But what I'm trying to do is I want the motor to run at let's say 100 once I start it up:&#xD;&#xA;&#xD;&#xA;- The first sensor should be used to slowly slow down the motor when an object is placed in front of it&#xD;&#xA;- The second sensor should be used to slowly speed up the motor when an object is placed in front of it&#xD;&#xA;&#xD;&#xA;**I do not want the speed to return to 100 once the object is removed.** It should remain at the same speed according to which sensor was used. (Tell me if I have to clarify anything in the comments)&#xD;&#xA;&#xD;&#xA;Code&#xD;&#xA;&#xD;&#xA;    int motorPin = 9;&#xD;&#xA;    int trigPin = 13;&#xD;&#xA;    int echoPin = 12;&#xD;&#xA;    int trigPin2 = 5;&#xD;&#xA;    int echoPin2 = 4;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin (9600);&#xD;&#xA;      pinMode(trigPin, OUTPUT);&#xD;&#xA;      pinMode(echoPin, INPUT);&#xD;&#xA;      pinMode(trigPin2, OUTPUT);&#xD;&#xA;      pinMode(echoPin2, INPUT);&#xD;&#xA;      pinMode(motorPin, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      int duration, distance;&#xD;&#xA;      digitalWrite (trigPin, HIGH);&#xD;&#xA;      delayMicroseconds (1000);&#xD;&#xA;      digitalWrite (trigPin, LOW);&#xD;&#xA;      duration = pulseIn (echoPin, HIGH);&#xD;&#xA;      distance = (duration/2) / 29.1;&#xD;&#xA;      if (distance &lt; 20) {  // Distance from sensor&#xD;&#xA;        analogWrite (motorPin, 50);&#xD;&#xA;      } else {&#xD;&#xA;        int duration, distance;&#xD;&#xA;        digitalWrite (trigPin2, HIGH);&#xD;&#xA;        delayMicroseconds (1000);&#xD;&#xA;        digitalWrite (trigPin2, LOW);&#xD;&#xA;        duration = pulseIn (echoPin2, HIGH);&#xD;&#xA;        distance = (duration/2) / 29.1;&#xD;&#xA;        if (distance &gt; 20) {  // Distance from sensor&#xD;&#xA;          analogWrite (motorPin, 150);&#xD;&#xA;        }&#xD;&#xA;        if  (distance &gt; 20) {  // Distance from sensor&#xD;&#xA;          Serial.println(&quot;Out of range&quot;);&#xD;&#xA;        } else {&#xD;&#xA;          Serial.print(distance);&#xD;&#xA;         Serial.println(&quot; cm&quot;);&#xD;&#xA;        }&#xD;&#xA;        delay(500);&#xD;&#xA;      }&#xD;&#xA;    }" />
  <row Id="3325" PostHistoryTypeId="2" PostId="1164" RevisionGUID="f6eac64c-9cb1-4e11-a358-99258a44dbce" CreationDate="2014-04-13T22:41:21.080" UserId="220" Text="This is *very* simple using the **[`map()` instruction](http://arduino.cc/en/reference/map).** Here's the code you would use (feel free to modify values:&#xD;&#xA;&#xD;&#xA;    int speed = 112 + map(distance_1, 0, 20, 0, 112) - map(distance_1, 0, 20, 0, 112);&#xD;&#xA;&#xD;&#xA;So if both sensors gave equal values, they would offset each other. To make it still work if an object is removed, you could just use the last `distance_1`/`distance_2` value and update the other.&#xD;&#xA;****&#xD;&#xA;One issue with this approach is, if the line of transformation of the object is *not* perpendicular to the line of the pings, the value will go:&#xD;&#xA;&gt; 10 → 11 → 12 → 13 → 14 → 15 → 16 → 17 → 18 → 19 → 20 → [Out of range]&#xD;&#xA;&#xD;&#xA;**I've added some pretty animations to show you what I mean:**&#xD;&#xA;&#xD;&#xA;Perpendicular:&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://i.stack.imgur.com/jmOp6.gif&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&#xD;&#xA;&#xD;&#xA;Collinear:&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://i.stack.imgur.com/tnk9M.gif&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;[Will add code in a bit]" />
  <row Id="3326" PostHistoryTypeId="5" PostId="1164" RevisionGUID="7710a72c-52d8-4f16-b6e8-6190e7fa4e5e" CreationDate="2014-04-13T22:57:47.890" UserId="220" Comment="Fixed Minor issues/added code" Text="This is *very* simple using the **[`map()` instruction](http://arduino.cc/en/reference/map).** Here's the code you would use (feel free to modify values:&#xD;&#xA;&#xD;&#xA;    int speed = 112 + map(distance, 0, 20, 0, 112) - map(distance2, 0, 20, 0, 112);&#xD;&#xA;&#xD;&#xA;So if both sensors gave equal values, they would offset each other. To make it still work if an object is removed, you could just use the last `distance`/`distance_2` value and update the other.&#xD;&#xA;****&#xD;&#xA;One issue with this approach is, if the line of transformation of the object is *not* perpendicular to the line of the pings, the value will go:&#xD;&#xA;&gt; 10 → 11 → 12 → 13 → 14 → 15 → 16 → 17 → 18 → 19 → 20 → [Out of range]&#xD;&#xA;&#xD;&#xA;**I've added some pretty animations to show you what I mean:**&#xD;&#xA;&#xD;&#xA;Perpendicular:&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://i.stack.imgur.com/jmOp6.gif&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&#xD;&#xA;&#xD;&#xA;Collinear:&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://i.stack.imgur.com/tnk9M.gif&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&#xD;&#xA;****&#xD;&#xA;As I understand, this is what you want:&#xD;&#xA;&#xD;&#xA;    int motorPin = 9;&#xD;&#xA;    int trigPin = 13;&#xD;&#xA;    int echoPin = 12;&#xD;&#xA;    int trigPin2 = 5;&#xD;&#xA;    int echoPin2 = 4;&#xD;&#xA;    int postdist = 112;&#xD;&#xA;    int postdist2 = 112;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin (9600);&#xD;&#xA;      pinMode(trigPin, OUTPUT);&#xD;&#xA;      pinMode(echoPin, INPUT);&#xD;&#xA;      pinMode(trigPin2, OUTPUT);&#xD;&#xA;      pinMode(echoPin2, INPUT);&#xD;&#xA;      pinMode(motorPin, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      //First Read&#xD;&#xA;      int duration, distance;&#xD;&#xA;      digitalWrite (trigPin, HIGH);&#xD;&#xA;      delayMicroseconds (1000);&#xD;&#xA;      digitalWrite (trigPin, LOW);&#xD;&#xA;      duration = pulseIn (echoPin, HIGH);&#xD;&#xA;      distance = (duration/2) / 29.1;&#xD;&#xA;      if (distance &gt; 20) {  // Distance from sensor&#xD;&#xA;        Serial.println(&quot;Out of range&quot;);&#xD;&#xA;        distance = postdist;&#xD;&#xA;      }&#xD;&#xA;      //Second Read&#xD;&#xA;      int duration2, distance2;&#xD;&#xA;      digitalWrite (trigPin2, HIGH);&#xD;&#xA;      delayMicroseconds (1000);&#xD;&#xA;      digitalWrite (trigPin2, LOW);&#xD;&#xA;      duration2 = pulseIn (echoPin2, HIGH);&#xD;&#xA;      distance2 = (duration2/2) / 29.1;&#xD;&#xA;      if (distance2 &gt; 20) {  // Distance from sensor&#xD;&#xA;        Serial.println(&quot;Out of range&quot;);&#xD;&#xA;        distance2 = postdist2;&#xD;&#xA;      }&#xD;&#xA;      //Math:&#xD;&#xA;      Serial.print(&quot;Distances-1: &quot;);&#xD;&#xA;      Serial.print(distance);&#xD;&#xA;      Serial.print(&quot; cm 2: &quot;);&#xD;&#xA;      Serial.print(&quot;Distances-1: &quot;);&#xD;&#xA;      Serial.print(distance2);&#xD;&#xA;      Serial.println(&quot; cm&quot;);&#xD;&#xA;      int speed = 112 + map(distance, 0, 20, 0, 112) - map(distance2, 0, 20, 0, 112); &#xD;&#xA;      analogWrite (motorPin, speed);&#xD;&#xA;      Serial.print(&quot;Motor Speed: &quot;);&#xD;&#xA;      Serial.println(speed);&#xD;&#xA;      delay(500);&#xD;&#xA;    }" />
  <row Id="3327" PostHistoryTypeId="2" PostId="1165" RevisionGUID="fe3a809e-8039-4fd6-9de5-9504ae456f10" CreationDate="2014-04-14T09:06:20.167" UserId="62" Text="If you're looking to speed your code up I would recommend not using `digitalWrite` or `Serial`. When using digitalWrite it can take quite a few unneeded clock cycles to turn the pin on or off, as a replacement I would suggest looking into using [port manipulation][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Example of turning a pin on or off with a preprocessor macro using port manipulation&#xD;&#xA;&#xD;&#xA;    #define DIGITAL_WRITE_10_HIGH() PORTB = PORTB | B00000100     // Town ON only pin 10&#xD;&#xA;    #define DIGITAL_WRITE_10_LOW() PORTB = PORTB &amp; ~B00000100     // Turn OFF only pin 10&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Using port manipulation in your code:&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #define DIGITAL_WRITE_10_HIGH() PORTB = PORTB | B00000100     // Town ON only pin 10&#xD;&#xA;    #define DIGITAL_WRITE_10_LOW() PORTB = PORTB &amp; ~B00000100     // Turn OFF only pin 10&#xD;&#xA;&#xD;&#xA;    void timing()&#xD;&#xA;    {&#xD;&#xA;        //incomingByte = Serial.read(); // If needed uncomment, but it's slow&#xD;&#xA;        //Serial.println(incomingByte); // If needed uncomment, but it's slow&#xD;&#xA;&#xD;&#xA;         // Set pinMode in setup()    &#xD;&#xA;         DIGITAL_WRITE_10_HIGH();&#xD;&#xA;         delayMicroseconds(16000);&#xD;&#xA;         DIGITAL_WRITE_10_LOW();&#xD;&#xA;         delayMicroseconds(2000);&#xD;&#xA;         DIGITAL_WRITE_10_HIGH();&#xD;&#xA;     }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/PortManipulation" />
  <row Id="3328" PostHistoryTypeId="2" PostId="1166" RevisionGUID="91b0e2cc-0722-43c3-82c1-a22215af2567" CreationDate="2014-04-14T09:08:21.907" UserId="643" Text="This code is wrong in many ways.&#xD;&#xA;&#xD;&#xA;first of all, `timing()` is execute inside an interrupt, this mean that while it is running, all other interrupt and timer stop (delayMicroseconds works because it does not rely on timer, but on know instruction execution time). That mean you have to keep the interrupt funzion faster as possible, or bad things may and will happen. (microsec&#xD;&#xA;&#xD;&#xA;For example, Serial is interrupt driven; this may cause a race condition that will freeze the code.&#xD;&#xA;&#xD;&#xA;As far as i can understand pin 3 may be a button (in that case you need to apply some antibounce code, just look at the signal create by pressing a button with your oscilloscope to see what happen), so you can just make a digitalRead every loop, if true do your code. So you will keep `timing()` out of interrupt.&#xD;&#xA;&#xD;&#xA;pinMode() can be setted only one time, in setup(), and also digitalRead is really slow: operating directly on the register is a lot faster! see [port manipulation][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;but in your case i would delete all precendent code and do some math to use an ad-hoc PWM, so you will be almost code free and because it will be almost all done by hardware, precision and possible granularity will increase, see [secret of arduino PWM][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/PortManipulation&#xD;&#xA;  [2]: http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM" />
  <row Id="3329" PostHistoryTypeId="5" PostId="1166" RevisionGUID="139b8fdf-624f-4a0a-b7d7-f4a899be22a4" CreationDate="2014-04-14T09:15:17.067" UserId="643" Comment="added 73 characters in body" Text="This code is wrong in many ways.&#xD;&#xA;&#xD;&#xA;first of all, `timing()` is execute inside an interrupt, this mean that while it is running, all other interrupt and timer stop (delayMicroseconds works because it does not rely on timer, but on know instruction execution time). That mean you have to keep the interrupt funzion faster as possible, or bad things may and will happen. (microseconds still work because it is based on know instruction duration in loop)&#xD;&#xA;&#xD;&#xA;For example, Serial is interrupt driven; this may cause a race condition that will freeze the code.&#xD;&#xA;&#xD;&#xA;As far as i can understand pin 3 may be a button (in that case you need to apply some antibounce code, just look at the signal create by pressing a button with your oscilloscope to see what happen), so you can just make a digitalRead every loop, if true do your code. So you will keep `timing()` out of interrupt.&#xD;&#xA;&#xD;&#xA;pinMode() can be setted only one time, in setup(), and also digitalRead is really slow: operating directly on the register is a lot faster! see [port manipulation][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;but in your case i would delete all precendent code and do some math to use an ad-hoc PWM, so you will be almost code free and because it will be almost all done by hardware, precision and possible granularity will increase, see [secret of arduino PWM][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/PortManipulation&#xD;&#xA;  [2]: http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM" />
  <row Id="3330" PostHistoryTypeId="5" PostId="1166" RevisionGUID="489eab44-e1cb-421b-ad09-23259e8a306e" CreationDate="2014-04-14T09:25:06.237" UserId="42" Comment="Corrected a sentence based on discussion in comments, and made some formatting improvements." Text="This code is wrong in many ways.&#xD;&#xA;&#xD;&#xA;first of all, `timing()` is execute inside an interrupt, this mean that while it is running, all other interrupt and timer stop (delayMicroseconds works because it does not rely on timer, but on know instruction execution time). That mean you have to keep the interrupt funzion faster as possible, or bad things may and will happen. (microseconds still work because it is based on know instruction duration in loop)&#xD;&#xA;&#xD;&#xA;For example, Serial is interrupt driven; this may cause a race condition that will freeze the code.&#xD;&#xA;&#xD;&#xA;As far as i can understand pin 3 may be a button (in that case you need to apply some antibounce code, just look at the signal create by pressing a button with your oscilloscope to see what happen), so you can just make a digitalRead every loop, if true do your code. So you will keep `timing()` out of interrupt.&#xD;&#xA;&#xD;&#xA;`pinMode()` only needs to be set once, in `setup()`. Also, `digitalRead()` is really slow: operating directly on the register is a lot faster! see [port manipulation][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;but in your case i would delete all precendent code and do some math to use an ad-hoc PWM, so you will be almost code free and because it will be almost all done by hardware, precision and possible granularity will increase, see [secret of arduino PWM][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/PortManipulation&#xD;&#xA;  [2]: http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM" />
  <row Id="3331" PostHistoryTypeId="2" PostId="1167" RevisionGUID="423ea8c1-dbca-4781-8371-c1bdbd65a490" CreationDate="2014-04-14T09:56:23.033" UserId="1039" Text="I'm currently trying to build an Arduino robot controlled via a wifi connection. I have an Arduino Mega running as a client and it successfully connects to the server on LAN via the Adafruit cc3000 wifi board. However instead of grabbing the contents of the JSON file and printing it to serial, I'm just getting a 100 continue response. While this means I'm doing something right, I don't know what to do next in order to grab the data I need. Do I need to get the 100 message then respond with the GET request, or is there a way that I can GET the data straight away?&#xD;&#xA;&#xD;&#xA;Thank you all in advance. Here is the Arduino code I have so far:&#xD;&#xA;&#xD;&#xA;    #include &lt;Adafruit_CC3000.h&gt;&#xD;&#xA;    #include &lt;ccspi.h&gt;&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;string.h&gt;&#xD;&#xA;    #include &quot;utility/debug.h&quot;&#xD;&#xA;    #include &lt;stdlib.h&gt;&#xD;&#xA;&#xD;&#xA;    // These are the interrupt and control pins&#xD;&#xA;    #define ADAFRUIT_CC3000_IRQ 3  // MUST be an interrupt pin!&#xD;&#xA;    #define ADAFRUIT_CC3000_VBAT 5 // Apparently these can be any two pins&#xD;&#xA;    #define ADAFRUIT_CC3000_CS 10  // But I wouldn't change these...&#xD;&#xA;    // Use hardware SPI for the remaining pins (On a Mega 2560, SCK = 52, MISO = 50, and MOSI = 51)&#xD;&#xA;    Adafruit_CC3000 cc3000 = Adafruit_CC3000(ADAFRUIT_CC3000_CS, ADAFRUIT_CC3000_IRQ, ADAFRUIT_CC3000_VBAT, SPI_CLOCK_DIV2);&#xD;&#xA;&#xD;&#xA;    #define WLAN_SSID &quot;VM540258-2G&quot;&#xD;&#xA;    #define WLAN_PASS &quot;XXXXXXXX&quot;&#xD;&#xA;    #define WLAN_SECURITY WLAN_SEC_WPA2&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    String readString = String(100); //string for fetching data from address&#xD;&#xA;    uint32_t ip = 3232235523; // This translates into the ip address we need&#xD;&#xA;                              // 323223552X; 192.168.0.X&#xD;&#xA;&#xD;&#xA;    void setup(){&#xD;&#xA;      Serial.begin(115200); //Can also work at 9600&#xD;&#xA;&#xD;&#xA;      //Initialise CC3000 module&#xD;&#xA;      Serial.println(F(&quot;\nInitializing CC3000...&quot;));&#xD;&#xA;      if (!cc3000.begin())&#xD;&#xA;      {&#xD;&#xA;        Serial.println(F(&quot;Couldn't begin()! Check your wiring?&quot;));&#xD;&#xA;        while(1);&#xD;&#xA;      }&#xD;&#xA;      //Connect to the Wireless Access Point&#xD;&#xA;      if (!cc3000.connectToAP(WLAN_SSID, WLAN_PASS, WLAN_SECURITY)) {&#xD;&#xA;        Serial.println(F(&quot;Failed!&quot;));&#xD;&#xA;        while(1);&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      Serial.println(F(&quot;Connected!&quot;));&#xD;&#xA;&#xD;&#xA;      Serial.println(F(&quot;Request DHCP&quot;));&#xD;&#xA;      while (!cc3000.checkDHCP()) { //Obtain IP addeess&#xD;&#xA;        delay(100);&#xD;&#xA;      } &#xD;&#xA;  &#xD;&#xA;      while (! displayConnectionDetails())&#xD;&#xA;      {&#xD;&#xA;        delay(1000);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop(){&#xD;&#xA;      Adafruit_CC3000_Client client = cc3000.connectTCP(ip, 80);&#xD;&#xA;&#xD;&#xA;      if (client.connected()) {&#xD;&#xA;        client.println(&quot;GET /project-test/state.json HTTP/1.0&quot;); //Make a request for state.json&#xD;&#xA;        client.println(&quot;&quot;); //Mandatory blank line?&#xD;&#xA;        if (client.available()){&#xD;&#xA;          char c = client.read();&#xD;&#xA;          Serial.print(c);&#xD;&#xA;          //read char by char HTTP request&#xD;&#xA;          if (readString.length() &lt; 100) {&#xD;&#xA;           //store characters to string &#xD;&#xA;           readString += c;&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      //Once we have obtained the data, disconnect from the server&#xD;&#xA;      client.close();&#xD;&#xA;      Serial.println(readString);&#xD;&#xA;      delay(1000);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    bool displayConnectionDetails(void)&#xD;&#xA;    {&#xD;&#xA;      uint32_t ipAddress, netmask, gateway, dhcpserv, dnsserv;&#xD;&#xA;  &#xD;&#xA;      if(!cc3000.getIPAddress(&amp;ipAddress, &amp;netmask, &amp;gateway, &amp;dhcpserv, &amp;dnsserv))&#xD;&#xA;      {&#xD;&#xA;        Serial.println(F(&quot;Unable to retrieve the IP Address!\r\n&quot;));&#xD;&#xA;        return false;&#xD;&#xA;      }&#xD;&#xA;      else&#xD;&#xA;      {&#xD;&#xA;        Serial.print(F(&quot;\nIP Addr: &quot;)); cc3000.printIPdotsRev(ipAddress);&#xD;&#xA;        Serial.print(F(&quot;\nNetmask: &quot;)); cc3000.printIPdotsRev(netmask);&#xD;&#xA;        Serial.print(F(&quot;\nGateway: &quot;)); cc3000.printIPdotsRev(gateway);&#xD;&#xA;        Serial.print(F(&quot;\nDHCPsrv: &quot;)); cc3000.printIPdotsRev(dhcpserv);&#xD;&#xA;        Serial.print(F(&quot;\nDNSserv: &quot;)); cc3000.printIPdotsRev(dnsserv);&#xD;&#xA;        Serial.println();&#xD;&#xA;        return true;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The initial JSON file I'm using contains the following:&#xD;&#xA;&#xD;&#xA;    {&quot;speed_left&quot;:null,&quot;speed_right&quot;:null,&quot;direction_left&quot;:null,&quot;direction_right&quot;:null}&#xD;&#xA;&#xD;&#xA;And the serial output I get when I run the Sketch:&#xD;&#xA;&#xD;&#xA;    Initializing CC3000...&#xD;&#xA;    Started AP/SSID scan&#xD;&#xA;&#xD;&#xA;    Connecting to VM540258-2G...Waiting to connect...Connected!&#xD;&#xA;    Request DHCP&#xD;&#xA;&#xD;&#xA;    IP Addr: 192.168.0.7&#xD;&#xA;    Netmask: 255.255.255.0&#xD;&#xA;    Gateway: 192.168.0.1&#xD;&#xA;    DHCPsrv: 192.168.0.1&#xD;&#xA;    DNSserv: 192.168.0.1&#xD;&#xA;&#xD;&#xA;    Connect to 192.168.0.3:80&#xD;&#xA;    100&#xD;&#xA;&#xD;&#xA;    Connect to 192.168.0.3:80&#xD;&#xA;    100&#xD;&#xA;ad infinitum" />
  <row Id="3332" PostHistoryTypeId="1" PostId="1167" RevisionGUID="423ea8c1-dbca-4781-8371-c1bdbd65a490" CreationDate="2014-04-14T09:56:23.033" UserId="1039" Text="TCP communication between Arduino client and server" />
  <row Id="3333" PostHistoryTypeId="3" PostId="1167" RevisionGUID="423ea8c1-dbca-4781-8371-c1bdbd65a490" CreationDate="2014-04-14T09:56:23.033" UserId="1039" Text="&lt;arduino-mega&gt;&lt;tcpip&gt;" />
  <row Id="3334" PostHistoryTypeId="2" PostId="1168" RevisionGUID="67d61404-b5af-4987-b0b9-22515cee00e3" CreationDate="2014-04-14T10:37:38.250" UserId="27" Text="Arduino Yun ships with python pre installed. You can copy python scripts from your pc to the yun with `scp` (or WinSCP or `putty`, if you're on windows). Once copied, just run it using Process from your sketch. As they are scripts, program name is `python` and the path to your script is its first argument (you can do that in a different way, but that would require some linux magic, which I suggest to postpone if you're new to it).&#xD;&#xA;&#xD;&#xA;Other pre installed options include [lua][1] and bash. Other languages such as ruby, erlang and php are available as optional packages.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.lua.org/" />
  <row Id="3335" PostHistoryTypeId="2" PostId="1169" RevisionGUID="0209c5f4-72ee-4222-99da-9e9c8ec6e45d" CreationDate="2014-04-14T12:31:17.287" UserId="643" Text="from the IDE's menu you can activate the verbose upload (and compile) mode, that will print all the command executed; Probabibly what you miss is the necessity to open the serial at 1200baud, that will trigger the reboot and consequent bootloader's start ont DUE chip, and bossac need to find the bootloader. see [autoReset][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Guide/ArduinoDue#toc4" />
  <row Id="3336" PostHistoryTypeId="5" PostId="873" RevisionGUID="0546a41d-f8a4-4690-930a-c8c3e6820e21" CreationDate="2014-04-14T12:58:18.287" UserId="510" Comment="Copy edited." Text="Using an [Arduino Nano][1] and a [current transformer ][2] (CT), I'm trying to sense the current flowing through a 120&amp;nbsp;V 60&amp;nbsp;Hz line.&#xD;&#xA;&#xD;&#xA;**Circuit**&#xD;&#xA;&#xD;&#xA;CT outputs `0-1&amp;nbsp;V` according to its specifications. This output is biased `AREF/2` = 2.5&amp;nbsp;V.&#xD;&#xA;&#xD;&#xA;![Enter image description here][3]&#xD;&#xA;&#xD;&#xA;**`analogRead` Values**&#xD;&#xA;&#xD;&#xA;The x-axis represents the index number of the ADC sample, while the y-axis represent the ADC value (0-1024). Sampling rate is about 9&amp;nbsp;kHz. Peak-to-peak difference is about 1026 samples.&#xD;&#xA;&#xD;&#xA;![Enter image description here][4]&#xD;&#xA;&#xD;&#xA;Is this waveform what you would expect from the CT? Why are there regions where the values are flat, rather than varying continuously?&#xD;&#xA;&#xD;&#xA;Furthermore, if we look at the curve part of the plot, why is Arduino reading values both above `512` and below `512` alternately? It reads a value above `512`, then a value below `512`, then a value above `512` and so on.&#xD;&#xA;&#xD;&#xA;Time taken for an `analogRead` was measured to be 110 microseconds for my setup and there are 1026 samples between the waveform peaks. That means there will be about 9 peaks in 1 second, although I would expect 60 peaks since we are sensing a 60&amp;nbsp;Hz line. What do you make out of this? There's a capacitor, `C1`, in the circuit, would it have anything to do with this?&#xD;&#xA;&#xD;&#xA;Are these analogRead values suitable to be used to calculate the RMS voltage, and hence the RMS current passing through the wire being sensed? The final goal of this is to calculate the power usage after determining the RMS current flowing through the wire.&#xD;&#xA;&#xD;&#xA;**[Sketch][5] used to get values for plot**&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;       double sensorValue = analogRead(1);&#xD;&#xA;       Serial.println(sensorValue)&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Actual `analogRead` data points in the bump regions**&#xD;&#xA;&#xD;&#xA;    487&#xD;&#xA;    534&#xD;&#xA;    487&#xD;&#xA;    535&#xD;&#xA;    488&#xD;&#xA;    537&#xD;&#xA;    484&#xD;&#xA;    536&#xD;&#xA;    487&#xD;&#xA;    538&#xD;&#xA;    486&#xD;&#xA;    536&#xD;&#xA;    484&#xD;&#xA;    540&#xD;&#xA;    484&#xD;&#xA;    539&#xD;&#xA;    485&#xD;&#xA;    540&#xD;&#xA;    483&#xD;&#xA;    540&#xD;&#xA;    484&#xD;&#xA;    541&#xD;&#xA;    481&#xD;&#xA;    539&#xD;&#xA;    481&#xD;&#xA;    540&#xD;&#xA;    484&#xD;&#xA;    540&#xD;&#xA;    480&#xD;&#xA;    543&#xD;&#xA;    484&#xD;&#xA;    539&#xD;&#xA;    481&#xD;&#xA;    540&#xD;&#xA;    484&#xD;&#xA;    541&#xD;&#xA;    486&#xD;&#xA;    542&#xD;&#xA;    485&#xD;&#xA;    538&#xD;&#xA;    485&#xD;&#xA;    538&#xD;&#xA;    488&#xD;&#xA;    535&#xD;&#xA;    489&#xD;&#xA;    534&#xD;&#xA;    491&#xD;&#xA;    530&#xD;&#xA;    491&#xD;&#xA;    529&#xD;&#xA;    493&#xD;&#xA;    531&#xD;&#xA;    492&#xD;&#xA;    526&#xD;&#xA;    498&#xD;&#xA;    526&#xD;&#xA;    499&#xD;&#xA;    524&#xD;&#xA;    499&#xD;&#xA;    520&#xD;&#xA;    503&#xD;&#xA;    518&#xD;&#xA;    502&#xD;&#xA;    518&#xD;&#xA;    507&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;**Plot of analogRead values**&#xD;&#xA;&#xD;&#xA;The analogRead values are now stored in a buffer before being transmitted over Serial. There are now 55 ADC datapoints making up 1 period. Considering the analogRead time is 110&amp;nbsp;µs, each cycle takes 6.05&amp;nbsp;ms, giving us a frequency of 165&amp;nbsp;Hz! What may have gone wrong?&#xD;&#xA;&#xD;&#xA;![Enter image description here][6]&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;        double sensorValue = analogRead(1);&#xD;&#xA;        char buf[32];&#xD;&#xA;&#xD;&#xA;        dtostrf(sensorValue, 8, 2, buf);&#xD;&#xA;        value = buf;&#xD;&#xA;&#xD;&#xA;        if (stop == 0) {&#xD;&#xA;            if (i &lt; 10000) {&#xD;&#xA;                message += ',';&#xD;&#xA;                message += value;&#xD;&#xA;                i++;&#xD;&#xA;            }&#xD;&#xA;            else {&#xD;&#xA;                stop = 1;&#xD;&#xA;                Serial.println(message);&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardNano&#xD;&#xA;  [2]: http://www.seeedstudio.com/depot/Noninvasive-AC-Current-Sensor-30A-max-p-519.html&#xD;&#xA;  [3]: http://i.stack.imgur.com/tgpsQ.png&#xD;&#xA;  [4]: http://i.stack.imgur.com/2Gdcc.png&#xD;&#xA;  [5]: http://www.arduino.cc/en/Tutorial/Sketch&#xD;&#xA;  [6]: http://i.stack.imgur.com/Wjw7T.png&#xD;&#xA;" />
  <row Id="3337" PostHistoryTypeId="24" PostId="873" RevisionGUID="0546a41d-f8a4-4690-930a-c8c3e6820e21" CreationDate="2014-04-14T12:58:18.287" Comment="Proposed by 510 approved by 46, 8 edit id of 284" />
  <row Id="3338" PostHistoryTypeId="2" PostId="1170" RevisionGUID="ee799e5c-25c1-4134-8c1e-7195311fbb33" CreationDate="2014-04-14T13:05:08.177" UserId="643" Text="there are varius calculation.&#xD;&#xA;&#xD;&#xA;At the end of the day, if take a point in every position (under no acceleration), you should end up with a sphere, or matematically speacking, wthe lenght of the vector should be equal to gravity, so `sqrt(x*x+y*y+z*z) = G` or, to do less computing `x*x+y*y+z*z = G*G` (same apply for magnetometer, but using local magnetic force, or gyroscope, using a know-speed rotation like a LP player)&#xD;&#xA;&#xD;&#xA;To create that spere you have to take many point, and find a multiplicator (or function) for each axes. That is particualary important when one axes has differnet precision of others, you are `linearizing` the axis output, and then `normalizig` its value relative to others axes.&#xD;&#xA;&#xD;&#xA;Once you have corrected the vector lenght to have a spere, you should look at the offset of the sphere; if its `center` point is not on the `origin` point 0,0,0 then the differece between `center` and `origin` is the correction you talk about. This is offset correction.&#xD;&#xA;&#xD;&#xA;Also many (well, all) sensor are affected on their temperature; many claim to be &quot;thermocompensated&quot;, that means this difference is less evident due to some some sort of hardware and/or software filtering." />
  <row Id="3339" PostHistoryTypeId="2" PostId="1171" RevisionGUID="44f63ffe-68f9-4aec-a452-82afddaba48e" CreationDate="2014-04-14T13:08:05.297" UserId="643" Text="you are missing the `HOST` header in the request, so the server tell you to `100 CONTINUE` you request.&#xD;&#xA;Also yes, the final empty row IS mandatory&#xD;&#xA;&#xD;&#xA;for example, to ask `www.example.com/index.html`&#xD;&#xA;&#xD;&#xA;    GET /index.html HTTP/1.1&#xD;&#xA;    Host: www.example.com&#xD;&#xA;    " />
  <row Id="3340" PostHistoryTypeId="2" PostId="1172" RevisionGUID="b6b988a6-75de-41f1-bb80-36ff4d3235f6" CreationDate="2014-04-14T13:21:26.257" UserId="8" Text="To get rid of the fluctuation, you could always try a moving average. It isn't hard to modify the `Smoothing` example (under `File-&gt;Examples-&gt;1. Analog-&gt;Smoothing`) to accept accelerometer values.&#xD;&#xA;&#xD;&#xA;As for the slight offset in the X &amp; Y values, that is probably because your sensor isn't sitting perfectly flat." />
  <row Id="3344" PostHistoryTypeId="5" PostId="1169" RevisionGUID="1ecefa91-332e-4595-8932-1ac0f3900ed4" CreationDate="2014-04-14T19:19:06.263" UserId="643" Comment="added 603 characters in body" Text="from the IDE's menu you can activate the verbose upload (and compile) mode, that will print all the command executed; Probabibly what you miss is the necessity to open the serial at 1200baud, that will trigger the reboot and consequent bootloader's start ont DUE chip, and bossac need to find the bootloader. see [autoReset][1]&#xD;&#xA;&#xD;&#xA;edit: i've now a pc with a physical Serial, so i've tryed to upload in verbose mode:&#xD;&#xA;&#xD;&#xA;    Sketch uses 10,380 bytes (1%) of program storage space. Maximum is 524,288 bytes.&#xD;&#xA;    Forcing reset using 1200bps open/close on port /dev/ttyS0&#xD;&#xA;    /home/xxx/arduino-1.5.6-r2/hardware/tools/bossac -i -d --port=ttyS0 -U false -e -w -v -b /tmp/build8035422101690460839.tmp/sketch_apr14a.cpp.bin -R &#xD;&#xA;as you can see he is resetting the board by opening the serial at 1200, forcing the bootloader to start. You have to do the same on your script befor launching bossac. How this can be done depends on your OS&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Guide/ArduinoDue#toc4" />
  <row Id="3345" PostHistoryTypeId="2" PostId="1174" RevisionGUID="8a4c26c8-0162-4d1f-a427-b7ce0d465065" CreationDate="2014-04-14T21:24:23.377" UserId="150" Text="I'm going to guess that it's a problem with your server not expecting an HTTP/1.0 request.  I note the following from RFC 1945 about the response codes:&#xD;&#xA;&#xD;&#xA;&gt; 9.1  Informational 1xx&#xD;&#xA;&gt;&#xD;&#xA;&gt;   This class of status code indicates a provisional response,&#xD;&#xA;&gt;   consisting only of the Status-Line and optional headers, and is&#xD;&#xA;&gt;   terminated by an empty line. HTTP/1.0 does not define any 1xx status&#xD;&#xA;&gt;   codes and they are not a valid response to a HTTP/1.0 request.&#xD;&#xA;&gt;   However, they may be useful for experimental applications which are&#xD;&#xA;&gt;   outside the scope of this specification.&#xD;&#xA;&#xD;&#xA;I'd recommend changing your request to be HTTP/1.1 compliant (with a Host: header as suggested by @lesto)&#xD;&#xA; " />
  <row Id="3346" PostHistoryTypeId="2" PostId="1175" RevisionGUID="b3a032b5-2c4d-42bb-bc21-1caf4d486b8c" CreationDate="2014-04-14T21:28:08.817" UserId="150" Text="Okay, I have a better answer, again done without testing.&#xD;&#xA;&#xD;&#xA;If I look at the BNF for an HTTP-message from the RFC, it indicates that the message body is terminated by a blank line. &#xD;&#xA;&#xD;&#xA;So, you actually need 2 CRLFs (i.e. 2 blank lines).  The first one separates the headers from the body of the HTTP request.  You don't actually have a message body (which is fine, it is optional).  But, you'll need another CRLF to terminate the (blank) body.  &#xD;&#xA;&#xD;&#xA;Since you only sent one blank line, the server is sending you the continue status codes, prompting you to finish sending your message (i.e. the message body).&#xD;&#xA;&#xD;&#xA;So, try adding another client.println(&quot;&quot;); " />
  <row Id="3347" PostHistoryTypeId="2" PostId="1176" RevisionGUID="caa25bed-9463-4dc6-afc6-469c4f1da97d" CreationDate="2014-04-15T05:02:06.587" UserId="1051" Text="I want to make a simple circuit which returns the time/delay between two, consecutive loud sounds (i.e, a mic reading of ~600) coming from a speaker. I have set up and ADMP 401 microphone for this purpose. How do I measure the time it takes for this application?" />
  <row Id="3348" PostHistoryTypeId="1" PostId="1176" RevisionGUID="caa25bed-9463-4dc6-afc6-469c4f1da97d" CreationDate="2014-04-15T05:02:06.587" UserId="1051" Text="How do I use the timers on an Arduino Uno R3?" />
  <row Id="3349" PostHistoryTypeId="3" PostId="1176" RevisionGUID="caa25bed-9463-4dc6-afc6-469c4f1da97d" CreationDate="2014-04-15T05:02:06.587" UserId="1051" Text="&lt;arduino-uno&gt;&lt;timers&gt;" />
  <row Id="3350" PostHistoryTypeId="36" PostId="1177" RevisionGUID="32966b72-87ad-49f1-9811-a373028c21b2" CreationDate="2014-04-15T05:05:06.293" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/106604/connection-problem-with-arduino-mega-2560-and-gsm-shield-official-m10" />
  <row Id="3351" PostHistoryTypeId="2" PostId="1177" RevisionGUID="21c2c807-64a1-4ee9-9b95-c470edd8a54c" CreationDate="2014-04-15T02:10:34.543" UserId="1049" Text="As I don't want to stack the shield over the mega 2560 board, I try to connect only the pins that used for GSM communication. Here are my connection:&#xD;&#xA;&#xD;&#xA;Pin 3 on Mega &lt;==&gt; Pin GSM Rx on Shield&#xD;&#xA;&#xD;&#xA;Pin 10 on Mega &lt;==&gt; Pin GSM Tx on Shield&#xD;&#xA;&#xD;&#xA;Pin 4 on Mega &lt;==&gt; Pin 4 on Shield&#xD;&#xA;&#xD;&#xA;Pin 5V on Mega &lt;==&gt; Pin Vin on Shield&#xD;&#xA;&#xD;&#xA;Pin GRD on Mega &lt;==&gt; Pin GRD on Shield&#xD;&#xA;&#xD;&#xA;Code I used is from the Examples library, GsmScanNetworks:&#xD;&#xA;&#xD;&#xA;    #include &lt;GSM.h&gt;&#xD;&#xA;&#xD;&#xA;    // PIN Number&#xD;&#xA;    #define PINNUMBER &quot;8888&quot;&#xD;&#xA;&#xD;&#xA;    // initialize the library instance&#xD;&#xA;    GSM gsmAccess;     // include a 'true' parameter to enable debugging&#xD;&#xA;    GSMScanner scannerNetworks;&#xD;&#xA;    GSMModem modemTest;&#xD;&#xA;&#xD;&#xA;    // Save data variables&#xD;&#xA;    String IMEI = &quot;&quot;;&#xD;&#xA;&#xD;&#xA;    // serial monitor result messages&#xD;&#xA;    String errortext = &quot;ERROR&quot;;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      // initialize serial communications and wait for port to open:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      while (!Serial) {&#xD;&#xA;        ; // wait for serial port to connect. Needed for Leonardo only&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      Serial.println(&quot;GSM networks scanner&quot;);&#xD;&#xA;      scannerNetworks.begin();&#xD;&#xA;  &#xD;&#xA;      // connection state&#xD;&#xA;      boolean notConnected = true;&#xD;&#xA;  &#xD;&#xA;      // Start GSM shield&#xD;&#xA;      // If your SIM has PIN, pass it as a parameter of begin() in quotes&#xD;&#xA;      while(notConnected)&#xD;&#xA;      {&#xD;&#xA;        if(gsmAccess.begin(PINNUMBER)==GSM_READY)&#xD;&#xA;          notConnected = false;&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;          Serial.println(&quot;Not connected&quot;);&#xD;&#xA;          delay(1000);&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;  &#xD;&#xA;      // get modem parameters&#xD;&#xA;      // IMEI, modem unique identifier&#xD;&#xA;      Serial.print(&quot;Modem IMEI: &quot;);&#xD;&#xA;      IMEI = modemTest.getIMEI();&#xD;&#xA;      IMEI.replace(&quot;\n&quot;,&quot;&quot;);&#xD;&#xA;      if(IMEI != NULL)&#xD;&#xA;        Serial.println(IMEI);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      // scan for existing networks, displays a list of networks&#xD;&#xA;      Serial.println(&quot;Scanning available networks. May take some seconds.&quot;);&#xD;&#xA;      Serial.println(scannerNetworks.readNetworks());&#xD;&#xA;  &#xD;&#xA;        // currently connected carrier&#xD;&#xA;      Serial.print(&quot;Current carrier: &quot;);&#xD;&#xA;      Serial.println(scannerNetworks.getCurrentCarrier());&#xD;&#xA;    &#xD;&#xA;      // returns strength and ber&#xD;&#xA;      // signal strength in 0-31 scale. 31 means power &gt; 51dBm&#xD;&#xA;      // BER is the Bit Error Rate. 0-7 scale. 99=not detectable&#xD;&#xA;      Serial.print(&quot;Signal Strength: &quot;);&#xD;&#xA;      Serial.print(scannerNetworks.getSignalStrength());&#xD;&#xA;      Serial.println(&quot; [0-31]&quot;);&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Questions:&#xD;&#xA;&#xD;&#xA; 1. After opening the serial port, only a line &quot;GSM network scanner&quot; is read. Seems that the program is stuck on`gsmAccess.begin(PINNUMBER)`, how shall I fix that?&#xD;&#xA; 2. Is it a must that I shall supply 5V 2A power to the shield seperately in order for the shield to work? (with connection mentioned above, the ON led light on the shield does turns on with an orange light)&#xD;&#xA; 3. For the PINNUMBER defined in the program, my SIM has default PIN 8888. I checked with a mobile phone that the SIM card does work. But my phone shows that the SIM card is not locked with PIN. So shall I define the PIN as 8888 for ''?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3352" PostHistoryTypeId="1" PostId="1177" RevisionGUID="21c2c807-64a1-4ee9-9b95-c470edd8a54c" CreationDate="2014-04-15T02:10:34.543" UserId="1049" Text="Connection problem with Arduino Mega 2560 and GSM shield ( official M10)" />
  <row Id="3353" PostHistoryTypeId="3" PostId="1177" RevisionGUID="21c2c807-64a1-4ee9-9b95-c470edd8a54c" CreationDate="2014-04-15T02:10:34.543" UserId="1049" Text="&lt;untagged&gt;" />
  <row Id="3355" PostHistoryTypeId="6" PostId="1177" RevisionGUID="eede48ef-a88f-4876-9ff3-d100630d62fd" CreationDate="2014-04-15T05:07:27.693" UserId="11" Comment="edited tags" Text="&lt;arduino-mega&gt;&lt;gsm&gt;" />
  <row Id="3356" PostHistoryTypeId="2" PostId="1178" RevisionGUID="0791f789-c46e-4ad9-bd7a-fc744568f007" CreationDate="2014-04-15T06:28:43.203" UserId="904" Text="This is first time programming with Ethernet shield . i want to test web server application with arduino.&#xD;&#xA;&#xD;&#xA;I have arduino uno, Ethernet shield,potentiometer. Below code being uploaded.&#xD;&#xA;Question are:&#xD;&#xA;&#xD;&#xA; **- currently i am using LAN connection to configure. How to configure it. Is internet is required for below application??&#xD;&#xA; - How to check the output??&#xD;&#xA; - is there any software where i can make customised tags&#xD;&#xA; - I have values coming from Serial port to be monitored on webserver. Can someone share how to monitor it**&#xD;&#xA;&#xD;&#xA;[Ethernet sheild][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoEthernetShield&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;Ethernet.h&gt;&#xD;&#xA;    &#xD;&#xA;    // Enter a MAC address and IP address for your controller below.&#xD;&#xA;    // The IP address will be dependent on your local network:&#xD;&#xA;    byte mac[] = { &#xD;&#xA;      0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };&#xD;&#xA;    IPAddress ip(192,168,1,177);&#xD;&#xA;    &#xD;&#xA;    // Initialize the Ethernet server library&#xD;&#xA;    // with the IP address and port you want to use &#xD;&#xA;    // (port 80 is default for HTTP):&#xD;&#xA;    EthernetServer server(80);&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;     // Open serial communications and wait for port to open:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;       while (!Serial) {&#xD;&#xA;        ; // wait for serial port to connect. Needed for Leonardo only&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // start the Ethernet connection and the server:&#xD;&#xA;      Ethernet.begin(mac, ip);&#xD;&#xA;      server.begin();&#xD;&#xA;      Serial.print(&quot;server is at &quot;);&#xD;&#xA;      Serial.println(Ethernet.localIP());&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      // listen for incoming clients&#xD;&#xA;      EthernetClient client = server.available();&#xD;&#xA;      if (client) {&#xD;&#xA;        Serial.println(&quot;new client&quot;);&#xD;&#xA;        // an http request ends with a blank line&#xD;&#xA;        boolean currentLineIsBlank = true;&#xD;&#xA;        while (client.connected()) {&#xD;&#xA;          if (client.available()) {&#xD;&#xA;            char c = client.read();&#xD;&#xA;            Serial.write(c);&#xD;&#xA;            // if you've gotten to the end of the line (received a newline&#xD;&#xA;            // character) and the line is blank, the http request has ended,&#xD;&#xA;            // so you can send a reply&#xD;&#xA;            if (c == '\n' &amp;&amp; currentLineIsBlank) {&#xD;&#xA;              // send a standard http response header&#xD;&#xA;              client.println(&quot;HTTP/1.1 200 OK&quot;);&#xD;&#xA;              client.println(&quot;Content-Type: text/html&quot;);&#xD;&#xA;              client.println(&quot;Connection: close&quot;);  // the connection will be closed after completion of the response&#xD;&#xA;          client.println(&quot;Refresh: 5&quot;);  // refresh the page automatically every 5 sec&#xD;&#xA;              client.println();&#xD;&#xA;              client.println(&quot;&lt;!DOCTYPE HTML&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;html&gt;&quot;);&#xD;&#xA;              // output the value of each analog input pin&#xD;&#xA;              for (int analogChannel = 0; analogChannel &lt; 6; analogChannel++) {&#xD;&#xA;                int sensorReading = analogRead(analogChannel);&#xD;&#xA;                client.print(&quot;analog input &quot;);&#xD;&#xA;                client.print(analogChannel);&#xD;&#xA;                client.print(&quot; is &quot;);&#xD;&#xA;                client.print(sensorReading);&#xD;&#xA;                client.println(&quot;&lt;br /&gt;&quot;);       &#xD;&#xA;              }&#xD;&#xA;              client.println(&quot;&lt;/html&gt;&quot;);&#xD;&#xA;              break;&#xD;&#xA;            }&#xD;&#xA;            if (c == '\n') {&#xD;&#xA;              // you're starting a new line&#xD;&#xA;              currentLineIsBlank = true;&#xD;&#xA;            } &#xD;&#xA;            else if (c != '\r') {&#xD;&#xA;              // you've gotten a character on the current line&#xD;&#xA;              currentLineIsBlank = false;&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;        // give the web browser time to receive the data&#xD;&#xA;        delay(1);&#xD;&#xA;        // close the connection:&#xD;&#xA;        client.stop();&#xD;&#xA;        Serial.println(&quot;client disconnected&quot;);&#xD;&#xA;      }&#xD;&#xA;    }" />
  <row Id="3357" PostHistoryTypeId="1" PostId="1178" RevisionGUID="0791f789-c46e-4ad9-bd7a-fc744568f007" CreationDate="2014-04-15T06:28:43.203" UserId="904" Text="Ethernet sheild programming" />
  <row Id="3358" PostHistoryTypeId="3" PostId="1178" RevisionGUID="0791f789-c46e-4ad9-bd7a-fc744568f007" CreationDate="2014-04-15T06:28:43.203" UserId="904" Text="&lt;arduino-uno&gt;&lt;ethernet&gt;&lt;networking&gt;&lt;web-server&gt;" />
  <row Id="3360" PostHistoryTypeId="5" PostId="1177" RevisionGUID="4684c554-fd2e-4778-ba26-36aa52ef1d1b" CreationDate="2014-04-15T07:46:44.677" UserId="1049" Comment="added 744 characters in body" Text="As I don't want to stack the shield over the mega 2560 board, I try to connect only the pins that used for GSM communication. Here are my connection:&#xD;&#xA;&#xD;&#xA;Pin 3 on Mega &lt;==&gt; Pin GSM Rx on Shield&#xD;&#xA;&#xD;&#xA;Pin 10 on Mega &lt;==&gt; Pin GSM Tx on Shield&#xD;&#xA;&#xD;&#xA;Pin 4 on Mega &lt;==&gt; Pin 4 on Shield&#xD;&#xA;&#xD;&#xA;Pin 5V on Mega &lt;==&gt; Pin Vin on Shield&#xD;&#xA;&#xD;&#xA;Pin GRD on Mega &lt;==&gt; Pin GRD on Shield&#xD;&#xA;&#xD;&#xA;Code I used is from the Examples library, GsmScanNetworks:&#xD;&#xA;&#xD;&#xA;    #include &lt;GSM.h&gt;&#xD;&#xA;&#xD;&#xA;    // PIN Number&#xD;&#xA;    #define PINNUMBER &quot;8888&quot;&#xD;&#xA;&#xD;&#xA;    // initialize the library instance&#xD;&#xA;    GSM gsmAccess;     // include a 'true' parameter to enable debugging&#xD;&#xA;    GSMScanner scannerNetworks;&#xD;&#xA;    GSMModem modemTest;&#xD;&#xA;&#xD;&#xA;    // Save data variables&#xD;&#xA;    String IMEI = &quot;&quot;;&#xD;&#xA;&#xD;&#xA;    // serial monitor result messages&#xD;&#xA;    String errortext = &quot;ERROR&quot;;&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      // initialize serial communications and wait for port to open:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      while (!Serial) {&#xD;&#xA;        ; // wait for serial port to connect. Needed for Leonardo only&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;      Serial.println(&quot;GSM networks scanner&quot;);&#xD;&#xA;      scannerNetworks.begin();&#xD;&#xA;  &#xD;&#xA;      // connection state&#xD;&#xA;      boolean notConnected = true;&#xD;&#xA;  &#xD;&#xA;      // Start GSM shield&#xD;&#xA;      // If your SIM has PIN, pass it as a parameter of begin() in quotes&#xD;&#xA;      while(notConnected)&#xD;&#xA;      {&#xD;&#xA;        if(gsmAccess.begin(PINNUMBER)==GSM_READY)&#xD;&#xA;          notConnected = false;&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;          Serial.println(&quot;Not connected&quot;);&#xD;&#xA;          delay(1000);&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;  &#xD;&#xA;      // get modem parameters&#xD;&#xA;      // IMEI, modem unique identifier&#xD;&#xA;      Serial.print(&quot;Modem IMEI: &quot;);&#xD;&#xA;      IMEI = modemTest.getIMEI();&#xD;&#xA;      IMEI.replace(&quot;\n&quot;,&quot;&quot;);&#xD;&#xA;      if(IMEI != NULL)&#xD;&#xA;        Serial.println(IMEI);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      // scan for existing networks, displays a list of networks&#xD;&#xA;      Serial.println(&quot;Scanning available networks. May take some seconds.&quot;);&#xD;&#xA;      Serial.println(scannerNetworks.readNetworks());&#xD;&#xA;  &#xD;&#xA;        // currently connected carrier&#xD;&#xA;      Serial.print(&quot;Current carrier: &quot;);&#xD;&#xA;      Serial.println(scannerNetworks.getCurrentCarrier());&#xD;&#xA;    &#xD;&#xA;      // returns strength and ber&#xD;&#xA;      // signal strength in 0-31 scale. 31 means power &gt; 51dBm&#xD;&#xA;      // BER is the Bit Error Rate. 0-7 scale. 99=not detectable&#xD;&#xA;      Serial.print(&quot;Signal Strength: &quot;);&#xD;&#xA;      Serial.print(scannerNetworks.getSignalStrength());&#xD;&#xA;      Serial.println(&quot; [0-31]&quot;);&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Questions:&#xD;&#xA;&#xD;&#xA; 1. After opening the serial port, only a line &quot;GSM network scanner&quot; is read. Seems that the program is stuck on`gsmAccess.begin(PINNUMBER)`, how shall I fix that?&#xD;&#xA; 2. Is it a must that I shall supply 5V 2A power to the shield seperately in order for the shield to work? (with connection mentioned above, the ON led light on the shield does turns on with an orange light)&#xD;&#xA; 3. For the PINNUMBER defined in the program, my SIM has default PIN 8888. I checked with a mobile phone that the SIM card does work. But my phone shows that the SIM card is not locked with PIN. So shall I define the PIN as 8888 for ''?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;EDIT:&#xD;&#xA;&#xD;&#xA;[GSM shield link][1]&#xD;&#xA;&#xD;&#xA;[Note for using GSM shield with Mega][2]&#xD;&#xA;&#xD;&#xA;*** And yes! The shield did work when stacked! (Orginally I don't want to bend pin 2...but...unnh...stacking and bending out pin 2 did work)&#xD;&#xA;&#xD;&#xA;*** Tried the examples &quot;GSMScanNetwork&quot; and &quot;SendSMS&quot;, works fine. But for &quot;GsmWebServer&quot;, an IP address is shown, but when I enter the IP address on my browser, chrome/ie says they cannot find the IP address.....Any clues?&#xD;&#xA;&#xD;&#xA;*** And does the status LED on the GSM board have anything to do with power? It goes on and off and on and off.....&#xD;&#xA;&#xD;&#xA;*** For question 1 &amp; 3, PINNUMBER is set to ''. Worked fine.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Guide/ArduinoGSMShield&#xD;&#xA;  [2]: http://arduino.cc/en/Guide/GSMShieldLeonardoMega" />
  <row Id="3361" PostHistoryTypeId="2" PostId="1179" RevisionGUID="b84f557b-19fe-4145-b627-e7f797077510" CreationDate="2014-04-15T08:03:21.857" UserId="1053" Text="You need to determine what the network address is of the LAN you have connected the arduino to. A router can often give you this information. Alternatively you can connect a computer to the same network and look at the computers network settings (this varies depending on what OS you use). Then you have determine what IP address is available on that network. You will enter this in the ip variable in your example.&#xD;&#xA;&#xD;&#xA;The internet is not required for your application, however you do need the arduino to be connected to a LAN and another device (probably a standard computer) to invoke the arduinos server behaviour.&#xD;&#xA;&#xD;&#xA;To test that it works, you can open an internet browser on the second device and type in the IP address that you have configured for the arduino into the address bar." />
  <row Id="3362" PostHistoryTypeId="5" PostId="1178" RevisionGUID="a2c2f64e-c7fe-4688-b26f-b4f5deb42a63" CreationDate="2014-04-15T08:32:02.243" UserId="904" Comment="added 238 characters in body" Text="This is first time programming with Ethernet shield . i want to test web server application with arduino.&#xD;&#xA;&#xD;&#xA;I have arduino uno, Ethernet shield,potentiometer. Below code being uploaded.&#xD;&#xA;Question are:&#xD;&#xA;&#xD;&#xA; **- currently i am using LAN connection to configure. How to configure it. Is internet is required for below application??&#xD;&#xA; - How to check the output??&#xD;&#xA; - is there any software where i can make customised tags&#xD;&#xA; - I have values coming from Serial port to be monitored on webserver. Can someone share how to monitor it**&#xD;&#xA;![Manually configured for windows 7][1]&#xD;&#xA;![After config][2]&#xD;&#xA;![enter image description here][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;[Ethernet sheild][4]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;Ethernet.h&gt;&#xD;&#xA;    &#xD;&#xA;    // Enter a MAC address and IP address for your controller below.&#xD;&#xA;    // The IP address will be dependent on your local network:&#xD;&#xA;    byte mac[] = { &#xD;&#xA;      0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };&#xD;&#xA;    IPAddress ip(192,168,1,177);&#xD;&#xA;    &#xD;&#xA;    // Initialize the Ethernet server library&#xD;&#xA;    // with the IP address and port you want to use &#xD;&#xA;    // (port 80 is default for HTTP):&#xD;&#xA;    EthernetServer server(80);&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;     // Open serial communications and wait for port to open:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;       while (!Serial) {&#xD;&#xA;        ; // wait for serial port to connect. Needed for Leonardo only&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // start the Ethernet connection and the server:&#xD;&#xA;      Ethernet.begin(mac, ip);&#xD;&#xA;      server.begin();&#xD;&#xA;      Serial.print(&quot;server is at &quot;);&#xD;&#xA;      Serial.println(Ethernet.localIP());&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      // listen for incoming clients&#xD;&#xA;      EthernetClient client = server.available();&#xD;&#xA;      if (client) {&#xD;&#xA;        Serial.println(&quot;new client&quot;);&#xD;&#xA;        // an http request ends with a blank line&#xD;&#xA;        boolean currentLineIsBlank = true;&#xD;&#xA;        while (client.connected()) {&#xD;&#xA;          if (client.available()) {&#xD;&#xA;            char c = client.read();&#xD;&#xA;            Serial.write(c);&#xD;&#xA;            // if you've gotten to the end of the line (received a newline&#xD;&#xA;            // character) and the line is blank, the http request has ended,&#xD;&#xA;            // so you can send a reply&#xD;&#xA;            if (c == '\n' &amp;&amp; currentLineIsBlank) {&#xD;&#xA;              // send a standard http response header&#xD;&#xA;              client.println(&quot;HTTP/1.1 200 OK&quot;);&#xD;&#xA;              client.println(&quot;Content-Type: text/html&quot;);&#xD;&#xA;              client.println(&quot;Connection: close&quot;);  // the connection will be closed after completion of the response&#xD;&#xA;          client.println(&quot;Refresh: 5&quot;);  // refresh the page automatically every 5 sec&#xD;&#xA;              client.println();&#xD;&#xA;              client.println(&quot;&lt;!DOCTYPE HTML&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;html&gt;&quot;);&#xD;&#xA;              // output the value of each analog input pin&#xD;&#xA;              for (int analogChannel = 0; analogChannel &lt; 6; analogChannel++) {&#xD;&#xA;                int sensorReading = analogRead(analogChannel);&#xD;&#xA;                client.print(&quot;analog input &quot;);&#xD;&#xA;                client.print(analogChannel);&#xD;&#xA;                client.print(&quot; is &quot;);&#xD;&#xA;                client.print(sensorReading);&#xD;&#xA;                client.println(&quot;&lt;br /&gt;&quot;);       &#xD;&#xA;              }&#xD;&#xA;              client.println(&quot;&lt;/html&gt;&quot;);&#xD;&#xA;              break;&#xD;&#xA;            }&#xD;&#xA;            if (c == '\n') {&#xD;&#xA;              // you're starting a new line&#xD;&#xA;              currentLineIsBlank = true;&#xD;&#xA;            } &#xD;&#xA;            else if (c != '\r') {&#xD;&#xA;              // you've gotten a character on the current line&#xD;&#xA;              currentLineIsBlank = false;&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;        // give the web browser time to receive the data&#xD;&#xA;        delay(1);&#xD;&#xA;        // close the connection:&#xD;&#xA;        client.stop();&#xD;&#xA;        Serial.println(&quot;client disconnected&quot;);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/De3WX.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/HDDWk.jpg&#xD;&#xA;  [3]: http://i.stack.imgur.com/yDM0O.jpg&#xD;&#xA;  [4]: http://arduino.cc/en/Main/ArduinoEthernetShield" />
  <row Id="3363" PostHistoryTypeId="2" PostId="1180" RevisionGUID="661ffd36-ba8e-4211-9855-c75f5638b3c7" CreationDate="2014-04-15T09:08:11.743" UserId="113" Text="I use  [Bridge Control Panel][1] to plot Serial Data from Arduino. It's released as a part of Cypress Semiconductor's PSOC Programming Utilities and supports:&#xD;&#xA;&#xD;&#xA; 1. Various data formats (e.g. signed, unsigned, 8 bits, 16 bits);&#xD;&#xA; 2. Plots several data on the same axes;&#xD;&#xA; 3. Exports / Imports file data.&#xD;&#xA;etc.. but can be tricky to setup.&#xD;&#xA;&#xD;&#xA;As plotting Serial Data from Arduino is a common need, my question is:&#xD;&#xA;What Programs/Utilities do SE users find useful for plotting Serial Data from Arduino?&#xD;&#xA;What are the advantages / disadvantages of the method you use?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://goo.gl/2c2Hb2" />
  <row Id="3364" PostHistoryTypeId="1" PostId="1180" RevisionGUID="661ffd36-ba8e-4211-9855-c75f5638b3c7" CreationDate="2014-04-15T09:08:11.743" UserId="113" Text="Which Serial Data Plotting Programs do Users Find Useful?" />
  <row Id="3365" PostHistoryTypeId="3" PostId="1180" RevisionGUID="661ffd36-ba8e-4211-9855-c75f5638b3c7" CreationDate="2014-04-15T09:08:11.743" UserId="113" Text="&lt;serial&gt;&lt;plot&gt;" />
  <row Id="3366" PostHistoryTypeId="2" PostId="1181" RevisionGUID="3553358a-1de1-4655-a280-a0b771fa8971" CreationDate="2014-04-15T09:16:09.757" UserId="113" Text="Responding to my own question here.. I use Bridge Control Panel as mentioned.&#xD;&#xA;&#xD;&#xA;Advantages: Lots of Features.&#xD;&#xA;&#xD;&#xA;Disadvantages: Tricky to setup and very poor syntax/error reporting.&#xD;&#xA;&#xD;&#xA;To use:&#xD;&#xA;You need to write the Arduino Data over the Serial Port one byte at a time. For an int data type that would look as follows:&#xD;&#xA;&#xD;&#xA;    // RX8 [h=43] @1Key1 @0Key1&#xD;&#xA;    Serial.print(&quot;C&quot;);&#xD;&#xA;    Serial.write(data&gt;&gt;8);&#xD;&#xA;    Serial.write(data&amp;0xff);&#xD;&#xA;&#xD;&#xA;In Bridge the command to Read Data is:  &#xD;&#xA;&#xD;&#xA;    RX8 [h=43] @1Key1 @0Key1&#xD;&#xA;&#xD;&#xA;RX8 is the read command&#xD;&#xA;[h=43] means the next valid byte is &quot;C&quot; in ASCII&#xD;&#xA;then the High Byte of Key1&#xD;&#xA;then the Low Byte of Key1&#xD;&#xA;&#xD;&#xA;It looks like this in Bridge:&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/wO2vf.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/BBQqC.png" />
  <row Id="3367" PostHistoryTypeId="2" PostId="1182" RevisionGUID="a249bdd3-d257-4e1f-b949-a6015dfeeb70" CreationDate="2014-04-15T09:21:02.133" UserId="904" Text="Here it mine code . I want to perform read and write coil operation using arduino. Here read operation working fine. For assigned value master reading proper value from slave address. Now i want to write coil operation. Here value being sent from master to slave properly. But when i again read the value i found no value being update.&#xD;&#xA; I am using qmodbus as master.&#xD;&#xA;&#xD;&#xA;![read coil operation][1]&#xD;&#xA;![Mod bus Write coil operation][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void Modbus_call()&#xD;&#xA;    {&#xD;&#xA;    int Time1;&#xD;&#xA;    int Time2;&#xD;&#xA;    int Ntime;&#xD;&#xA;    /*reading of coil where i can succefully read value*/&#xD;&#xA;      au16data[0]=local_year;&#xD;&#xA;      au16data[1]=local_month;&#xD;&#xA;      au16data[2]=local_day;&#xD;&#xA;      au16data[3]=wkDay;&#xD;&#xA;      au16data[4]=local_h;&#xD;&#xA;      au16data[5]=local_m;&#xD;&#xA;      au16data[6]=local_s;&#xD;&#xA;      au16data[7]=(int)Wind_Speed;&#xD;&#xA;      au16data[8]=(int)Wind_Kmph; &#xD;&#xA;      int  desired_deg=360-tracker_des_angle;&#xD;&#xA;      int actual_deg=360-tracker_actual_pos; &#xD;&#xA;      au16data[9]=desired_deg;&#xD;&#xA;      au16data[10]=actual_deg;  &#xD;&#xA;        au16data[13] = slave.getInCnt();&#xD;&#xA;      au16data[14] = slave.getOutCnt();&#xD;&#xA;      au16data[15] = slave.getErrCnt();  &#xD;&#xA;    /*here i want write value for variable used*/&#xD;&#xA;     yy=au16data[0];&#xD;&#xA;     mm=au16data[1];&#xD;&#xA;     dd=au16data[2];&#xD;&#xA;     h=au16data[3];&#xD;&#xA;     m=au16data[4];&#xD;&#xA;     &#xD;&#xA;     Time1=(60*5)+(30);&#xD;&#xA;     Time2=60*au16data[3]+au16data[4];&#xD;&#xA;     Ntime=Time2-Time1;&#xD;&#xA;     Ntime=Ntime/60;&#xD;&#xA;     h=(int)(Ntime);&#xD;&#xA;     s=au16data[5]; &#xD;&#xA;     wkDay =2;&#xD;&#xA;     void rtcWrite(int sec1,int min1,int hour1, int  wkday1,int dd1,int mm1,int yy1);&#xD;&#xA;     wind_int=au16data[5] ;&#xD;&#xA;     Angle_int=au16data[6]; &#xD;&#xA;     &#xD;&#xA;     &#xD;&#xA;     &#xD;&#xA;     }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    Modbus_call();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/7tTSn.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/1Qv7i.jpg" />
  <row Id="3368" PostHistoryTypeId="1" PostId="1182" RevisionGUID="a249bdd3-d257-4e1f-b949-a6015dfeeb70" CreationDate="2014-04-15T09:21:02.133" UserId="904" Text="READ AND WRITE OPERATION FROM MODBUS" />
  <row Id="3369" PostHistoryTypeId="3" PostId="1182" RevisionGUID="a249bdd3-d257-4e1f-b949-a6015dfeeb70" CreationDate="2014-04-15T09:21:02.133" UserId="904" Text="&lt;arduino-uno&gt;&lt;networking&gt;&lt;modbus&gt;" />
  <row Id="3373" PostHistoryTypeId="4" PostId="1182" RevisionGUID="8418ddc9-f26c-419e-847b-479aec3c815e" CreationDate="2014-04-15T13:06:49.620" UserId="8" Comment="Allcaps title removed" Text="Read and write operations from Modbus" />
  <row Id="3375" PostHistoryTypeId="2" PostId="1184" RevisionGUID="4c326c6b-2e9c-4858-8d3a-4249b7aa7f95" CreationDate="2014-04-15T17:37:20.687" UserId="1060" Text="I am trying to connect a 2 cell 7.4 volt LiPo battery into my motor shield. I am a beginner at robotics so I am not sure if I just connect the battery, via a connector of some sort, into the motor shield itself or do I use some 22 AWG wire and connect it via that way. Sorry if that sounds confusing. " />
  <row Id="3376" PostHistoryTypeId="1" PostId="1184" RevisionGUID="4c326c6b-2e9c-4858-8d3a-4249b7aa7f95" CreationDate="2014-04-15T17:37:20.687" UserId="1060" Text="How to connect a 2 cell LiPo batter to Arduino Motor Shield?" />
  <row Id="3377" PostHistoryTypeId="3" PostId="1184" RevisionGUID="4c326c6b-2e9c-4858-8d3a-4249b7aa7f95" CreationDate="2014-04-15T17:37:20.687" UserId="1060" Text="&lt;arduino-uno&gt;" />
  <row Id="3378" PostHistoryTypeId="2" PostId="1185" RevisionGUID="c56f4385-36d6-4fa9-b79a-c05ab1f57b14" CreationDate="2014-04-15T18:27:22.257" UserId="11" Text="From the Motor Shield page,&#xD;&#xA;&#xD;&#xA;&gt; External (non-USB) power can come either from an AC-to-DC adapter&#xD;&#xA;&gt; (wall-wart) or battery. The adapter can be connected by plugging a&#xD;&#xA;&gt; 2.1mm center-positive plug into the Arduino's board power jack on which the motor shield is mounted or by **connecting the wires that lead&#xD;&#xA;&gt; the power supply to the Vin and GND screw terminals, taking care to&#xD;&#xA;&gt; respect the polarities.**&#xD;&#xA;&#xD;&#xA;So they provide the screw terminals for a battery, you should be able to insert two wires from your battery/pack into the terminals. If your battery has a connector on it, you'll need to either cut it off or find an adapter.&#xD;&#xA;&#xD;&#xA;**Be extra careful:** if you have exposed leads from your battery and they touch, it'll get extremely hot and possibly catch fire." />
  <row Id="3379" PostHistoryTypeId="5" PostId="1160" RevisionGUID="53a3af31-ddbe-493e-b3a4-10f10ad6b48c" CreationDate="2014-04-15T18:53:50.953" UserId="693" Comment="deleted 4 characters in body" Text="Running Ubuntu 12.04.4 LTS (64 bit) I try to upload my code to the Arduino Due through the Native port. I have tried both the `bossac` that ships with the Arduino IDE (which is a modified version of BOSSA), and the master BOSSA branch.&#xD;&#xA;&#xD;&#xA;Running this command:&#xD;&#xA;&#xD;&#xA;    sudo ./bossac -p /dev/ttyACM0&#xD;&#xA;&#xD;&#xA;I get this error:&#xD;&#xA;&#xD;&#xA;    No device found on /dev/ttyACM0&#xD;&#xA;&#xD;&#xA;However, it works perfectly inside the Arduino IDE.&#xD;&#xA;&#xD;&#xA;What can the problem be?" />
  <row Id="3380" PostHistoryTypeId="2" PostId="1186" RevisionGUID="03342cb7-7d83-422f-b10f-fb57e0d8eb7a" CreationDate="2014-04-15T20:33:26.320" UserId="1063" Text="I will be using an Arduino as a bridge between a computer high-level Java client and some low-level hardware computing units (e.g. other Arduinos). I need to find a solution to **periodically** communicate in **both** ways. It should be possible to send digital, analog inputs to the PC and receive digital, analog outputs from the PC via serial.&#xD;&#xA;&#xD;&#xA;I have very specific requirements for my project to work: &#xD;&#xA;&#xD;&#xA; 1. Lowest possible latency in both ways. High latency would cause&#xD;&#xA;    instability of controlled systems.&#xD;&#xA;    &#xD;&#xA; 2. Extremely constant, possibly user-defined update period. Varying&#xD;&#xA;    sample rate would cause inaccuracies in the control.&#xD;&#xA;&#xD;&#xA;I need a very fast solution possible for update frequency of 100 Hz and higher.&#xD;&#xA;&#xD;&#xA;So far I have tried to send data via Firmata to my java client using time interrupt.&#xD;&#xA;&#xD;&#xA;    ISR(TIMER1_COMPA_vect) {&#xD;&#xA;      Firmata.sendAnalog(analog, analogRead(analog));&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The messages however don't come at a very constant rate and are sometimes held up for twice the sample period or more which is unnaceptable. For higher frequencies this happens even more often. I suspect some kind of a buffer. Do you have any idea where should I look for bottlenecks? Would it be benefiting to design my own communication protocol and ditch Firmata?&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3381" PostHistoryTypeId="1" PostId="1186" RevisionGUID="03342cb7-7d83-422f-b10f-fb57e0d8eb7a" CreationDate="2014-04-15T20:33:26.320" UserId="1063" Text="What's the fastest way to periodically communicate via serial?" />
  <row Id="3382" PostHistoryTypeId="3" PostId="1186" RevisionGUID="03342cb7-7d83-422f-b10f-fb57e0d8eb7a" CreationDate="2014-04-15T20:33:26.320" UserId="1063" Text="&lt;serial&gt;" />
  <row Id="3383" PostHistoryTypeId="2" PostId="1187" RevisionGUID="0bf25549-b827-4690-91b1-1908bdafeb05" CreationDate="2014-04-15T21:00:22.073" UserId="84" Text="Your question is probably not as simple as it may seem.&#xD;&#xA;&#xD;&#xA;One approach I would use if I was to address this same problem would consist in:&#xD;&#xA;&#xD;&#xA;1. converting the analog output of the mike into a digital value (based on a threshold to determine)&#xD;&#xA;2. connect this digital signal to one Arduino pin that can trigger an interrupt when its level changes&#xD;&#xA;&#xD;&#xA;Let's first start with the easy part: Arduino program.&#xD;&#xA;&#xD;&#xA;Let's say we have a digital signal that raises to 1 as soon as a sound of too high amplitude is captured by the mike; it shall stay 1 as long as the sound does not reduce amplitude enough. We will connect this signal to Arduino pin 3; then we can use `attachInterrupt()` to have a function called whenever this pon level raises to 1:&#xD;&#xA;&#xD;&#xA;    volatile static bool started = false;&#xD;&#xA;    volatile static unsigned long timing = 0;&#xD;&#xA;    volatile static bool finished = false;&#xD;&#xA;    &#xD;&#xA;    void loud() {&#xD;&#xA;        if (started) {&#xD;&#xA;            timing = micros() - timing;&#xD;&#xA;            started = false;&#xD;&#xA;            finished = true;&#xD;&#xA;        } else {&#xD;&#xA;            timing = micros();&#xD;&#xA;            started = true;&#xD;&#xA;            finished = false;&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;        pinMode(3, INPUT);&#xD;&#xA;        attachInterrupt(1, loud, RAISE);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        if (finished) {&#xD;&#xA;            // Do something with timing&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Now the hardest part: electronics!&#xD;&#xA;&#xD;&#xA;A first issue we have to deal with is related to the fact that the raw mike signal will have same wave shape as the sound it captures, this wave has a frequency that can vary between 10Hz (bass) and 20KHz (treble).&#xD;&#xA;&#xD;&#xA;Indeed, if we convert the mike analog output to a logical value (`1` when the analog value is above a threshold we'll call `Vt`, `0` when it is under `Vt`) fast enough, then, if the environmental sound as an amplitude above `Vt`, the logical input connected to your Arduino will oscillate at the same frequency as the sound! This would make our efforts pointless as you would measure the period of the sound wave instead of the elapsed time between two distinct sound bursts.&#xD;&#xA;&#xD;&#xA;That means that we should probably first &quot;smoothen&quot; the analog sound signal in order to avoid disturbance of its frequency.&#xD;&#xA;&#xD;&#xA;Hence point 1 will have to deal with these 2 aspects:&#xD;&#xA;&#xD;&#xA;- smoothen analog input value&#xD;&#xA;- compare smoothened value with `Vt` threshold and provide a logical value from this comparison&#xD;&#xA;&#xD;&#xA;Comparison can rather easily be performed by an [op-amp][1] used as a comparator.&#xD;&#xA;&#xD;&#xA;However, the main difficulty you may have with an op-amp is the need for a symetric voltage supply (e.g. +5V/-5V) although it is possible to use a single supply but that raises further limitations (outside the scope of my answer).&#xD;&#xA;&#xD;&#xA;Smoothening the signal is potentially more complex, although it can be done with a simple capacitor, because smoothening the signal generally means weakening it, thus you would lose the initial amplitude of the sound signal.&#xD;&#xA;&#xD;&#xA;So how can we deal with that? &#xD;&#xA;&#xD;&#xA;A [Schmitt trigger][2] is probably a good solution for this problem but further experiment will be needed to confirm that.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Operational_amplifier&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Schmitt_trigger" />
  <row Id="3384" PostHistoryTypeId="5" PostId="1126" RevisionGUID="b6c3e37c-69f2-417d-89f7-d98a13c718d7" CreationDate="2014-04-15T22:22:25.030" UserId="979" Comment="Added details" Text="I am trying to create a wireless remote control to control a servo motor via Bluetooth. What all do I need to establish this? I did some research and found the following:&#xD;&#xA;&#xD;&#xA;[Tinyduino][1]&#xD;&#xA;&#xD;&#xA;[Bluetooth low energy shield][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://tiny-circuits.com/products/tinyduino/&#xD;&#xA;  [2]: https://tiny-circuits.com/shop/tinyshield-bluetooth-le/&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Would these be enough (in addition to the servo motor) to establish my needs? Any advice on how I would go about coding this? I can research on the specifics but hints on functions to use would be greatly appreciated. Thanks!&#xD;&#xA;&#xD;&#xA;Edit: I need to be able to control the system wirelessly (may it be Bluetooth or whatever) through a remote control. This remote control could be a push button system or an app on the phone. I do not have this designed yet. I do not know how to make iPhone apps so the best solution for me would be a simple push button on/off switch that can wirelessly tell the servo motor to either turn 90º clockwise or counterclockwise. &#xD;&#xA;&#xD;&#xA;The RFDuino suggestion is very helpful, thank you for that. Can anyone recommend a push-button switch (small) that can wirelessly transmit the signal to the servo motor on the device? I hope this clears things up. Thanks!" />
  <row Id="3385" PostHistoryTypeId="2" PostId="1188" RevisionGUID="ac1b7f0e-d739-4ecc-8cc0-2775631ce5d4" CreationDate="2014-04-15T23:05:37.447" UserId="643" Text="&gt; Lowest possible latency in both ways. High latency would cause instability of controlled systems.&#xD;&#xA;&#xD;&#xA;the fact that you are using a not-real-time OS introduce a lot of unpredictable latency, the use of a visrtual machine over that os then add a bit more.&#xD;&#xA;Fast communication can be obtained increasing the baudrate, that will decrease the latency between the sample and the elaboration. &#xD;&#xA;Also sending RAW data instead of string will be faster (no convertion AND less byte send), and finally decreasing the overhead caused by the protocol.&#xD;&#xA;&#xD;&#xA;For example Firmata by default use a low baudrate AND will add a lot of overhead to send WHAT kind of operation is doing. Writing your own communication protocol is better.&#xD;&#xA;&#xD;&#xA;For example: analogRead use 10bit, so you may send a raw int, 2 byte, 16bit, so 6 bit are lost.. or you can &quot;compress&quot; with a bit of bitwise operation 4 read (40 bit) into 5 byte (40bit, no bit loss) instead of 8(int size * 4)!&#xD;&#xA;&#xD;&#xA;AnalogRead is a really slow operation by default on arduino (~200us), but can be faster if you set up a lower prescaler (attention, lower prescaler means less ADC precision. at prescaler 16 guaranteed precision is 8bit, if my memory is good)&#xD;&#xA;&#xD;&#xA;&gt; Extremely constant, possibly user-defined update period. Varying sample rate would cause inaccuracies in the control.&#xD;&#xA;&#xD;&#xA;On the PC side, if you need micro/nano second precision you need a `real time os`, newest linux kernel add a new special schedule but i think is still hard to find documentation. If less precision is ok, just use a timer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;On the arduino side, using a hardware timer is the best way, see [LeOS][1] for a nice scheduler on arduino&#xD;&#xA;&#xD;&#xA;Please note HardwareSerial on the arduino side use interrupt to send data, so using it inside an ISR (like you are doing now or with LeOS) is really usafe and deadlock prone.&#xD;&#xA;Also ISR will &quot;slow down&quot; each others, as they cannnot be executed parallel; and analogRead is a realtivly slow operation..&#xD;&#xA;I would use timer to set up a flag, and in the loop if i see the flag, start the analogread, Serial.write and finally Serial.flush (to be sure to not fill Serial buffer, causing a lot of trouble on the arduino reprogrammation reset)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.leonardomiliani.com/2012/leos-un-semplice-so-per-arduino/?lang=en" />
  <row Id="3386" PostHistoryTypeId="10" PostId="1180" RevisionGUID="683a0e7f-8ebb-4915-90c8-ba79324c4656" CreationDate="2014-04-16T00:47:00.963" UserId="220" Comment="105" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:220,&quot;DisplayName&quot;:&quot;Annonomus Person&quot;}]}" />
  <row Id="3387" PostHistoryTypeId="2" PostId="1189" RevisionGUID="f4ee5172-627d-49ba-9201-788498acadb4" CreationDate="2014-04-16T01:50:05.913" UserId="1065" Text="http://pastebin.com/fjxawPWP&#xD;&#xA;Thats the pastebin of my code. Basically, despite having my potentiometer wired up as a analog input and analog output for the LED its reading and/or outputting it as digital. and the button wire up isn't working, its always read as HIGH.&#xD;&#xA;&#xD;&#xA;Help appreciated, thanks!" />
  <row Id="3388" PostHistoryTypeId="1" PostId="1189" RevisionGUID="f4ee5172-627d-49ba-9201-788498acadb4" CreationDate="2014-04-16T01:50:05.913" UserId="1065" Text="Can someone help me with this code bug" />
  <row Id="3389" PostHistoryTypeId="3" PostId="1189" RevisionGUID="f4ee5172-627d-49ba-9201-788498acadb4" CreationDate="2014-04-16T01:50:05.913" UserId="1065" Text="&lt;button&gt;&lt;led&gt;&lt;debugging&gt;&lt;potentiometer&gt;" />
  <row Id="3391" PostHistoryTypeId="5" PostId="1189" RevisionGUID="88f67f98-6443-49c0-8473-857ce1d7186d" CreationDate="2014-04-16T05:04:42.687" UserId="84" Comment="added 1337 characters in body; edited title" Text="I have made a simple Arduino program that uses a potentiometer to dim a LED.&#xD;&#xA;&#xD;&#xA;This program also makes a second LED blink.&#xD;&#xA;&#xD;&#xA;Finally, I have added a button that controls a third LED; this part of my program does not work: the 3rd LED is always lit as the button always reads HIGH.&#xD;&#xA;&#xD;&#xA;Here is the code:&#xD;&#xA;&#xD;&#xA;    //sensePin is wired up to the potentiometer&#xD;&#xA;    int sensePin = 2;&#xD;&#xA;     &#xD;&#xA;    //this is wired up to an LED&#xD;&#xA;    int ledPin = 9;&#xD;&#xA;     &#xD;&#xA;    //Wired up to a button&#xD;&#xA;    int inputPin = 1;&#xD;&#xA;     &#xD;&#xA;    int val = 0;&#xD;&#xA;     &#xD;&#xA;    //I was broed so added the default Blink&#xD;&#xA;    int ledPinX = 13;&#xD;&#xA;    &#xD;&#xA;    //Wired up to a second LED&#xD;&#xA;    int ledPinY = 7;&#xD;&#xA;     &#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      pinMode(ledPin, OUTPUT);&#xD;&#xA;      pinMode(inputPin, INPUT);&#xD;&#xA;      pinMode(ledPinX, OUTPUT);&#xD;&#xA;      pinMode(ledPinY, OUTPUT);&#xD;&#xA;      val = digitalRead(inputPin);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      if (val == HIGH){&#xD;&#xA;        //This should ask &quot;If your button is pressed, then do the code below&#xD;&#xA;        digitalWrite(ledPinY, HIGH);&#xD;&#xA;        //but for some reason the light is always on. I've tried it with more than one button&#xD;&#xA;      }&#xD;&#xA;      else if(val == LOW){&#xD;&#xA;        digitalWrite(ledPinY, LOW);&#xD;&#xA;      }&#xD;&#xA;      int value;&#xD;&#xA;&#xD;&#xA;      /*&#xD;&#xA;     The rest of this stuff works. Well, it did before adding in the button. Now the potentiometer acts as a digital input. Please help.&#xD;&#xA;       */&#xD;&#xA;      value = analogRead(sensePin) / 4;&#xD;&#xA;      analogWrite(ledPin, value);&#xD;&#xA;      digitalWrite(ledPinX, HIGH);&#xD;&#xA;      delay(500);&#xD;&#xA;      digitalWrite(ledPinX, LOW);&#xD;&#xA;      delay(500);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;What did I do wrong in this code?" />
  <row Id="3392" PostHistoryTypeId="4" PostId="1189" RevisionGUID="88f67f98-6443-49c0-8473-857ce1d7186d" CreationDate="2014-04-16T05:04:42.687" UserId="84" Comment="added 1337 characters in body; edited title" Text="Why does my wired button always read HIGH?" />
  <row Id="3393" PostHistoryTypeId="2" PostId="1190" RevisionGUID="367ecdae-90b8-4e4a-8c2d-1998f4447a96" CreationDate="2014-04-16T05:06:36.150" UserId="368" Text="You read the button once, in `setup()`. The function is not called every time the variable's value is read, only when the line is executed and the variable assigned to. Move the `digitalRead()` call and assignment into `loop()`, before you check the variable's value." />
  <row Id="3394" PostHistoryTypeId="2" PostId="1191" RevisionGUID="154ede92-c896-4fc4-a87f-c3c93a62b176" CreationDate="2014-04-16T05:10:12.517" UserId="84" Text="The main problem with your code is that you read the button state **only once** at the beginning of your program in `setup()`, so it keeps the initial value forever.&#xD;&#xA;&#xD;&#xA;You should modify `loop()` as follows:&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      digitalWrite(ledPinY, digitalRead(inputPin));&#xD;&#xA;      ...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You can also remove the `val` variable, it is totally useless here; then you must also simplify `setup()`:&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      pinMode(ledPin, OUTPUT);&#xD;&#xA;      pinMode(inputPin, INPUT);&#xD;&#xA;      pinMode(ledPinX, OUTPUT);&#xD;&#xA;      pinMode(ledPinY, OUTPUT);&#xD;&#xA;      // val = digitalRead(inputPin);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3395" PostHistoryTypeId="5" PostId="1182" RevisionGUID="e6bc669c-54a1-4513-9c6a-d49d8e4cdab0" CreationDate="2014-04-16T05:21:37.720" UserId="904" Comment="added 27025 characters in body" Text="Here it mine code . I want to perform read and write coil operation using arduino. Here read operation working fine. For assigned value master reading proper value from slave address. Now i want to write coil operation. Here value being sent from master to slave properly. But when i again read the value i found no value being update.&#xD;&#xA; I am using qmodbus as master.&#xD;&#xA;&#xD;&#xA;![read coil operation][1]&#xD;&#xA;![Mod bus Write coil operation][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void Modbus_call()&#xD;&#xA;    {&#xD;&#xA;    int Time1;&#xD;&#xA;    int Time2;&#xD;&#xA;    int Ntime;&#xD;&#xA;    /*reading of coil where i can succefully read value*/&#xD;&#xA;      au16data[0]=local_year;&#xD;&#xA;      au16data[1]=local_month;&#xD;&#xA;      au16data[2]=local_day;&#xD;&#xA;      au16data[3]=wkDay;&#xD;&#xA;      au16data[4]=local_h;&#xD;&#xA;      au16data[5]=local_m;&#xD;&#xA;      au16data[6]=local_s;&#xD;&#xA;      au16data[7]=(int)Wind_Speed;&#xD;&#xA;      au16data[8]=(int)Wind_Kmph; &#xD;&#xA;      int  desired_deg=360-tracker_des_angle;&#xD;&#xA;      int actual_deg=360-tracker_actual_pos; &#xD;&#xA;      au16data[9]=desired_deg;&#xD;&#xA;      au16data[10]=actual_deg;  &#xD;&#xA;        au16data[13] = slave.getInCnt();&#xD;&#xA;      au16data[14] = slave.getOutCnt();&#xD;&#xA;      au16data[15] = slave.getErrCnt();  &#xD;&#xA;    /*here i want write value for variable used*/&#xD;&#xA;     yy=au16data[0];&#xD;&#xA;     mm=au16data[1];&#xD;&#xA;     dd=au16data[2];&#xD;&#xA;     h=au16data[3];&#xD;&#xA;     m=au16data[4];&#xD;&#xA;     &#xD;&#xA;     Time1=(60*5)+(30);&#xD;&#xA;     Time2=60*au16data[3]+au16data[4];&#xD;&#xA;     Ntime=Time2-Time1;&#xD;&#xA;     Ntime=Ntime/60;&#xD;&#xA;     h=(int)(Ntime);&#xD;&#xA;     s=au16data[5]; &#xD;&#xA;     wkDay =2;&#xD;&#xA;     void rtcWrite(int sec1,int min1,int hour1, int  wkday1,int dd1,int mm1,int yy1);&#xD;&#xA;     wind_int=au16data[5] ;&#xD;&#xA;     Angle_int=au16data[6]; &#xD;&#xA;     &#xD;&#xA;     &#xD;&#xA;     &#xD;&#xA;     }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    Modbus_call();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/7tTSn.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/1Qv7i.jpg&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Modbus library defined here&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #define  MAX_BUFFER  64	&#xD;&#xA;    typedef struct {&#xD;&#xA;      uint8_t u8id;          /*!&lt; slave address between 1 and 247. 0 means broadcast */&#xD;&#xA;      uint8_t u8fct;         /*!&lt; function code: 1, 2, 3, 4, 5, 6, 15 or 16 */&#xD;&#xA;      uint16_t u16RegAdd;    /*!&lt; address of the first register to access at slave/s */&#xD;&#xA;      uint16_t u16CoilsNo;   /*!&lt; number of coils or registers to access */&#xD;&#xA;      uint16_t *au16reg;     /*!&lt; pointer to memory image in master */&#xD;&#xA;    }&#xD;&#xA;    modbus_t;&#xD;&#xA;    &#xD;&#xA;    enum {&#xD;&#xA;      RESPONSE_SIZE = 6,&#xD;&#xA;      EXCEPTION_SIZE = 3,&#xD;&#xA;      CHECKSUM_SIZE = 2&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum MESSAGE {&#xD;&#xA;      ID                             = 0,&#xD;&#xA;      FUNC,&#xD;&#xA;      ADD_HI,&#xD;&#xA;      ADD_LO,&#xD;&#xA;      NB_HI,&#xD;&#xA;      NB_LO,&#xD;&#xA;      BYTE_CNT&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum MB_FC {&#xD;&#xA;      MB_FC_NONE                     = 0,   /*!&lt; null operator */&#xD;&#xA;      MB_FC_READ_COILS               = 1,	/*!&lt; FCT=1 -&gt; read coils or digital outputs */&#xD;&#xA;      MB_FC_READ_DISCRETE_INPUT      = 2,	/*!&lt; FCT=2 -&gt; read digital inputs */&#xD;&#xA;      MB_FC_READ_REGISTERS           = 3,	/*!&lt; FCT=3 -&gt; read registers or analog outputs */&#xD;&#xA;      MB_FC_READ_INPUT_REGISTER      = 4,	/*!&lt; FCT=4 -&gt; read analog inputs */&#xD;&#xA;      MB_FC_WRITE_COIL               = 5,	/*!&lt; FCT=5 -&gt; write single coil or output */&#xD;&#xA;      MB_FC_WRITE_REGISTER           = 6,	/*!&lt; FCT=6 -&gt; write single register */&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_COILS     = 15,	/*!&lt; FCT=15 -&gt; write multiple coils or outputs */&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_REGISTERS = 16	/*!&lt; FCT=16 -&gt; write multiple registers */&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum COM_STATES {&#xD;&#xA;      COM_IDLE                     = 0,&#xD;&#xA;      COM_WAITING                  = 1&#xD;&#xA;    &#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    enum ERR_LIST {&#xD;&#xA;      ERR_NOT_MASTER                = -1,&#xD;&#xA;      ERR_POLLING                   = -2,&#xD;&#xA;      ERR_BUFF_OVERFLOW             = -3,&#xD;&#xA;      ERR_BAD_CRC                   = -4,&#xD;&#xA;      ERR_EXCEPTION                 = -5&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    enum {&#xD;&#xA;      NO_REPLY = 255, 			/*!&lt; */&#xD;&#xA;      EXC_FUNC_CODE = 1,		/*!&lt; Function code not available */&#xD;&#xA;      EXC_ADDR_RANGE = 2, 		/*!&lt; Address beyond available space for Modbus registers */&#xD;&#xA;      EXC_REGS_QUANT = 3,  		/*!&lt; Coils or registers number beyond the available space */&#xD;&#xA;      EXC_EXECUTE = 4 			/*!&lt; */&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    const unsigned char fctsupported[] = {&#xD;&#xA;      MB_FC_READ_COILS,&#xD;&#xA;      MB_FC_READ_DISCRETE_INPUT,&#xD;&#xA;      MB_FC_READ_REGISTERS,&#xD;&#xA;      MB_FC_READ_INPUT_REGISTER,&#xD;&#xA;      MB_FC_WRITE_COIL,&#xD;&#xA;      MB_FC_WRITE_REGISTER,&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_COILS,&#xD;&#xA;      MB_FC_WRITE_MULTIPLE_REGISTERS&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    #define T35  5&#xD;&#xA;    &#xD;&#xA;    class Modbus {&#xD;&#xA;    private:&#xD;&#xA;      HardwareSerial *port; //!&lt; Pointer to Serial class object&#xD;&#xA;      uint8_t u8id; //!&lt;0=master, 1..247=slave number&#xD;&#xA;      uint8_t u8serno; //!&lt;serial port: 0-Serial, 1..3-Serial1..Serial3&#xD;&#xA;      uint8_t u8txenpin; //!&lt;flow control pin: 0=USB or RS-232 mode, &gt;0=RS-485 mode&#xD;&#xA;      uint8_t u8state;&#xD;&#xA;      uint8_t au8Buffer[MAX_BUFFER];&#xD;&#xA;      uint8_t u8BufferSize;&#xD;&#xA;      uint8_t u8lastRec;&#xD;&#xA;      uint16_t *au16regs;&#xD;&#xA;      uint16_t u16InCnt, u16OutCnt, u16errCnt;&#xD;&#xA;      uint16_t u16timeOut;&#xD;&#xA;      uint32_t u32time, u32timeOut;&#xD;&#xA;      uint8_t u8regsize;&#xD;&#xA;    &#xD;&#xA;      void init(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin);&#xD;&#xA;      void sendTxBuffer(); // transmit buffer to serial port&#xD;&#xA;      int8_t getRxBuffer(); // get serial buffer contents&#xD;&#xA;      uint16_t calcCRC(uint8_t u8length); // get CRC from au8Buffer until u8length&#xD;&#xA;      uint8_t validateAnswer();&#xD;&#xA;      uint8_t validateRequest(); // validate master request&#xD;&#xA;      void get_FC1(); // *** only master ***&#xD;&#xA;      void get_FC3(); // *** only master ***&#xD;&#xA;      int8_t process_FC1( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC3( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC5( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC6( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;       int8_t process_FC15( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      int8_t process_FC16( uint16_t *regs, uint8_t u8size ); //!&lt; *** only slave ***&#xD;&#xA;      void buildException( uint8_t u8exception ); // build exception message&#xD;&#xA;    &#xD;&#xA;    public:&#xD;&#xA;      Modbus(); // !&lt; Default Constructor&#xD;&#xA;      Modbus(uint8_t u8id, uint8_t u8serno); // !&lt; Constructor&#xD;&#xA;      Modbus(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin); // !&lt; Full Constructor&#xD;&#xA;      void begin(long u32speed);&#xD;&#xA;      void begin();&#xD;&#xA;      void setTimeOut( uint16_t u16timeout); //!&lt; write communication watch-dog timer&#xD;&#xA;      uint16_t getTimeOut(); //!&lt; get communication watch-dog timer value&#xD;&#xA;      boolean getTimeOutState(); //!&lt; get communication watch-dog timer state&#xD;&#xA;      int8_t query( modbus_t telegram ); //!&lt; only for master&#xD;&#xA;      int8_t poll(); //!&lt; cyclic poll for master&#xD;&#xA;      int8_t poll( uint16_t *regs, uint8_t u8size ); //!&lt; cyclic poll for slave&#xD;&#xA;      uint16_t getInCnt(); //!&lt; number of incoming messages&#xD;&#xA;      uint16_t getOutCnt(); //!&lt; number of outcoming messages&#xD;&#xA;      uint16_t getErrCnt(); //!&lt; error counter&#xD;&#xA;      uint8_t getID(); //!&lt; get slave ID between 1 and 247&#xD;&#xA;      uint8_t getState();&#xD;&#xA;      uint8_t getLastError(); //!&lt; get last error message&#xD;&#xA;      &#xD;&#xA;     &#xD;&#xA;      &#xD;&#xA;      void setID( uint8_t u8id ); //!&lt; write new ID for the slave&#xD;&#xA;      void end(); //!&lt; finish any communication and release serial communication port&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus() {&#xD;&#xA;      init(0, 0, 0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus(uint8_t u8id, uint8_t u8serno) {&#xD;&#xA;      init(u8id, u8serno, 0);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    Modbus::Modbus(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin) {&#xD;&#xA;      init(u8id, u8serno, u8txenpin);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::begin(long u32speed) {&#xD;&#xA;    &#xD;&#xA;      switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;      case 1:&#xD;&#xA;        port = &amp;Serial1;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;      case 2:&#xD;&#xA;        port = &amp;Serial2;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;      case 3:&#xD;&#xA;        port = &amp;Serial3;&#xD;&#xA;        break;&#xD;&#xA;    #endif&#xD;&#xA;      case 0:&#xD;&#xA;      default:&#xD;&#xA;        port = &amp;Serial;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // port-&gt;begin(u32speed, u8config);&#xD;&#xA;      port-&gt;begin(u32speed);&#xD;&#xA;      if (u8txenpin &gt; 1) { // pin 0 &amp; pin 1 are reserved for RX/TX&#xD;&#xA;        // return RS485 transceiver to transmit mode&#xD;&#xA;        pinMode(u8txenpin, OUTPUT);&#xD;&#xA;        digitalWrite(u8txenpin, LOW);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      port-&gt;flush();&#xD;&#xA;      u8lastRec = u8BufferSize = 0;&#xD;&#xA;      u16InCnt = u16OutCnt = u16errCnt = 0;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::begin() {&#xD;&#xA;      begin(19200);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void Modbus::setID( uint8_t u8id) {&#xD;&#xA;      if (( u8id != 0) &amp;&amp; (u8id &lt;= 247)) {&#xD;&#xA;        this-&gt;u8id = u8id;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::getID() {&#xD;&#xA;      return this-&gt;u8id;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::setTimeOut( uint16_t u16timeOut) {&#xD;&#xA;      this-&gt;u16timeOut = u16timeOut;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    boolean Modbus::getTimeOutState() {&#xD;&#xA;      return (millis() &gt; u32timeOut);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getInCnt() {&#xD;&#xA;      return u16InCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getOutCnt() {&#xD;&#xA;      return u16OutCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    uint16_t Modbus::getErrCnt() {&#xD;&#xA;      return u16errCnt;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::getState() {&#xD;&#xA;      return u8state;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::query( modbus_t telegram ) {&#xD;&#xA;      uint8_t u8regsno, u8bytesno;&#xD;&#xA;      if (u8id != 0) return -2;&#xD;&#xA;      if (u8state != COM_IDLE) return -1;&#xD;&#xA;    &#xD;&#xA;      if ((telegram.u8id == 0) || (telegram.u8id &gt; 247)) return -3;&#xD;&#xA;    &#xD;&#xA;      au16regs = telegram.au16reg;&#xD;&#xA;    &#xD;&#xA;      // telegram header&#xD;&#xA;      au8Buffer[ ID ]         = telegram.u8id;&#xD;&#xA;      au8Buffer[ FUNC ]       = telegram.u8fct;&#xD;&#xA;      au8Buffer[ ADD_HI ]     = highByte(telegram.u16RegAdd );&#xD;&#xA;      au8Buffer[ ADD_LO ]     = lowByte( telegram.u16RegAdd );&#xD;&#xA;    &#xD;&#xA;      switch ( telegram.u8fct ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;      case MB_FC_READ_REGISTERS:&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        au8Buffer[ NB_HI ]      = ((au16regs[0] &gt; 0) ? 0xff : 0);&#xD;&#xA;        au8Buffer[ NB_LO ]      = 0;&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(au16regs[0]);&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte(au16regs[0]);&#xD;&#xA;        u8BufferSize = 6;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        u8regsno = telegram.u16CoilsNo / 16;&#xD;&#xA;        u8bytesno = u8regsno * 2;&#xD;&#xA;        if ((telegram.u16CoilsNo % 16) != 0) {&#xD;&#xA;          u8bytesno++;&#xD;&#xA;          u8regsno++;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO + 1 ]    = u8bytesno;&#xD;&#xA;        u8BufferSize = 7;&#xD;&#xA;    &#xD;&#xA;        u8regsno = u8bytesno = 0; // now auxiliary registers&#xD;&#xA;        for (uint16_t i = 0; i &lt; telegram.u16CoilsNo; i++) {&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;        break;&#xD;&#xA;    &#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS:&#xD;&#xA;        au8Buffer[ NB_HI ]      = highByte(telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO ]      = lowByte( telegram.u16CoilsNo );&#xD;&#xA;        au8Buffer[ NB_LO + 1 ]    = (uint8_t) ( telegram.u16CoilsNo * 2 );&#xD;&#xA;        u8BufferSize = 7;&#xD;&#xA;    &#xD;&#xA;        for (uint16_t i = 0; i &lt; telegram.u16CoilsNo; i++) {&#xD;&#xA;          au8Buffer[ u8BufferSize ] = highByte( au16regs[ i ] );&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;          au8Buffer[ u8BufferSize ] = lowByte( au16regs[ i ] );&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;        }&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      u8state = COM_WAITING;&#xD;&#xA;      return 0;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::poll() {&#xD;&#xA;      // check if there is any incoming frame&#xD;&#xA;      uint8_t u8current = port-&gt;available();&#xD;&#xA;    &#xD;&#xA;      if (millis() &gt; u32timeOut) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      if (u8current == 0) return 0;&#xD;&#xA;    &#xD;&#xA;      // check T35 after frame end or still no frame end&#xD;&#xA;      if (u8current != u8lastRec) {&#xD;&#xA;        u8lastRec = u8current;&#xD;&#xA;        u32time = millis() + T35;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;      if (millis() &lt; u32time) return 0;&#xD;&#xA;    &#xD;&#xA;      // transfer Serial buffer frame to auBuffer&#xD;&#xA;      u8lastRec = 0;&#xD;&#xA;      int8_t i8state = getRxBuffer();&#xD;&#xA;      if (i8state &lt; 7) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return i8state;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // validate message: id, CRC, FCT, exception&#xD;&#xA;      uint8_t u8exception = validateAnswer();&#xD;&#xA;      if (u8exception != 0) {&#xD;&#xA;        u8state = COM_IDLE;&#xD;&#xA;        return u8exception;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // process answer&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;        // call get_FC1 to transfer the incoming message to au16regs buffer&#xD;&#xA;        get_FC1( );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;        // call get_FC3 to transfer the incoming message to au16regs buffer&#xD;&#xA;        get_FC3( );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        // nothing to do&#xD;&#xA;        break;&#xD;&#xA;      default:&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      u8state = COM_IDLE;&#xD;&#xA;      return u8BufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::poll( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      au16regs = regs;&#xD;&#xA;      u8regsize = u8size;&#xD;&#xA;    &#xD;&#xA;      // check if there is any incoming frame&#xD;&#xA;      uint8_t u8current = port-&gt;available();&#xD;&#xA;      if (u8current == 0) return 0;&#xD;&#xA;    &#xD;&#xA;      // check T35 after frame end or still no frame end&#xD;&#xA;      if (u8current != u8lastRec) {&#xD;&#xA;        u8lastRec = u8current;&#xD;&#xA;        u32time = millis() + T35;&#xD;&#xA;        return 0;&#xD;&#xA;      }&#xD;&#xA;      if (millis() &lt; u32time) return 0;&#xD;&#xA;    &#xD;&#xA;      u8lastRec = 0;&#xD;&#xA;      int8_t i8state = getRxBuffer();&#xD;&#xA;      if (i8state &lt; 7) return i8state;&#xD;&#xA;    &#xD;&#xA;      // check slave id&#xD;&#xA;      if (au8Buffer[ ID ] != u8id) return 0;&#xD;&#xA;    &#xD;&#xA;      // validate message: CRC, FCT, address and size&#xD;&#xA;      uint8_t u8exception = validateRequest();&#xD;&#xA;      if (u8exception &gt; 0) {&#xD;&#xA;        if (u8exception != NO_REPLY) {&#xD;&#xA;          buildException( u8exception );&#xD;&#xA;          sendTxBuffer();&#xD;&#xA;        }&#xD;&#xA;        return u8exception;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      u32timeOut = millis() + long(u16timeOut);&#xD;&#xA;    &#xD;&#xA;      // process message&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;        return process_FC1( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER:&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;        return process_FC3( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        return process_FC5( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;        return process_FC6( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        return process_FC15( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        return process_FC16( regs, u8size );&#xD;&#xA;        break;&#xD;&#xA;      default:&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /* _____PRIVATE FUNCTIONS_____________________________________________________ */&#xD;&#xA;    &#xD;&#xA;    void Modbus::init(uint8_t u8id, uint8_t u8serno, uint8_t u8txenpin) {&#xD;&#xA;      this-&gt;u8id = u8id;&#xD;&#xA;      this-&gt;u8serno = (u8serno &gt; 3) ? 0 : u8serno;&#xD;&#xA;      this-&gt;u8txenpin = u8txenpin;&#xD;&#xA;      this-&gt;u16timeOut = 1000;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::getRxBuffer() {&#xD;&#xA;      boolean bBuffOverflow = false;&#xD;&#xA;    &#xD;&#xA;      if (u8txenpin &gt; 1) digitalWrite( u8txenpin, LOW );&#xD;&#xA;    &#xD;&#xA;      u8BufferSize = 0;&#xD;&#xA;      while ( port-&gt;available() ) {&#xD;&#xA;        au8Buffer[ u8BufferSize ] = port-&gt;read();&#xD;&#xA;        u8BufferSize ++;&#xD;&#xA;    &#xD;&#xA;        if (u8BufferSize &gt;= MAX_BUFFER) bBuffOverflow = true;&#xD;&#xA;      }&#xD;&#xA;      u16InCnt++;&#xD;&#xA;    &#xD;&#xA;      if (bBuffOverflow) {&#xD;&#xA;        u16errCnt++;&#xD;&#xA;        return ERR_BUFF_OVERFLOW;&#xD;&#xA;      }&#xD;&#xA;      return u8BufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::sendTxBuffer() {&#xD;&#xA;      uint8_t i = 0;&#xD;&#xA;    &#xD;&#xA;      // append CRC to message&#xD;&#xA;      uint16_t u16crc = calcCRC( u8BufferSize );&#xD;&#xA;      au8Buffer[ u8BufferSize ] = u16crc &gt;&gt; 8;&#xD;&#xA;      u8BufferSize++;&#xD;&#xA;      au8Buffer[ u8BufferSize ] = u16crc &amp; 0x00ff;&#xD;&#xA;      u8BufferSize++;&#xD;&#xA;    &#xD;&#xA;      // set RS485 transceiver to transmit mode&#xD;&#xA;      if (u8txenpin &gt; 1) {&#xD;&#xA;        switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;        case 1:&#xD;&#xA;          UCSR1A = UCSR1A | (1 &lt;&lt; TXC1);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;        case 2:&#xD;&#xA;          UCSR2A = UCSR2A | (1 &lt;&lt; TXC2);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;        case 3:&#xD;&#xA;          UCSR3A = UCSR3A | (1 &lt;&lt; TXC3);&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;        case 0:&#xD;&#xA;        default:&#xD;&#xA;          UCSR0A = UCSR0A | (1 &lt;&lt; TXC0);&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;        digitalWrite( u8txenpin, HIGH );&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // transfer buffer to serial line&#xD;&#xA;      port-&gt;write( au8Buffer, u8BufferSize );&#xD;&#xA;    &#xD;&#xA;      // keep RS485 transceiver in transmit mode as long as sending&#xD;&#xA;      if (u8txenpin &gt; 1) {&#xD;&#xA;        switch ( u8serno ) {&#xD;&#xA;    #if defined(UBRR1H)&#xD;&#xA;        case 1:&#xD;&#xA;          while (!(UCSR1A &amp; (1 &lt;&lt; TXC1)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR2H)&#xD;&#xA;        case 2:&#xD;&#xA;          while (!(UCSR2A &amp; (1 &lt;&lt; TXC2)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    #if defined(UBRR3H)&#xD;&#xA;        case 3:&#xD;&#xA;          while (!(UCSR3A &amp; (1 &lt;&lt; TXC3)));&#xD;&#xA;          break;&#xD;&#xA;    #endif&#xD;&#xA;        case 0:&#xD;&#xA;        default:&#xD;&#xA;          while (!(UCSR0A &amp; (1 &lt;&lt; TXC0)));&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        // return RS485 transceiver to receive mode&#xD;&#xA;        digitalWrite( u8txenpin, LOW );&#xD;&#xA;      }&#xD;&#xA;      port-&gt;flush();&#xD;&#xA;      u8BufferSize = 0;&#xD;&#xA;    &#xD;&#xA;      // set time-out for master&#xD;&#xA;      u32timeOut = millis() + (unsigned long) u16timeOut;&#xD;&#xA;    &#xD;&#xA;      // increase message counter&#xD;&#xA;      u16OutCnt++;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    /**&#xD;&#xA;     * @brief&#xD;&#xA;     * This method calculates CRC&#xD;&#xA;     *&#xD;&#xA;     * @return uint16_t calculated CRC value for the message&#xD;&#xA;     * @ingroup buffer&#xD;&#xA;     */&#xD;&#xA;    uint16_t Modbus::calcCRC(uint8_t u8length) {&#xD;&#xA;      unsigned int temp, temp2, flag;&#xD;&#xA;      temp = 0xFFFF;&#xD;&#xA;      for (unsigned char i = 0; i &lt; u8length; i++) {&#xD;&#xA;        temp = temp ^ au8Buffer[i];&#xD;&#xA;        for (unsigned char j = 1; j &lt;= 8; j++) {&#xD;&#xA;          flag = temp &amp; 0x0001;&#xD;&#xA;          temp &gt;&gt;= 1;&#xD;&#xA;          if (flag)&#xD;&#xA;            temp ^= 0xA001;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      // Reverse byte order.&#xD;&#xA;      temp2 = temp &gt;&gt; 8;&#xD;&#xA;      temp = (temp &lt;&lt; 8) | temp2;&#xD;&#xA;      temp &amp;= 0xFFFF;&#xD;&#xA;      // the returned value is already swapped&#xD;&#xA;      // crcLo byte is first &amp; crcHi byte is last&#xD;&#xA;      return temp;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::validateRequest() {&#xD;&#xA;      // check message crc vs calculated crc&#xD;&#xA;      uint16_t u16MsgCRC =&#xD;&#xA;        ((au8Buffer[u8BufferSize - 2] &lt;&lt; 8)&#xD;&#xA;        | au8Buffer[u8BufferSize - 1]); // combine the crc Low &amp; High bytes&#xD;&#xA;      if ( calcCRC( u8BufferSize - 2 ) != u16MsgCRC ) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return NO_REPLY;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check fct code&#xD;&#xA;      boolean isSupported = false;&#xD;&#xA;      for (uint8_t i = 0; i &lt; sizeof( fctsupported ); i++) {&#xD;&#xA;        if (fctsupported[i] == au8Buffer[FUNC]) {&#xD;&#xA;          isSupported = 1;&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      if (!isSupported) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return EXC_FUNC_CODE;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check start address &amp; nb range&#xD;&#xA;      uint16_t u16regs = 0;&#xD;&#xA;      uint8_t u8regs;&#xD;&#xA;      switch ( au8Buffer[ FUNC ] ) {&#xD;&#xA;      case MB_FC_READ_COILS:&#xD;&#xA;      case MB_FC_READ_DISCRETE_INPUT:&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_COILS:&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]) / 16;&#xD;&#xA;        u16regs += word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ]) / 16;&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_COIL:&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]) / 16;&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_WRITE_REGISTER :&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]);&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      case MB_FC_READ_REGISTERS :&#xD;&#xA;      case MB_FC_READ_INPUT_REGISTER :&#xD;&#xA;      case MB_FC_WRITE_MULTIPLE_REGISTERS :&#xD;&#xA;        u16regs = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ]);&#xD;&#xA;        u16regs += word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ]);&#xD;&#xA;        u8regs = (uint8_t) u16regs;&#xD;&#xA;        if (u8regs &gt; u8regsize) return EXC_ADDR_RANGE;&#xD;&#xA;        break;&#xD;&#xA;      }&#xD;&#xA;      return 0; // OK, no exception code thrown&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    uint8_t Modbus::validateAnswer() {&#xD;&#xA;      // check message crc vs calculated crc&#xD;&#xA;      uint16_t u16MsgCRC =&#xD;&#xA;        ((au8Buffer[u8BufferSize - 2] &lt;&lt; 8)&#xD;&#xA;        | au8Buffer[u8BufferSize - 1]); // combine the crc Low &amp; High bytes&#xD;&#xA;      if ( calcCRC( u8BufferSize - 2 ) != u16MsgCRC ) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return NO_REPLY;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check exception&#xD;&#xA;      if ((au8Buffer[ FUNC ] &amp; 0x80) != 0) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return ERR_EXCEPTION;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // check fct code&#xD;&#xA;      boolean isSupported = false;&#xD;&#xA;      for (uint8_t i = 0; i &lt; sizeof( fctsupported ); i++) {&#xD;&#xA;        if (fctsupported[i] == au8Buffer[FUNC]) {&#xD;&#xA;          isSupported = 1;&#xD;&#xA;          break;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      if (!isSupported) {&#xD;&#xA;        u16errCnt ++;&#xD;&#xA;        return EXC_FUNC_CODE;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      return 0; // OK, no exception code thrown&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::buildException( uint8_t u8exception ) {&#xD;&#xA;      uint8_t u8func = au8Buffer[ FUNC ];  // get the original FUNC code&#xD;&#xA;    &#xD;&#xA;      au8Buffer[ ID ]      = u8id;&#xD;&#xA;      au8Buffer[ FUNC ]    = u8func + 0x80;&#xD;&#xA;      au8Buffer[ 2 ]       = u8exception;&#xD;&#xA;      u8BufferSize         = EXCEPTION_SIZE;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Modbus::get_FC1() {&#xD;&#xA;      uint8_t u8byte, i;&#xD;&#xA;      u8byte = 0;&#xD;&#xA;    &#xD;&#xA;      // check the answer length&#xD;&#xA;      boolean bEvenOdd =&#xD;&#xA;        ( au8Buffer[ ADD_HI ] % 2 == 0) ?&#xD;&#xA;      false :&#xD;&#xA;      true;&#xD;&#xA;    &#xD;&#xA;      uint8_t u8WordsNo =&#xD;&#xA;        ( !bEvenOdd ) ?&#xD;&#xA;      au8Buffer[ ADD_HI ] / 2 :&#xD;&#xA;      au8Buffer[ ADD_HI ] / 2 + 1;&#xD;&#xA;    &#xD;&#xA;      for (i = 0; i &lt; u8WordsNo; i++) {&#xD;&#xA;        au16regs[ i ] = word(&#xD;&#xA;        au8Buffer[ u8byte ],&#xD;&#xA;        au8Buffer[ u8byte + 1 ]);&#xD;&#xA;        u8byte += 2;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // cut last byte&#xD;&#xA;      if (bEvenOdd) {&#xD;&#xA;        au16regs[ u8WordsNo - 1 ] &amp;= 0xff00;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void Modbus::get_FC3() {&#xD;&#xA;      uint8_t u8byte, i;&#xD;&#xA;      u8byte = 3;&#xD;&#xA;    &#xD;&#xA;      for (i = 0; i &lt; au8Buffer[ 2 ] / 2; i++) {&#xD;&#xA;        au16regs[ i ] = word(&#xD;&#xA;        au8Buffer[ u8byte ],&#xD;&#xA;        au8Buffer[ u8byte + 1 ]);&#xD;&#xA;        u8byte += 2;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC1( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit, u8bytesno, u8bitsno;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16currentCoil, u16coil;&#xD;&#xA;    &#xD;&#xA;      // get the first and last coil from the message&#xD;&#xA;      uint16_t u16StartCoil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint16_t u16Coilno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;      // put the number of bytes in the outcoming message&#xD;&#xA;      u8bytesno = (uint8_t) (u16Coilno / 8);&#xD;&#xA;      if (u16Coilno % 8 != 0) u8bytesno ++;&#xD;&#xA;      au8Buffer[ ADD_HI ]  = u8bytesno;&#xD;&#xA;      u8BufferSize         = ADD_LO;&#xD;&#xA;    &#xD;&#xA;      // read each coil from the register map and put its value inside the outcoming message&#xD;&#xA;      u8bitsno = 0;&#xD;&#xA;    &#xD;&#xA;      for (u16currentCoil = 0; u16currentCoil &lt; u16Coilno; u16currentCoil++) {&#xD;&#xA;        u16coil = u16StartCoil + u16currentCoil;&#xD;&#xA;        u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;        u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;        bitWrite(&#xD;&#xA;        au8Buffer[ u8BufferSize ],&#xD;&#xA;        u8bitsno,&#xD;&#xA;        bitRead( regs[ u8currentRegister ], u8currentBit ) );&#xD;&#xA;        u8bitsno ++;&#xD;&#xA;    &#xD;&#xA;        if (u8bitsno &gt; 7) {&#xD;&#xA;          u8bitsno = 0;&#xD;&#xA;          u8BufferSize++;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // send outcoming message&#xD;&#xA;      if (u16Coilno % 8 != 0) u8BufferSize ++;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC3( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      uint8_t u8StartAdd = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint8_t u8regsno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint8_t i;&#xD;&#xA;    &#xD;&#xA;      au8Buffer[ 2 ]       = u8regsno * 2;&#xD;&#xA;      u8BufferSize         = 3;&#xD;&#xA;    &#xD;&#xA;      for (i = u8StartAdd; i &lt; u8StartAdd + u8regsno; i++) {&#xD;&#xA;        au8Buffer[ u8BufferSize ] = highByte(regs[i]);&#xD;&#xA;        u8BufferSize++;&#xD;&#xA;        au8Buffer[ u8BufferSize ] = lowByte(regs[i]);&#xD;&#xA;        u8BufferSize++;&#xD;&#xA;      }&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC5( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16coil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;    &#xD;&#xA;      // point to the register and its bit&#xD;&#xA;      u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;      u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;      // write to coil&#xD;&#xA;      bitWrite(&#xD;&#xA;      regs[ u8currentRegister ],&#xD;&#xA;      u8currentBit,&#xD;&#xA;      au8Buffer[ NB_HI ] == 0xff );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // send answer to master&#xD;&#xA;      u8BufferSize = 6;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC6( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;    &#xD;&#xA;      uint8_t u8add = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16val = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;      regs[ u8add ] = u16val;&#xD;&#xA;    &#xD;&#xA;      // keep the same header&#xD;&#xA;      u8BufferSize         = RESPONSE_SIZE;&#xD;&#xA;    &#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC15( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8currentRegister, u8currentBit, u8frameByte, u8bitsno;&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint16_t u16currentCoil, u16coil;&#xD;&#xA;      boolean bTemp;&#xD;&#xA;    &#xD;&#xA;      // get the first and last coil from the message&#xD;&#xA;      uint16_t u16StartCoil = word( au8Buffer[ ADD_HI ], au8Buffer[ ADD_LO ] );&#xD;&#xA;      uint16_t u16Coilno = word( au8Buffer[ NB_HI ], au8Buffer[ NB_LO ] );&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // read each coil from the register map and put its value inside the outcoming message&#xD;&#xA;      u8bitsno = 0;&#xD;&#xA;      u8frameByte = 7;&#xD;&#xA;      for (u16currentCoil = 0; u16currentCoil &lt; u16Coilno; u16currentCoil++) {&#xD;&#xA;    &#xD;&#xA;        u16coil = u16StartCoil + u16currentCoil;&#xD;&#xA;        u8currentRegister = (uint8_t) (u16coil / 16);&#xD;&#xA;        u8currentBit = (uint8_t) (u16coil % 16);&#xD;&#xA;    &#xD;&#xA;        bTemp = bitRead(&#xD;&#xA;        au8Buffer[ u8frameByte ],&#xD;&#xA;        u8bitsno );&#xD;&#xA;    &#xD;&#xA;        bitWrite(&#xD;&#xA;        regs[ u8currentRegister ],&#xD;&#xA;        u8currentBit,&#xD;&#xA;        bTemp );&#xD;&#xA;    &#xD;&#xA;        u8bitsno ++;&#xD;&#xA;    &#xD;&#xA;        if (u8bitsno &gt; 7) {&#xD;&#xA;          u8bitsno = 0;&#xD;&#xA;          u8frameByte++;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;      // send outcoming message&#xD;&#xA;      // it's just a copy of the incomping frame until 6th byte&#xD;&#xA;      u8BufferSize         = 6;&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    int8_t Modbus::process_FC16( uint16_t *regs, uint8_t u8size ) {&#xD;&#xA;      uint8_t u8func = au8Buffer[ FUNC ];  // get the original FUNC code&#xD;&#xA;      uint8_t u8StartAdd = au8Buffer[ ADD_HI ] &lt;&lt; 8 | au8Buffer[ ADD_LO ];&#xD;&#xA;      uint8_t u8regsno = au8Buffer[ NB_HI ] &lt;&lt; 8 | au8Buffer[ NB_LO ];&#xD;&#xA;      uint8_t u8CopyBufferSize;&#xD;&#xA;      uint8_t i;&#xD;&#xA;      uint16_t temp;&#xD;&#xA;    &#xD;&#xA;      // build header&#xD;&#xA;      au8Buffer[ NB_HI ]   = 0;&#xD;&#xA;      au8Buffer[ NB_LO ]   = u8regsno;&#xD;&#xA;      u8BufferSize         = RESPONSE_SIZE;&#xD;&#xA;    &#xD;&#xA;      // write registers&#xD;&#xA;      for (i = 0; i &lt; u8regsno; i++) {&#xD;&#xA;        temp = word(&#xD;&#xA;        au8Buffer[ (BYTE_CNT + 1) + i * 2 ],&#xD;&#xA;        au8Buffer[ (BYTE_CNT + 2) + i * 2 ]);&#xD;&#xA;    &#xD;&#xA;        regs[ u8StartAdd + i ] = temp;&#xD;&#xA;      }&#xD;&#xA;      u8CopyBufferSize = u8BufferSize +2;&#xD;&#xA;      sendTxBuffer();&#xD;&#xA;    &#xD;&#xA;      return u8CopyBufferSize;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3396" PostHistoryTypeId="4" PostId="1180" RevisionGUID="d1fe37cc-bd44-4d79-98c4-c6d224164fbf" CreationDate="2014-04-16T08:39:15.960" UserId="113" Comment="edited title" Text="Serial Data Plotting Programs: What are the advantages / disadvantages?" />
  <row Id="3397" PostHistoryTypeId="5" PostId="1180" RevisionGUID="d1fe37cc-bd44-4d79-98c4-c6d224164fbf" CreationDate="2014-04-16T08:39:15.960" UserId="113" Comment="edited title" Text="I use  [Bridge Control Panel][1] to plot Serial Data from Arduino. It's released as a part of Cypress Semiconductor's PSOC Programming Utilities and supports:&#xD;&#xA;&#xD;&#xA; 1. Various data formats (e.g. signed, unsigned, 8 bits, 16 bits);&#xD;&#xA; 2. Plots several data on the same axes;&#xD;&#xA; 3. Exports / Imports file data.&#xD;&#xA;etc.. but can be tricky to setup.&#xD;&#xA;&#xD;&#xA;As plotting Serial Data from Arduino is a common need, my question is:&#xD;&#xA;What Programs/Utilities are available for plotting Serial Data from Arduino?&#xD;&#xA;What are the advantages / disadvantages of the method you use?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://goo.gl/2c2Hb2" />
  <row Id="3398" PostHistoryTypeId="2" PostId="1192" RevisionGUID="b565a885-ee87-4a21-8684-9983fc959218" CreationDate="2014-04-16T09:24:20.727" UserId="575" Text="I assume you're using TinyGPS which I sourced from https://github.com/mikalhart/TinyGPS&#xD;&#xA;&#xD;&#xA;I've recently done a similar thing - just trying to get the gps to work and give me as much data as possible.&#xD;&#xA;&#xD;&#xA;The code I used to do this is here:&#xD;&#xA;&#xD;&#xA;	#include &quot;TinyGPS.h&quot;&#xD;&#xA;&#xD;&#xA;	#define GPS_BAUD 115200&#xD;&#xA;	#define PC_BAUD 115200&#xD;&#xA;&#xD;&#xA;	TinyGPS gps;&#xD;&#xA;&#xD;&#xA;	int led1 = 13;&#xD;&#xA;&#xD;&#xA;	long lat, lon;&#xD;&#xA;&#xD;&#xA;	unsigned long fix_age, time, date, speed, course;&#xD;&#xA;&#xD;&#xA;	unsigned long chars;&#xD;&#xA;	unsigned short sentences, failed_checksum;&#xD;&#xA;&#xD;&#xA;	void setup()&#xD;&#xA;	{&#xD;&#xA;	  pinMode(led1, OUTPUT);&#xD;&#xA;	  Serial1.begin(GPS_BAUD);&#xD;&#xA;	  Serial.begin(PC_BAUD);&#xD;&#xA;	  Serial1.println(&quot;&quot;);&#xD;&#xA;	  Serial1.println(&quot;Initializing&quot;);&#xD;&#xA;	  Serial1.println(&quot;&quot;);&#xD;&#xA;	  digitalWrite(led1, HIGH);&#xD;&#xA;	  delay(2000);&#xD;&#xA;	  digitalWrite(led1, LOW);&#xD;&#xA;	  delay(500);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	void loop()&#xD;&#xA;	{&#xD;&#xA;	  while(Serial1.available()){&#xD;&#xA;		if(gps.encode(Serial1.read())){&#xD;&#xA;		  digitalWrite(led1, HIGH);&#xD;&#xA;		  gps.get_position(&amp;lat, &amp;lon, &amp;fix_age);&#xD;&#xA;		  gps.get_datetime(&amp;date, &amp;time);&#xD;&#xA;		  Serial1.println(&quot;&quot;);&#xD;&#xA;		  Serial1.println(&quot;Lat: &quot; + String(lat));&#xD;&#xA;		  Serial1.println(&quot;Lon: &quot; + String(lon));&#xD;&#xA;		  delay(3000);&#xD;&#xA;		  gps.stats(&amp;chars, &amp;sentences, &amp;failed_checksum);&#xD;&#xA;		  Serial1.println(&quot;Chars: &quot; + String(chars));&#xD;&#xA;		  Serial1.println(&quot;Sents: &quot; + String(sentences));&#xD;&#xA;		  delay(1000);&#xD;&#xA;		  Serial1.println(&quot;Fails: &quot; + String(failed_checksum));&#xD;&#xA;		  Serial1.println(&quot;&quot;);&#xD;&#xA;		  delay(1000);&#xD;&#xA;		}&#xD;&#xA;		Serial1.print(&quot;.&quot;);&#xD;&#xA;	  }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;I was using an Arduino Mega 2560, but I think you have the same Serial ports on your Due. I connected the TX pin of my GPS ( can't remember the model but I think it was a 10Hz version of this: https://www.sparkfun.com/products/9891 ) to Serial1's RX and I used a small serial 2 row LCD display to output which was connected to Serial1's TX, hence I was using serial1 for both transmitting and receiving. If you remove the delays from the code above the data is read and then written back as fast as possible and while I never measured how many fixes I was seeing per second I'm fairly sure there were at least 5.&#xD;&#xA;&#xD;&#xA;The code you want is probably something like this:&#xD;&#xA;&#xD;&#xA;	#include &quot;TinyGPS.h&quot;&#xD;&#xA;&#xD;&#xA;	#define GPS_BAUD 115200&#xD;&#xA;	#define PC_BAUD 115200&#xD;&#xA;&#xD;&#xA;	TinyGPS gps;&#xD;&#xA;&#xD;&#xA;	int led1 = 13;&#xD;&#xA;&#xD;&#xA;	long lat, lon;&#xD;&#xA;&#xD;&#xA;	unsigned long fix_age, time, date, speed, course;&#xD;&#xA;&#xD;&#xA;	unsigned long chars;&#xD;&#xA;	unsigned short sentences, failed_checksum;&#xD;&#xA;&#xD;&#xA;	void setup()&#xD;&#xA;	{&#xD;&#xA;	  pinMode(led1, OUTPUT);&#xD;&#xA;	  Serial1.begin(GPS_BAUD);&#xD;&#xA;	  Serial.begin(PC_BAUD);&#xD;&#xA;	  Serial1.println(&quot;&quot;);&#xD;&#xA;	  Serial1.println(&quot;Initializing&quot;);&#xD;&#xA;	  Serial1.println(&quot;&quot;);&#xD;&#xA;	  digitalWrite(led1, HIGH);&#xD;&#xA;	  delay(2000);&#xD;&#xA;	  digitalWrite(led1, LOW);&#xD;&#xA;	  delay(500);&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;	void loop()&#xD;&#xA;	{&#xD;&#xA;	  while(Serial1.available()){&#xD;&#xA;		if(gps.encode(Serial1.read())){&#xD;&#xA;		  digitalWrite(led1, HIGH);&#xD;&#xA;		  gps.get_position(&amp;lat, &amp;lon, &amp;fix_age);&#xD;&#xA;		  gps.get_datetime(&amp;date, &amp;time);&#xD;&#xA;		  Serial.print(&quot;    &quot;);&#xD;&#xA;		  Serial.print(lat);&#xD;&#xA;		  Serial.print(&quot; &quot;);&#xD;&#xA;		  Serial.print(long);&#xD;&#xA;		}&#xD;&#xA;	  }&#xD;&#xA;	}&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;As commented by @connor-wolf above you will probably need to change the baud-rate of your communications up because otherwise you the limit of the amount of information you can send/receive per second is probably too low. The baud rate must also match the baud rate of your GPS device. Some GPS devices have an adjustable baud rate.&#xD;&#xA;&#xD;&#xA;------&#xD;&#xA;&#xD;&#xA;A quick google turned up an average NMEA sentence length of 60 bytes and if I recall correctly you may have 2 or 3 sentences to each fix? (I think the extra sentences contain extra info like satellite counts, and stuff). So assume you need 180 bytes per fix and you want at least 5 fixes per second that would be 900 bytes. In baud that is 900x8 = 7200. So assuming my estimations above are accurate or overestimated then you have enough bandwidth.&#xD;&#xA;&#xD;&#xA;I'm not sure however if the Micro transmits/receives over serial while running the other instructions in your code - I would assume not to be safe but it's worth some research. Therefore you have to account for the time the micro spends transmitting and interpreting the data as time in the second that it can't spend receiving the data. Therefore I would suggest that doubling or even tripling the data rate would be a good idea. (as you can see from my example I just set it to as high as the GPS would go.)&#xD;&#xA;&#xD;&#xA;Anyway. I hope all that helps.&#xD;&#xA;&#xD;&#xA;P.S please forgive if I've used the wrong terminology for fixes/sentences or whatever" />
  <row Id="3399" PostHistoryTypeId="2" PostId="1193" RevisionGUID="0e7fbad9-0a19-4aa6-9f8e-57e5c76c298d" CreationDate="2014-04-16T15:50:42.617" UserId="1072" Text="Hi there people im quit new with this so ive succeed to work with pressure sensor arduino but i need to work it out good. My question is how do i pair it with time...&#xD;&#xA;What i want to is when i put pressure on the sensor the time needs to go till 5 minutes and it starts over again if theres no pressure pressing on the sensor... when its reached that 5 minutes the led lights on or a sound comes of the sound sensor(alarm)." />
  <row Id="3400" PostHistoryTypeId="1" PostId="1193" RevisionGUID="0e7fbad9-0a19-4aa6-9f8e-57e5c76c298d" CreationDate="2014-04-16T15:50:42.617" UserId="1072" Text="Need help with arduino time(milli) and pressure sensor" />
  <row Id="3401" PostHistoryTypeId="3" PostId="1193" RevisionGUID="0e7fbad9-0a19-4aa6-9f8e-57e5c76c298d" CreationDate="2014-04-16T15:50:42.617" UserId="1072" Text="&lt;arduino-uno&gt;&lt;time&gt;&lt;millis&gt;&lt;timing&gt;" />
  <row Id="3402" PostHistoryTypeId="2" PostId="1194" RevisionGUID="19026da1-ea78-4fb3-8d03-7168ec3c2c67" CreationDate="2014-04-16T16:15:29.203" UserId="943" Text="I&amp;#039;m planning to build a device that would read some sensor data and send it via GPRS, eg. once per day. (Not that original, yeah.) But my problem is choosing a GSM/GPRS shield.&#xD;&#xA;&#xD;&#xA;The official shield has a [**nice interface for doing an HTTP POST/GET**][1]. OTOH, the shield seems to be sold out (and would be quite expensive anyway).&#xD;&#xA;&#xD;&#xA;There seem to be other shields available, but their code examples tend to look [**quite hacky**][2]: the device waits for an arbitrary moment and then hopes that the server is done. That&amp;#039;s IMO both inefficient or unreliable.&#xD;&#xA;&#xD;&#xA;My question: which GSM/GPRS shield would you recommend, with these features:&#xD;&#xA;&#xD;&#xA;&lt;ul&gt;&lt;li&gt;a sane library w/ examples, such as the official one&lt;/li&gt;&lt;li&gt;an external antenna&lt;/li&gt;&lt;li&gt;bonus: a competitive price&lt;/li&gt;&lt;li&gt;another bonus: hopefully a &amp;quot;real&amp;quot; shield, so no soldering required and a few pins still easily usable for the sensors.&lt;/li&gt;&lt;/ul&gt;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Guide/ArduinoGSMShield#toc10&#xD;&#xA;  [2]: http://www.seeedstudio.com/wiki/GPRS_Shield_V1.0#A_Simple_Source_Code_Examples" />
  <row Id="3403" PostHistoryTypeId="1" PostId="1194" RevisionGUID="19026da1-ea78-4fb3-8d03-7168ec3c2c67" CreationDate="2014-04-16T16:15:29.203" UserId="943" Text="Which shield to use for GPRS?" />
  <row Id="3404" PostHistoryTypeId="3" PostId="1194" RevisionGUID="19026da1-ea78-4fb3-8d03-7168ec3c2c67" CreationDate="2014-04-16T16:15:29.203" UserId="943" Text="&lt;shields&gt;&lt;tcpip&gt;&lt;gsm&gt;" />
  <row Id="3405" PostHistoryTypeId="2" PostId="1195" RevisionGUID="e1993399-c18c-4950-ad21-0e15845b96f8" CreationDate="2014-04-16T16:37:59.233" UserId="11" Text="That library should work with pretty much anything that has the M10 module on it.&#xD;&#xA;&#xD;&#xA;I only have experience with the SIM900 modules. Found the cheapest one on EBay.&#xD;&#xA;&#xD;&#xA;While interfacing with these things can be a challenge at first, you really just need to read the manual for all the AT commands and execute them. I've written a couple of functions that may help:&#xD;&#xA;&#xD;&#xA;Note: you may safely replace all instances of `DEBUG_PRINT` and `DEBUG_PRINTLN` with `Serial.print` and `Serial.println`.&#xD;&#xA;&#xD;&#xA;    SoftwareSerial SIM900(7, 8);&#xD;&#xA;&#xD;&#xA;    /*&#xD;&#xA;        Sends AT commands to SIM900 module.&#xD;&#xA;        &#xD;&#xA;        Parameter   Description&#xD;&#xA;        command     String containing the AT command to send to the module&#xD;&#xA;        timeout     A timeout, in milliseconds, to wait for the response&#xD;&#xA;        &#xD;&#xA;        Returns a string containing the response. Returns NULL on timeout.&#xD;&#xA;        &#xD;&#xA;    */&#xD;&#xA;    String SIMCommunication::sendCommand(String command, int timeout) {&#xD;&#xA;        SIM900.listen();&#xD;&#xA;        // Clear read buffer before sending new command&#xD;&#xA;        while(SIM900.available()) { SIM900.read(); }&#xD;&#xA;    &#xD;&#xA;        SIM900.println(command);&#xD;&#xA;        &#xD;&#xA;        if (responseTimedOut(timeout)) {&#xD;&#xA;            DEBUG_PRINT(F(&quot;sendCommand Timed Out: &quot;));DEBUG_PRINTLN(command);&#xD;&#xA;            return NULL;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        String response = &quot;&quot;;&#xD;&#xA;        &#xD;&#xA;        while(SIM900.available()) {&#xD;&#xA;            response.concat((char)SIM900.read());&#xD;&#xA;            delayMicroseconds(500);&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        return response;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    /*&#xD;&#xA;        Waits for a response from SIM900 for &lt;ms&gt; milliseconds&#xD;&#xA;        &#xD;&#xA;        Returns true if timed out without response. False otherwise.&#xD;&#xA;    */&#xD;&#xA;    bool SIMCommunication::responseTimedOut(int ms) {&#xD;&#xA;        SIM900.listen();&#xD;&#xA;        &#xD;&#xA;        int counter = 0;&#xD;&#xA;        while(!SIM900.available() &amp;&amp; counter &lt; ms) {&#xD;&#xA;            counter++;&#xD;&#xA;            delay(1);&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        // Timed out, return null&#xD;&#xA;        if (counter &gt;= ms) {&#xD;&#xA;            return true;&#xD;&#xA;        }&#xD;&#xA;        counter = 0;&#xD;&#xA;        return false;&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="3406" PostHistoryTypeId="2" PostId="1196" RevisionGUID="12c0ca34-df30-49f7-8685-0c9adc395377" CreationDate="2014-04-16T16:41:27.620" UserId="313" Text="The very simplest way - not necessarily the best way - is something like:&#xD;&#xA;&#xD;&#xA;&gt;     Keep re-reading the pressure sensor until it senses pressure;&#xD;&#xA;&gt;     Read millis(), add 300000 (# of msec in 5 min) to it's value, and store that;&#xD;&#xA;&gt;     Keep re-read millis() until it returns a number &gt;= to that stored value;&#xD;&#xA;&gt;     Read the pressure sensor;&#xD;&#xA;&gt;     If it senses pressure,&#xD;&#xA;&gt;       turn on the alarm;&#xD;&#xA;&gt;       do nothing, forever;&#xD;&#xA;&gt;     Otherwise, start over again;&#xD;&#xA;&#xD;&#xA;It isn't the best way, because the Arduino does nothing else for the 5 minutes until the final sensor check. But as you're learning, you probably don't need it to do anything else - for now. When that time comes, there are better ways than dedicating your processor to watching the clock. But this will get you started, and you may figure out some of those ways on your own, by then. Good luck!&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3407" PostHistoryTypeId="2" PostId="1197" RevisionGUID="d1780f55-875f-410f-aff6-b5fba81f29e4" CreationDate="2014-04-16T16:41:54.100" UserId="756" Text="I'm trying to program a little bit in Arduino, but I'm stuck with probably something trivial.&#xD;&#xA;&#xD;&#xA;This is what I have:  &#xD;&#xA;&#xD;&#xA;    char ang[3], lat[9];&#xD;&#xA;    dtostrf(GPS.angle, 3, 0, ang);&#xD;&#xA;    dtostrf(GPS.latitude, 9,5, lat);&#xD;&#xA;          &#xD;&#xA;    Serial.println(lat);             &#xD;&#xA;    Serial.println(ang);&#xD;&#xA;    Serial.println(&quot;-------&quot;);&#xD;&#xA;&#xD;&#xA;I would expect the following in the serial monitor:&#xD;&#xA;&#xD;&#xA;    5111.60160&#xD;&#xA;    267&#xD;&#xA;    -------&#xD;&#xA;&#xD;&#xA;But instead, I'm getting this:&#xD;&#xA;&#xD;&#xA;    5111.60160&#xD;&#xA;    2675111.60160&#xD;&#xA;    -------&#xD;&#xA;&#xD;&#xA;So it looks like the `ang` holds both the angle and the latitude....&#xD;&#xA;&#xD;&#xA;Why is this happening? And how can I solve this?&#xD;&#xA;&#xD;&#xA;My goal is to make one big string, comma separated, from the data stored in `GPS`&#xD;&#xA;" />
  <row Id="3408" PostHistoryTypeId="1" PostId="1197" RevisionGUID="d1780f55-875f-410f-aff6-b5fba81f29e4" CreationDate="2014-04-16T16:41:54.100" UserId="756" Text="strange behaviour of dtostrf()" />
  <row Id="3409" PostHistoryTypeId="3" PostId="1197" RevisionGUID="d1780f55-875f-410f-aff6-b5fba81f29e4" CreationDate="2014-04-16T16:41:54.100" UserId="756" Text="&lt;programming&gt;&lt;sketch&gt;" />
  <row Id="3410" PostHistoryTypeId="5" PostId="1126" RevisionGUID="a3c38a6f-4509-43e3-94fe-a177707f1622" CreationDate="2014-04-16T16:43:59.433" UserId="11" Comment="deleted 6 characters in body" Text="I am trying to create a wireless remote control to control a servo motor via Bluetooth. What all do I need to establish this? I did some research and found the following:&#xD;&#xA;&#xD;&#xA;[Tinyduino][1]&#xD;&#xA;&#xD;&#xA;[Bluetooth low energy shield][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://tiny-circuits.com/products/tinyduino/&#xD;&#xA;  [2]: https://tiny-circuits.com/shop/tinyshield-bluetooth-le/&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Would these be enough (in addition to the servo motor) to establish my needs? Any advice on how I would go about coding this? I can research on the specifics but hints on functions to use would be greatly appreciated. Thanks!&#xD;&#xA;&#xD;&#xA;I need to be able to control the system wirelessly (may it be Bluetooth or whatever) through a remote control. This remote control could be a push button system or an app on the phone. I do not have this designed yet. I do not know how to make iPhone apps so the best solution for me would be a simple push button on/off switch that can wirelessly tell the servo motor to either turn 90º clockwise or counterclockwise. &#xD;&#xA;&#xD;&#xA;The RFDuino suggestion is very helpful, thank you for that. Can anyone recommend a push-button switch (small) that can wirelessly transmit the signal to the servo motor on the device? I hope this clears things up. Thanks!" />
  <row Id="3411" PostHistoryTypeId="11" PostId="1126" RevisionGUID="af453257-7e0a-4d56-885f-263219dfed77" CreationDate="2014-04-16T16:43:59.640" UserId="11" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="3412" PostHistoryTypeId="5" PostId="1189" RevisionGUID="7177499f-9970-4386-a564-b501ea36de7c" CreationDate="2014-04-16T17:42:19.693" UserId="1065" Comment="deleted 20 characters in body" Text="I have made a simple Arduino program that uses a potentiometer to dim a LED.&#xD;&#xA;&#xD;&#xA;This program also makes a second LED blink.&#xD;&#xA;&#xD;&#xA;Finally, I have added a button that controls a third LED; this part of my program does not work: the 3rd LED is always lit as the button always reads HIGH.&#xD;&#xA;&#xD;&#xA;Here is the code:&#xD;&#xA;&#xD;&#xA;    //sensePin is wired up to the FSR&#xD;&#xA;    int sensePin = 2;&#xD;&#xA;     &#xD;&#xA;    //this is wired up to an LED&#xD;&#xA;    int ledPin = 9;&#xD;&#xA;     &#xD;&#xA;    //Wired up to a button&#xD;&#xA;    int inputPin = 1;&#xD;&#xA;     &#xD;&#xA;    int val = 0;&#xD;&#xA;     &#xD;&#xA;    //I was broed so added the default Blink&#xD;&#xA;    int ledPinX = 13;&#xD;&#xA;    &#xD;&#xA;    //Wired up to a second LED&#xD;&#xA;    int ledPinY = 7;&#xD;&#xA;     &#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      pinMode(ledPin, OUTPUT);&#xD;&#xA;      pinMode(inputPin, INPUT);&#xD;&#xA;      pinMode(ledPinX, OUTPUT);&#xD;&#xA;      pinMode(ledPinY, OUTPUT);&#xD;&#xA;      val = digitalRead(inputPin);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      if (val == HIGH){&#xD;&#xA;        //This should ask &quot;If your button is pressed, then do the code below&#xD;&#xA;        digitalWrite(ledPinY, HIGH);&#xD;&#xA;        //but for some reason the light is always on. I've tried it with more than one button&#xD;&#xA;      }&#xD;&#xA;      else if(val == LOW){&#xD;&#xA;        digitalWrite(ledPinY, LOW);&#xD;&#xA;      }&#xD;&#xA;      int value;&#xD;&#xA;&#xD;&#xA;      /*&#xD;&#xA;     The rest of this stuff works. Well, it did before adding in the button. Now the FSR acts as a digital input. Please help.&#xD;&#xA;       */&#xD;&#xA;      value = analogRead(sensePin) / 4;&#xD;&#xA;      analogWrite(ledPin, value);&#xD;&#xA;      digitalWrite(ledPinX, HIGH);&#xD;&#xA;      delay(500);&#xD;&#xA;      digitalWrite(ledPinX, LOW);&#xD;&#xA;      delay(500);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;What did I do wrong in this code?&#xD;&#xA;&#xD;&#xA;EDIT:: diagram and pic at: instagram.com/p/m3AmHWmp4e" />
  <row Id="3413" PostHistoryTypeId="2" PostId="1198" RevisionGUID="60d6dc5d-40a4-4f1a-ae4f-71b205edf1ab" CreationDate="2014-04-16T17:44:33.433" UserId="313" Text="Your arrays are both too short for the strings they're meant to hold. In particular, ang has three digits and only three bytes. The string-terminator, NUL, ends up in the 1st byte of lat. Since you generated the ang string first, lat over-wrote ang's NUL character, effectively getting appended to ang.&#xD;&#xA;&#xD;&#xA;The lat string will need at least (10+1) bytes; ang will need (3+1) bytes, counting only the actual data in your question.&#xD;&#xA;&#xD;&#xA;I make it a habit to declare string arrays just as I wrote the sums above, to make it clear that I've counted both the contents and the NUL byte, so:&#xD;&#xA;&#xD;&#xA;&gt; char ang[3+1], lat[10+1];&#xD;&#xA;&#xD;&#xA;I doubt that you need to specifically add the NUL terminator; it would quite unusual (counter-conventional) for a C/C++ function that generates a string to leave off the terminator (except in a few special cases).&#xD;&#xA;&#xD;&#xA;Try increasing just your array sizes first; it'll probably work." />
  <row Id="3415" PostHistoryTypeId="5" PostId="1196" RevisionGUID="5993eacd-9805-4f81-ad54-8c914cf0b70b" CreationDate="2014-04-16T18:36:47.750" UserId="313" Comment="added 377 characters in body" Text="The very simplest way - not necessarily the best way - is something like:&#xD;&#xA;&#xD;&#xA;&gt;     Keep re-reading the pressure sensor until it senses pressure;&#xD;&#xA;&gt;     Read millis(), add 300000 (# of msec in 5 min) to it's value, and store that;&#xD;&#xA;&gt;     Keep re-read millis() until it returns a number &gt;= to that stored value;&#xD;&#xA;&gt;     Read the pressure sensor;&#xD;&#xA;&gt;     If it senses pressure,&#xD;&#xA;&gt;       turn on the alarm;&#xD;&#xA;&gt;       do nothing, forever;&#xD;&#xA;&gt;     Otherwise, start over again;&#xD;&#xA;&#xD;&#xA;It isn't the best way, because the Arduino does nothing else for the 5 minutes until the final sensor check. But as you're learning, you probably don't need it to do anything else - for now. When that time comes, there are better ways than dedicating your processor to watching the clock. But this will get you started, and you may figure out some of those ways on your own, by then. Good luck!&#xD;&#xA;&#xD;&#xA;Update: I realized my answer does not account for the possibility that pressure is released from the sensor and reapplied some time later, if both occur within the 5 minute wait. How you treat that situation will depend on the needs of your application (which I'm guessing is for you to learn to work with time and physical data). I'll leave that as a further exercise for you." />
  <row Id="3416" PostHistoryTypeId="2" PostId="1199" RevisionGUID="d4e34233-b299-44c6-ab18-11454d8142ec" CreationDate="2014-04-16T21:30:03.107" UserId="79" Text="You need to compare the pins' functions between your Mega and your friend's Uno. Then you need to make those electrical connections happen. I talk about this a little in the &quot;pin locations&quot; section of [my answer here][1].&#xD;&#xA;&#xD;&#xA;This requires &quot;hacking&quot;. Something needs to be done to reroute those physical connections. I normally use an intermediate shield to translate pins as needed. There was a shield specifically made for this purpose but I couldn't find it. [Maybe this one would work][2]?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/questions/462/which-are-the-competitors-of-the-arduino-boards/476#476&#xD;&#xA;  [2]: http://www.dfrobot.com/index.php?route=product/product&amp;path=123_124&amp;product_id=990#.U071vPldX_M" />
  <row Id="3417" PostHistoryTypeId="2" PostId="1200" RevisionGUID="c2affdbb-aa87-4b8a-a2d3-e2c21f9d5749" CreationDate="2014-04-17T03:59:23.890" UserId="1049" Text="I have a [Mega board][1] and a [GSM shield][2]. I'm using Arduino's example &quot;TestWebServer&quot;. The serial monitor shows that the GSM is connected, and returns a IP. &#xD;&#xA;&#xD;&#xA;However, the IP is always 10.X.X.X. Isn't that a internal network IP address? How should I get the SIM cards IP? Thanks!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoBoardMega2560&#xD;&#xA;  [2]: http://arduino.cc/en/Main/ArduinoGSMShield" />
  <row Id="3418" PostHistoryTypeId="1" PostId="1200" RevisionGUID="c2affdbb-aa87-4b8a-a2d3-e2c21f9d5749" CreationDate="2014-04-17T03:59:23.890" UserId="1049" Text="GSM library getIPaddress returns local network address 10.X.X.X" />
  <row Id="3419" PostHistoryTypeId="3" PostId="1200" RevisionGUID="c2affdbb-aa87-4b8a-a2d3-e2c21f9d5749" CreationDate="2014-04-17T03:59:23.890" UserId="1049" Text="&lt;gsm&gt;" />
  <row Id="3420" PostHistoryTypeId="2" PostId="1201" RevisionGUID="02058871-381b-4c0d-aabb-e699c6e2b8a9" CreationDate="2014-04-17T05:08:49.297" UserId="904" Text="I successfully run Webserver example. Now i am trying to implement editing option on webserver. I have date and time. Which display properly. Now i wanna create edit tag if press where you can edit date and time once edited that being changed while refresh. &#xD;&#xA;&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;Ethernet.h&gt;&#xD;&#xA;    byte mac[] = { &#xD;&#xA;      0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };&#xD;&#xA;    IPAddress ip(192,168,7, 100);&#xD;&#xA;    EthernetServer server(80);&#xD;&#xA;    #include &quot;Wire.h&quot;&#xD;&#xA;    #define DS1307_ADDRESS 0x68&#xD;&#xA;    byte zero = 0x00; //workaround for issue #527&#xD;&#xA;    static int dd;&#xD;&#xA;    static int mm;&#xD;&#xA;    static int yy;&#xD;&#xA;    static int s;&#xD;&#xA;    static int h;&#xD;&#xA;    static int m;&#xD;&#xA;    static int wkDay;&#xD;&#xA;    int CENTURY=2000;&#xD;&#xA;    int RTC_ERROR_FLAG=0;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void getRTCDateTime(){&#xD;&#xA;    &#xD;&#xA;      Wire.beginTransmission(DS1307_ADDRESS);&#xD;&#xA;      Wire.write(zero);&#xD;&#xA;      Wire.endTransmission();&#xD;&#xA;      Wire.requestFrom(DS1307_ADDRESS, 7);&#xD;&#xA;    &#xD;&#xA;      if(RTC_ERROR_FLAG==0)&#xD;&#xA;      {&#xD;&#xA;        //Serial.println(&quot;RTC IS ACTIVE :\n&quot;);&#xD;&#xA;        s = bcdToDec(Wire.read());&#xD;&#xA;        m = bcdToDec(Wire.read());&#xD;&#xA;        h = bcdToDec(Wire.read() &amp; 0b111111); //24 hour time&#xD;&#xA;        wkDay = bcdToDec(Wire.read()); //0-6 -&gt; sunday - Saturday&#xD;&#xA;        dd = bcdToDec(Wire.read());&#xD;&#xA;        mm = bcdToDec(Wire.read());&#xD;&#xA;        yy = CENTURY + bcdToDec(Wire.read());&#xD;&#xA;    &#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    byte decToBcd(byte val){&#xD;&#xA;      // Convert normal decimal numbers to binary coded decimal&#xD;&#xA;      return ( (val/10*16) + (val%10) );&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    byte bcdToDec(byte val)  {&#xD;&#xA;      // Convert binary coded decimal to normal decimal numbers&#xD;&#xA;      return ( (val/16*10) + (val%16) );&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int getLastTwoDigOfYear(int y){&#xD;&#xA;      return(y%1000); &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void rtcWrite(){&#xD;&#xA;    &#xD;&#xA;      Wire.beginTransmission(DS1307_ADDRESS);&#xD;&#xA;      Wire.write(zero); //stop Oscillator&#xD;&#xA;    &#xD;&#xA;      Wire.write(decToBcd(s));&#xD;&#xA;      Wire.write(decToBcd(m));&#xD;&#xA;      Wire.write(decToBcd(h));&#xD;&#xA;      Wire.write(decToBcd(wkDay));&#xD;&#xA;      Wire.write(decToBcd(dd));&#xD;&#xA;      Wire.write(decToBcd(mm));&#xD;&#xA;      Wire.write(decToBcd(getLastTwoDigOfYear(yy)));&#xD;&#xA;    &#xD;&#xA;      Wire.write(zero); //start&#xD;&#xA;    &#xD;&#xA;      Wire.endTransmission();&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      Wire.begin();&#xD;&#xA;      Ethernet.begin(mac, ip);&#xD;&#xA;      server.begin();&#xD;&#xA;      Serial.print(&quot;server is at &quot;);&#xD;&#xA;      Serial.println(Ethernet.localIP());&#xD;&#xA;    } &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      getRTCDateTime();&#xD;&#xA;      Ethernet_webserver();&#xD;&#xA;    &#xD;&#xA;      delay(1000);&#xD;&#xA;    }&#xD;&#xA;    void Ethernet_webserver()&#xD;&#xA;    {&#xD;&#xA;      EthernetClient client = server.available();&#xD;&#xA;      if (client) &#xD;&#xA;      {&#xD;&#xA;        boolean currentLineIsBlank = true;&#xD;&#xA;        while (client.connected()) {&#xD;&#xA;          if (client.available()) {&#xD;&#xA;            char c = client.read();&#xD;&#xA;            if (c == '\n' &amp;&amp; currentLineIsBlank) {&#xD;&#xA;              // send a standard http response header&#xD;&#xA;              client.println(&quot;HTTP/1.1 200 OK&quot;);&#xD;&#xA;              client.println(&quot;Content-Type: text/html&quot;);&#xD;&#xA;              client.println(&quot;Connnection: close&quot;);&#xD;&#xA;              client.println();&#xD;&#xA;              client.println(&quot;&lt;!DOCTYPE HTML&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;html&gt;&quot;);&#xD;&#xA;              // add a meta refresh tag, so the browser pulls again every 5 seconds:&#xD;&#xA;              client.println(&quot;&lt;meta http-equiv=\&quot;refresh\&quot; content=\&quot;5\&quot;&gt;&quot;);&#xD;&#xA;              // add sententence here&#xD;&#xA;              client.print(&quot;LOCAL DATE :&quot;); &#xD;&#xA;              client.print(dd);&#xD;&#xA;              client.print(&quot;/&quot;);&#xD;&#xA;              client.print(mm);&#xD;&#xA;              client.print(&quot;/&quot;);&#xD;&#xA;              client.print(yy); &#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);   &#xD;&#xA;              client.print(&quot;LOCAL TIME :&quot;); &#xD;&#xA;              client.print(h);&#xD;&#xA;              client.print(&quot;/&quot;);&#xD;&#xA;              client.print(m);&#xD;&#xA;              client.print(&quot;/&quot;);&#xD;&#xA;              client.print(s); &#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;/html&gt;&quot;);&#xD;&#xA;              break;&#xD;&#xA;            }&#xD;&#xA;            if (c == '\n') {&#xD;&#xA;              // you're starting a new line&#xD;&#xA;              currentLineIsBlank = true;&#xD;&#xA;            } &#xD;&#xA;            else if (c != '\r') {&#xD;&#xA;              // you've gotten a character on the current line&#xD;&#xA;              currentLineIsBlank = false;&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;        // give the web browser time to receive the data&#xD;&#xA;        delay(1);&#xD;&#xA;        // close the connection:&#xD;&#xA;        client.stop();&#xD;&#xA;        Serial.println(&quot;client disonnected&quot;);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3421" PostHistoryTypeId="1" PostId="1201" RevisionGUID="02058871-381b-4c0d-aabb-e699c6e2b8a9" CreationDate="2014-04-17T05:08:49.297" UserId="904" Text="Editing on Webserver using ethernet sheild" />
  <row Id="3422" PostHistoryTypeId="3" PostId="1201" RevisionGUID="02058871-381b-4c0d-aabb-e699c6e2b8a9" CreationDate="2014-04-17T05:08:49.297" UserId="904" Text="&lt;arduino-uno&gt;&lt;ethernet&gt;&lt;networking&gt;" />
  <row Id="3423" PostHistoryTypeId="2" PostId="1202" RevisionGUID="055d0057-b131-48a9-8a79-0abe1864ce3d" CreationDate="2014-04-17T07:33:16.643" UserId="1052" Text="I have been using only Arduino Uno. Now I am about to buy Mega. But a question rises. Are those 4 Serial Ports of Mega controlled still through one usb cable?" />
  <row Id="3424" PostHistoryTypeId="1" PostId="1202" RevisionGUID="055d0057-b131-48a9-8a79-0abe1864ce3d" CreationDate="2014-04-17T07:33:16.643" UserId="1052" Text="Arduino Mega's 4 Serial Ports?" />
  <row Id="3425" PostHistoryTypeId="3" PostId="1202" RevisionGUID="055d0057-b131-48a9-8a79-0abe1864ce3d" CreationDate="2014-04-17T07:33:16.643" UserId="1052" Text="&lt;serial&gt;&lt;arduino-mega&gt;" />
  <row Id="3426" PostHistoryTypeId="5" PostId="1182" RevisionGUID="3ed7d0e6-9ada-47a0-9f98-f0a0cd67aac5" CreationDate="2014-04-17T07:45:11.030" UserId="904" Comment="deleted 28311 characters in body" Text="Here it mine code . I want to perform read and write coil operation using arduino. Here read operation working fine. For assigned value master reading proper value from slave address. Now i want to write coil operation. Here value being sent from master to slave properly. But when i again read the value i found no value being update.&#xD;&#xA; I am using qmodbus as master.&#xD;&#xA;&#xD;&#xA;![read coil operation][1]&#xD;&#xA;![Mod bus Write coil operation][2]&#xD;&#xA;[Click link to see my code][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://paste.ubuntu.com/7266265/" />
  <row Id="3427" PostHistoryTypeId="2" PostId="1203" RevisionGUID="53b21668-e251-4c88-b7ad-fa9cf65e93b4" CreationDate="2014-04-17T07:49:37.900" UserId="83" Text="No. If Arduino ATmega microcontroller supports more than a single UART, then only the first one is available through the standard USB connection. Other UARTs use their own pins that you have to connect to on the board. Mind you these pins are TTL logic serial and need a converter for RS232 or similar. It is possible to use a second (third, ...) TTL-serial to USB cable to access the port on your PC." />
  <row Id="3431" PostHistoryTypeId="5" PostId="1180" RevisionGUID="34590620-8d7a-47b1-aa75-67a31dab937b" CreationDate="2014-04-17T08:44:25.767" UserId="113" Comment="updated to comply with rules. Pls Reopen." Text="I need to plot Serial Data from Arduino.&#xD;&#xA;&#xD;&#xA;I require support for:&#xD;&#xA;&#xD;&#xA; 1. Various data formats (e.g. signed, unsigned, 8 bits, 16 bits);&#xD;&#xA; 2. Plots several data on the same axes;&#xD;&#xA; 3. Exports / Imports file data.&#xD;&#xA;&#xD;&#xA;As plotting Serial Data from Arduino is a common need, my question is:&#xD;&#xA;What Programs/Utilities are available for plotting Serial Data from Arduino?&#xD;&#xA;What are the advantages / disadvantages of the method you have suggested?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://goo.gl/2c2Hb2" />
  <row Id="3432" PostHistoryTypeId="4" PostId="1180" RevisionGUID="34590620-8d7a-47b1-aa75-67a31dab937b" CreationDate="2014-04-17T08:44:25.767" UserId="113" Comment="updated to comply with rules. Pls Reopen." Text="Serial Data Plotting Programs" />
  <row Id="3433" PostHistoryTypeId="5" PostId="1180" RevisionGUID="f74ddfcc-f3e7-4262-8272-ba278a755747" CreationDate="2014-04-17T08:52:13.163" UserId="113" Comment="added 26 characters in body" Text="I need to plot Serial Data from Arduino.&#xD;&#xA;&#xD;&#xA;I require support for:&#xD;&#xA;&#xD;&#xA; 1. Various data formats (e.g. signed, unsigned, 8 bits, 16 bits);&#xD;&#xA; 2. Plots several data on the same axes;&#xD;&#xA; 3. Exports / Imports file data.&#xD;&#xA;&#xD;&#xA;As plotting Serial Data from Arduino is a common need, my question is:&#xD;&#xA;What Programs/Utilities are available for plotting Serial Data from Arduino that meet the needs above?&#xD;&#xA;What are the advantages / disadvantages of the method you have suggested?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://goo.gl/2c2Hb2" />
  <row Id="3435" PostHistoryTypeId="2" PostId="1205" RevisionGUID="dcf8212f-0084-475e-8c35-6f7c25f11524" CreationDate="2014-04-17T11:28:22.180" UserId="904" Text="I have below code With Ethernet shield.I would like to edit the date and time  using web server. Individually i tried those code working fine . Now i am trying to combine  led control and display parameter code here.I also wanted to edit Date and time let me know how to do it. What is mistake i have made here&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;Ethernet.h&gt;&#xD;&#xA;    String readString;&#xD;&#xA;    int led = 8;&#xD;&#xA;    byte mac[] = { &#xD;&#xA;      0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };&#xD;&#xA;    IPAddress ip(192,168,7, 150);&#xD;&#xA;    EthernetServer server(80);&#xD;&#xA;    int local_day=12;&#xD;&#xA;    int local_month=04;&#xD;&#xA;    int local_year=2014;&#xD;&#xA;    int local_h=12;&#xD;&#xA;    int local_m=30;&#xD;&#xA;    int local_s=21;&#xD;&#xA;    float latitude=15.08;&#xD;&#xA;    float longitude=58.05;&#xD;&#xA;    float tracker_des_angle=45.0;&#xD;&#xA;    float tracker_actual_pos=43.0;&#xD;&#xA;    int Wind_Speed=12;&#xD;&#xA;    int Wind_Kmph=120;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      while (!Serial) {&#xD;&#xA;        ; // wait for serial port to connect. Needed for Leonardo only&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      // start the Ethernet connection and the server:&#xD;&#xA;      Ethernet.begin(mac, ip);&#xD;&#xA;      server.begin();&#xD;&#xA;      Serial.print(&quot;server is at &quot;);&#xD;&#xA;      Serial.println(Ethernet.localIP());&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      Ethernet_webserver();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Ethernet_webserver()&#xD;&#xA;    {&#xD;&#xA;      EthernetClient client = server.available();&#xD;&#xA;      if (client) &#xD;&#xA;      {&#xD;&#xA;        boolean currentLineIsBlank = true;&#xD;&#xA;        while (client.connected()) &#xD;&#xA;        {&#xD;&#xA;          if (client.available())&#xD;&#xA;          {&#xD;&#xA;            char c = client.read();&#xD;&#xA;            if (c == '\n' &amp;&amp; currentLineIsBlank)&#xD;&#xA;            {&#xD;&#xA;              client.println(&quot;HTTP/1.1 200 OK&quot;);&#xD;&#xA;              client.println(&quot;Content-Type: text/html&quot;);&#xD;&#xA;              client.println(&quot;Connnection: close&quot;);&#xD;&#xA;              client.println();&#xD;&#xA;              client.println(&quot;&lt;!DOCTYPE HTML&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;html&gt;&quot;);&#xD;&#xA;              // add a meta refresh tag, so the browser pulls again every 5 seconds:&#xD;&#xA;              client.println(&quot;&lt;meta http-equiv=\&quot;refresh\&quot; content=\&quot;5\&quot;&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;TITLE&gt;NAVYA TITLE &lt;/TITLE&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;/HEAD&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;BODY&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;H1&gt;NAVYA TITLE &lt;/H1&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;hr /&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);  &#xD;&#xA;              client.println(&quot;&lt;H2&gt;NAVYA TRACKER PROJECT &lt;/H2&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);  &#xD;&#xA;              client.println(&quot;&lt;a href=\&quot;/?button1on\&quot;\&quot;&gt;Turn On LED&lt;/a&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;a href=\&quot;/?button1off\&quot;\&quot;&gt;Turn Off LED&lt;/a&gt;&lt;br /&gt;&quot;);   &#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);     &#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;); &#xD;&#xA;    &#xD;&#xA;              /*&#xD;&#xA;              client.println(&quot;&lt;!DOCTYPE HTML&gt;&quot;);&#xD;&#xA;               client.println(&quot;&lt;html&gt;&quot;);*/&#xD;&#xA;              // add a meta refresh tag, so the browser pulls again every 5 seconds:&#xD;&#xA;              //  client.println(&quot;&lt;meta http-equiv=\&quot;refresh\&quot; content=\&quot;5\&quot;&gt;&quot;);&#xD;&#xA;              // add sententence here&#xD;&#xA;              client.print(&quot;LOCAL DATE :&quot;); &#xD;&#xA;              client.print(local_day);&#xD;&#xA;              client.print(&quot;/&quot;);&#xD;&#xA;              client.print(local_month);&#xD;&#xA;              client.print(&quot;/&quot;);&#xD;&#xA;              client.print(local_year); &#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);   &#xD;&#xA;              client.print(&quot;LOCAL TIME :&quot;); &#xD;&#xA;              client.print(local_h);&#xD;&#xA;              client.print(&quot;/&quot;);&#xD;&#xA;              client.print(local_m);&#xD;&#xA;              client.print(&quot;/&quot;);&#xD;&#xA;              client.print(local_s); &#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);   &#xD;&#xA;              client.print(&quot;LATITUDE :&quot;);&#xD;&#xA;              client.print(latitude); &#xD;&#xA;              client.print(&quot;&lt;br /&gt;&quot;);   &#xD;&#xA;              client.print(&quot;LONGITUDE :&quot;);&#xD;&#xA;              client.print(longitude); &#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);   &#xD;&#xA;              client.print(&quot;DESIRED ANGLE:&quot;);&#xD;&#xA;              client.print(tracker_des_angle); &#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);   &#xD;&#xA;              client.print(&quot;ACTUAL ANGLE:&quot;);&#xD;&#xA;              client.print(tracker_actual_pos); &#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);   &#xD;&#xA;              client.print(&quot;WIND SPEED M/S:&quot;);&#xD;&#xA;              client.print(Wind_Speed); &#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);   &#xD;&#xA;              client.print(&quot;WIND SPEED KMPH:&quot;);&#xD;&#xA;              client.print(Wind_Kmph); &#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);   &#xD;&#xA;    &#xD;&#xA;              client.println(&quot;&lt;/html&gt;&quot;);&#xD;&#xA;              //break;&#xD;&#xA;            }&#xD;&#xA;            if (c == '\n') {&#xD;&#xA;              // you're starting a new line&#xD;&#xA;              currentLineIsBlank = true;&#xD;&#xA;              if (readString.indexOf(&quot;?button1on&quot;) &gt;0){&#xD;&#xA;                digitalWrite(led, HIGH);&#xD;&#xA;              }&#xD;&#xA;              if (readString.indexOf(&quot;?button1off&quot;) &gt;0){&#xD;&#xA;                digitalWrite(led, LOW);&#xD;&#xA;              }&#xD;&#xA;              readString=&quot;&quot;;  &#xD;&#xA;            } &#xD;&#xA;            else if (c != '\r') {&#xD;&#xA;              // you've gotten a character on the current line&#xD;&#xA;              currentLineIsBlank = false;&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;        // give the web browser time to receive the data&#xD;&#xA;        delay(1);&#xD;&#xA;        // close the connection:&#xD;&#xA;        client.stop();&#xD;&#xA;    &#xD;&#xA;        Serial.println(&quot;client disonnected&quot;);&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="3436" PostHistoryTypeId="1" PostId="1205" RevisionGUID="dcf8212f-0084-475e-8c35-6f7c25f11524" CreationDate="2014-04-17T11:28:22.180" UserId="904" Text="Editing option on web server using Ethernet sheild" />
  <row Id="3437" PostHistoryTypeId="3" PostId="1205" RevisionGUID="dcf8212f-0084-475e-8c35-6f7c25f11524" CreationDate="2014-04-17T11:28:22.180" UserId="904" Text="&lt;arduino-uno&gt;&lt;arduino-mega&gt;&lt;ethernet&gt;&lt;networking&gt;&lt;c&gt;" />
  <row Id="3442" PostHistoryTypeId="2" PostId="1207" RevisionGUID="bd78b794-c706-45ed-b46b-674892dffa0d" CreationDate="2014-04-17T14:00:24.670" UserId="643" Text="it is up to you.&#xD;&#xA;Welded cable is better, but you will probably need a connector, so you should take care to use low-ipendance one that can hadle your current need, like `bullet connector` used by RC toys.&#xD;&#xA;&#xD;&#xA;Also the battery should have a `discarge current` higher that the maximum current used by the engine: normaly this can be calculated by the discarge factor (labeled as 'C' on the hobbyst battery) multiplied by the capacity in Ah o the battery. Pay attention to this as this can damage the battery and alco cause lipo-fire, witch cannot pulled off with just water, you need an extinguer. (this is what happen when you short-circuit the + and -)&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3443" PostHistoryTypeId="2" PostId="1208" RevisionGUID="c0098e12-becd-4249-a3fd-edce09902ac5" CreationDate="2014-04-17T14:03:33.200" UserId="1089" Text="I bought an RF Transmitter and Receiver like these: ![RF pair][1]&#xD;&#xA;&#xD;&#xA;But how would I use them on the same arduino, I need this because it is easier to program this way. I only have one arduino, but also an ATTiny85 and there is the other one going to be used for, but using an arduino it is easier to program.&#xD;&#xA;&#xD;&#xA;So how could I do this?&#xD;&#xA;&#xD;&#xA;    #include &lt;VirtualWire.h&gt;&#xD;&#xA;    &#xD;&#xA;    const uint8_t transmitterPin = 2;&#xD;&#xA;    const uint8_t receiverPin = 12;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;    	Serial.begin(9600);&#xD;&#xA;    	pinMode(5, OUTPUT);&#xD;&#xA;    &#xD;&#xA;    	vw_set_ptt_inverted(true);&#xD;&#xA;    	vw_set_tx_pin(transmitterPin);&#xD;&#xA;    	vw_set_rx_pin(receiverPin);&#xD;&#xA;    	vw_setup(2000);&#xD;&#xA;    	vw_rx_start();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    	uint8_t buf[VW_MAX_MESSAGE_LEN];&#xD;&#xA;    	uint8_t buflen = VW_MAX_MESSAGE_LEN;&#xD;&#xA;    	&#xD;&#xA;    	char* msg = &quot;hey&quot;;&#xD;&#xA;    	vw_send((uint8_t*)msg, 3);&#xD;&#xA;    	// vw_wait_tx() we don't use this because then the data maybe is gone already&#xD;&#xA;    	&#xD;&#xA;    	vw_wait_rx();	//Wait for message&#xD;&#xA;    	if (vw_get_message(buf, &amp;buflen)) &#xD;&#xA;    	{&#xD;&#xA;    		digitalWrite(5, HIGH);&#xD;&#xA;    		delay(400);&#xD;&#xA;    		Serial.print(&quot;Got: &quot;);&#xD;&#xA;    &#xD;&#xA;    		for (int i = 0; i &lt; buflen; i++)&#xD;&#xA;    		{&#xD;&#xA;    			Serial.print(buf[i], HEX);&#xD;&#xA;    			Serial.print(' ');&#xD;&#xA;    		}&#xD;&#xA;    		Serial.println();&#xD;&#xA;    		digitalWrite(5, LOW);&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/XPL0L.png" />
  <row Id="3444" PostHistoryTypeId="1" PostId="1208" RevisionGUID="c0098e12-becd-4249-a3fd-edce09902ac5" CreationDate="2014-04-17T14:03:33.200" UserId="1089" Text="RF 433MHz Transmitter and Receiver on same Arduino" />
  <row Id="3445" PostHistoryTypeId="3" PostId="1208" RevisionGUID="c0098e12-becd-4249-a3fd-edce09902ac5" CreationDate="2014-04-17T14:03:33.200" UserId="1089" Text="&lt;virtualwire&gt;&lt;rf&gt;" />
  <row Id="3447" PostHistoryTypeId="2" PostId="1210" RevisionGUID="c2105bb0-a11b-4be5-8dcc-c1c22ef6c91e" CreationDate="2014-04-17T15:12:06.210" UserId="1015" Text="I am using Arduino Yun and I would like to disable it to work as Access Point. That is, I don't want that it is displayed in the list of available networks.&#xD;&#xA;&#xD;&#xA;Then I would like to set and use it (separately) in the following scenarios:&#xD;&#xA;&#xD;&#xA;a) Arduino Yun connected just over a given Wi-Fi network (Ethernet connection disabled).&#xD;&#xA;&#xD;&#xA;b) Arduino Yun connected just over Ethernet (Wi-Fi connection disabled).&#xD;&#xA;&#xD;&#xA;How can I make it?&#xD;&#xA;&#xD;&#xA;**Note**: In my previous attempts I tried to customize and/or disable someway the Wi-Fi connection (through the LuCI panel) in order to reach what I am looking for but in all of these cases [I had to restore my Arduino Yun][1] from scratch because it did not work anymore.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Hardware/Yun#restoring_a_yun" />
  <row Id="3448" PostHistoryTypeId="1" PostId="1210" RevisionGUID="c2105bb0-a11b-4be5-8dcc-c1c22ef6c91e" CreationDate="2014-04-17T15:12:06.210" UserId="1015" Text="How to disable Arduino Yun to work as Access Point and set it to work as needed?" />
  <row Id="3449" PostHistoryTypeId="3" PostId="1210" RevisionGUID="c2105bb0-a11b-4be5-8dcc-c1c22ef6c91e" CreationDate="2014-04-17T15:12:06.210" UserId="1015" Text="&lt;arduino-yun&gt;&lt;wifi&gt;&lt;networking&gt;&lt;ethernet&gt;" />
  <row Id="3450" PostHistoryTypeId="5" PostId="1182" RevisionGUID="c53cdd1b-58ff-4bb8-be79-c8f5620e5da7" CreationDate="2014-04-17T17:00:35.913" UserId="11" Comment="deleted 64 characters in body" Text="Here it mine code . I want to perform read and write coil operation using arduino. Here read operation working fine. For assigned value master reading proper value from slave address. Now i want to write coil operation. Here value being sent from master to slave properly. But when i again read the value i found no value being update.&#xD;&#xA;I am using qmodbus as master.&#xD;&#xA;&#xD;&#xA;[Click link to see my code][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://paste.ubuntu.com/7266265/" />
  <row Id="3451" PostHistoryTypeId="2" PostId="1211" RevisionGUID="59ac5eb5-a2c2-46cf-b1fc-038a0a47e2bc" CreationDate="2014-04-17T19:55:03.580" UserId="632" Text="I'm looking to find a suitable board for a robot I'm developing (it'll involve computer vision, else I'd be using my Arduino Micro) and I've come across two possibilities: [The Intel Galileo][1] and the [Arduino Tre][2].&#xD;&#xA;&#xD;&#xA;Now as I understand it, the Intel Galileo has a 400MHz Quark processor, whilst the Arduino Tre has 2 processors, an onboard 16MHz standard ATmega32u4 with the Arduino bootloader and then another 1GHz TI processor with Linux installed on it.&#xD;&#xA;&#xD;&#xA;However, I'm not sure of the advantages and disadvantages of each product, as price estimates appear to place them at approximately the same price (around $70) and the Intel Galileo doesn't appear to have any real advantage over the Arduino Tre (except for a full x86 instruction set).&#xD;&#xA;&#xD;&#xA;Does anyone have any information on comparison of the two boards so I can make a better informed decision?&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Moderation Note: Could someone add more relevant tags (perhaps [tag:comparison], [tag:arduino-tre] and [tag:intel-galileo])?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://store.arduino.cc/index.php?main_page=product_info&amp;products_id=522&#xD;&#xA;  [2]: http://arduino.cc/en/Main/ArduinoBoardTre" />
  <row Id="3452" PostHistoryTypeId="1" PostId="1211" RevisionGUID="59ac5eb5-a2c2-46cf-b1fc-038a0a47e2bc" CreationDate="2014-04-17T19:55:03.580" UserId="632" Text="Advantages and disadvantages of Arduino Tre versus Intel Galileo" />
  <row Id="3453" PostHistoryTypeId="3" PostId="1211" RevisionGUID="59ac5eb5-a2c2-46cf-b1fc-038a0a47e2bc" CreationDate="2014-04-17T19:55:03.580" UserId="632" Text="&lt;robotics&gt;" />
  <row Id="3454" PostHistoryTypeId="2" PostId="1212" RevisionGUID="1a93df37-b243-4d2d-b6d6-94adc94ff5a6" CreationDate="2014-04-17T20:33:47.877" UserId="1092" Text="I have built my own ATTiny programmer, but made a bit of a mistake along the way - I didn't align the headers properly, and now instead of them plugging into pins 10, 11, 12 and 13 as per the ArduinoISP example - they now plug into pins 8, 9, 10 and 11.&#xD;&#xA;&#xD;&#xA;If I use some jumper cables to wire the pins to match the ArduinoISP example, it all works fine, meaning the wiring on the actual board is OK, however, I want to be able to just plug my board I have made straight in, and thus need to get the bootloader burning and the uploading to work via pins 8, 9, 10 and 11 instead.&#xD;&#xA;&#xD;&#xA;I have tried modifying the example myself by replacing the references to RESET, MOSI, MISO and SCK with my own pin numbers, but this doesn't seem to suffice. When I try to burn the bootloader now, I get the following error:&#xD;&#xA;&#xD;&#xA;    avrdude: stk500_program_enable(): protocol error, expect=0x14, resp=0x50&#xD;&#xA;    avrdude: initialization failed, rc=-1&#xD;&#xA;             Double check connections and try again, or use -F to override&#xD;&#xA;             this check.&#xD;&#xA;    &#xD;&#xA;    avrdude: stk500_disable(): protocol error, expect=0x14, resp=0x51&#xD;&#xA;&#xD;&#xA;If I try to upload a sketch using my version which has the custom pin numbers, I get this error:&#xD;&#xA;&#xD;&#xA;    avrdude: stk500_getsync(): not in sync: resp=0x00&#xD;&#xA;&#xD;&#xA;The wiring of my programmer is the same as can be found here: http://highlowtech.org/?p=1706 except I want the programmer sketch to work with different pins.&#xD;&#xA;&#xD;&#xA;Thanks" />
  <row Id="3455" PostHistoryTypeId="1" PostId="1212" RevisionGUID="1a93df37-b243-4d2d-b6d6-94adc94ff5a6" CreationDate="2014-04-17T20:33:47.877" UserId="1092" Text="Changing pins used in ArduinoISP example" />
  <row Id="3456" PostHistoryTypeId="3" PostId="1212" RevisionGUID="1a93df37-b243-4d2d-b6d6-94adc94ff5a6" CreationDate="2014-04-17T20:33:47.877" UserId="1092" Text="&lt;bootloader&gt;&lt;isp&gt;&lt;attiny&gt;" />
  <row Id="3457" PostHistoryTypeId="11" PostId="1180" RevisionGUID="f601a2ea-c2fc-4c07-b443-57deeb99e539" CreationDate="2014-04-17T20:41:44.213" UserId="220" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:46,&quot;DisplayName&quot;:&quot;Ricardo&quot;},{&quot;Id&quot;:313,&quot;DisplayName&quot;:&quot;JRobert&quot;},{&quot;Id&quot;:84,&quot;DisplayName&quot;:&quot;jfpoilpret&quot;},{&quot;Id&quot;:220,&quot;DisplayName&quot;:&quot;Annonomus Person&quot;}]}" />
  <row Id="3458" PostHistoryTypeId="2" PostId="1213" RevisionGUID="9200b579-24ba-418a-86a4-73be248036da" CreationDate="2014-04-17T20:48:53.133" UserId="337" Text="You can't change the pins.&#xD;&#xA;&#xD;&#xA;ArduinoISP uses the SPI interface on pins 10-13 which is provided by the underlying AVR hardware." />
  <row Id="3459" PostHistoryTypeId="5" PostId="1211" RevisionGUID="a92168f0-3b60-40c3-9164-a5fd3571d46f" CreationDate="2014-04-17T21:30:50.243" UserId="220" Comment="Edited tags, made question more general: a disadvantage for one might be an advantage for another" Text="I'm looking to find a suitable board for a robot I'm developing (it'll involve computer vision, else I'd be using my Arduino Micro) and I've come across two possibilities: [The Intel Galileo][1] and the [Arduino Tre][2].&#xD;&#xA;&#xD;&#xA;Now as I understand it, the Intel Galileo has a 400MHz Quark processor, whilst the Arduino Tre has 2 processors, an onboard 16MHz standard ATmega32u4 with the Arduino bootloader and then another 1GHz TI processor with Linux installed on it.&#xD;&#xA;&#xD;&#xA;However, I'm not sure of the differences between both products, as price estimates appear to place them at approximately the same price (around $70) and the Intel Galileo doesn't appear to have any real advantage over the Arduino Tre (except for a full x86 instruction set).&#xD;&#xA;&#xD;&#xA;Does anyone have any information on comparison of the two boards so I can make a better informed decision?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://store.arduino.cc/index.php?main_page=product_info&amp;products_id=522&#xD;&#xA;  [2]: http://arduino.cc/en/Main/ArduinoBoardTre" />
  <row Id="3460" PostHistoryTypeId="4" PostId="1211" RevisionGUID="a92168f0-3b60-40c3-9164-a5fd3571d46f" CreationDate="2014-04-17T21:30:50.243" UserId="220" Comment="Edited tags, made question more general: a disadvantage for one might be an advantage for another" Text="What are the main differences between the Arduino Tre and the Intel Galileo?" />
  <row Id="3461" PostHistoryTypeId="6" PostId="1211" RevisionGUID="a92168f0-3b60-40c3-9164-a5fd3571d46f" CreationDate="2014-04-17T21:30:50.243" UserId="220" Comment="Edited tags, made question more general: a disadvantage for one might be an advantage for another" Text="&lt;robotics&gt;&lt;arduino-tre&gt;&lt;arduino-galileo&gt;" />
  <row Id="3462" PostHistoryTypeId="6" PostId="917" RevisionGUID="36ce1f89-e2dc-418a-a560-1f95802cfe31" CreationDate="2014-04-17T21:43:11.353" UserId="220" Comment="edited tags" Text="&lt;map&gt;&lt;code-optimization&gt;" />
  <row Id="3463" PostHistoryTypeId="2" PostId="1214" RevisionGUID="6652dc74-f8f1-4417-9fae-afb9aa6c0476" CreationDate="2014-04-17T23:28:18.500" UserId="353" Text="As a practical matter, you're much better off correcting things so you're using the original pins, which correspond to hardware SPI. &#xD;&#xA;&#xD;&#xA;However, it's not terribly hard to implement SPI in software (at a lower performance, of course):&#xD;&#xA;&#xD;&#xA;    static uint8_t &#xD;&#xA;    SPITransfer(uint8_t out)&#xD;&#xA;    {&#xD;&#xA;        uint8_t in = 0;&#xD;&#xA;        for (int i=0; i&lt;8; ++i) {&#xD;&#xA;            digitalWrite(MOSI, (out &amp; 0x80) != 0);&#xD;&#xA;            out &lt;&lt;= 1;&#xD;&#xA;            digitalWrite(SCK, HIGH);&#xD;&#xA;            in = (in &lt;&lt; 1) | digitalRead(MISO);&#xD;&#xA;            digitalWrite(SCK, LOW);&#xD;&#xA;        }&#xD;&#xA;        return in;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;There are several SPI modes, but this implements the one used for ISP.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3464" PostHistoryTypeId="2" PostId="1215" RevisionGUID="1acf40ec-013b-46dc-8d99-03bf6fa13db3" CreationDate="2014-04-17T23:49:49.450" UserId="220" Text="## Biggest difference IMHO: Tre hasn't been released yet!&#xD;&#xA;Besides that, there are a few different things that you should compare. Not much is available about the Tre as of now, but I'll update this post when it's released.&#xD;&#xA;&#xD;&#xA;****&#xD;&#xA;## *Basic Specs:* [First sub-bullet is TRE, second Galileo; better spec in bold]&#xD;&#xA; - Microcontroller:&#xD;&#xA;  - Texas Instrument Sitara AM3359AZCZ100 (ARM Cortex-A8) (**1 GHz,** 32 bit), Atmel ATmega32u4 (16 MHz, Secondary, found on Leonardo)&#xD;&#xA;  - Intel® Quark SoC X1000 (400 MHz, 32 bit)&#xD;&#xA; - RAM:&#xD;&#xA;  - 512 MB SRAM (2.5 KB ATmega32u4)&#xD;&#xA;  - 512 MB SRAM&#xD;&#xA; - Pins&#xD;&#xA;  - **14 Digital 5V, 7 of which are PWM, 6 analog 5V (additional 6 multiplexed) (32u4); 12 Digital 3.3V, 4 of those are PWM (Sitara)**&#xD;&#xA;  - 14 5V digital, 6 of those are PWM&#xD;&#xA; - Networking:&#xD;&#xA;  - Ethernet 10/100&#xD;&#xA;  - Ethernet 10/100&#xD;&#xA; - USB port:&#xD;&#xA;  - 1 USB as slave, 4 USB host ports&#xD;&#xA;  - Up to 128 devices as host, 1 USB slave&#xD;&#xA; - Video&#xD;&#xA;  - **HDMI (1920x1080), LCD header**&#xD;&#xA;  - None that I can find&#xD;&#xA; - Audio&#xD;&#xA;  - HDMI, stereo analog audio input and output&#xD;&#xA;  - None that I can find&#xD;&#xA; - MicroSD card&#xD;&#xA;  - Yes&#xD;&#xA;  - Yes&#xD;&#xA; - PCIe Slot&#xD;&#xA;  - No&#xD;&#xA;  - **Yes**&#xD;&#xA;&#xD;&#xA;Sources (I combined a bunch of data for this): [Galileo](http://arduino.cc/en/ArduinoCertified/IntelGalileo) &amp; [Tre](http://arduino.cc/en/Main/ArduinoBoardTre)&#xD;&#xA;****&#xD;&#xA;**Conclusion:** If you need a board before the Tre comes out, which seems to be soon (Spring 2014), Galileo is your only option. Other than that, the Tre seems to be better all around in most aspects, minus the PCIe slot. I can't comment on power, but it seems like the Tre will be able to supply 4x the power per pin than the Galileo. The Galileo is getting older, and it doesn't seem like the Galileo can provide full Linux support like the Tre will.&#xD;&#xA;&#xD;&#xA;Personally, I'd wait for the Tre. The *only* thing I can think that the Galileo would be better for would be either a.) lower power usage or b.) the PCIe slot for a WiFi adapter that works decently. The second one could be solved by [doing a common WiFi router hack](http://www.instructables.com/id/Cheap-and-Easy-Arduino-Wi-Fi-Hack/0).&#xD;&#xA;&#xD;&#xA;If you need a lot of processing power without the need of low latency, you should conciser sending data to a computer to process.&#xD;&#xA;&#xD;&#xA;&gt; &lt;img src=&quot;http://arduino.cc/en/uploads/Main/ArduinoTre_LandingPage.jpg&quot;&gt;&#xD;&#xA;&#xD;&#xA;[Source](http://arduino.cc/en/uploads/Main/ArduinoTre_LandingPage.jpg)&#xD;&#xA;&gt; &lt;img src=&quot;http://arduino.cc/en/uploads/ArduinoCertified/IntelGalileo_fabD_Front.jpg&quot;&gt;&#xD;&#xA;&#xD;&#xA;[Source](http://arduino.cc/en/uploads/ArduinoCertified/IntelGalileo_fabD_Front.jpg)" />
  <row Id="3465" PostHistoryTypeId="2" PostId="1216" RevisionGUID="2d973360-da72-467f-97f1-decfb648c87d" CreationDate="2014-04-17T23:50:45.257" UserId="1095" Text="I'm trying to make my first library for Arduino and for the life of me I cannot figure out how to make a servo object in my library!!! Can someone please help??" />
  <row Id="3466" PostHistoryTypeId="1" PostId="1216" RevisionGUID="2d973360-da72-467f-97f1-decfb648c87d" CreationDate="2014-04-17T23:50:45.257" UserId="1095" Text="Servo object in my own library?" />
  <row Id="3467" PostHistoryTypeId="3" PostId="1216" RevisionGUID="2d973360-da72-467f-97f1-decfb648c87d" CreationDate="2014-04-17T23:50:45.257" UserId="1095" Text="&lt;library&gt;" />
  <row Id="3468" PostHistoryTypeId="5" PostId="1216" RevisionGUID="705df5ba-1969-4858-9731-21bf48de818e" CreationDate="2014-04-17T23:59:15.267" UserId="220" Comment="Changed tone of post" Text="I'm trying to make my first library for Arduino and for the make a servo object in my library. How can I do this?" />
  <row Id="3469" PostHistoryTypeId="4" PostId="1216" RevisionGUID="705df5ba-1969-4858-9731-21bf48de818e" CreationDate="2014-04-17T23:59:15.267" UserId="220" Comment="Changed tone of post" Text="How do I initialize a servo object in my own library?" />
  <row Id="3470" PostHistoryTypeId="5" PostId="1216" RevisionGUID="ca5ace0e-5ee4-4c79-beca-b52d5e6e16c6" CreationDate="2014-04-18T00:09:24.420" UserId="11" Comment="deleted 1 character in body" Text="I'm trying to make my first library for Arduino and want to use a servo object in my library. How can I do this?" />
  <row Id="3471" PostHistoryTypeId="2" PostId="1217" RevisionGUID="6c9893b7-c042-4ed1-97c4-408c54be882e" CreationDate="2014-04-18T00:50:07.537" UserId="220" Text="**This is a simple solution.** All you need to do is declare a *global variable* (i.e. make it accessible everywhere in your sketch), and then add some additional code to &quot;share&quot; the servo between the different parts of the code.&#xD;&#xA;&#xD;&#xA;## Code you need:&#xD;&#xA;&#xD;&#xA;**Your library:**&#xD;&#xA;&#xD;&#xA;    Servo servoname;&#xD;&#xA;    void foo() {&#xD;&#xA;      //Some code here!&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void bar() {&#xD;&#xA;      //More code here!&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The methods `foo()` and `bar()` are irreverent to the code, you just need to declare it.&#xD;&#xA;&#xD;&#xA;**Your library header file (`name.h`):**&#xD;&#xA;&#xD;&#xA;    extern Servo servoname;&#xD;&#xA;All you need to do then is import your new library and use `servoname`. You will have to still call `servoname.attach([pin]);` before you can use the servo, but then you just need to use the servo.&#xD;&#xA;&#xD;&#xA;*[Source](http://stackoverflow.com/questions/1045501/how-do-i-share-variables-between-different-c-files)*" />
  <row Id="3472" PostHistoryTypeId="2" PostId="1218" RevisionGUID="3f39efb2-8193-4eb9-87e8-1d019818e5a0" CreationDate="2014-04-18T01:13:41.930" UserId="86" Text="I use [Matplotlib][1] for any plotting I need to do.&#xD;&#xA;&#xD;&#xA;It's not arduino specific in any way, but it is a very excellent *Python* plotting toolkit.&#xD;&#xA;&#xD;&#xA;I've built a number of applications that plot data from a variety of microcontrollers in real-time to a graph, but that was really more of a two-step process: 1. Get data from device into computer, 2. plot realtime data.&#xD;&#xA;&#xD;&#xA;Really, I think you should break your question into two parts:&#xD;&#xA;&#xD;&#xA; - How do you get data from an Arduino/Any serial device into a computer easily.&#xD;&#xA; - What is a good plotting library that is easy to use.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://matplotlib.org/" />
  <row Id="3473" PostHistoryTypeId="2" PostId="1219" RevisionGUID="fcb3c785-0b8a-470a-b00f-782f108b5638" CreationDate="2014-04-18T08:07:18.610" UserId="27" Text="Yun expects wifi to be working and, if it's not, it will reboot itself after 60 seconds and return in access point mode.&#xD;&#xA;&#xD;&#xA;In order to disable this check, edit file `/etc/rc.local` and turn `wifi-live-or-reset` into `#wifi-live-or-reset` (with a starting `#`).&#xD;&#xA;&#xD;&#xA;Once done, use LuCI (the advanced configuration panel) to configure network interfaces." />
  <row Id="3474" PostHistoryTypeId="5" PostId="1215" RevisionGUID="75813fc7-0e41-4d05-aef8-994875e9589a" CreationDate="2014-04-18T08:42:10.730" UserId="84" Comment="Added missing Galileo analog inputs" Text="## Biggest difference IMHO: Tre hasn't been released yet!&#xD;&#xA;Besides that, there are a few different things that you should compare. Not much is available about the Tre as of now, but I'll update this post when it's released.&#xD;&#xA;&#xD;&#xA;****&#xD;&#xA;## *Basic Specs:* [First sub-bullet is TRE, second Galileo; better spec in bold]&#xD;&#xA; - Microcontroller:&#xD;&#xA;  - Texas Instrument Sitara AM3359AZCZ100 (ARM Cortex-A8) (**1 GHz,** 32 bit), Atmel ATmega32u4 (16 MHz, Secondary, found on Leonardo)&#xD;&#xA;  - Intel® Quark SoC X1000 (400 MHz, 32 bit)&#xD;&#xA; - RAM:&#xD;&#xA;  - 512 MB SRAM (2.5 KB ATmega32u4)&#xD;&#xA;  - 512 MB SRAM&#xD;&#xA; - Pins&#xD;&#xA;  - **14 Digital 5V, 7 of which are PWM, 6 analog 5V (additional 6 multiplexed) (32u4); 12 Digital 3.3V, 4 of those are PWM (Sitara)**&#xD;&#xA;  - 14 5V digital, 6 of those are PWM, 6 analog 5V&#xD;&#xA; - Networking:&#xD;&#xA;  - Ethernet 10/100&#xD;&#xA;  - Ethernet 10/100&#xD;&#xA; - USB port:&#xD;&#xA;  - 1 USB as slave, 4 USB host ports&#xD;&#xA;  - Up to 128 devices as host, 1 USB slave&#xD;&#xA; - Video&#xD;&#xA;  - **HDMI (1920x1080), LCD header**&#xD;&#xA;  - None that I can find&#xD;&#xA; - Audio&#xD;&#xA;  - HDMI, stereo analog audio input and output&#xD;&#xA;  - None that I can find&#xD;&#xA; - MicroSD card&#xD;&#xA;  - Yes&#xD;&#xA;  - Yes&#xD;&#xA; - PCIe Slot&#xD;&#xA;  - No&#xD;&#xA;  - **Yes**&#xD;&#xA;&#xD;&#xA;Sources (I combined a bunch of data for this): [Galileo](http://arduino.cc/en/ArduinoCertified/IntelGalileo) &amp; [Tre](http://arduino.cc/en/Main/ArduinoBoardTre)&#xD;&#xA;****&#xD;&#xA;**Conclusion:** If you need a board before the Tre comes out, which seems to be soon (Spring 2014), Galileo is your only option. Other than that, the Tre seems to be better all around in most aspects, minus the PCIe slot. I can't comment on power, but it seems like the Tre will be able to supply 4x the power per pin than the Galileo. The Galileo is getting older, and it doesn't seem like the Galileo can provide full Linux support like the Tre will.&#xD;&#xA;&#xD;&#xA;Personally, I'd wait for the Tre. The *only* thing I can think that the Galileo would be better for would be either a.) lower power usage or b.) the PCIe slot for a WiFi adapter that works decently. The second one could be solved by [doing a common WiFi router hack](http://www.instructables.com/id/Cheap-and-Easy-Arduino-Wi-Fi-Hack/0).&#xD;&#xA;&#xD;&#xA;If you need a lot of processing power without the need of low latency, you should conciser sending data to a computer to process.&#xD;&#xA;&#xD;&#xA;&gt; &lt;img src=&quot;http://arduino.cc/en/uploads/Main/ArduinoTre_LandingPage.jpg&quot;&gt;&#xD;&#xA;&#xD;&#xA;[Source](http://arduino.cc/en/uploads/Main/ArduinoTre_LandingPage.jpg)&#xD;&#xA;&gt; &lt;img src=&quot;http://arduino.cc/en/uploads/ArduinoCertified/IntelGalileo_fabD_Front.jpg&quot;&gt;&#xD;&#xA;&#xD;&#xA;[Source](http://arduino.cc/en/uploads/ArduinoCertified/IntelGalileo_fabD_Front.jpg)" />
  <row Id="3475" PostHistoryTypeId="2" PostId="1220" RevisionGUID="831a778c-a877-4c79-ad42-2099441f26db" CreationDate="2014-04-18T10:40:37.260" UserId="973" Text="Really the only way to proceed is create a spreadsheet showing the pin positions used by this board, the Arduino signals they plug into on Uno, and the signals that they plug into on Mega2560. In the column for Mega2560, find the signals that are not the same as those on Uno. Then either make some way to wire the problem pins on the shield to the correct pins on Mega, OR figure out how to change the code so that it drives the pins as the are connected on the Mega2560" />
  <row Id="3476" PostHistoryTypeId="5" PostId="1220" RevisionGUID="367d20c3-4303-490f-a258-384eef5bf809" CreationDate="2014-04-18T11:46:51.360" UserId="973" Comment="Better description of Mega2560 vs Uno shield pins" Text="A way to proceed is to create a spreadsheet showing the pin positions used by this board, and the Arduino shield signals they plug into. Next to these, you need columns showing the actual signals on the ATMega2560 (for Mega2560) and ATMega328 (for Uno) that these shield pins attach to. You can get this info from the Uno and Mega2560 schematic drawings.&#xD;&#xA;&#xD;&#xA;In a quick look, it seems that the Arduino shield pin names for Uno and Mega are the same: for example, shield pin '0' (digital zero) is in the same location on both boards, and likewise for other pins. &#xD;&#xA;&#xD;&#xA;However, on the Uno digital-0 attaches to ATMega328 Port D bit 0, while on the Mega2560, it attaches to ATMega2560 Port E bit 0. And things get more obtuse with digital 2..7.&#xD;&#xA;&#xD;&#xA;Now, when twiddling bits individually using digitalWrite(pin, value), the Arduino library no doubt takes care of translating to the appropriate port/bits that need to be set for the ATMega chip that's in use. However, libraries that use lower-level functions (especially if they need to write entire bytes to ports, as a fast LCD library might) will need to take their own steps to make this translation.&#xD;&#xA;&#xD;&#xA;So... first step is to determine whether there is a separate LCD driver library for Mega2560. &#xD;&#xA;&#xD;&#xA;Next, investigate whether the library you have has initialization code that is supposed to determine what board it's running on (and is your board included?), or requires you to set some flag to tell it what board is in use.&#xD;&#xA;&#xD;&#xA;Failing that, you _could_ create a mess of jumpers or some other wiring scheme to jumper the Mega's ATMega2560's signals so that it's wired up like a Uno would be. It's not clear that this is possible, since some of ATMega2560's Port D is not even wired to a header.&#xD;&#xA;&#xD;&#xA;Or you could look at the source code for the library and see what it's actually doing, and what it would need to do different to operate the ATMega 2560 pins that the shield does connect to." />
  <row Id="3477" PostHistoryTypeId="2" PostId="1221" RevisionGUID="d2bba2cc-da8f-4d4a-a42f-2b7bd7b288d9" CreationDate="2014-04-18T14:14:26.397" UserId="1100" Text="I am planning on making a simple stopwatch with a display and one or two buttons to start the stopwatch and stop the stopwatch and maybe reset it.&#xD;&#xA;The problem is that it has to be as small as possible.&#xD;&#xA;With all those different Arduino boards out there, I don't know which one I should buy (mini, micro, nano, ...).&#xD;&#xA;Also, I am not sure how many pins I need for the LCD since I have read that in fact not all pins are mandatory for the LCD. I have done something earlier with an LCD and I found the pot meter for the LCD contrast level a bit of waste of space. Could I just replace it with a certain resistor or something?&#xD;&#xA;How many pins in the end would I need and which board would be fitting for this little project?&#xD;&#xA;&#xD;&#xA;Thanks in advance, peepz!" />
  <row Id="3478" PostHistoryTypeId="1" PostId="1221" RevisionGUID="d2bba2cc-da8f-4d4a-a42f-2b7bd7b288d9" CreationDate="2014-04-18T14:14:26.397" UserId="1100" Text="Arduino stopwatch, which board to use?" />
  <row Id="3479" PostHistoryTypeId="3" PostId="1221" RevisionGUID="d2bba2cc-da8f-4d4a-a42f-2b7bd7b288d9" CreationDate="2014-04-18T14:14:26.397" UserId="1100" Text="&lt;arduino-nano&gt;&lt;arduino-pro-mini&gt;&lt;arduino-pro-micro&gt;" />
  <row Id="3480" PostHistoryTypeId="2" PostId="1222" RevisionGUID="4eac8467-cd73-48d0-85ec-18b3d0db5588" CreationDate="2014-04-18T17:22:11.233" UserId="1103" Text="I'm using an arduino UNO, and i want to turn a motor a set number of revolutions, i'm trying to read the clicks of the encoder which has a resolution of 360 clicks/ revolution, my logic is that i count the number of clicks until i get to the desired number which represents the the number of revolutions * the resolution of the encoder:&#xD;&#xA;1 revolution ==&gt; 360 clicks  &#xD;&#xA;5 revolutions ==&gt; 360*5 (desired number)&#xD;&#xA;&#xD;&#xA;i'm a beginner with arduino so here is my code:&#xD;&#xA;&#xD;&#xA;    int motor=5;  // motor is connected to pin 5&#xD;&#xA;&#xD;&#xA;    void setup(){&#xD;&#xA;&#xD;&#xA;    pinMode(motor,OUTPUT);&#xD;&#xA;    attachInterrupt(0, count,RISING); // attaching encoder on interrupt 0&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop(){&#xD;&#xA;&#xD;&#xA;    while(counter&lt; 360*5){&#xD;&#xA;    analogWrite(motor,255);&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void count(){&#xD;&#xA;    counter++;&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;This code is not working at all, how can i fix it?" />
  <row Id="3481" PostHistoryTypeId="1" PostId="1222" RevisionGUID="4eac8467-cd73-48d0-85ec-18b3d0db5588" CreationDate="2014-04-18T17:22:11.233" UserId="1103" Text="Turning a DC motor a set number of Rotations using an encoder" />
  <row Id="3482" PostHistoryTypeId="3" PostId="1222" RevisionGUID="4eac8467-cd73-48d0-85ec-18b3d0db5588" CreationDate="2014-04-18T17:22:11.233" UserId="1103" Text="&lt;arduino-uno&gt;&lt;rotary-encoder&gt;" />
  <row Id="3483" PostHistoryTypeId="5" PostId="1222" RevisionGUID="f8d9bcd8-c854-4ed4-a007-e19fd45c3269" CreationDate="2014-04-18T17:23:12.533" UserId="11" Comment="added 18 characters in body" Text="I'm using an arduino UNO, and i want to turn a motor a set number of revolutions, i'm trying to read the clicks of the encoder which has a resolution of 360 clicks/ revolution, my logic is that i count the number of clicks until i get to the desired number which represents the the number of revolutions * the resolution of the encoder:&#xD;&#xA;&#xD;&#xA;1 revolution ==&gt; 360 clicks  &#xD;&#xA;5 revolutions ==&gt; 360*5 (desired number)&#xD;&#xA;&#xD;&#xA;i'm a beginner with arduino so here is my code:&#xD;&#xA;&#xD;&#xA;    int motor=5;  // motor is connected to pin 5&#xD;&#xA;&#xD;&#xA;    void setup(){&#xD;&#xA;      pinMode(motor,OUTPUT);&#xD;&#xA;      attachInterrupt(0, count,RISING); // attaching encoder on interrupt 0&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop(){&#xD;&#xA;      while(counter&lt; 360*5){&#xD;&#xA;        analogWrite(motor,255);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void count(){&#xD;&#xA;      counter++;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This code is not working at all, how can i fix it?" />
  <row Id="3486" PostHistoryTypeId="5" PostId="1222" RevisionGUID="80b26183-75a2-4f81-b0d4-1cec9443d734" CreationDate="2014-04-18T18:34:56.173" UserId="11" Comment="added 29 characters in body" Text="I'm using an arduino UNO, and i want to turn a motor a set number of revolutions, i'm trying to read the clicks of the encoder which has a resolution of 360 clicks/ revolution, my logic is that i count the number of clicks until i get to the desired number which represents the the number of revolutions * the resolution of the encoder:&#xD;&#xA;&#xD;&#xA;1 revolution ==&gt; 360 clicks  &#xD;&#xA;5 revolutions ==&gt; 360*5 (desired number)&#xD;&#xA;&#xD;&#xA;i'm a beginner with arduino so here is my code:&#xD;&#xA;&#xD;&#xA;    volatile int counter=0;&#xD;&#xA;    int motor=5;  // motor is connected to pin 5&#xD;&#xA;&#xD;&#xA;    void setup(){&#xD;&#xA;      pinMode(motor,OUTPUT);&#xD;&#xA;      attachInterrupt(0, count,RISING); // attaching encoder on interrupt 0&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop(){&#xD;&#xA;      while(counter&lt; 360*5){&#xD;&#xA;        analogWrite(motor,255);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void count(){&#xD;&#xA;      counter++;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This code is not working at all, how can i fix it?" />
  <row Id="3487" PostHistoryTypeId="2" PostId="1224" RevisionGUID="50b658be-0257-49b6-a2c2-cdc138c45b0f" CreationDate="2014-04-18T18:40:27.003" UserId="612" Text="You never tell the motor to stop.&#xD;&#xA;&#xD;&#xA;    void loop(){&#xD;&#xA;       while(counter&lt; 360*5){&#xD;&#xA;         analogWrite(motor,255);&#xD;&#xA;       }&#xD;&#xA;       analogWrite(motor, 0); //add something like this or whatever could stop it&#xD;&#xA;       //you may want to disable the counter now too&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;However, even with that change you are likely a long way from having a working, or at least reliable system - see other issues in my comment on the question.&#xD;&#xA;" />
  <row Id="3488" PostHistoryTypeId="5" PostId="1221" RevisionGUID="8e2f59fb-af41-4307-9372-387f9bab5517" CreationDate="2014-04-18T21:09:06.740" UserId="220" Comment="Edited tags, improved flow of post, removed signature" Text="I am planning on making a simple stopwatch with:&#xD;&#xA;&#xD;&#xA; - A display &#xD;&#xA; - One or two additional buttons to start the stopwatch and stop the stopwatch and&#xD;&#xA;   maybe reset it.&#xD;&#xA;&#xD;&#xA;The problem is that it has to be as small as possible.&#xD;&#xA;With all those different Arduino boards out there, I don't know which one I should buy (mini, micro, nano, ...).&#xD;&#xA;&#xD;&#xA;I am not sure how many pins I need for the LCD since I have read that in fact not all pins are mandatory for the LCD. I have done something earlier with an LCD and I found the pot meter for the LCD contrast level a bit of waste of space. Could I just replace it with a certain resistor or something?&#xD;&#xA;&#xD;&#xA;How many pins in the end would I need and which board would be fitting for this little project?" />
  <row Id="3489" PostHistoryTypeId="6" PostId="1221" RevisionGUID="8e2f59fb-af41-4307-9372-387f9bab5517" CreationDate="2014-04-18T21:09:06.740" UserId="220" Comment="Edited tags, improved flow of post, removed signature" Text="&lt;arduino-nano&gt;&lt;system-design&gt;&lt;arduino-pro-mini&gt;&lt;arduino-pro-micro&gt;" />
  <row Id="3490" PostHistoryTypeId="2" PostId="1225" RevisionGUID="92d0d449-376e-4834-b261-d7a9a7662361" CreationDate="2014-04-18T21:15:14.107" UserId="313" Text="[GnuPlot](http://www.gnuplot.info/)&#xD;&#xA;&#xD;&#xA; Advantages: It's very flexible, scriptable, and freely available. &#xD;&#xA;&#xD;&#xA;Disadvantages: A bit complex to learn (but I figured out how to get started in a few minutes, and quite functional in an hour or two), runs in a terminal window (if you consider that a disadvantage). &#xD;&#xA;&#xD;&#xA;Something I found very useful was to script it to reload my terminal program's logfile periodically so i got a dynamic graph as my experiment progressed.     " />
  <row Id="3491" PostHistoryTypeId="2" PostId="1226" RevisionGUID="d8585295-fea1-4e6d-82e4-e0bb5fcc2b43" CreationDate="2014-04-18T21:37:25.320" UserId="220" Text="**By that [photo](http://arduino.cc/en/uploads/Tutorial/LCD_bb.png) you posted, you pretty much answered a decent part of your question.** You'll need six pins for the LCD, and one or two for the button. That means that you need a *total* of 8 pins. That Uno pictured has 20 (analog can act as digital, too).&#xD;&#xA;&#xD;&#xA;As far as the boards, if you feel comfortable with some extra work, I'd recommend an ATtiny. From what I can find, it seems like you can drive a LCD with a 44 or an 84 (similar, but the 84 is more powerful).&#xD;&#xA;&#xD;&#xA;&gt; &lt;img src=&quot;http://highlowtech.org/wp-content/uploads/2011/10/ATtiny44-84.png&quot;&gt;&#xD;&#xA;&#xD;&#xA;*[Source for image and how to program chip](http://highlowtech.org/?p=1695)*. I'm not going to go into the details for this method, as the link has the necessary files...&#xD;&#xA;****&#xD;&#xA;That's the smallest way to do this*, however, if you want to use a real Arduino board, then I'd recommend the Micro for a few reasons.&#xD;&#xA;&#xD;&#xA;First of all, it has the newer ATMEGA32u4 chip, found on the Leonardo. I do *not* recommend the Mini because, although it's the smallest of the three, it doesn't feature on board USB. You would have to buy another adapter to program it. If you're already using a breadboard, the extra 2cm (or so) is worth not having to spend *more* to buy both of those components. The Nano is the equivalent of the Mini, only with USB. Also, the Nano and the Micro are roughly the same size, one a little bit longer and one a little bit wider.&#xD;&#xA;&#xD;&#xA;However, the Nano and Micro are roughly the same as far as processing power, so I'd recommend that, if you can get one significantly cheaper, to go with that. It doesn't really matter that much.&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;*If you're building this on a breadboard, it won't be smaller. If you're transferring to a PCB, then you should use an ATtiny.&lt;/sub&gt;&#xD;&#xA;****&#xD;&#xA;As far as the pot goes, I'd recommend getting a *trimmer* with an equivalent value. Some of them are very small, as I have one that fits on the USB connector part of my thumb drive. They need a screwdriver to adjust, but I would recommend it. I've had issues moving it from a dark room to in the sun and not being able to see it clearly. Spend the two cents and the 2 cm&lt;sup&gt;2&lt;/sup&gt; and have an opportunity to change it if needed.&#xD;&#xA;&#xD;&#xA;For the battery, I would recommend any rechargeable battery (under ~3.5V) **if and *only* if** you add a proper chip to not waste energy in the conversion. I talked about this in [this post](http://arduino.stackexchange.com/questions/665/powering-arduino-with-solar-panels/667#667)." />
  <row Id="3495" PostHistoryTypeId="2" PostId="1228" RevisionGUID="0caa35fa-b8ab-44a9-936a-97227b0ec03d" CreationDate="2014-04-19T08:43:10.460" UserId="904" Text="I have wind speed sensor that can measure max speed upto 30 m/s with analog out put 0-5v. I have simple code calling from loop. when i put Wind speed average code Web server is not working and it just hangs. If i comment out web server working fine. Let me know What makes &#xD;&#xA;web server to get hanged or not get connected.Is there any way i can change average taking code.&#xD;&#xA;&#xD;&#xA;    Working  should like below:&#xD;&#xA;    if wind speed exceed 30 m/s &#xD;&#xA;       mode =stow&#xD;&#xA;    else &#xD;&#xA;       mode =track&#xD;&#xA;&#xD;&#xA; My code. And how can write average of windload of day to SDcard&#xD;&#xA;&#xD;&#xA;    #include&quot;wind.h&quot;&#xD;&#xA;    #include&quot;mode.h&quot;&#xD;&#xA;    &#xD;&#xA;    float sampleAverage(void)&#xD;&#xA;    {&#xD;&#xA;      float accumulator = 0;&#xD;&#xA;      for (int i = 0; i &lt; SAMPLE_COUNT; i++)&#xD;&#xA;      {&#xD;&#xA;        accumulator += sample[i];&#xD;&#xA;      }&#xD;&#xA;      return accumulator / SAMPLE_COUNT;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void Wind_calc()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;      static unsigned long lastSampleTime = 0;&#xD;&#xA;      unsigned long currentTime = millis();&#xD;&#xA;    &#xD;&#xA;      // check if time for new reading&#xD;&#xA;      if (currentTime - lastSampleTime &gt;= SAMPLE_RATE)&#xD;&#xA;      {&#xD;&#xA;        lastSampleTime = currentTime;&#xD;&#xA;        int sensorValue = analogRead(SENSOR_PIN);&#xD;&#xA;        float voltage = sensorValue * (5.0 / 1023.0);&#xD;&#xA;        /* Serial.print(&quot;voltage: &quot;);&#xD;&#xA;         Serial.println(voltage);*/&#xD;&#xA;        // add the newest reading at the oldest pointer&#xD;&#xA;        sample[sampleIndex] = voltage;&#xD;&#xA;        // advance to next index which is now oldest&#xD;&#xA;        sampleIndex++;&#xD;&#xA;        // check for and handle rollover&#xD;&#xA;        if (sampleIndex == SAMPLE_COUNT)&#xD;&#xA;        {&#xD;&#xA;          sampleIndex = 0;&#xD;&#xA;        }&#xD;&#xA;        // the sample array now contains the last ten readings&#xD;&#xA;        // sampleIndex now points to the oldest reading&#xD;&#xA;        // it will be replaced with the newest next time &#xD;&#xA;    &#xD;&#xA;        float average = sampleAverage();&#xD;&#xA;        /*Serial.print(&quot;average:&quot;);&#xD;&#xA;         Serial.println(average);*/&#xD;&#xA;        Wind_Speed = (6 * average);&#xD;&#xA;        Wind_Kmph = 3.6 * Wind_Speed;&#xD;&#xA;        /*    Serial.print(&quot;Wind_Speed:&quot;);&#xD;&#xA;         Serial.print(Wind_Speed);&#xD;&#xA;         Serial.println(&quot;m/s&quot;);&#xD;&#xA;         &#xD;&#xA;         Serial.print(&quot;Wind_Exceed_count:&quot;);Serial.println(Wind_Exceed_count);Serial.println(&quot;.................&quot;);&#xD;&#xA;         Serial.print(&quot;Wind_Kmph:&quot;);&#xD;&#xA;         Serial.print(Wind_Kmph);&#xD;&#xA;         Serial.println(&quot;KMPH&quot;);&#xD;&#xA;         */&#xD;&#xA;        if((Wind_Speed&gt;4.0)&amp;&amp;(Stow_flag==0))&#xD;&#xA;        {&#xD;&#xA;          Wind_Exceed_count=Wind_Exceed_count+1;&#xD;&#xA;    &#xD;&#xA;          //Serial.println(&quot;Wind_Exceed_count&quot;);Serial.print(Wind_Exceed_count);&#xD;&#xA;          if(Wind_Exceed_count&lt;5)&#xD;&#xA;          {&#xD;&#xA;            Stow_flag=0;&#xD;&#xA;          }&#xD;&#xA;          else&#xD;&#xA;          {&#xD;&#xA;            Stow_flag=1; &#xD;&#xA;            MODE=STOW;&#xD;&#xA;          }&#xD;&#xA;    &#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;          Redo_Wind_calc();&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;      } &#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void Redo_Wind_calc()&#xD;&#xA;    {&#xD;&#xA;      //  Serial.println(&quot;Wind_Exceed_count&quot;);Serial.print(Wind_Exceed_count);&#xD;&#xA;      if(Wind_Speed&gt;4.0 &amp;&amp;Stow_flag==1)&#xD;&#xA;      {&#xD;&#xA;        Wind_Exceed_count=Wind_Exceed_count+1;&#xD;&#xA;        if(Wind_Exceed_count&lt;=10)&#xD;&#xA;        {&#xD;&#xA;          MODE=STOW;    &#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;          MODE=TRACK;&#xD;&#xA;          Wind_Exceed_count=0;&#xD;&#xA;          Stow_flag=0;&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;     Wind_calc();&#xD;&#xA;    webcontrol();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void webcontrol()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;    //Web control function are defined here&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="3496" PostHistoryTypeId="1" PostId="1228" RevisionGUID="0caa35fa-b8ab-44a9-936a-97227b0ec03d" CreationDate="2014-04-19T08:43:10.460" UserId="904" Text="Analog average sample wind speed sensor" />
  <row Id="3497" PostHistoryTypeId="3" PostId="1228" RevisionGUID="0caa35fa-b8ab-44a9-936a-97227b0ec03d" CreationDate="2014-04-19T08:43:10.460" UserId="904" Text="&lt;arduino-uno&gt;&lt;web-server&gt;&lt;analogwrite&gt;" />
  <row Id="3498" PostHistoryTypeId="6" PostId="1056" RevisionGUID="443cb686-e902-4a38-bdfb-66e879ab23c7" CreationDate="2014-04-19T13:21:26.243" UserId="220" Comment="edited tags" Text="&lt;arduino-uno&gt;&lt;programming&gt;&lt;arduino-mega&gt;&lt;networking&gt;" />
  <row Id="3499" PostHistoryTypeId="2" PostId="1229" RevisionGUID="1dd6be2a-73a5-4656-9f44-e18ae75ac178" CreationDate="2014-04-19T14:18:30.783" UserId="84" Text="If your question is about **including library A inside library B and then including library B in your main program**, then you need to be aware of a limitation of Arduino IDE (discussed in [this answer][1] to a similar question).&#xD;&#xA;&#xD;&#xA;Arduino IDE (at least 1.0.x, I have not checked with 1.5) for an obscure reason will not include libraries included by other libraries.&#xD;&#xA;&#xD;&#xA;The only way to work around this issue is to include ALL libraries (direct **and** indirect) in your main program file (`.ino` file):&#xD;&#xA;&#xD;&#xA;    // Needed by library &quot;B&quot;&#xD;&#xA;    #include &quot;A.h&quot;&#xD;&#xA;    // Needed by your program&#xD;&#xA;    #include &quot;B.h&quot;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;        // You can use B stuff here&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;        // You can use B stuff here&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Another workaround is to trash Arduino IDE and use a better (I mean a real) IDE: many good options have been discussed in [this question][2].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/questions/322/why-do-i-need-to-include-libraries-used-in-other-libraries/328#328&#xD;&#xA;  [2]: http://arduino.stackexchange.com/questions/40/what-are-the-other-ides-for-arduino" />
  <row Id="3500" PostHistoryTypeId="5" PostId="1164" RevisionGUID="0b79dc29-093e-4937-8946-29df0510fdb1" CreationDate="2014-04-19T15:03:27.270" UserId="220" Comment="Improved Code" Text="This is *very* simple using the **[`map()` instruction](http://arduino.cc/en/reference/map).** Here's the code you would use (feel free to modify values:&#xD;&#xA;&#xD;&#xA;    int speed = 112 + map(distance, 0, 20, 0, 112) - map(distance2, 0, 20, 0, 112);&#xD;&#xA;&#xD;&#xA;So if both sensors gave equal values, they would offset each other. To make it still work if an object is removed, you could just use the last `distance`/`distance_2` value and update the other.&#xD;&#xA;****&#xD;&#xA;One issue with this approach is, if the line of transformation of the object is *not* perpendicular to the line of the pings, the value will go:&#xD;&#xA;&gt; 10 → 11 → 12 → 13 → 14 → 15 → 16 → 17 → 18 → 19 → 20 → [Out of range]&#xD;&#xA;&#xD;&#xA;**I've added some pretty animations to show you what I mean:**&#xD;&#xA;&#xD;&#xA;Perpendicular:&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://i.stack.imgur.com/jmOp6.gif&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&#xD;&#xA;&#xD;&#xA;Collinear:&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://i.stack.imgur.com/tnk9M.gif&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&#xD;&#xA;****&#xD;&#xA;As I understand, this is what you want:&#xD;&#xA;&#xD;&#xA;    int motorPin = 9;&#xD;&#xA;    int trigPin = 13;&#xD;&#xA;    int echoPin = 12;&#xD;&#xA;    int trigPin2 = 5;&#xD;&#xA;    int echoPin2 = 4;&#xD;&#xA;    int postdist = 112;&#xD;&#xA;    int postdist2 = 112;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin (9600);&#xD;&#xA;      pinMode(trigPin, OUTPUT);&#xD;&#xA;      pinMode(echoPin, INPUT);&#xD;&#xA;      pinMode(trigPin2, OUTPUT);&#xD;&#xA;      pinMode(echoPin2, INPUT);&#xD;&#xA;      pinMode(motorPin, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      //First Read&#xD;&#xA;      int duration, distance;&#xD;&#xA;      digitalWrite (trigPin, HIGH);&#xD;&#xA;      delayMicroseconds (1000);&#xD;&#xA;      digitalWrite (trigPin, LOW);&#xD;&#xA;      duration = pulseIn (echoPin, HIGH);&#xD;&#xA;      distance = (duration/2) / 29.1;&#xD;&#xA;      int ltol = postdist - 5;&#xD;&#xA;      int htol = postdist + 5;&#xD;&#xA;      if (distance &gt; 20 || !(distance &gt; ltol &amp;&amp; distance &lt; htol)) {  // Distance from sensor&#xD;&#xA;        Serial.println(&quot;Out of range&quot;);&#xD;&#xA;        distance = postdist;&#xD;&#xA;      }&#xD;&#xA;      //Second Read&#xD;&#xA;      int duration2, distance2;&#xD;&#xA;      digitalWrite (trigPin2, HIGH);&#xD;&#xA;      delayMicroseconds (1000);&#xD;&#xA;      digitalWrite (trigPin2, LOW);&#xD;&#xA;      duration2 = pulseIn (echoPin2, HIGH);&#xD;&#xA;      distance2 = (duration2/2) / 29.1;&#xD;&#xA;      int ltol2 = postdist2 - 5;&#xD;&#xA;      int htol2 = postdist2 + 5;&#xD;&#xA;      if (distance2 &gt; 20 || !(distance2 &gt; ltol2 &amp;&amp; distance2 &lt; htol2)) {  // Distance from sensor&#xD;&#xA;        Serial.println(&quot;Out of range&quot;);&#xD;&#xA;        distance2 = postdist2;&#xD;&#xA;      }&#xD;&#xA;      //Math:&#xD;&#xA;      Serial.print(&quot;Distances-1: &quot;);&#xD;&#xA;      Serial.print(distance);&#xD;&#xA;      Serial.print(&quot; cm 2: &quot;);&#xD;&#xA;      Serial.print(&quot;Distances-1: &quot;);&#xD;&#xA;      Serial.print(distance2);&#xD;&#xA;      Serial.println(&quot; cm&quot;);&#xD;&#xA;      postdist = distance;&#xD;&#xA;      postdist2 = distance2;&#xD;&#xA;      int speed = 112 + map(distance, 0, 20, 0, 112) - map(distance2, 0, 20, 0, 112); &#xD;&#xA;      if(speed &lt; 60) {speed = 60;} //Modify 60 to meet your needs for minimum threshold&#xD;&#xA;      analogWrite (motorPin, speed);&#xD;&#xA;      Serial.print(&quot;Motor Speed: &quot;);&#xD;&#xA;      Serial.println(speed);&#xD;&#xA;      delay(500);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**Changelog:** forgot to edit `postdist`/`postdist2` at end of cycle, added minimum threshold, prevent very small changes in voltage to keep voltage stable and prevent noise." />
  <row Id="3501" PostHistoryTypeId="2" PostId="1230" RevisionGUID="304cbee2-2c7f-4a76-9929-781d31fe20f3" CreationDate="2014-04-19T17:19:18.207" UserId="1113" Text="I have a complex requirement that uses a number of libraries that depend on timing I.e. OneWire. When using the official GSM shield on a mega, it loads a version of software serial to talk to the GSM. I want to make it use a spare hardware serial port on the MEGA for more timing stability. How should I modify the GSM library to (optionally) auto detect a MEGA and then use a nominated serial port. I am happy to jumper the correct pins from the mega serial hardware port to the bent outwards pins 2 and 3 of the GSM shield ( pin 2 is already bent out if you use a MEGA anyway)." />
  <row Id="3502" PostHistoryTypeId="1" PostId="1230" RevisionGUID="304cbee2-2c7f-4a76-9929-781d31fe20f3" CreationDate="2014-04-19T17:19:18.207" UserId="1113" Text="Can the official arduino shield library be changed to work with hardware serial on mega" />
  <row Id="3503" PostHistoryTypeId="3" PostId="1230" RevisionGUID="304cbee2-2c7f-4a76-9929-781d31fe20f3" CreationDate="2014-04-19T17:19:18.207" UserId="1113" Text="&lt;serial&gt;&lt;arduino-mega&gt;&lt;gsm&gt;&lt;hardware&gt;" />
  <row Id="3504" PostHistoryTypeId="2" PostId="1231" RevisionGUID="2fb83aaf-83f6-486a-802c-dc6e03854fa6" CreationDate="2014-04-19T17:34:08.457" UserId="1113" Text="What arduino board is being used? I find that some webserver code takes up a lot of the SRAM and in an UNO this leaves very little space for other code.&#xD;&#xA;&#xD;&#xA;To save SRAM use the F macro on all the Serial.print statements that have quoted text. i.e:&#xD;&#xA;&#xD;&#xA;Serial.print(&quot;Some text you want output&quot;); // takes up SRAM when running. 1 byte per letter and space.&#xD;&#xA;&#xD;&#xA;Serial.print(F(&quot;Some text you want output&quot;)); // takes up no SRAM as it is stored in program space and is makes a big difference.&#xD;&#xA;&#xD;&#xA;Search for a freeRam() and use that in debugging your sketch to see how much free space you have.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3505" PostHistoryTypeId="2" PostId="1232" RevisionGUID="26c6eece-3216-4d61-b39d-3c929e5d3b75" CreationDate="2014-04-19T17:37:10.797" UserId="693" Text="I have set up Eclipse to compile for the Arduino Due using all the tools shipped with the Arduino IDE 1.5.6-r2. It compiles without errors, but when uploaded, the Arduino does nothing, and isn't recognized on the computer. It then has to be reset manually using the erase and reset buttons.&#xD;&#xA;&#xD;&#xA;This is the output from Eclipse compiling the library itself: http://pastebin.com/EK9bmc1Q (too big for the question)&#xD;&#xA;&#xD;&#xA;Here is the project itself: http://pastebin.com/2GCXP0L1&#xD;&#xA;&#xD;&#xA;Here is the upload command: http://pastebin.com/t8dcYy8q" />
  <row Id="3506" PostHistoryTypeId="1" PostId="1232" RevisionGUID="26c6eece-3216-4d61-b39d-3c929e5d3b75" CreationDate="2014-04-19T17:37:10.797" UserId="693" Text="Why doesn't successfully compiled code run on the Arduino Due?" />
  <row Id="3507" PostHistoryTypeId="3" PostId="1232" RevisionGUID="26c6eece-3216-4d61-b39d-3c929e5d3b75" CreationDate="2014-04-19T17:37:10.797" UserId="693" Text="&lt;arduino-due&gt;&lt;compile&gt;&lt;eclipse&gt;" />
  <row Id="3508" PostHistoryTypeId="2" PostId="1233" RevisionGUID="0222a47d-dd5b-4b8a-971d-3b8513df50cc" CreationDate="2014-04-19T17:48:39.577" UserId="1113" Text="The SIM card does not have an IP address. When the data connection is made to your GSM APN it is assigned an IP in a similar way to DHCP. Often the address is the same after the first connection as the service provider will link that to your SIM for audit purposes. If you setup a private APN then you can arrange to have specific range allocated to your SIM card(s). This is normally only done for security of volume reasons." />
  <row Id="3509" PostHistoryTypeId="2" PostId="1234" RevisionGUID="7b14e30b-e83a-4d8f-a29e-ba4fe8354796" CreationDate="2014-04-19T17:53:02.027" UserId="1113" Text="Pin 1 is used for the serial output and can't be used if you enable serial using serial.begin(9600).&#xD;&#xA;&#xD;&#xA;Change button to pin 2." />
  <row Id="3510" PostHistoryTypeId="2" PostId="1235" RevisionGUID="3e616ac0-fcb5-41fd-b318-cdcf4782301e" CreationDate="2014-04-19T18:05:35.040" UserId="1113" Text="I have had great success removing serial from such an example and setting up a closed network and then Ethernet enabling all the arduino devices. I then have a DCHP and SNTP server in the closed network. The PC etc are all in the closed network. I then setup a MQTT server (see www.mosquitto.org) and use the arduino PubSub library on the arduino. I get extremely short round trips with pretty consistent response times and this has the advantage that multiple sources can publish or subscribe to the data steams created. The SNTP server is used so that all the devices get the same time reference to use and I time stamp all messages and can then work out message sequence etc even if they are physically delayed slightly by an Ethernet collision! although in a closed network this is minimized." />
  <row Id="3512" PostHistoryTypeId="4" PostId="1230" RevisionGUID="acecf9bd-dd45-4667-9378-f5efbddd8eb2" CreationDate="2014-04-19T18:28:45.223" UserId="1113" Comment="edited title" Text="Can the official arduino GSM shield library be changed to work with hardware serial on mega" />
  <row Id="3515" PostHistoryTypeId="5" PostId="1234" RevisionGUID="81e8467c-1253-4abd-8f6a-0771246f9613" CreationDate="2014-04-19T18:50:23.963" UserId="11" Comment="added 2 characters in body" Text="Pin 1 is used for the serial output and can't be used if you enable serial using `serial.begin(9600)`.&#xD;&#xA;&#xD;&#xA;Change button to pin 2." />
  <row Id="3516" PostHistoryTypeId="5" PostId="1231" RevisionGUID="e3b5a9d1-6b49-4d1e-9e95-239cb0157b7c" CreationDate="2014-04-19T18:52:59.087" UserId="11" Comment="added 201 characters in body" Text="What arduino board is being used? I find that some webserver code takes up a lot of the SRAM and in an UNO this leaves very little space for other code.&#xD;&#xA;&#xD;&#xA;To save SRAM use the F macro on all the Serial.print statements that have quoted text. i.e:&#xD;&#xA;&#xD;&#xA;    Serial.print(&quot;Some text you want output&quot;);&#xD;&#xA;This takes up SRAM when running. 1 byte per letter and space.&#xD;&#xA;&#xD;&#xA;    Serial.print(F(&quot;Some text you want output&quot;));&#xD;&#xA;This takes up no SRAM as it is stored in program space and is makes a big difference.&#xD;&#xA;&#xD;&#xA;Search for a `freeRam()` and use that in debugging your sketch to see how much free space you have.&#xD;&#xA;&#xD;&#xA;Relevant question: [What can I do if I run out of Flash memory or SRAM?][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/questions/221/what-can-i-do-if-i-run-out-of-flash-memory-or-sram" />
  <row Id="3517" PostHistoryTypeId="2" PostId="1237" RevisionGUID="ab5e8b8b-f8b4-4e79-8ff7-68b9585eceb6" CreationDate="2014-04-19T19:08:33.473" UserId="1115" Text="This function can be used to seperate a string into pieces based on what the separating character is.  &#xD;&#xA;&#xD;&#xA;    String xval = getValue(myString, ':', 0);&#xD;&#xA;    String yval = getValue(myString, ':', 1);&#xD;&#xA;&#xD;&#xA;    Serial.println(&quot;Y:&quot; + yval);&#xD;&#xA;    Serial.print(&quot;X:&quot; + xval);&#xD;&#xA;&#xD;&#xA;Convert String to int&#xD;&#xA;&#xD;&#xA;    int xvalue = stringToNumber(xval);&#xD;&#xA;    int yvalue = stringToNumber(yval);&#xD;&#xA;&#xD;&#xA;This Chunk of code takes a string and separates it based on a given character and     returns&#xD;&#xA;The item between the separating character  &#xD;&#xA;&#xD;&#xA;    String getValue(String data, char separator, int index)&#xD;&#xA;    {&#xD;&#xA;     int found = 0;&#xD;&#xA;      int strIndex[] = {&#xD;&#xA;    0, -1  };&#xD;&#xA;      int maxIndex = data.length()-1;&#xD;&#xA;      for(int i=0; i&lt;=maxIndex &amp;&amp; found&lt;=index; i++){&#xD;&#xA;      if(data.charAt(i)==separator || i==maxIndex){&#xD;&#xA;      found++;&#xD;&#xA;      strIndex[0] = strIndex[1]+1;&#xD;&#xA;      strIndex[1] = (i == maxIndex) ? i+1 : i;&#xD;&#xA;      }&#xD;&#xA;     }&#xD;&#xA;      return found&gt;index ? data.substring(strIndex[0], strIndex[1]) : &quot;&quot;;&#xD;&#xA;    }" />
  <row Id="3518" PostHistoryTypeId="5" PostId="1232" RevisionGUID="e5cd349c-ede3-48fc-9c74-d26c80230357" CreationDate="2014-04-19T19:21:39.050" UserId="693" Comment="added 8959 characters in body" Text="I have set up Eclipse to compile for the Arduino Due using all the tools shipped with the Arduino IDE 1.5.6-r2. It compiles without errors, but when uploaded, the Arduino does nothing, and isn't recognized on the computer. It then has to be reset manually using the erase and reset buttons.&#xD;&#xA;&#xD;&#xA;There is one static library (ArduinoDueCore) consisting of the Arduino library (`core`), and other code (Atmel found in `lib`). The other Eclipse project is the TestProject. It contains one file blinking an LED on pin 13. All the files from the Arduino library are there.&#xD;&#xA;&#xD;&#xA;This is the output from Eclipse compiling the library itself: (excerpt of only one of each type of command)&#xD;&#xA;&#xD;&#xA;    18:31:36 **** Build of configuration Release for project ArduinoDueCore ****&#xD;&#xA;    make all&#xD;&#xA;    Building file: ../src/lib/variants/arduino_due_x/variant.cpp&#xD;&#xA;    Invoking: ARM Sourcery Linux GCC C++ Compiler&#xD;&#xA;    arm-none-eabi-g++ -DUSB_PRODUCT=&quot;Arduino Due&quot; -DARDUINO=156 -DUSB_MANUFACTURER=&quot;Unknown&quot; -DARDUINO_ARCH_SAM -DARDUINO_SAM_DUE -D__SAM3X8E__ -Dprintf=iprintf -DF_CPU=84000000L -DUSB_VID=0x2341 -DUSB_PID=0x003E -DUSBCON -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/core&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/CMSIS/Include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL/sam3xa/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/variants/arduino_due_x&quot; -Os -ffunction-sections -fdata-sections -Wall -Wa,-adhlns=&quot;src/lib/variants/arduino_due_x/variant.o.lst&quot; -fno-exceptions -fno-rtti -w -c -g -fmessage-length=0 --param max-inline-insns-single=500 -nostdlib -MMD -MP -MF&quot;src/lib/variants/arduino_due_x/variant.d&quot; -MT&quot;src/lib/variants/arduino_due_x/variant.d&quot; -mcpu=cortex-m3 -mthumb -o &quot;src/lib/variants/arduino_due_x/variant.o&quot; &quot;../src/lib/variants/arduino_due_x/variant.cpp&quot;&#xD;&#xA;    Finished building: ../src/lib/variants/arduino_due_x/variant.cpp&#xD;&#xA;&#xD;&#xA;    Building file: ../src/lib/libsam/source/adc.c&#xD;&#xA;    Invoking: ARM Sourcery Linux GCC C Compiler&#xD;&#xA;    arm-none-eabi-gcc -DARDUINO=156 -DARM_MATH_CM3 -DUSB_MANUFACTURER=&quot;Unknown&quot; -DARDUINO_ARCH_SAM -DARDUINO_SAM_DUE -D__SAM3X8E__ -Dprintf=iprintf -DF_CPU=84000000L -DUSB_VID=0x2341 -DUSB_PRODUCT=&quot;Arduino Due&quot; -DUSB_PID=0x003E -DUSBCON -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/core&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/CMSIS/Include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL/sam3xa/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/variants/arduino_due_x&quot; -Os -ffunction-sections -fdata-sections -Wall -Wa,-adhlns=&quot;src/lib/libsam/source/adc.o.lst&quot; -w -c -fmessage-length=0 --param max-inline-insns-single=500 -nostdlib -std=c99 -MMD -MP -MF&quot;src/lib/libsam/source/adc.d&quot; -MT&quot;src/lib/libsam/source/adc.d&quot; -mcpu=cortex-m3 -mthumb -o &quot;src/lib/libsam/source/adc.o&quot; &quot;../src/lib/libsam/source/adc.c&quot;&#xD;&#xA;    Finished building: ../src/lib/libsam/source/adc.c&#xD;&#xA;&#xD;&#xA;    Building file: ../src/core/USB/HID.cpp&#xD;&#xA;    Invoking: ARM Sourcery Linux GCC C++ Compiler&#xD;&#xA;    arm-none-eabi-g++ -DUSB_PRODUCT=&quot;Arduino Due&quot; -DARDUINO=156 -DUSB_MANUFACTURER=&quot;Unknown&quot; -DARDUINO_ARCH_SAM -DARDUINO_SAM_DUE -D__SAM3X8E__ -Dprintf=iprintf -DF_CPU=84000000L -DUSB_VID=0x2341 -DUSB_PID=0x003E -DUSBCON -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/core&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/CMSIS/Include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL/sam3xa/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/variants/arduino_due_x&quot; -Os -ffunction-sections -fdata-sections -Wall -Wa,-adhlns=&quot;src/core/USB/HID.o.lst&quot; -fno-exceptions -fno-rtti -w -c -g -fmessage-length=0 --param max-inline-insns-single=500 -nostdlib -MMD -MP -MF&quot;src/core/USB/HID.d&quot; -MT&quot;src/core/USB/HID.d&quot; -mcpu=cortex-m3 -mthumb -o &quot;src/core/USB/HID.o&quot; &quot;../src/core/USB/HID.cpp&quot;&#xD;&#xA;    Finished building: ../src/core/USB/HID.cpp&#xD;&#xA;&#xD;&#xA;    Building file: ../src/core/cortex_handlers.c&#xD;&#xA;    Invoking: ARM Sourcery Linux GCC C Compiler&#xD;&#xA;    arm-none-eabi-gcc -DARDUINO=156 -DARM_MATH_CM3 -DUSB_MANUFACTURER=&quot;Unknown&quot; -DARDUINO_ARCH_SAM -DARDUINO_SAM_DUE -D__SAM3X8E__ -Dprintf=iprintf -DF_CPU=84000000L -DUSB_VID=0x2341 -DUSB_PRODUCT=&quot;Arduino Due&quot; -DUSB_PID=0x003E -DUSBCON -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/core&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/CMSIS/Include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL/sam3xa/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/variants/arduino_due_x&quot; -Os -ffunction-sections -fdata-sections -Wall -Wa,-adhlns=&quot;src/core/cortex_handlers.o.lst&quot; -w -c -fmessage-length=0 --param max-inline-insns-single=500 -nostdlib -std=c99 -MMD -MP -MF&quot;src/core/cortex_handlers.d&quot; -MT&quot;src/core/cortex_handlers.d&quot; -mcpu=cortex-m3 -mthumb -o &quot;src/core/cortex_handlers.o&quot; &quot;../src/core/cortex_handlers.c&quot;&#xD;&#xA;    Finished building: ../src/core/cortex_handlers.c&#xD;&#xA;&#xD;&#xA;    18:31:39 Build Finished (took 2s.811ms)&#xD;&#xA;&#xD;&#xA;Here is the project itself:&#xD;&#xA;&#xD;&#xA;    18:33:42 **** Build of configuration Release for project TestProject ****&#xD;&#xA;    make all&#xD;&#xA;    Building file: ../src/TestProject.cpp&#xD;&#xA;    Invoking: ARM Sourcery Linux GCC C++ Compiler&#xD;&#xA;    arm-none-eabi-g++ -DARDUINO=156 -DUSB_PRODUCT=&quot;Arduino Due&quot; -DARDUINO_SAM_DUE -D__SAM3X8E__ -DARDUINO_ARCH_SAM -Dprintf=iprintf -DF_CPU=84000000L -DUSB_MANUFACTURER=&quot;Unknown&quot; -DUSB_VID=0x2341 -DUSB_PID=0x003E -DUSBCON -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/core&quot; -I&quot;/home/kim/workspace_juno/TestProject/src&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/variants/arduino_due_x&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/CMSIS/Include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL/sam3xa/include&quot; -Os -ffunction-sections -fdata-sections -Wall -fno-exceptions -fno-rtti -c -fmessage-length=0 --param max-inline-insns-single=500 -nostdlib -g -w -MMD -MP -MF&quot;src/TestProject.d&quot; -MT&quot;src/TestProject.d&quot; -mcpu=cortex-m3 -mthumb -o &quot;src/TestProject.o&quot; &quot;../src/TestProject.cpp&quot;&#xD;&#xA;    Finished building: ../src/TestProject.cpp&#xD;&#xA;    &#xD;&#xA;    Building target: TestProject.elf&#xD;&#xA;    Invoking: ARM Sourcery Linux GCC C++ Linker&#xD;&#xA;    arm-none-eabi-g++ -T&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/variants/arduino_due_x/linker_scripts/gcc/flash.ld&quot; -L&quot;/home/kim/workspace_juno/ArduinoDueCore/Release&quot; -Wl,-Map,TestProject.map -lm -lgcc  -Wl,--cref -Wl,--check-sections -Wl,--gc-sections -Wl,--entry=Reset_Handler -Wl,--unresolved-symbols=report-all -Wl,--warn-common -Wl,--warn-section-align -Wl,--warn-unresolved-symbols -Wl,--gc-sections -mcpu=cortex-m3 -mthumb -o &quot;TestProject.elf&quot; -Wl,--start-group  ./src/TestProject.o   -lArduinoDueCore -Wl,--end-group&#xD;&#xA;    Finished building target: TestProject.elf&#xD;&#xA;    &#xD;&#xA;    make --no-print-directory post-build&#xD;&#xA;    /home/kim/arduino-1.5.6-r2/hardware/tools/g++_arm_none_eabi/bin/arm-none-eabi-objcopy -O binary TestProject.elf TestProject.bin&#xD;&#xA;    &#xD;&#xA;    Invoking: ARM Sourcery Linux GNU Create Listing&#xD;&#xA;    arm-none-eabi-objdump -h -S TestProject.elf &gt; &quot;TestProject.lst&quot;&#xD;&#xA;    Finished building: TestProject.lst&#xD;&#xA;    &#xD;&#xA;    Invoking: ARM Sourcery Linux GNU Print Size&#xD;&#xA;    arm-none-eabi-size  --format=berkeley TestProject.elf&#xD;&#xA;       text	   data	    bss	    dec	    hex	filename&#xD;&#xA;      10396	     24	   1188	  11608	   2d58	TestProject.elf&#xD;&#xA;    Finished building: TestProject.siz&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    18:33:43 Build Finished (took 308ms)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Here is the upload command: (removed `readWord`, `go`, `write` and `writeWord` lines)&#xD;&#xA;&#xD;&#xA;    -i -d --port=ttyACM0 -U true -e -w -v -b ${project_loc}/Release/${project_name}.bin -R&#xD;&#xA;    &#xD;&#xA;    Set binary mode&#xD;&#xA;    chipId=0x285e0a60&#xD;&#xA;    Connected at 921600 baud&#xD;&#xA;    Erase flash&#xD;&#xA;    Write 10420 bytes to flash&#xD;&#xA;    &#xD;&#xA;    [                              ] 0% (0/41 pages)&#xD;&#xA;    [=======                       ] 24% (10/41 pages)&#xD;&#xA;    [==============                ] 48% (20/41 pages)&#xD;&#xA;    [=====================         ] 73% (30/41 pages)&#xD;&#xA;    [============================= ] 97% (40/41 pages)&#xD;&#xA;    [==============================] 100% (41/41 pages)&#xD;&#xA;    Verify 10420 bytes of flash&#xD;&#xA;    &#xD;&#xA;    [                              ] 0% (0/41 pages)&#xD;&#xA;    [=======                       ] 24% (10/41 pages)&#xD;&#xA;    [==============                ] 48% (20/41 pages)&#xD;&#xA;    [=====================         ] 73% (30/41 pages)&#xD;&#xA;    [============================= ] 97% (40/41 pages)&#xD;&#xA;    [==============================] 100% (41/41 pages)&#xD;&#xA;    Verify successful&#xD;&#xA;    Set boot flash true&#xD;&#xA;    Device       : ATSAM3X8&#xD;&#xA;    Chip ID      : 285e0a60&#xD;&#xA;    version()=v1.1 Dec 15 2010 19:25:04&#xD;&#xA;    Version      : v1.1 Dec 15 2010 19:25:04&#xD;&#xA;    Address      : 524288&#xD;&#xA;    Pages        : 2048&#xD;&#xA;    Page Size    : 256 bytes&#xD;&#xA;    Total Size   : 512KB&#xD;&#xA;    Planes       : 2&#xD;&#xA;    Lock Regions : 32&#xD;&#xA;    Locked       : none&#xD;&#xA;    Security     : false&#xD;&#xA;    Boot Flash   : true&#xD;&#xA;    CPU reset." />
  <row Id="3519" PostHistoryTypeId="5" PostId="1232" RevisionGUID="118840a7-5be2-4f3a-acc5-7835447d5044" CreationDate="2014-04-19T19:27:48.587" UserId="693" Comment="added 251 characters in body" Text="I have set up Eclipse to compile for the Arduino Due using all the tools shipped with the Arduino IDE 1.5.6-r2. It compiles without errors, but when uploaded, the Arduino does nothing, and isn't recognized on the computer. It then has to be reset manually using the erase and reset buttons.&#xD;&#xA;&#xD;&#xA;There is one static library (ArduinoDueCore) consisting of the Arduino library (`core`), and other code (Atmel found in `lib`). The other Eclipse project is the TestProject. It contains one file blinking an LED on pin 13. All the files from the Arduino library are there.&#xD;&#xA;&#xD;&#xA;This is the output from Eclipse compiling the library itself: (excerpt of only one of each type of command)&#xD;&#xA;&#xD;&#xA;    18:31:36 **** Build of configuration Release for project ArduinoDueCore ****&#xD;&#xA;    make all&#xD;&#xA;    Building file: ../src/lib/variants/arduino_due_x/variant.cpp&#xD;&#xA;    Invoking: ARM Sourcery Linux GCC C++ Compiler&#xD;&#xA;    arm-none-eabi-g++ -DUSB_PRODUCT=&quot;Arduino Due&quot; -DARDUINO=156 -DUSB_MANUFACTURER=&quot;Unknown&quot; -DARDUINO_ARCH_SAM -DARDUINO_SAM_DUE -D__SAM3X8E__ -Dprintf=iprintf -DF_CPU=84000000L -DUSB_VID=0x2341 -DUSB_PID=0x003E -DUSBCON -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/core&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/CMSIS/Include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL/sam3xa/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/variants/arduino_due_x&quot; -Os -ffunction-sections -fdata-sections -Wall -Wa,-adhlns=&quot;src/lib/variants/arduino_due_x/variant.o.lst&quot; -fno-exceptions -fno-rtti -w -c -g -fmessage-length=0 --param max-inline-insns-single=500 -nostdlib -MMD -MP -MF&quot;src/lib/variants/arduino_due_x/variant.d&quot; -MT&quot;src/lib/variants/arduino_due_x/variant.d&quot; -mcpu=cortex-m3 -mthumb -o &quot;src/lib/variants/arduino_due_x/variant.o&quot; &quot;../src/lib/variants/arduino_due_x/variant.cpp&quot;&#xD;&#xA;    Finished building: ../src/lib/variants/arduino_due_x/variant.cpp&#xD;&#xA;&#xD;&#xA;    Building file: ../src/lib/libsam/source/adc.c&#xD;&#xA;    Invoking: ARM Sourcery Linux GCC C Compiler&#xD;&#xA;    arm-none-eabi-gcc -DARDUINO=156 -DARM_MATH_CM3 -DUSB_MANUFACTURER=&quot;Unknown&quot; -DARDUINO_ARCH_SAM -DARDUINO_SAM_DUE -D__SAM3X8E__ -Dprintf=iprintf -DF_CPU=84000000L -DUSB_VID=0x2341 -DUSB_PRODUCT=&quot;Arduino Due&quot; -DUSB_PID=0x003E -DUSBCON -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/core&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/CMSIS/Include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL/sam3xa/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/variants/arduino_due_x&quot; -Os -ffunction-sections -fdata-sections -Wall -Wa,-adhlns=&quot;src/lib/libsam/source/adc.o.lst&quot; -w -c -fmessage-length=0 --param max-inline-insns-single=500 -nostdlib -std=c99 -MMD -MP -MF&quot;src/lib/libsam/source/adc.d&quot; -MT&quot;src/lib/libsam/source/adc.d&quot; -mcpu=cortex-m3 -mthumb -o &quot;src/lib/libsam/source/adc.o&quot; &quot;../src/lib/libsam/source/adc.c&quot;&#xD;&#xA;    Finished building: ../src/lib/libsam/source/adc.c&#xD;&#xA;&#xD;&#xA;    Building file: ../src/core/USB/HID.cpp&#xD;&#xA;    Invoking: ARM Sourcery Linux GCC C++ Compiler&#xD;&#xA;    arm-none-eabi-g++ -DUSB_PRODUCT=&quot;Arduino Due&quot; -DARDUINO=156 -DUSB_MANUFACTURER=&quot;Unknown&quot; -DARDUINO_ARCH_SAM -DARDUINO_SAM_DUE -D__SAM3X8E__ -Dprintf=iprintf -DF_CPU=84000000L -DUSB_VID=0x2341 -DUSB_PID=0x003E -DUSBCON -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/core&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/CMSIS/Include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL/sam3xa/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/variants/arduino_due_x&quot; -Os -ffunction-sections -fdata-sections -Wall -Wa,-adhlns=&quot;src/core/USB/HID.o.lst&quot; -fno-exceptions -fno-rtti -w -c -g -fmessage-length=0 --param max-inline-insns-single=500 -nostdlib -MMD -MP -MF&quot;src/core/USB/HID.d&quot; -MT&quot;src/core/USB/HID.d&quot; -mcpu=cortex-m3 -mthumb -o &quot;src/core/USB/HID.o&quot; &quot;../src/core/USB/HID.cpp&quot;&#xD;&#xA;    Finished building: ../src/core/USB/HID.cpp&#xD;&#xA;&#xD;&#xA;    Building file: ../src/core/cortex_handlers.c&#xD;&#xA;    Invoking: ARM Sourcery Linux GCC C Compiler&#xD;&#xA;    arm-none-eabi-gcc -DARDUINO=156 -DARM_MATH_CM3 -DUSB_MANUFACTURER=&quot;Unknown&quot; -DARDUINO_ARCH_SAM -DARDUINO_SAM_DUE -D__SAM3X8E__ -Dprintf=iprintf -DF_CPU=84000000L -DUSB_VID=0x2341 -DUSB_PRODUCT=&quot;Arduino Due&quot; -DUSB_PID=0x003E -DUSBCON -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/core&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/CMSIS/Include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL/sam3xa/include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/variants/arduino_due_x&quot; -Os -ffunction-sections -fdata-sections -Wall -Wa,-adhlns=&quot;src/core/cortex_handlers.o.lst&quot; -w -c -fmessage-length=0 --param max-inline-insns-single=500 -nostdlib -std=c99 -MMD -MP -MF&quot;src/core/cortex_handlers.d&quot; -MT&quot;src/core/cortex_handlers.d&quot; -mcpu=cortex-m3 -mthumb -o &quot;src/core/cortex_handlers.o&quot; &quot;../src/core/cortex_handlers.c&quot;&#xD;&#xA;    Finished building: ../src/core/cortex_handlers.c&#xD;&#xA;&#xD;&#xA;    18:31:39 Build Finished (took 2s.811ms)&#xD;&#xA;&#xD;&#xA;Here is the project itself:&#xD;&#xA;&#xD;&#xA;    18:33:42 **** Build of configuration Release for project TestProject ****&#xD;&#xA;    make all&#xD;&#xA;    Building file: ../src/TestProject.cpp&#xD;&#xA;    Invoking: ARM Sourcery Linux GCC C++ Compiler&#xD;&#xA;    arm-none-eabi-g++ -DARDUINO=156 -DUSB_PRODUCT=&quot;Arduino Due&quot; -DARDUINO_SAM_DUE -D__SAM3X8E__ -DARDUINO_ARCH_SAM -Dprintf=iprintf -DF_CPU=84000000L -DUSB_MANUFACTURER=&quot;Unknown&quot; -DUSB_VID=0x2341 -DUSB_PID=0x003E -DUSBCON -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/core&quot; -I&quot;/home/kim/workspace_juno/TestProject/src&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/libsam&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/variants/arduino_due_x&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/CMSIS/Include&quot; -I&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/CMSIS/Device/ATMEL/sam3xa/include&quot; -Os -ffunction-sections -fdata-sections -Wall -fno-exceptions -fno-rtti -c -fmessage-length=0 --param max-inline-insns-single=500 -nostdlib -g -w -MMD -MP -MF&quot;src/TestProject.d&quot; -MT&quot;src/TestProject.d&quot; -mcpu=cortex-m3 -mthumb -o &quot;src/TestProject.o&quot; &quot;../src/TestProject.cpp&quot;&#xD;&#xA;    Finished building: ../src/TestProject.cpp&#xD;&#xA;    &#xD;&#xA;    Building target: TestProject.elf&#xD;&#xA;    Invoking: ARM Sourcery Linux GCC C++ Linker&#xD;&#xA;    arm-none-eabi-g++ -T&quot;/home/kim/workspace_juno/ArduinoDueCore/src/lib/variants/arduino_due_x/linker_scripts/gcc/flash.ld&quot; -L&quot;/home/kim/workspace_juno/ArduinoDueCore/Release&quot; -Wl,-Map,TestProject.map -lm -lgcc  -Wl,--cref -Wl,--check-sections -Wl,--gc-sections -Wl,--entry=Reset_Handler -Wl,--unresolved-symbols=report-all -Wl,--warn-common -Wl,--warn-section-align -Wl,--warn-unresolved-symbols -Wl,--gc-sections -mcpu=cortex-m3 -mthumb -o &quot;TestProject.elf&quot; -Wl,--start-group  ./src/TestProject.o   -lArduinoDueCore -Wl,--end-group&#xD;&#xA;    Finished building target: TestProject.elf&#xD;&#xA;    &#xD;&#xA;    make --no-print-directory post-build&#xD;&#xA;    /home/kim/arduino-1.5.6-r2/hardware/tools/g++_arm_none_eabi/bin/arm-none-eabi-objcopy -O binary TestProject.elf TestProject.bin&#xD;&#xA;    &#xD;&#xA;    Invoking: ARM Sourcery Linux GNU Create Listing&#xD;&#xA;    arm-none-eabi-objdump -h -S TestProject.elf &gt; &quot;TestProject.lst&quot;&#xD;&#xA;    Finished building: TestProject.lst&#xD;&#xA;    &#xD;&#xA;    Invoking: ARM Sourcery Linux GNU Print Size&#xD;&#xA;    arm-none-eabi-size  --format=berkeley TestProject.elf&#xD;&#xA;       text	   data	    bss	    dec	    hex	filename&#xD;&#xA;      10396	     24	   1188	  11608	   2d58	TestProject.elf&#xD;&#xA;    Finished building: TestProject.siz&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    18:33:43 Build Finished (took 308ms)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Here is the upload command: (removed `readWord`, `go`, `write` and `writeWord` lines)&#xD;&#xA;&#xD;&#xA;    -i -d --port=ttyACM0 -U true -e -w -v -b ${project_loc}/Release/${project_name}.bin -R&#xD;&#xA;    &#xD;&#xA;    Set binary mode&#xD;&#xA;    chipId=0x285e0a60&#xD;&#xA;    Connected at 921600 baud&#xD;&#xA;    Erase flash&#xD;&#xA;    Write 10420 bytes to flash&#xD;&#xA;    &#xD;&#xA;    [                              ] 0% (0/41 pages)&#xD;&#xA;    [=======                       ] 24% (10/41 pages)&#xD;&#xA;    [==============                ] 48% (20/41 pages)&#xD;&#xA;    [=====================         ] 73% (30/41 pages)&#xD;&#xA;    [============================= ] 97% (40/41 pages)&#xD;&#xA;    [==============================] 100% (41/41 pages)&#xD;&#xA;    Verify 10420 bytes of flash&#xD;&#xA;    &#xD;&#xA;    [                              ] 0% (0/41 pages)&#xD;&#xA;    [=======                       ] 24% (10/41 pages)&#xD;&#xA;    [==============                ] 48% (20/41 pages)&#xD;&#xA;    [=====================         ] 73% (30/41 pages)&#xD;&#xA;    [============================= ] 97% (40/41 pages)&#xD;&#xA;    [==============================] 100% (41/41 pages)&#xD;&#xA;    Verify successful&#xD;&#xA;    Set boot flash true&#xD;&#xA;    Device       : ATSAM3X8&#xD;&#xA;    Chip ID      : 285e0a60&#xD;&#xA;    version()=v1.1 Dec 15 2010 19:25:04&#xD;&#xA;    Version      : v1.1 Dec 15 2010 19:25:04&#xD;&#xA;    Address      : 524288&#xD;&#xA;    Pages        : 2048&#xD;&#xA;    Page Size    : 256 bytes&#xD;&#xA;    Total Size   : 512KB&#xD;&#xA;    Planes       : 2&#xD;&#xA;    Lock Regions : 32&#xD;&#xA;    Locked       : none&#xD;&#xA;    Security     : false&#xD;&#xA;    Boot Flash   : true&#xD;&#xA;    CPU reset.&#xD;&#xA;&#xD;&#xA;TestProject.cpp:&#xD;&#xA;&#xD;&#xA;    #include &quot;Arduino.h&quot;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;        pinMode(13, OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        digitalWrite(13, HIGH);&#xD;&#xA;        delay(50);&#xD;&#xA;        digitalWrite(13, LOW);&#xD;&#xA;        delay(950);&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="3520" PostHistoryTypeId="2" PostId="1238" RevisionGUID="06a80222-c4f7-4eb3-a8ff-7fbaeda2aa28" CreationDate="2014-04-20T08:45:02.320" UserId="1117" Text="could you be more specific with your question ?&#xD;&#xA;From what I understood:&#xD;&#xA;&#xD;&#xA; - you have a client java program acting as the &quot;brain&quot; of your system&#xD;&#xA; - your control is time sensitive. You have a PID or other regulation loop running on the pc&#xD;&#xA; - you have or plan to have multiple arguing boards on your system and you need to communicate with them.&#xD;&#xA; - you are dealing with analog IOs&#xD;&#xA;&#xD;&#xA;## bridging ##&#xD;&#xA;If you want to stick to serial port,you have to use RS485 or RS422. Those can work as a bus. Protocol on top of that can be Modbus.&#xD;&#xA;Note that this has a higher latency and you need at least 2 serial ports on your bridge&#xD;&#xA;&#xD;&#xA;I2C. Lower latency 2 wires bus. Command oriented,runs at 400 kHz. So you have plenty of time to send/receive data&#xD;&#xA;&#xD;&#xA;SPI even lower latency as bytes are sent as stream .arduino mega has 5 pins for it. Note that you have to deal with the addressing yourself in this case.&#xD;&#xA;&#xD;&#xA;Arduino like many micro controllers is bad as doing many tasks at the same time like for the bridging case. I would avoid using an arduino in this case&#xD;&#xA;&#xD;&#xA;## latency ##&#xD;&#xA;&#xD;&#xA;As already answered, ADC conversion takes time and you cannot nest interrupt.&#xD;&#xA;Your minimum latency can be computed from the specifications of the arduino.&#xD;&#xA;The maximum latency is a value you fix yourself. &#xD;&#xA;Knowing the amount of time to send one byte on the communication port,&#xD;&#xA;You can decide between options like&#xD;&#xA; &#xD;&#xA; - run the AD conversion in a loop outside interrupt, put the value inside a variable and do the communication a synchronously inside an interrupt&#xD;&#xA; - run the AD conversion interrupt based and the communication in the main loop of operation&#xD;&#xA;&#xD;&#xA;## conclusions##&#xD;&#xA;Don't do hardware in the loop using a PC. The latency and lack of strict timing possibilities worsened by the use of java make it a dead end with your current setup.&#xD;&#xA;&#xD;&#xA;Use a stronger micro controller like an AVR32 with USB running the brain of your system.&#xD;&#xA;You can also use a raspberries pi or a beaglebone. Those runs &quot;standard&quot; Linux distributions and so you can use a PC like approach. &#xD;&#xA;&#xD;&#xA;In any case guidelines are :&#xD;&#xA;&#xD;&#xA; - try to stay as close to the micro controller as possible and avoid abstraction libraries and OSes&#xD;&#xA; - don't use a pc for hardware in the loop&#xD;&#xA; - try to make your task run a synchronously as much as possible&#xD;&#xA; - keep your interrupt routines as small as possible&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;" />
  <row Id="3521" PostHistoryTypeId="5" PostId="771" RevisionGUID="806c7532-bb0c-4db9-8922-d585c73fae7f" CreationDate="2014-04-20T09:45:32.687" UserId="84" Comment="removed expired pastebin link (useless sicne previous edit added code to question)" Text="I'm using a PROGMEM char* to store a massive array. When I try to print a certain part of the array, the message comes out mangled. How do I fix this?&#xD;&#xA;&#xD;&#xA;The output should be &quot;Poliwag&quot;, but it comes out as &quot;arow&quot;.&#xD;&#xA;&#xD;&#xA;&lt;!-- language-all: lang-c --&gt;&#xD;&#xA;&#xD;&#xA;    #include &lt;TrueRandom.h&gt;&#xD;&#xA;    #include &lt;EEPROM.h&gt;&#xD;&#xA;    #define numPokemon 151&#xD;&#xA;    PROGMEM char* nameArray[] = {&quot;MISSINGNO&quot;,&quot;Bulbasaur&quot;,&quot;Ivysaur&quot;,&quot;Venusaur&quot;,&quot;Charmander&quot;,&quot;Charmeleon&quot;,&quot;Charizard&quot;,&quot;Squirtle&quot;,&#xD;&#xA;    &quot;Wartortle&quot;,&quot;Blastoise&quot;,&quot;Caterpie&quot;,&quot;Metapod&quot;,&quot;Butterfree&quot;,&quot;Weedle&quot;,&quot;Kakuna&quot;,&quot;Beedrill&quot;,&quot;Pidgey&quot;,&quot;Pidgeotto&quot;,&#xD;&#xA;    &quot;Pidgeot&quot;,&quot;Rattata&quot;,&quot;Raticate&quot;,&quot;Spearow&quot;,&quot;Fearow&quot;,&quot;Ekans&quot;,&quot;Arbok&quot;,&quot;Pikachu&quot;,&quot;Raichu&quot;,&quot;Sandshrew&quot;,&quot;Sandslash&quot;,&#xD;&#xA;    &quot;Nidoran♀&quot;,&quot;Nidorina&quot;,&quot;Nidoqueen&quot;,&quot;Nidoran♂&quot;,&quot;Nidorino&quot;,&quot;Nidoking&quot;,&quot;Clefairy&quot;,&quot;Clefable&quot;,&quot;Vulpix&quot;,&quot;Ninetales&quot;,&quot;Jigglypuff&quot;,&#xD;&#xA;    &quot;Wigglytuff&quot;,&quot;Zubat&quot;,&quot;Golbat&quot;,&quot;Oddish&quot;,&quot;Gloom&quot;,&quot;Vileplume&quot;,&quot;Paras&quot;,&quot;Parasect&quot;,&quot;Venonat&quot;,&quot;Venomoth&quot;,&quot;Diglett&quot;,&quot;Dugtrio&quot;,&quot;Meowth&quot;,&#xD;&#xA;    &quot;Persian&quot;,&quot;Psyduck&quot;,&quot;Golduck&quot;,&quot;Mankey&quot;,&quot;Primeape&quot;,&quot;Growlithe&quot;,&quot;Arcanine&quot;,&quot;Poliwag&quot;,&quot;Poliwhirl&quot;,&quot;Poliwrath&quot;,&quot;Abra&quot;,&quot;Kadabra&quot;,&quot;Alakazam&quot;,&#xD;&#xA;    &quot;Machop&quot;,&quot;Machoke&quot;,&quot;Machamp&quot;,&quot;Bellsprout&quot;,&quot;Weepinbell&quot;,&quot;Victreebel&quot;,&quot;Tentacool&quot;,&quot;Tentacruel&quot;,&quot;Geodude&quot;,&quot;Graveler&quot;,&quot;Golem&quot;,&quot;Ponyta&quot;,&quot;Rapidash&quot;,&#xD;&#xA;    &quot;Slowpoke&quot;,&quot;Slowbro&quot;,&quot;Magnemite&quot;,&quot;Magneton&quot;,&quot;Farfetch`d&quot;,&quot;Doduo&quot;,&quot;Dodrio&quot;,&quot;Seel&quot;,&quot;Dewgong&quot;,&quot;Grimer&quot;,&quot;Muk&quot;,&quot;Shellder&quot;,&quot;Cloyster&quot;,&quot;Gastly&quot;,&quot;Haunter&quot;,&#xD;&#xA;    &quot;Gengar&quot;,&quot;Onix&quot;,&quot;Drowzee&quot;,&quot;Hypno&quot;,&quot;Krabby&quot;,&quot;Kingler&quot;,&quot;Voltorb&quot;,&quot;Electrode&quot;,&quot;Exeggcute&quot;,&quot;Exeggutor&quot;,&quot;Cubone&quot;,&quot;Marowak&quot;,&quot;Hitmonlee&quot;,&quot;Hitmonchan&quot;,&quot;Lickitung&quot;,&#xD;&#xA;    &quot;Koffing&quot;,&quot;Weezing&quot;,&quot;Rhyhorn&quot;,&quot;Rhydon&quot;,&quot;Chansey&quot;,&quot;Tangela&quot;,&quot;Kangaskhan&quot;,&quot;Horsea&quot;,&quot;Seadra&quot;,&quot;Goldeen&quot;,&quot;Seaking&quot;,&quot;Staryu&quot;,&quot;Starmie&quot;,&quot;Mr. Mime&quot;,&quot;Scyther&quot;,&quot;Jynx&quot;,&#xD;&#xA;    &quot;Electabuzz&quot;,&quot;Magmar&quot;,&quot;Pinsir&quot;,&quot;Tauros&quot;,&quot;Magikarp&quot;,&quot;Gyarados&quot;,&quot;Lapras&quot;,&quot;Ditto&quot;,&quot;Eevee&quot;,&quot;Vaporeon&quot;,&quot;Jolteon&quot;,&quot;Flareon&quot;,&quot;Porygon&quot;,&quot;Omanyte&quot;,&quot;Omastar&quot;,&quot;Kabuto&quot;,&quot;Kabutops&quot;,&#xD;&#xA;    &quot;Aerodactyl&quot;,&quot;Snorlax&quot;,&quot;Articuno&quot;,&quot;Zapdos&quot;,&quot;Moltres&quot;,&quot;Dratini&quot;,&quot;Dragonair&quot;,&quot;Dragonite&quot;,&quot;Mewtwo&quot;,&quot;Mew&quot;&#xD;&#xA;    };&#xD;&#xA;    int a = 0;&#xD;&#xA;    int b = 0;&#xD;&#xA;    int value;&#xD;&#xA;    String pokemonName = &quot;Missingno&quot;;&#xD;&#xA;    int currentID = TrueRandom.random(1,numPokemon+1);&#xD;&#xA;    // a = CurrentID&#xD;&#xA;    void setup(){&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      if (EEPROM.read(a)!=0){&#xD;&#xA;        currentID = EEPROM.read(a);&#xD;&#xA;        Serial.print(&quot;The Stored ID is &quot;);&#xD;&#xA;        Serial.println(EEPROM.read(a));&#xD;&#xA;        Serial.println(&quot;Stored = true&quot;);&#xD;&#xA;      }else{&#xD;&#xA;        value = EEPROM.read(a);&#xD;&#xA;        Serial.println(value);&#xD;&#xA;        EEPROM.write(a,currentID);&#xD;&#xA;        value = EEPROM.read(a);&#xD;&#xA;        Serial.println(value);&#xD;&#xA;        Serial.println(&quot;Stored = false&quot;);&#xD;&#xA;      }&#xD;&#xA;      pokemonName = nameArray[currentID];&#xD;&#xA;      Serial.println(pokemonName);&#xD;&#xA;    }&#xD;&#xA;    void loop(){&#xD;&#xA;      &#xD;&#xA;    }" />
  <row Id="3522" PostHistoryTypeId="4" PostId="1232" RevisionGUID="c8af7288-c562-4785-ba33-1b4cd99459fe" CreationDate="2014-04-20T11:08:05.783" UserId="693" Comment="edited title" Text="How to compile code for the Arduino Due?" />
  <row Id="3523" PostHistoryTypeId="5" PostId="1193" RevisionGUID="cc789848-f520-4640-9608-80314d5cf9df" CreationDate="2014-04-20T15:04:14.040" UserId="316" Comment="Grammar, formatting, include image of code from &quot;answer&quot;" Text="I've succeeded to get an Arduino to work with a pressure sensor.&#xD;&#xA;&#xD;&#xA;What I want to do is &#xD;&#xA;&#xD;&#xA; - when I put pressure on the sensor, after 5 minutes the led lights on.&#xD;&#xA; - it starts over again if there's no pressure on the sensor.&#xD;&#xA;&#xD;&#xA;Here's the program&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/LxPFV.png" />
  <row Id="3524" PostHistoryTypeId="4" PostId="1193" RevisionGUID="cc789848-f520-4640-9608-80314d5cf9df" CreationDate="2014-04-20T15:04:14.040" UserId="316" Comment="Grammar, formatting, include image of code from &quot;answer&quot;" Text="Arduino time(milli) and pressure sensor." />
  <row Id="3525" PostHistoryTypeId="24" PostId="1193" RevisionGUID="cc789848-f520-4640-9608-80314d5cf9df" CreationDate="2014-04-20T15:04:14.040" Comment="Proposed by 316 approved by 1072 edit id of 285" />
  <row Id="3526" PostHistoryTypeId="5" PostId="1193" RevisionGUID="01424b04-3c82-4161-b91d-1bb06f5e773f" CreationDate="2014-04-20T18:44:11.233" UserId="11" Comment="appended answer 1209 as supplemental" Text="I've succeeded to get an Arduino to work with a pressure sensor.&#xD;&#xA;&#xD;&#xA;What I want to do is &#xD;&#xA;&#xD;&#xA; - when I put pressure on the sensor, after 5 minutes the led lights on.&#xD;&#xA; - it starts over again if there's no pressure on the sensor.&#xD;&#xA;&#xD;&#xA;Here's the program&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;ive got this for the pressure sensor...now i need to combine it with 5 minutes and the led lights on when its reached that 5 min of pressure.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/LxPFV.png" />
  <row Id="3527" PostHistoryTypeId="4" PostId="1193" RevisionGUID="01424b04-3c82-4161-b91d-1bb06f5e773f" CreationDate="2014-04-20T18:44:11.233" UserId="11" Comment="appended answer 1209 as supplemental" Text="Arduino time(milli) and pressure sensor" />
  <row Id="3529" PostHistoryTypeId="2" PostId="1239" RevisionGUID="192dbaa4-f330-4e50-80d8-f248a30c8d8f" CreationDate="2014-04-21T00:32:52.443" UserId="1109" Text="I want to add CO2 measuring feature to my room weather station.&#xD;&#xA;Please recommend CO2 sensor easy to integrate with Arduino.&#xD;&#xA;&#xD;&#xA;Thanks!" />
  <row Id="3530" PostHistoryTypeId="1" PostId="1239" RevisionGUID="192dbaa4-f330-4e50-80d8-f248a30c8d8f" CreationDate="2014-04-21T00:32:52.443" UserId="1109" Text="CO2 sensor for arduino" />
  <row Id="3531" PostHistoryTypeId="3" PostId="1239" RevisionGUID="192dbaa4-f330-4e50-80d8-f248a30c8d8f" CreationDate="2014-04-21T00:32:52.443" UserId="1109" Text="&lt;sensors&gt;" />
  <row Id="3532" PostHistoryTypeId="5" PostId="1239" RevisionGUID="8b6bf577-53df-4551-a605-20ac522cc8a8" CreationDate="2014-04-21T01:58:15.213" UserId="220" Comment="Improved flow of post" Text="I want to add CO2 measuring feature to my room weather station. Can someone please recommend a CO2 sensor easy to integrate with Arduino?" />
  <row Id="3534" PostHistoryTypeId="4" PostId="863" RevisionGUID="e2ba130d-b851-46f4-90aa-309d362dd1c8" CreationDate="2014-04-21T03:58:10.537" UserId="11" Comment="edited title" Text="Connect to more than one Arduino with Adobe AIR" />
  <row Id="3535" PostHistoryTypeId="5" PostId="1186" RevisionGUID="70fc30b7-fc61-41d9-a0ea-12106965746e" CreationDate="2014-04-21T08:03:55.637" UserId="1063" Comment="added 221 characters in body" Text="I will be using an Arduino as a bridge between a computer high-level Java client and some low-level hardware computing units (e.g. other Arduinos). I need to find a solution to **periodically** communicate in **both** ways. It should be possible to send digital, analog inputs to the PC and receive digital, analog outputs from the PC via serial.&#xD;&#xA;&#xD;&#xA;I have very specific requirements for my project to work: &#xD;&#xA;&#xD;&#xA; 1. Lowest possible latency in both ways. High latency would cause&#xD;&#xA;    instability of controlled systems.&#xD;&#xA;    &#xD;&#xA; 2. Extremely constant, possibly user-defined update period. Varying&#xD;&#xA;    sample rate would cause inaccuracies in the control.&#xD;&#xA;&#xD;&#xA;I need a very fast solution possible for update frequency of 100 Hz and higher.&#xD;&#xA;&#xD;&#xA;So far I have tried to send data via Firmata to my java client using time interrupt.&#xD;&#xA;&#xD;&#xA;    ISR(TIMER1_COMPA_vect) {&#xD;&#xA;      Firmata.sendAnalog(analog, analogRead(analog));&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The messages however don't come at a very constant rate and are sometimes held up for twice the sample period or more which is unnaceptable. For higher frequencies this happens even more often. I suspect some kind of a buffer. Do you have any idea where should I look for bottlenecks? Would it be benefiting to design my own communication protocol and ditch Firmata?&#xD;&#xA;&#xD;&#xA;EDIT: Look at the attached [diagram ][1]. Blue lines are &quot;inputs&quot;, green lines &quot;outputs&quot;. Right now I am trying to design the &quot;Arduino (Bridge)&quot;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://i.imgur.com/8dHjU8A.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/fAmud.png" />
  <row Id="3536" PostHistoryTypeId="2" PostId="1240" RevisionGUID="e95e89fa-d3bb-4c32-abd0-05f4b8be3c25" CreationDate="2014-04-21T09:22:12.893" UserId="1129" Text="I am building an early prototype, proof of concept, network monitoring tool.  A big part of it uses localization of a Smartphone.  Seems that the best way to do this is using RSSI from multiple points, I plan to do this using several Arduino Fios with Xbee WiFi (S6B) cards.  &#xD;&#xA;&#xD;&#xA;My current setup has a network running from my smartphone (it is running DHCP) with a laptop monitoring all the traffic on the network.&#xD;&#xA;&#xD;&#xA;What I need is my Fio Xbees to dump the rssi of the &quot;access point&quot; (Smartphone) onto the network so my laptop can pull the data.&#xD;&#xA;&#xD;&#xA;Thus, to/from is not important as far as the packet is concerned, I just need the data dropped on the &quot;wire&quot; for my laptop to later parse, which is good because Serial.print* sends out a broadcast to 255.255.255.255:fffff.&#xD;&#xA;&#xD;&#xA;I can make my devices broadcast any integer, but when I go into AT mode nothing aside from the DHCP request gets put on the wire, any help would be appreciated.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup() { &#xD;&#xA;      Serial.begin(9600); &#xD;&#xA;      Serial.flush();&#xD;&#xA;      delay(1000);//enter AT mode start&#xD;&#xA;      Serial.print(&quot;+&quot;);//AT&#xD;&#xA;      Serial.print(&quot;+&quot;);//AT&#xD;&#xA;      Serial.print(&quot;+&quot;);//AT&#xD;&#xA;      Serial.flush();&#xD;&#xA;      delay(1000);//enter AT mode finish &#xD;&#xA;      while(Serial.available()&gt;0){&#xD;&#xA;        Serial.write(Serial.read());&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop(){&#xD;&#xA;      Serial.println(&quot;ATDB&quot;);&#xD;&#xA;      &#xD;&#xA;      while(Serial.available()&gt;0){&#xD;&#xA;        Serial.write(Serial.read());&#xD;&#xA;      }&#xD;&#xA;      delay(750);//3/4 a sec&#xD;&#xA;    } &#xD;&#xA;&#xD;&#xA; &#xD;&#xA;Serial.println(&quot;ATDB&quot;); should cause the xbee to drop on the wire the RSSI, see: http://examples.digi.com/wp-content/uploads/2012/06/XBee_WiFi_AT_Commands.pdf&#xD;&#xA;&#xD;&#xA;The three + at the start are how you move the device into AT mode, see:&#xD;&#xA;http://www.mouser.com/pdfdocs/Digi_International_90002124_G.pdf&#xD;&#xA;&#xD;&#xA;Once again what I am trying to do is get the collected RSSI information dropped onto a wifi connection from multiple xbee WiFi S6B equipped Fios.&#xD;&#xA;&#xD;&#xA;Tags: XBEE WiFi 6SB Arduino-Fio RSSI" />
  <row Id="3537" PostHistoryTypeId="1" PostId="1240" RevisionGUID="e95e89fa-d3bb-4c32-abd0-05f4b8be3c25" CreationDate="2014-04-21T09:22:12.893" UserId="1129" Text="XBEE WiFi S6B RSSI" />
  <row Id="3538" PostHistoryTypeId="3" PostId="1240" RevisionGUID="e95e89fa-d3bb-4c32-abd0-05f4b8be3c25" CreationDate="2014-04-21T09:22:12.893" UserId="1129" Text="&lt;wifi&gt;&lt;xbee&gt;" />
  <row Id="3539" PostHistoryTypeId="2" PostId="1241" RevisionGUID="e0e955d0-8ba4-45d8-93ca-b288f87238af" CreationDate="2014-04-21T12:00:09.353" UserId="1132" Text="So I've tried this a few times and I always get the same issue. When I try to run the sweep example the servo goes round 180 degrees but only in steps. Anyone know a way to fix this?&#xD;&#xA;&#xD;&#xA;The servo I'm using is a **Tower Pro Micro Servo 9G SG90**&#xD;&#xA;&#xD;&#xA;Video: http://vidd.me/A40" />
  <row Id="3540" PostHistoryTypeId="1" PostId="1241" RevisionGUID="e0e955d0-8ba4-45d8-93ca-b288f87238af" CreationDate="2014-04-21T12:00:09.353" UserId="1132" Text="My Servo Won't Sweep Smoothly" />
  <row Id="3541" PostHistoryTypeId="3" PostId="1241" RevisionGUID="e0e955d0-8ba4-45d8-93ca-b288f87238af" CreationDate="2014-04-21T12:00:09.353" UserId="1132" Text="&lt;arduino-uno&gt;" />
  <row Id="3547" PostHistoryTypeId="2" PostId="1244" RevisionGUID="92ee8bfb-8679-442b-9b2c-200e8575519d" CreationDate="2014-04-21T16:08:45.997" UserId="980" Text="i got some doubts, i wanna know if it's possible to conect those 2 shields on my arduino uno, after a research on internet, i discovered that they use some of the same pins, even so, still possible for me to conect the LcdKeypad and the ArduinoWifi on my arduino UNO(i know that if i would do it, i would put the lcd on top);&#xD;&#xA;&#xD;&#xA;Here are the pic of the shields, and some information;&#xD;&#xA;[LDC KEYPAD][1]&#xD;&#xA;[Arduino WIFI][2]&#xD;&#xA;&#xD;&#xA;info i got of wifi shield: &#xD;&#xA;&#xD;&#xA;&gt; The Arduino communicates with the processor WiFi shield with the microSD card by SPI &#xD;&#xA;&gt; (Eurotherm the ICSP bus) that is on pins 11, 12&#xD;&#xA;&gt; and 13 at Uno. The pin 10 is used to select the HDG104 and pin 4 to&#xD;&#xA;&gt; the microSD card(i dont need the pin 4 cause i wont use SD). These pins can not be used &#xD;&#xA;&gt; for input and output. The&#xD;&#xA;&gt; digital pin 7 is used for initialization of the communication protocol&#xD;&#xA;&gt; between the shield and Arduino WiFi and should not be used.&#xD;&#xA;&#xD;&#xA;info i got of lcd keypad:&#xD;&#xA;&#xD;&#xA;&gt; This shield we will have to use the following sequence to initialize&#xD;&#xA;&gt; the library LiquidCrystal: &#xD;&#xA;&gt; LiquidCrystal lcd (8,9,4,5,6,7);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;As you guys have noticed, there is the pin 7 on both shields that i need to use, how would it work? can i do this? if i can't, is there any solution that i can expand my pins that would not result buying a MEGA?&#xD;&#xA;&#xD;&#xA;**PS:I STILL HAVE TO CONNECT 2 INFRA-RED SENSORS AND A MOTOR(would result getting the pins 0,1,and 2)(i don't know too if i can connect on the pins TX RX(i tested and they did the job)**&#xD;&#xA;&#xD;&#xA;  [1]: http://www.robotshop.com/media/catalog/product/cache/1/image/325x325/9df78eab33525d08d6e5fb8d27136e95/a/d/adafruit-rgb-lcd-keypad-shield-kit-arduino-i2c.jpg&#xD;&#xA;  [2]: http://ktjjnx9q5vgx99fk.zippykid.netdna-cdn.com/wp-content/uploads/2013/06/arduino-wifi-shield.jpeg&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3548" PostHistoryTypeId="1" PostId="1244" RevisionGUID="92ee8bfb-8679-442b-9b2c-200e8575519d" CreationDate="2014-04-21T16:08:45.997" UserId="980" Text="ArduinoUno+LcdKeypad+ArduinoWifi=Pins Problems" />
  <row Id="3549" PostHistoryTypeId="3" PostId="1244" RevisionGUID="92ee8bfb-8679-442b-9b2c-200e8575519d" CreationDate="2014-04-21T16:08:45.997" UserId="980" Text="&lt;arduino-uno&gt;&lt;pins&gt;&lt;shields&gt;&lt;wifi&gt;" />
  <row Id="3550" PostHistoryTypeId="5" PostId="1240" RevisionGUID="745491ee-c332-4880-a467-202228e9c0ba" CreationDate="2014-04-21T17:19:24.890" UserId="1129" Comment="added 12 characters in body" Text="I am building an early prototype, proof of concept, network monitoring tool.  A big part of it uses localization of a Smartphone.  Seems that the best way to do this is using RSSI from multiple points, I plan to do this using several Arduino Fios with Xbee WiFi (S6B) cards.  &#xD;&#xA;&#xD;&#xA;My current setup has a network running from my smartphone (it is running DHCP) with a laptop monitoring all the traffic on the network.&#xD;&#xA;&#xD;&#xA;What I need is my Fio Xbees to dump the rssi of the &quot;access point&quot; (Smartphone) onto the network so my laptop can pull the data.&#xD;&#xA;&#xD;&#xA;Thus, to/from is not important as far as the packet is concerned, I just need the data dropped on the &quot;wire&quot; for my laptop to later parse, which is good because Serial.print* sends out a broadcast to 255.255.255.255:fffff.&#xD;&#xA;&#xD;&#xA;I can make my devices broadcast any integer, but when I go into AT mode nothing aside from the initial DHCP handshake gets put on the wire, any help would be appreciated.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup() { &#xD;&#xA;      Serial.begin(9600); &#xD;&#xA;      Serial.flush();&#xD;&#xA;      delay(1000);//enter AT mode start&#xD;&#xA;      Serial.print(&quot;+&quot;);//AT&#xD;&#xA;      Serial.print(&quot;+&quot;);//AT&#xD;&#xA;      Serial.print(&quot;+&quot;);//AT&#xD;&#xA;      Serial.flush();&#xD;&#xA;      delay(1000);//enter AT mode finish &#xD;&#xA;      while(Serial.available()&gt;0){&#xD;&#xA;        Serial.write(Serial.read());&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop(){&#xD;&#xA;      Serial.println(&quot;ATDB&quot;);&#xD;&#xA;      &#xD;&#xA;      while(Serial.available()&gt;0){&#xD;&#xA;        Serial.write(Serial.read());&#xD;&#xA;      }&#xD;&#xA;      delay(750);//3/4 a sec&#xD;&#xA;    } &#xD;&#xA;&#xD;&#xA; &#xD;&#xA;Serial.println(&quot;ATDB&quot;); should cause the xbee to drop on the wire the RSSI, see: http://examples.digi.com/wp-content/uploads/2012/06/XBee_WiFi_AT_Commands.pdf&#xD;&#xA;&#xD;&#xA;The three &quot;+&quot; at the start are how you move the device into AT mode, see:&#xD;&#xA;http://www.mouser.com/pdfdocs/Digi_International_90002124_G.pdf&#xD;&#xA;&#xD;&#xA;Once again what I am trying to do is get the collected RSSI information dropped onto a wifi connection from multiple xbee WiFi S6B equipped Fios.&#xD;&#xA;&#xD;&#xA;Tags: XBEE WiFi 6SB Arduino-Fio RSSI" />
  <row Id="3551" PostHistoryTypeId="5" PostId="1240" RevisionGUID="6d162fa3-2836-4698-a122-7e0082326970" CreationDate="2014-04-21T17:41:44.240" UserId="11" Comment="Don't put tags in the question body, there is a dedicated area for that." Text="I am building an early prototype, proof of concept, network monitoring tool.  A big part of it uses localization of a Smartphone.  Seems that the best way to do this is using RSSI from multiple points, I plan to do this using several Arduino Fios with Xbee WiFi (S6B) cards.  &#xD;&#xA;&#xD;&#xA;My current setup has a network running from my smartphone (it is running DHCP) with a laptop monitoring all the traffic on the network.&#xD;&#xA;&#xD;&#xA;What I need is my Fio Xbees to dump the rssi of the &quot;access point&quot; (Smartphone) onto the network so my laptop can pull the data.&#xD;&#xA;&#xD;&#xA;Thus, to/from is not important as far as the packet is concerned, I just need the data dropped on the &quot;wire&quot; for my laptop to later parse, which is good because Serial.print* sends out a broadcast to 255.255.255.255:fffff.&#xD;&#xA;&#xD;&#xA;I can make my devices broadcast any integer, but when I go into AT mode nothing aside from the initial DHCP handshake gets put on the wire, any help would be appreciated.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void setup() { &#xD;&#xA;      Serial.begin(9600); &#xD;&#xA;      Serial.flush();&#xD;&#xA;      delay(1000);//enter AT mode start&#xD;&#xA;      Serial.print(&quot;+&quot;);//AT&#xD;&#xA;      Serial.print(&quot;+&quot;);//AT&#xD;&#xA;      Serial.print(&quot;+&quot;);//AT&#xD;&#xA;      Serial.flush();&#xD;&#xA;      delay(1000);//enter AT mode finish &#xD;&#xA;      while(Serial.available()&gt;0){&#xD;&#xA;        Serial.write(Serial.read());&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop(){&#xD;&#xA;      Serial.println(&quot;ATDB&quot;);&#xD;&#xA;      &#xD;&#xA;      while(Serial.available()&gt;0){&#xD;&#xA;        Serial.write(Serial.read());&#xD;&#xA;      }&#xD;&#xA;      delay(750);//3/4 a sec&#xD;&#xA;    } &#xD;&#xA;&#xD;&#xA; &#xD;&#xA;Serial.println(&quot;ATDB&quot;); should cause the xbee to drop on the wire the RSSI, see: http://examples.digi.com/wp-content/uploads/2012/06/XBee_WiFi_AT_Commands.pdf&#xD;&#xA;&#xD;&#xA;The three &quot;+&quot; at the start are how you move the device into AT mode, see:&#xD;&#xA;http://www.mouser.com/pdfdocs/Digi_International_90002124_G.pdf&#xD;&#xA;&#xD;&#xA;Once again what I am trying to do is get the collected RSSI information dropped onto a wifi connection from multiple xbee WiFi S6B equipped Fios." />
  <row Id="3552" PostHistoryTypeId="6" PostId="1240" RevisionGUID="6d162fa3-2836-4698-a122-7e0082326970" CreationDate="2014-04-21T17:41:44.240" UserId="11" Comment="Don't put tags in the question body, there is a dedicated area for that." Text="&lt;wifi&gt;&lt;xbee&gt;&lt;arduino-fio&gt;" />
  <row Id="3553" PostHistoryTypeId="5" PostId="1241" RevisionGUID="a2d9cdc7-795d-4b4a-9fa4-67eeadf49043" CreationDate="2014-04-21T17:43:57.703" UserId="11" Comment="added 1197 characters in body; edited tags" Text="So I've tried this a few times and I always get the same issue. When I try to run the sweep example the servo goes round 180 degrees but only in steps. Anyone know a way to fix this?&#xD;&#xA;&#xD;&#xA;The servo I'm using is a **Tower Pro Micro Servo 9G SG90**&#xD;&#xA;&#xD;&#xA;    // Sweep&#xD;&#xA;    // by BARRAGAN &lt;http://barraganstudio.com&gt; &#xD;&#xA;    // This example code is in the public domain.&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    #include &lt;Servo.h&gt; &#xD;&#xA;     &#xD;&#xA;    Servo myservo;  // create servo object to control a servo &#xD;&#xA;                    // a maximum of eight servo objects can be created &#xD;&#xA;     &#xD;&#xA;    int pos = 0;    // variable to store the servo position &#xD;&#xA;     &#xD;&#xA;    void setup() &#xD;&#xA;    { &#xD;&#xA;      myservo.attach(9);  // attaches the servo on pin 9 to the servo object &#xD;&#xA;    } &#xD;&#xA;     &#xD;&#xA;     &#xD;&#xA;    void loop() &#xD;&#xA;    { &#xD;&#xA;      for(pos = 0; pos &lt; 180; pos += 1)  // goes from 0 degrees to 180 degrees &#xD;&#xA;      {                                  // in steps of 1 degree &#xD;&#xA;        myservo.write(pos);              // tell servo to go to position in variable 'pos' &#xD;&#xA;        delay(15);                       // waits 15ms for the servo to reach the position &#xD;&#xA;      } &#xD;&#xA;      for(pos = 180; pos&gt;=1; pos-=1)     // goes from 180 degrees to 0 degrees &#xD;&#xA;      {                                &#xD;&#xA;        myservo.write(pos);              // tell servo to go to position in variable 'pos' &#xD;&#xA;        delay(15);                       // waits 15ms for the servo to reach the position &#xD;&#xA;      } &#xD;&#xA;    } &#xD;&#xA;&#xD;&#xA;Video: http://vidd.me/A40" />
  <row Id="3554" PostHistoryTypeId="6" PostId="1241" RevisionGUID="a2d9cdc7-795d-4b4a-9fa4-67eeadf49043" CreationDate="2014-04-21T17:43:57.703" UserId="11" Comment="added 1197 characters in body; edited tags" Text="&lt;arduino-uno&gt;&lt;servo&gt;" />
  <row Id="3557" PostHistoryTypeId="5" PostId="1244" RevisionGUID="d00a93f5-3ca2-4209-b540-efe29ed1da7c" CreationDate="2014-04-21T21:31:04.957" UserId="220" Comment="Please do not bold or use all caps" Text="Is it possible to connect these two shields to my Arduino Uno? After a research on the internet, I discovered that they use some of the same pins. Even so, is it still possible for me to connect the LcdKeypad and the ArduinoWifi on my Arduino Uno? (the LCD would be on top)&#xD;&#xA;&#xD;&#xA;Here are the pic of the shields, and some information:&#xD;&#xA;&#xD;&#xA;[LDC KEYPAD][1]&#xD;&#xA;&#xD;&#xA;[Arduino WIFI][2]&#xD;&#xA;&#xD;&#xA;WiFi shield info:&#xD;&#xA;&#xD;&#xA;&gt; The Arduino communicates with the processor WiFi shield with the microSD card by SPI &#xD;&#xA;&gt; (Eurotherm the ICSP bus) that is on pins 11, 12&#xD;&#xA;&gt; and 13 at Uno. The pin 10 is used to select the HDG104 and pin 4 to&#xD;&#xA;&gt; the microSD card(i dont need the pin 4 cause i wont use SD). These pins can not be used &#xD;&#xA;&gt; for input and output. The&#xD;&#xA;&gt; digital pin 7 is used for initialization of the communication protocol&#xD;&#xA;&gt; between the shield and Arduino WiFi and should not be used.&#xD;&#xA;&#xD;&#xA;LCD info:&#xD;&#xA;&#xD;&#xA;&gt; This shield we will have to use the following sequence to initialize&#xD;&#xA;&gt; the library LiquidCrystal: &#xD;&#xA;&gt; LiquidCrystal lcd (8,9,4,5,6,7);&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;As you guys have noticed, there is the pin 7 on both shields that I need to use. How would it work? Can I do this? If i can't, is there any solution that I can expand my pins that would not result buying a Mega?&#xD;&#xA;&#xD;&#xA;I still have to connect two INFRA-RED sensors and a motor (using pins 0, 1, and 2). I don't know if i can connect on the pins TX and RX (they seem to work).&#xD;&#xA;&#xD;&#xA;  [1]: http://www.robotshop.com/media/catalog/product/cache/1/image/325x325/9df78eab33525d08d6e5fb8d27136e95/a/d/adafruit-rgb-lcd-keypad-shield-kit-arduino-i2c.jpg&#xD;&#xA;  [2]: http://ktjjnx9q5vgx99fk.zippykid.netdna-cdn.com/wp-content/uploads/2013/06/arduino-wifi-shield.jpeg&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3558" PostHistoryTypeId="2" PostId="1245" RevisionGUID="e22eb527-28cc-4c67-bd66-5509d1e6ef94" CreationDate="2014-04-21T22:05:54.970" UserId="220" Text="**So here are your needs:**&#xD;&#xA;&#xD;&#xA; - WiFi, which uses pins 4, 10, 11, 12, 13. I know you said that you don't need pin 4 since no SD, **but because that pin switches on/off the SD card, if you use it *at all,* the SD card will be enabled.**&#xD;&#xA; - LCD, which uses pins 4, 5, 6, 7, 8, 9. The standard Arduino LCD library can use any pins, but your shield is hard wired to use those. Don't worry, you can still connect them!&#xD;&#xA;&#xD;&#xA;All you will have to do is:&#xD;&#xA;&#xD;&#xA; - Bend pin 4 on the LCD shield and the WiFi shield outward so it doesn't make contact with the header&#xD;&#xA; - Use `LiquidCrystal lcd(8,9,3,5,6,7);` in your code&#xD;&#xA; - Attach a jumper between the pin 4 on the header of the WiFi shield and the pin 4 on the Arduino Uno&#xD;&#xA; - Attach a jumper between the pin 3 of the WiFi shield (or the Uno, if that's easier) and the pin 4 of the LCD.&#xD;&#xA;&#xD;&#xA;This will isolate pin 4 on the LCD, still send the pin 4 signal to the WiFi shield, and reroute the signal from pin 3 on your Arduino to pin 4 on the LCD shield.&#xD;&#xA;&#xD;&#xA;For number of pins, you should be fine. You can use pins 0 and 1 (TX/RX) **as long as you aren't connecting to the computer or any other UART device**  (i.e. using the `Serial()` library). Don't forget you can use the analog pins as digital pins by referencing them as `A0` to `A5`." />
  <row Id="3559" PostHistoryTypeId="5" PostId="1245" RevisionGUID="5d0e10a4-e1d0-47c7-b03e-b858769c27b6" CreationDate="2014-04-22T00:51:10.803" UserId="220" Comment="Clarified about pin 4" Text="**So here are your needs:**&#xD;&#xA;&#xD;&#xA; - WiFi, which uses pins 4, 10, 11, 12, 13. I know you said that you don't need pin 4 since no SD, but because that pin switches on/off the SD card, if you use it at all, the SD card will be enabled. Note: As Connor Wolf points out, it's not really relevant when there's no SD card, but I still think that it shouldn't be overlooked because if you forget and plug in a SD card, problems will arise. If you want to prevent this from happening, look at my &quot;hack&quot; below.&#xD;&#xA; - LCD, which uses pins 4, 5, 6, 7, 8, 9. The standard Arduino LCD library can use any pins, but your shield is hard wired to use those. As mentioned before, you can reroute them if you want to. Below is the method for rerouting pins.&#xD;&#xA;&#xD;&#xA;****&#xD;&#xA;## Rerouting pins (optional):&#xD;&#xA;&#xD;&#xA; - Bend pin 4 on the LCD shield and the WiFi shield outward so it doesn't make contact with the header&#xD;&#xA; - Use `LiquidCrystal lcd(8,9,3,5,6,7);` in your code&#xD;&#xA; - Attach a jumper between the pin 4 on the header of the WiFi shield and the pin 4 on the Arduino Uno&#xD;&#xA; - Attach a jumper between the pin 3 of the WiFi shield (or the Uno, if that's easier) and the pin 4 of the LCD.&#xD;&#xA;&#xD;&#xA;This will isolate pin 4 on the LCD, still send the pin 4 signal to the WiFi shield, and reroute the signal from pin 3 on your Arduino to pin 4 on the LCD shield.&#xD;&#xA;****&#xD;&#xA;For number of pins, you should be fine. You can use pins 0 and 1 (TX/RX) **as long as you aren't connecting to the computer or any other UART device**  (i.e. using the `Serial()` library). Don't forget you can use the analog pins as digital pins by referencing them as `A0` to `A5`." />
  <row Id="3560" PostHistoryTypeId="2" PostId="1246" RevisionGUID="20b23ee2-c6e9-4e92-bc1b-0938fe7346d4" CreationDate="2014-04-22T06:10:25.483" UserId="904" Text="I am creating webserver application . I am new to webserver Design system . I wanted to create  tag Where i can change date &amp; time and write from webserver.Here is my code. I want to get data from Webserver see change is Display &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;Ethernet.h&gt;&#xD;&#xA;    static int local_day;&#xD;&#xA;    static int local_month;&#xD;&#xA;    static int local_year;&#xD;&#xA;    static int local_s;&#xD;&#xA;    static int local_h;&#xD;&#xA;    static int local_m;&#xD;&#xA;    byte mac[] = { &#xD;&#xA;      0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };&#xD;&#xA;    byte ip[] = { &#xD;&#xA;      192, 168,1, 120 };  &#xD;&#xA;    EthernetServer server(80);&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      Ethernet.begin(mac, ip);&#xD;&#xA;      server.begin();&#xD;&#xA;    }&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      Ethernet_Control();&#xD;&#xA;    }&#xD;&#xA;    void Ethernet_Control()&#xD;&#xA;    {&#xD;&#xA;      EthernetClient client = server.available();&#xD;&#xA;      // detect if current is the first line&#xD;&#xA;      boolean current_line_is_first = true;&#xD;&#xA;    &#xD;&#xA;      if (client) {&#xD;&#xA;        // an http request ends with a blank line&#xD;&#xA;        boolean current_line_is_blank = true;&#xD;&#xA;        while (client.connected()) {&#xD;&#xA;          if (client.available()) {&#xD;&#xA;            char c = client.read();&#xD;&#xA;    &#xD;&#xA;            // if we've gotten to the end of the line (received a newline&#xD;&#xA;            // character) and the line is blank, the http request has ended,&#xD;&#xA;            // so we can send a reply&#xD;&#xA;            if (c == '\n' &amp;&amp; current_line_is_blank) {&#xD;&#xA;    &#xD;&#xA;              // send a standard http response header&#xD;&#xA;              client.println(F(&quot;HTTP/1.1 200 OK&quot;));&#xD;&#xA;              client.println(F(&quot;Content-Type: text/html&quot;));&#xD;&#xA;              client.println();&#xD;&#xA;              client.print(&quot; &lt;font&gt; &lt;color=blue&gt; DD: &lt;input type=text name=01 value=&quot;);&#xD;&#xA;              client.println(local_day);&#xD;&#xA;              client.print(&quot; &lt;font&gt; &lt;color=blue&gt; month: &lt;input type=text name=01 value=&quot;);&#xD;&#xA;              client.println(local_month);&#xD;&#xA;              client.print(&quot; &lt;font&gt; &lt;color=blue&gt; year: &lt;input type=text name=01 value=&quot;);&#xD;&#xA;              client.println(local_year);&#xD;&#xA;              client.print(&quot; &lt;font&gt; &lt;color=blue&gt; hour: &lt;input type=text name=01 value=&quot;);&#xD;&#xA;              client.println(local_h);&#xD;&#xA;              client.print(&quot; &lt;font&gt; &lt;color=blue&gt; min: &lt;input type=text name=01 value=&quot;);&#xD;&#xA;              client.println(local_m);&#xD;&#xA;              client.print(&quot; &lt;font&gt; &lt;color=blue&gt; sec: &lt;input type=text name=01 value=&quot;);&#xD;&#xA;              client.println(local_s);&#xD;&#xA;              client.println(&quot;&quot;);&#xD;&#xA;               client.println(F(&quot;&lt;/form&gt;&lt;br /&gt;&quot;));&#xD;&#xA;              client.println(&quot;&lt;p&gt;NOTE: This page will automatically refresh every 5 seconds.&lt;/p&gt;&lt;/center&gt;&quot;);&#xD;&#xA;              &#xD;&#xA;              client.println(F(&quot;&lt;center&gt;&lt;p&gt;&lt;h5&gt;Web application  V1.0&lt;/h5&gt;&lt;/p&gt;&lt;center&gt;&lt;hr&gt;&lt;br /&gt;&quot;));&#xD;&#xA;              client.print(F(&quot;&lt;p&gt;&lt;h5&gt;DATE: = &lt;font color=indigo&gt;&quot;));&#xD;&#xA;              client.print(local_day);&#xD;&#xA;              client.print(&quot;/&quot;);&#xD;&#xA;              client.print(local_month);&#xD;&#xA;              client.print(&quot;/&quot;);&#xD;&#xA;              client.print(local_year); &#xD;&#xA;              client.println(&quot;&lt;/font&gt;&lt;/h5&gt;&lt;/p&gt;&quot;);&#xD;&#xA;              client.print(F(&quot;&lt;p&gt;&lt;h5&gt;TIME: = &lt;font color=indigo&gt;&quot;));&#xD;&#xA;              client.print(local_h);&#xD;&#xA;              client.print(&quot;:&quot;);&#xD;&#xA;              client.print(local_m);&#xD;&#xA;              client.print(&quot;:&quot;);&#xD;&#xA;              client.print(local_s);&#xD;&#xA;              client.println(&quot;&lt;/font&gt;&lt;/h5&gt;&lt;/p&gt;&quot;);&#xD;&#xA;              &#xD;&#xA;              &#xD;&#xA;    &#xD;&#xA;              break;&#xD;&#xA;            }&#xD;&#xA;    &#xD;&#xA;            if (c == '\n') {&#xD;&#xA;              // we're starting a new line&#xD;&#xA;    &#xD;&#xA;              current_line_is_blank = true;&#xD;&#xA;            } &#xD;&#xA;            else if (c != '\r') {&#xD;&#xA;              // we've gotten a character on the current line&#xD;&#xA;              current_line_is_blank = false;&#xD;&#xA;            }&#xD;&#xA;          }&#xD;&#xA;         &#xD;&#xA;        }&#xD;&#xA;      delay(1);&#xD;&#xA;      client.stop();  &#xD;&#xA;     &#xD;&#xA;    }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3561" PostHistoryTypeId="1" PostId="1246" RevisionGUID="20b23ee2-c6e9-4e92-bc1b-0938fe7346d4" CreationDate="2014-04-22T06:10:25.483" UserId="904" Text="Web server alternating value" />
  <row Id="3562" PostHistoryTypeId="3" PostId="1246" RevisionGUID="20b23ee2-c6e9-4e92-bc1b-0938fe7346d4" CreationDate="2014-04-22T06:10:25.483" UserId="904" Text="&lt;arduino-uno&gt;&lt;programming&gt;&lt;web-server&gt;&lt;web&gt;" />
  <row Id="3563" PostHistoryTypeId="2" PostId="1247" RevisionGUID="f91552a6-02cd-4a1d-b3f6-e9b06730c197" CreationDate="2014-04-22T07:48:37.103" UserId="693" Text="I have downloaded BOSSA for Linux, and have run `bossash-&gt;scan`. I have also tried erasing and resetting the board before scanning. It does not work. According to the [Arduino website][1], the native USB port is connected directly to the chip. &#xD;&#xA;&#xD;&#xA;Isn't the master branch BOSSA (Arduino IDE uses it's own modified version of BOSSA) working because of a problem with this specific board, or have Arduino modified something inside the chip which alters the behaviour of the native port?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/arduinoBoardDue" />
  <row Id="3564" PostHistoryTypeId="1" PostId="1247" RevisionGUID="f91552a6-02cd-4a1d-b3f6-e9b06730c197" CreationDate="2014-04-22T07:48:37.103" UserId="693" Text="Why doesn't the master branch BOSSA work on Arduino Due?" />
  <row Id="3565" PostHistoryTypeId="3" PostId="1247" RevisionGUID="f91552a6-02cd-4a1d-b3f6-e9b06730c197" CreationDate="2014-04-22T07:48:37.103" UserId="693" Text="&lt;arduino-due&gt;&lt;bootloader&gt;&lt;bossa&gt;" />
  <row Id="3566" PostHistoryTypeId="2" PostId="1248" RevisionGUID="82a1a4c7-564c-492f-84b7-39a232d508a6" CreationDate="2014-04-22T09:47:09.093" UserId="1136" Text="It looks like your sketch runs in slow motion.&#xD;&#xA;&#xD;&#xA;Check if you wrote delay(150) or have an additional delay in your loop.&#xD;&#xA;Check twice and - just to make sure - upload the corrected sketch again.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3567" PostHistoryTypeId="2" PostId="1249" RevisionGUID="c357d910-879d-4978-87bb-86842e1a3e4c" CreationDate="2014-04-22T10:36:36.723" UserId="9" Text="You could try the [K30 CO2 sensor][1]. There is also a guide using it to make an arduino CO2 detector [here][2].&#xD;&#xA;&#xD;&#xA;I've also seen people use the MG-811 module, you can buy them from dfrobot.com(for some reason I can't post more than 2 links). There is also good documentation for how to use the MG-811 with arduino(see my comment).&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.co2meter.com/products/k-30-co2-sensor-module&#xD;&#xA;  [2]: http://www.openhomeautomation.net/wireless-co2-sensor-arduino/&#xD;&#xA;  [3]: http://www.dfrobot.com/index.php?route=product/product&amp;product_id=1023#.U1ZEtvldWxY" />
  <row Id="3569" PostHistoryTypeId="2" PostId="1251" RevisionGUID="ba8a9497-69b6-4562-bbe6-708441dd0124" CreationDate="2014-04-22T16:44:36.173" UserId="490" Text="Does anyone know where I can find a Chlorine Sensor to use with the Arduino? It would need to be water proof. I've googled, but I couldn't find anything." />
  <row Id="3570" PostHistoryTypeId="1" PostId="1251" RevisionGUID="ba8a9497-69b6-4562-bbe6-708441dd0124" CreationDate="2014-04-22T16:44:36.173" UserId="490" Text="A waterproof Chlorine Sensor" />
  <row Id="3571" PostHistoryTypeId="3" PostId="1251" RevisionGUID="ba8a9497-69b6-4562-bbe6-708441dd0124" CreationDate="2014-04-22T16:44:36.173" UserId="490" Text="&lt;sensors&gt;" />
  <row Id="3572" PostHistoryTypeId="2" PostId="1252" RevisionGUID="51da13f6-85df-486d-ac9c-0da4d1fe8e0c" CreationDate="2014-04-22T16:50:41.413" UserId="83" Text="No Arduino did not alter the chip, custom chips are massively expensive. If they are using their own modified version of BOSSA, then there must be a reason for it, probably the support of Arduino's hardware platform. To find out what the difference is, you have to find the code base used for Due and the original version when the code was forked. Often in such cases a project like Arduino can provide a patch to the BOSSA project, and that patch may or may not be applied to the master tree. Only way to find out is to check the BOSSA project repository / bug  reports and documentation." />
  <row Id="3573" PostHistoryTypeId="2" PostId="1253" RevisionGUID="508c203a-3d86-4903-a03a-984b97c80ad1" CreationDate="2014-04-22T18:53:38.687" UserId="1129" Text="Just incase anybody stumbles onto this page googling, I am posting my solution below (I *think* it will work for any xbee radio)&#xD;&#xA;&#xD;&#xA;Basically for some reason the RSSI values are getting nulled out before I can read them, both in my API mode tests and AT commands.  I'm not convinced that there is not some way around this in API mode at least, but it is irrelevant for my current purpose.&#xD;&#xA; &#xD;&#xA;What I did was wire pin 6 on the xbee to a digital pin on the Arduino (I used 7) then use a pulse detector to find the period of the wireless signal coming in.&#xD;&#xA;&#xD;&#xA;    int pin = 7;&#xD;&#xA;    unsigned long period;&#xD;&#xA;    &#xD;&#xA;    void setup(){&#xD;&#xA;      Serial.begin(9600); &#xD;&#xA;      pinMode(pin, INPUT);&#xD;&#xA;      Serial.println(&quot;Getting started&quot;);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop(){&#xD;&#xA;      delay(100);&#xD;&#xA;      period = pulseIn(pin, HIGH);&#xD;&#xA;      Serial.println(period);&#xD;&#xA;    &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;It is not perfect, but for now it works, might help someone else in the future." />
  <row Id="3574" PostHistoryTypeId="2" PostId="1254" RevisionGUID="84d2d213-4ced-4c21-8ece-b5c5c288cb71" CreationDate="2014-04-22T19:07:42.567" UserId="1136" Text="This should give you an idea of how to create a custom library which you can use in your project. I actually compiled it with Arduino IDE 1.0.5 on Mac OsX. &#xD;&#xA;I did not run it on an Arduino board, but have similar code in a production project, that works just fine.&#xD;&#xA;&#xD;&#xA;Start a new Arduino sketch, name it as you like.&#xD;&#xA;&#xD;&#xA;Go to the folder where you saved that file.&#xD;&#xA;&#xD;&#xA;Add a new file called MyServoLib.h parallel to your main project file.&#xD;&#xA;&#xD;&#xA;In your main file, include the servo library from Arduino and your custom library like so:&#xD;&#xA;&#xD;&#xA;    #include &lt;Servo.h&gt;&#xD;&#xA;    #include &quot;MyNewLib.h&quot;&#xD;&#xA;&#xD;&#xA;If you close and reopen your project, it the Arduino IDE will automatically load your custom library file as well.&#xD;&#xA;&#xD;&#xA;Copy the following simple stub code into your custom library file:&#xD;&#xA;&#xD;&#xA;    #ifndef MY_SERVO_LIB_H__&#xD;&#xA;    #define  MY_SERVO_LIB_H__&#xD;&#xA;    &#xD;&#xA;    #include &lt;Servo.h&gt;&#xD;&#xA;    #include &lt;Arduino.h&gt;&#xD;&#xA;    &#xD;&#xA;    class MyServoLib&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;    &#xD;&#xA;      MyServoLib()&#xD;&#xA;        : _servoPin(9)&#xD;&#xA;        , _attached(false)&#xD;&#xA;      {}&#xD;&#xA;    &#xD;&#xA;      void attach()&#xD;&#xA;      {&#xD;&#xA;        if (_attached)&#xD;&#xA;          return;      &#xD;&#xA;    &#xD;&#xA;        _attached = true;&#xD;&#xA;        _servo.attach(_servoPin);&#xD;&#xA;      }&#xD;&#xA;        &#xD;&#xA;      void detach()&#xD;&#xA;      {&#xD;&#xA;          if (! _attached)&#xD;&#xA;              return;&#xD;&#xA;        &#xD;&#xA;          _attached = false;&#xD;&#xA;          _servo.detach();&#xD;&#xA;      }    &#xD;&#xA;      &#xD;&#xA;      void setPin(int pin){&#xD;&#xA;        _servoPin = pin;&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    private:&#xD;&#xA;    &#xD;&#xA;      bool _attached;&#xD;&#xA;      Servo _servo;&#xD;&#xA;      int _servoPin;&#xD;&#xA;    &#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Your main file should look like this:&#xD;&#xA;&#xD;&#xA;    #include &lt;Servo.h&gt;&#xD;&#xA;    #include &quot;MyNewLib.h&quot;&#xD;&#xA;    &#xD;&#xA;    // use your custom lib here&#xD;&#xA;    MyServoLib myServo;&#xD;&#xA;    int MyServoPin = 5;&#xD;&#xA;    &#xD;&#xA;    void setup(){&#xD;&#xA;    &#xD;&#xA;      pinMode(MyServoPin, OUTPUT);&#xD;&#xA;      myServo.setPin(MyServoPin);  &#xD;&#xA;      myServo.attach();&#xD;&#xA;&#xD;&#xA;      // your additional setup code here&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop(){&#xD;&#xA;    &#xD;&#xA;      // your main code here&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;That's it!&#xD;&#xA;&#xD;&#xA;Upload it to an Arduino board and give it a try. The servo won't move, but it should get powered on." />
  <row Id="3575" PostHistoryTypeId="5" PostId="1193" RevisionGUID="2d5ff165-eec2-468b-be94-af6dc4cca45b" CreationDate="2014-04-22T20:58:49.460" UserId="84" Comment="formatted code from picture to text" Text="I've succeeded to get an Arduino to work with a pressure sensor.&#xD;&#xA;&#xD;&#xA;What I want to do is &#xD;&#xA;&#xD;&#xA; - when I put pressure on the sensor, after 5 minutes the led lights on.&#xD;&#xA; - it starts over again if there's no pressure on the sensor.&#xD;&#xA;&#xD;&#xA;Here's the program:&#xD;&#xA;&#xD;&#xA;    // FSR is verbonden met analoog 0 &#xD;&#xA;    int fsrAnalogePin = 0; &#xD;&#xA;    // De LED is verbonden met pin 11 (pmw pin) &#xD;&#xA;    int LEDpin = 11; &#xD;&#xA;    // De analoge waarde van de fsr spanningdeler &#xD;&#xA;    int fsrWaarde; &#xD;&#xA;    // De helderheid van de led tussen 0 en 255 &#xD;&#xA;    int LEDhelderheid; &#xD;&#xA;    &#xD;&#xA;    void setup() { &#xD;&#xA;        // start de serial monitor &#xD;&#xA;        Serial.begin(9600); &#xD;&#xA;        pinMode(LEDpin, OUTPUT); &#xD;&#xA;    } &#xD;&#xA;    &#xD;&#xA;    void loop() { &#xD;&#xA;        fsrWaarde = analogRead(fsrAnalogePin); &#xD;&#xA;        // print ‘Analoge waarde’ &#xD;&#xA;        Serial.print(“Analoge waarde = “); &#xD;&#xA;        // print de fsrwaarde op de monitor &#xD;&#xA;        Serial.println(fsrWaarde); &#xD;&#xA;    &#xD;&#xA;        // maak van getallen tussen 0 en 1023 getallen tussen 0 en 255 &#xD;&#xA;        LEDhelderheid = map(fsrWaarde, 0, 50, 0, 255); &#xD;&#xA;        analogWrite(LEDpin, LEDhelderheid); &#xD;&#xA;        delay(100); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I've got this for the pressure sensor... now I need to combine it with 5 minutes and the led lights on when it's reached that 5 min of pressure.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3576" PostHistoryTypeId="5" PostId="1245" RevisionGUID="cfb13226-5040-427c-8c11-0ac99b2fa816" CreationDate="2014-04-22T21:21:06.470" UserId="220" Comment="added 674 characters in body" Text="**So here are your needs:**&#xD;&#xA;&#xD;&#xA; - WiFi, which uses pins 4, 10, 11, 12, 13. I know you said that you don't need pin 4 since no SD, but because that pin switches on/off the SD card, if you use it at all. Note: As Connor Wolf points out, it's not really relevant when there's no SD card. If you're facing problems with the Ethernet shield using the LCD additionally, you might have to reroute pin 4.&#xD;&#xA; - LCD, which uses pins 4, 5, 6, 7, 8, 9. The standard Arduino LCD library can use any pins, but your shield is hard wired to use those. As mentioned before, you can reroute them if you want to. Below is the method for rerouting pins.&#xD;&#xA;&#xD;&#xA;****&#xD;&#xA;## Rerouting pin 7 (you need to do this!):&#xD;&#xA;&#xD;&#xA; - Bend pin 7 on the LCD shield and the WiFi shield outward so it doesn't make contact with the header&#xD;&#xA; - Use `LiquidCrystal lcd(8,9,3,5,6,2);` if you're rerouting pin 4, or `LiquidCrystal lcd (8,9,4,5,6,2);` in your code if you're not rerouting&#xD;&#xA; - Attach a jumper between the pin 7 on the header of the WiFi shield and the pin 7 on the Arduino Uno&#xD;&#xA; - Attach a jumper between the pin 2 of the WiFi shield (or the Uno, if that's easier) and the pin 7 of the LCD using the free space of the pin bent above it.&#xD;&#xA;&#xD;&#xA;This will isolate pin 7 on the LCD, still send the pin 4 signal to the WiFi shield, and reroute the signal from pin 2 on your Arduino to pin 7 on the LCD shield.&#xD;&#xA;****&#xD;&#xA;## Rerouting pin 4 (optional):&#xD;&#xA;&#xD;&#xA; - Bend pin 4 on the LCD shield and the WiFi shield outward so it doesn't make contact with the header&#xD;&#xA; - Use `LiquidCrystal lcd(8,9,3,5,6,2);` in your code&#xD;&#xA; - Attach a jumper between the pin 4 on the header of the WiFi shield and the pin 4 on the Arduino Uno&#xD;&#xA; - Attach a jumper between the pin 3 of the WiFi shield (or the Uno, if that's easier) and the pin 4 of the LCD using the free space of the pin bent above it.&#xD;&#xA;&#xD;&#xA;This will isolate pin 4 on the LCD, still send the pin 4 signal to the WiFi shield, and reroute the signal from pin 3 on your Arduino to pin 4 on the LCD shield.&#xD;&#xA;****&#xD;&#xA;For number of pins, you should be fine. You can use pins 0 and 1 (TX/RX) **as long as you aren't connecting to the computer or any other UART device**  (i.e. using the `Serial()` library). Don't forget you can use the analog pins as digital pins by referencing them as `A0` to `A5`." />
  <row Id="3577" PostHistoryTypeId="36" PostId="1255" RevisionGUID="a6125ad3-2f67-42f4-971f-6569df7b0a9d" CreationDate="2014-04-22T21:22:07.400" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/107324/seeed-studio-motor-shield" />
  <row Id="3578" PostHistoryTypeId="2" PostId="1255" RevisionGUID="206e09f4-9fff-4693-a208-03be6d3b4db5" CreationDate="2014-04-21T00:52:39.887" UserId="1193" UserDisplayName="user40632" Text="My goal is to have my Arduino fire two stepper motors.  They need not be simultaneous. I'm using an Arduino Uno with 2 motor shields - specifically, the [Seeed Studio Motor Shield v1.0][1]. I know this shield uses D8-13.  &#xD;&#xA;&#xD;&#xA;Question is, how can I get the Arduino to use both shields?  Is there a way to make one of the shields take D0-D7?  If I could do that that'd be great. As far as I can tell, there's no way. The motor shields cannot be physically mounted either.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.seeedstudio.com/depot/Motor-Shield-p-913.html?cPath=73" />
  <row Id="3579" PostHistoryTypeId="1" PostId="1255" RevisionGUID="206e09f4-9fff-4693-a208-03be6d3b4db5" CreationDate="2014-04-21T00:52:39.887" UserId="1193" UserDisplayName="user40632" Text="Seeed Studio motor shield" />
  <row Id="3580" PostHistoryTypeId="3" PostId="1255" RevisionGUID="206e09f4-9fff-4693-a208-03be6d3b4db5" CreationDate="2014-04-21T00:52:39.887" UserId="1193" UserDisplayName="user40632" Text="&lt;motor&gt;" />
  <row Id="3583" PostHistoryTypeId="2" PostId="1256" RevisionGUID="66a58543-2443-4bfe-bd88-01e15a4d37fe" CreationDate="2014-04-23T02:17:16.723" UserId="1143" Text="I got some code to receive characters from Bluetooth and code and print it back to the LCD display.&#xD;&#xA;&#xD;&#xA;However, want to detect the *`Enter`* *character* to be the input signal, in other words, not to print nothing to the display until &lt;kbd&gt;Enter&lt;/kbd&gt; is pressed.&#xD;&#xA;&#xD;&#xA;An strange character is shown at display for &lt;kbd&gt;Enter&lt;/kbd&gt; but I can't *catch it*.&#xD;&#xA;&#xD;&#xA;This is my code:&#xD;&#xA;&#xD;&#xA;    #include &lt;Wire.h&gt; &#xD;&#xA;    #include &lt;LiquidCrystal_I2C.h&gt;&#xD;&#xA;    &#xD;&#xA;    LiquidCrystal_I2C lcd(0x20,16,2); &#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      lcd.init();&#xD;&#xA;      lcd.backlight();&#xD;&#xA;      pinMode(13,OUTPUT);&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      Serial1.begin(9600);&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;      while (Serial1.available())&#xD;&#xA;      { &#xD;&#xA;        char dato= Serial1.read(); //Comprobamos el dato &#xD;&#xA;        &#xD;&#xA;         lcd.print(dato);&#xD;&#xA;         &#xD;&#xA;        &#xD;&#xA;        switch(dato) { &#xD;&#xA;        case '#':  &#xD;&#xA;          Serial.println(&quot;GATO...&quot;);&#xD;&#xA;        break;  &#xD;&#xA;        case 'e':  digitalWrite(13,LOW); &#xD;&#xA;    &#xD;&#xA;        Serial1.println(&quot;Led apagado&quot;);&#xD;&#xA;        break;  &#xD;&#xA;          case 'r':  &#xD;&#xA;          digitalWrite(13,HIGH); delay(200); &#xD;&#xA;          digitalWrite(13,LOW); delay(200);&#xD;&#xA;    &#xD;&#xA;          Serial1.println(&quot;Led intermitente&quot;);&#xD;&#xA;          break;&#xD;&#xA;      } //fin switch&#xD;&#xA;    &#xD;&#xA;    }//serial disponible&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    }//fin programa&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3584" PostHistoryTypeId="1" PostId="1256" RevisionGUID="66a58543-2443-4bfe-bd88-01e15a4d37fe" CreationDate="2014-04-23T02:17:16.723" UserId="1143" Text="How to catch the Enter key received by Bluetooth?" />
  <row Id="3585" PostHistoryTypeId="3" PostId="1256" RevisionGUID="66a58543-2443-4bfe-bd88-01e15a4d37fe" CreationDate="2014-04-23T02:17:16.723" UserId="1143" Text="&lt;bluetooth&gt;&lt;display&gt;" />
  <row Id="3587" PostHistoryTypeId="2" PostId="1257" RevisionGUID="61954900-e7f3-4e1f-a166-877e54196690" CreationDate="2014-04-23T03:42:41.967" UserId="11" Text="It depends on what the enter key sends. It may be just CR (carriage return), LF (line feed), or both. You can check the [ASCII table][1] for the hex values for those characters.&#xD;&#xA;&#xD;&#xA;LF is 0x0A and CR is 0x0D. Those are the characters you're looking for, you can add cases for those.&#xD;&#xA;&#xD;&#xA;  [1]: http://www.cdrummond.qc.ca/cegep/informat/professeurs/alain/images/ASCII1.GIF" />
  <row Id="3592" PostHistoryTypeId="5" PostId="1257" RevisionGUID="c8afcf65-4a73-49c9-84ce-083b9ea06c00" CreationDate="2014-04-23T05:11:50.530" UserId="84" Comment="added 177 characters in body" Text="It depends on what the enter key sends. It may be just CR (carriage return), LF (line feed), or both. You can check the [ASCII table][1] for the hex values for those characters.&#xD;&#xA;&#xD;&#xA;LF is 0x0A and CR is 0x0D. Those are the characters you're looking for, you can add a `if` for these cases in order to guard the call to `lcd.print(dato)`:&#xD;&#xA;&#xD;&#xA;    char dato= Serial1.read(); //Comprobamos el dato &#xD;&#xA;    if (dato != 0x0A &amp;&amp; dato != 0x0F)&#xD;&#xA;        lcd.print(dato);&#xD;&#xA;&#xD;&#xA;  [1]: http://www.cdrummond.qc.ca/cegep/informat/professeurs/alain/images/ASCII1.GIF" />
  <row Id="3593" PostHistoryTypeId="2" PostId="1259" RevisionGUID="faa4e5ce-70ea-49a6-a9c9-dd8cdc3f55ee" CreationDate="2014-04-23T05:53:28.067" UserId="84" Text="In electronics, as usual in situations where a cricuit is misbehaving and we don't understand why, a solution that generally works is to add a **decoupling cap** between `+5V` and `GND`. &#xD;&#xA;&#xD;&#xA;In your case, I would put at least **220uF**; that would ensure two things:&#xD;&#xA;&#xD;&#xA;- the voltage used to control the servo never drops&#xD;&#xA;- the voltage brought to Arduino by the USB does not drop either (which would have very bad impact on the Arduino, probably resetting it)&#xD;&#xA;&#xD;&#xA;Electrolytic caps are a **must-have** for every electronics hobbyist (and professional as well, of course).&#xD;&#xA;&#xD;&#xA;You can read more about decoupling capacitors on [Wikipedia][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Decoupling_capacitor" />
  <row Id="3594" PostHistoryTypeId="2" PostId="1260" RevisionGUID="bec93aee-0f39-41b7-8474-460bdc5c9ef7" CreationDate="2014-04-23T07:48:16.900" UserId="1145" Text="On the documentation of Arduino, I quote:&#xD;&#xA;&#xD;&#xA;&gt; http://playground.arduino.cc/Learning/Memory&#xD;&#xA;&gt; Note: Flash (PROGMEM) memory can only be populated at program burn time. You can’t change &gt; the values in the flash after the program has started running.&#xD;&#xA;&#xD;&#xA;And on the PROGMEM description:&#xD;&#xA;&gt; http://arduino.cc/en/Reference/PROGMEM&#xD;&#xA;&gt; Store data in flash (program) memory instead of SRAM. There's a description of the various types of memory available on an Arduino board.&#xD;&#xA;&gt;&#xD;&#xA;&gt; The PROGMEM keyword is a variable modifier, it should be used only with the datatypes defined in pgmspace.h. It tells the compiler &quot;put this information into flash memory&quot;, instead of into SRAM, where it would normally go.&#xD;&#xA;&#xD;&#xA;So can we or can't we? Or it's not the same thing?" />
  <row Id="3595" PostHistoryTypeId="1" PostId="1260" RevisionGUID="bec93aee-0f39-41b7-8474-460bdc5c9ef7" CreationDate="2014-04-23T07:48:16.900" UserId="1145" Text="Can I write to Flash Memory using PROGMEM?" />
  <row Id="3596" PostHistoryTypeId="3" PostId="1260" RevisionGUID="bec93aee-0f39-41b7-8474-460bdc5c9ef7" CreationDate="2014-04-23T07:48:16.900" UserId="1145" Text="&lt;progmem&gt;&lt;memory-usage&gt;" />
  <row Id="3601" PostHistoryTypeId="5" PostId="758" RevisionGUID="558ae800-713d-4d9f-a7b3-e646c115f66e" CreationDate="2014-04-23T08:46:56.323" UserId="-1" Comment="Migration of MSO links to MSE links" Text="&lt;p&gt;Serial1 on the Arduino Leonardo is hardware serial, not software. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;There are several ways to read in multiple bytes from Serial.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Instead of detecting &lt;code&gt;Serial.available()&lt;/code&gt; (i.e. non-zero), change it to &lt;code&gt;Serial.available() &amp;gt;= 2&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if (Serial.available() &amp;gt;= 2) {&#xA;  for (int i=0; i&amp;lt;2; i++) {&#xA;    buffer[i] = Serial.read();&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Or you can leave it as it is, and read into the buffer one at a time.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;static int bufferIndex;&#xA;&#xA;if (Serial.available())&#xA;{&#xA;    buffer[bufferIndex++] = Serial.read()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;You'll need to detect the contents of the buffer in another &lt;code&gt;if&lt;/code&gt; statement, and also deal with the bounds of the index.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Honestly though, noise is your issue here - this is an example of an &lt;a href=&quot;http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem&quot;&gt;XY problem&lt;/a&gt;. There's nothing inherent in using a microcontroller with relays that should mean that serial won't work.&lt;/p&gt;&#xA;" />
  <row Id="3602" PostHistoryTypeId="2" PostId="1261" RevisionGUID="8f904b56-7467-4e8f-bd01-31c2869a524a" CreationDate="2014-04-23T09:06:56.640" UserId="1146" Text="i want to measure the SPI Clock (PIN 13) using the arduino example Codes for SPI library ( very simple example ). Basically independent from the Loop Function, the Clock should be fired continously.&#xD;&#xA;&#xD;&#xA;I deployed the Arduino SPI example code on the Board and meassured the pin 13 on Osziloscope,&#xD;&#xA;but nothing found, always Zero Volt.&#xD;&#xA;Please help.!!&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3603" PostHistoryTypeId="1" PostId="1261" RevisionGUID="8f904b56-7467-4e8f-bd01-31c2869a524a" CreationDate="2014-04-23T09:06:56.640" UserId="1146" Text="Arduino UNO and Leonardo SPI Clock can't be meassured" />
  <row Id="3604" PostHistoryTypeId="3" PostId="1261" RevisionGUID="8f904b56-7467-4e8f-bd01-31c2869a524a" CreationDate="2014-04-23T09:06:56.640" UserId="1146" Text="&lt;arduino-uno&gt;&lt;arduino-leonardo&gt;&lt;spi&gt;" />
  <row Id="3605" PostHistoryTypeId="2" PostId="1262" RevisionGUID="1b5588c2-ece1-4b87-9d9d-acecfb370adf" CreationDate="2014-04-23T09:49:36.940" UserId="42" Text="The short answer is no: PROGMEM data is read-only.&#xD;&#xA;&#xD;&#xA;**Flash memory limitations**  &#xD;&#xA;The first thing to understand is that Flash memory (where program space lives) is designed for long-term fixed storage. Reading from it is very fast and precise. However, generally speaking, you can't modify it on a byte-by-byte basis (e.g. changing a specific variable). You usually have to erase and re-write it in large blocks. That makes it completely impractical for run-time manipulation, because you'd have to store a lot of redundant information somewhere else while you do the erase and write cycle.&#xD;&#xA;&#xD;&#xA;**What PROGMEM actually does**  &#xD;&#xA;Any literal data specified in your code (such as strings and numbers) always reside in program space at first (i.e. in Flash). However, when your sketch actually wants to use that data at runtime, it normally has to allocate some space for it in SRAM and copy it over. That means you end up with two copies: the fixed original in Flash, and the temporary copy in SRAM.&#xD;&#xA;&#xD;&#xA;When you use the PROGMEM modifier, you're telling it not to make that second copy in SRAM. Instead, your sketch will simply access the original in Flash. That's very useful if you only ever have to *read* the data, as it avoids the allocation and copy operations.&#xD;&#xA;&#xD;&#xA;However, copying it to SRAM is essential if you want to modify the data. Aside from the Flash limitations I mentioned above, it's also a question of code safety.&#xD;&#xA;&#xD;&#xA;If you're able to modify the **data** stored in program space, then it follows logically that you could also modify the **code** stored in program space. That would mean that a simple mistake (or in theory a malicious attack) could result in your sketch being partially or fully rewritten at run-time. This could have very unpredictable results, ranging from simply ceasing to work, through to damaging/destroying any connected equipment.&#xD;&#xA;&#xD;&#xA;**More information**  &#xD;&#xA;You can learn more about the low-level PROGMEM stuff from here:&#xD;&#xA;&#xD;&#xA; * http://www.fourwalledcubicle.com/AVRArticles.php&#xD;&#xA;&#xD;&#xA;An older version of the same PROGMEM tutorial is available here:&#xD;&#xA;&#xD;&#xA; * http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;p=243018&#xD;&#xA;" />
  <row Id="3606" PostHistoryTypeId="2" PostId="1263" RevisionGUID="4ffb4d61-7ee0-4113-8726-f3cffc865f64" CreationDate="2014-04-23T10:04:37.873" UserId="1137" Text="I was trying out a basic button tutorial on my new Arduino UNO. But for some reason, the Arduino was detecting the button as on (pressed) even when it was off (unpressed).&#xD;&#xA;&#xD;&#xA;After some experimentation, I found that the digital pins were flickering between `HIGH` and `LOW`, even if there was just a loose wire plugged in with nothing at the other end. And the state of the button, etc. wasn't making any difference. I tried this with pins 5,6 and 7, and it's happening with all of them, even when the neighbouring pins are connected to the ground. &#xD;&#xA;&#xD;&#xA;**Is this behaviour normal or is there something wrong with my input pins?**&#xD;&#xA;&#xD;&#xA;*Since I'm new to Arduino, there might also be something wrong with my testing code. Here's what I used...*&#xD;&#xA;&#xD;&#xA;    const unsigned int LED_PIN = 12;&#xD;&#xA;    const unsigned int BUTTON_PIN = 7;&#xD;&#xA;    const unsigned int INDICATOR_PIN = 13;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      pinMode(LED_PIN, OUTPUT);&#xD;&#xA;      pinMode(LED_PIN, OUTPUT);&#xD;&#xA;      pinMode(BUTTON_PIN, INPUT);&#xD;&#xA;      digitalWrite(LED_PIN, LOW);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      const int BUTTON_STATE = digitalRead(BUTTON_PIN);&#xD;&#xA;      &#xD;&#xA;      if (BUTTON_STATE == HIGH) {&#xD;&#xA;        digitalWrite(LED_PIN, HIGH);&#xD;&#xA;        digitalWrite(INDICATOR_PIN, LOW);&#xD;&#xA;      }&#xD;&#xA;      else if (BUTTON_STATE == LOW) {&#xD;&#xA;        digitalWrite(LED_PIN, LOW);&#xD;&#xA;        digitalWrite(INDICATOR_PIN, HIGH);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;*This code makes the lights always in opposite states: when one is on, the other is off. When I ran the code, both lights seemed on, which meant they were probably flickering, which meant that there was some interference in the input pin.*&#xD;&#xA;" />
  <row Id="3607" PostHistoryTypeId="1" PostId="1263" RevisionGUID="4ffb4d61-7ee0-4113-8726-f3cffc865f64" CreationDate="2014-04-23T10:04:37.873" UserId="1137" Text="Interference at digital input (UNO)" />
  <row Id="3608" PostHistoryTypeId="3" PostId="1263" RevisionGUID="4ffb4d61-7ee0-4113-8726-f3cffc865f64" CreationDate="2014-04-23T10:04:37.873" UserId="1137" Text="&lt;arduino-uno&gt;&lt;pins&gt;" />
  <row Id="3609" PostHistoryTypeId="2" PostId="1264" RevisionGUID="c5770a4f-6bea-4091-a37e-4b4fd31cdd4d" CreationDate="2014-04-23T10:23:59.497" UserId="42" Text="It sounds like you're seeing entirely normal behaviour. If you leave a digital input unconnected (or connected to an open button) then it's 'floating'. That means it can pick up interference from all sorts of things, and may appear to drift between high and low.&#xD;&#xA;&#xD;&#xA;The usual way to resolve this problem is using a pull-up or pull-down resistor. This is usually a high-ohm resistor (e.g. 10,000 Ohm or more) which will gently pull the pin HIGH or LOW in the absence of any other signal. When another signal comes in (e.g. from a button being pushed), it should have a much stronger effect than the resistor, so that is what the input will see.&#xD;&#xA;&#xD;&#xA;Your Uno has built-in pull-up resistors which you can use for this, although it will require a couple of changes. In your `setup()` function, you can enable the pull-up on your input pin like this:&#xD;&#xA;&#xD;&#xA;    pinMode(BUTTON_PIN, INPUT_PULLUP);&#xD;&#xA;&#xD;&#xA;That will cause the input to appear HIGH when the button is **not** pushed. That means you'll need to wire the other end of your button to ground (negative) instead of the voltage supply (positive). If you've set it up correctly, the input should appear LOW when the button is pushed." />
  <row Id="3610" PostHistoryTypeId="5" PostId="1261" RevisionGUID="37aac441-dfc2-425b-bc79-4b13d49670b7" CreationDate="2014-04-23T10:25:38.913" UserId="3" Comment="Fixed Text" Text="I want to measure the SPI Clock (PIN 13) using the arduino example Codes for SPI library ( very simple example ). Basically independent from the Loop Function, the Clock should be fired continously.&#xD;&#xA;&#xD;&#xA;I deployed the Arduino SPI example code on the Board and measured the pin 13 on Osciloscope,&#xD;&#xA;but nothing found, always Zero Volt.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3611" PostHistoryTypeId="24" PostId="1261" RevisionGUID="37aac441-dfc2-425b-bc79-4b13d49670b7" CreationDate="2014-04-23T10:25:38.913" Comment="Proposed by 3 approved by 42 edit id of 286" />
  <row Id="3614" PostHistoryTypeId="5" PostId="758" RevisionGUID="43255196-b975-445c-a973-2fce91194578" CreationDate="2014-04-23T13:48:19.153" UserId="-1" Comment="Fixup of bad MSO links to MSE links migration" Text="Serial1 on the Arduino Leonardo is hardware serial, not software. &#xD;&#xA;&#xD;&#xA;There are several ways to read in multiple bytes from Serial.&#xD;&#xA;&#xD;&#xA;Instead of detecting `Serial.available()` (i.e. non-zero), change it to `Serial.available() &gt;= 2`&#xD;&#xA;&#xD;&#xA;    if (Serial.available() &gt;= 2) {&#xD;&#xA;      for (int i=0; i&lt;2; i++) {&#xD;&#xA;        buffer[i] = Serial.read();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Or you can leave it as it is, and read into the buffer one at a time.&#xD;&#xA;&#xD;&#xA;    static int bufferIndex;&#xD;&#xA;    &#xD;&#xA;    if (Serial.available())&#xD;&#xA;    {&#xD;&#xA;    	buffer[bufferIndex++] = Serial.read()&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You'll need to detect the contents of the buffer in another `if` statement, and also deal with the bounds of the index.&#xD;&#xA;&#xD;&#xA;Honestly though, noise is your issue here - this is an example of an [XY problem][1]. There's nothing inherent in using a microcontroller with relays that should mean that serial won't work.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem" />
  <row Id="3615" PostHistoryTypeId="2" PostId="1265" RevisionGUID="7ca7943a-8870-470a-bef7-f5c45fd43456" CreationDate="2014-04-23T14:04:52.393" UserId="1149" Text="Using an Arduino and an L293D IC, can I control the number of rotations a DC motor makes? Or can I only control the direction and speed of the motor?&#xD;&#xA;&#xD;&#xA;I purchased a two-wheeled robot platform to learn Arduino programming and electronics. The platform is here: http://www.robotshop.com/en/dfrobot-2wd-mobile-platform-arduino.html&#xD;&#xA;&#xD;&#xA;Each wheel is controlled by a DC motor. I followed Adafruit's tutorial (https://learn.adafruit.com/adafruit-arduino-lesson-15-dc-motor-reversing) to control the motors with the help of an L293D IC.&#xD;&#xA;&#xD;&#xA;Now I realize that I can't directly control the rotations of the motor. I can control the direction, voltage, and time of the rotation. For example: turn forward at 50% voltage for 500 milliseconds. &#xD;&#xA;&#xD;&#xA;But that's difficult to translate into actual rotations. The speed of the motor varies according to voltage (like if I switch from 2AA batteries to 4AA's) and weight (adding sensors slows the motors down). Every time I change voltage or weight, I have to guess how much voltage/time causes a single rotation.&#xD;&#xA;&#xD;&#xA;I think I should just buy stepper motors. Before I do that, I'll ask the community: Is there a way to control DC motors by rotations rather than time?" />
  <row Id="3616" PostHistoryTypeId="1" PostId="1265" RevisionGUID="7ca7943a-8870-470a-bef7-f5c45fd43456" CreationDate="2014-04-23T14:04:52.393" UserId="1149" Text="Control/count rotations of a DC motor" />
  <row Id="3617" PostHistoryTypeId="3" PostId="1265" RevisionGUID="7ca7943a-8870-470a-bef7-f5c45fd43456" CreationDate="2014-04-23T14:04:52.393" UserId="1149" Text="&lt;motor&gt;" />
  <row Id="3618" PostHistoryTypeId="2" PostId="1266" RevisionGUID="9a73ce2b-5f67-43d9-80ce-4b2cb3443ad9" CreationDate="2014-04-23T14:20:43.030" UserId="60" Text="Please note the SPI clock will only be active while it is shifting data. So simply put the spi.transfer in a hard loop&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      SPI.begin();&#xD;&#xA;      while (1) {&#xD;&#xA;        SPI.transfer(0x00);&#xD;&#xA;      } &#xD;&#xA;    }" />
  <row Id="3619" PostHistoryTypeId="2" PostId="1267" RevisionGUID="15502fed-9514-4c36-9606-27bb9c28ef9d" CreationDate="2014-04-23T17:53:55.487" UserId="1151" Text="I am able to control my monitor and most other applications by giving serial input to python through arduino.&#xD;&#xA;Arduino code:&#xD;&#xA;&#xD;&#xA;void setup()&#xD;&#xA; {&#xD;&#xA;  &#xD;&#xA;  pinMode(2, INPUT); &#xD;&#xA;  pinMode(3, INPUT);&#xD;&#xA;  pinMode(4, INPUT);&#xD;&#xA;  pinMode(5, INPUT);&#xD;&#xA;  pinMode(6, INPUT);&#xD;&#xA;  pinMode(7, INPUT);&#xD;&#xA;  Serial.begin(9600);&#xD;&#xA;  &#xD;&#xA;}&#xD;&#xA; &#xD;&#xA;void loop()&#xD;&#xA;{&#xD;&#xA;  if(digitalRead(2) == HIGH)&#xD;&#xA;  {&#xD;&#xA;    delay(5);&#xD;&#xA;  }&#xD;&#xA;  else &#xD;&#xA;  {&#xD;&#xA;    Serial.println(&quot;up&quot;);&#xD;&#xA;  }&#xD;&#xA;  if(digitalRead(3) == HIGH)&#xD;&#xA;  {&#xD;&#xA;    delay(5);&#xD;&#xA;  }&#xD;&#xA;  else &#xD;&#xA;  {&#xD;&#xA;    Serial.println(&quot;down&quot;);&#xD;&#xA;  }&#xD;&#xA;  if(digitalRead(4) == HIGH)&#xD;&#xA;  {&#xD;&#xA;    delay(5);&#xD;&#xA;  }&#xD;&#xA;  else &#xD;&#xA;  {&#xD;&#xA;    Serial.println(&quot;left&quot;);&#xD;&#xA;  }&#xD;&#xA;  if(digitalRead(5) == HIGH)&#xD;&#xA;  {&#xD;&#xA;    delay(5);&#xD;&#xA;  }&#xD;&#xA;  else &#xD;&#xA;  {&#xD;&#xA;    Serial.println(&quot;right&quot;);&#xD;&#xA;  }&#xD;&#xA;  if(digitalRead(6)== HIGH)&#xD;&#xA;  {&#xD;&#xA;    delay(5);&#xD;&#xA;  } &#xD;&#xA;  else&#xD;&#xA;  {&#xD;&#xA;    Serial.println(&quot;space&quot;);//orange&#xD;&#xA;  }&#xD;&#xA;  if(digitalRead(7)==HIGH)&#xD;&#xA;  {&#xD;&#xA;     delay(5);&#xD;&#xA;  }   &#xD;&#xA;  else&#xD;&#xA;  {  &#xD;&#xA;    Serial.println(&quot;nitro&quot;);//brown&#xD;&#xA;  }  &#xD;&#xA; }&#xD;&#xA;&#xD;&#xA;Python code:&#xD;&#xA;&#xD;&#xA;import serial&#xD;&#xA;from pymouse import PyMouse&#xD;&#xA;from pykeyboard import PyKeyboard&#xD;&#xA;&#xD;&#xA;k = PyKeyboard()&#xD;&#xA;&#xD;&#xA;ser = serial.Serial('COM7', 9600)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;#sp.write(&quot;AT\r\n&quot;.encode('ascii'))&#xD;&#xA;&#xD;&#xA;while True:&#xD;&#xA;    p=ser.readline()&#xD;&#xA;    print p&#xD;&#xA;    if ('up' in p):&#xD;&#xA;        k = PyKeyboard()&#xD;&#xA;        &#xD;&#xA;        k.tap_key(k.up_key)&#xD;&#xA;    &#xD;&#xA;    if ('down' in p):&#xD;&#xA;        k = PyKeyboard()&#xD;&#xA;        &#xD;&#xA;        k.tap_key(k.down_key)&#xD;&#xA;&#xD;&#xA;    &#xD;&#xA;    if ('right' in p):&#xD;&#xA;        k = PyKeyboard()&#xD;&#xA;        &#xD;&#xA;        k.tap_key(k.right_key)&#xD;&#xA; &#xD;&#xA;    &#xD;&#xA;    if ('left' in p):&#xD;&#xA;        k = PyKeyboard()&#xD;&#xA;        &#xD;&#xA;        k.tap_key(k.left_key)&#xD;&#xA;&#xD;&#xA;    if ('space' in p):&#xD;&#xA;        k = PyKeyboard()&#xD;&#xA;        &#xD;&#xA;        k.tap_key(k.space_key)&#xD;&#xA;&#xD;&#xA;    if ('nitro' in p):&#xD;&#xA;        k = PyKeyboard()&#xD;&#xA;        &#xD;&#xA;        k.tap_key(k.enter_key)    &#xD;&#xA;&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;My problem is that..I am not able to play games such as NFS and other similar games using these controls..&#xD;&#xA;What should i do??&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3620" PostHistoryTypeId="1" PostId="1267" RevisionGUID="15502fed-9514-4c36-9606-27bb9c28ef9d" CreationDate="2014-04-23T17:53:55.487" UserId="1151" Text="How to control Keyboard inputs using arduino(serial monitor) and python keyboard libraries?" />
  <row Id="3621" PostHistoryTypeId="3" PostId="1267" RevisionGUID="15502fed-9514-4c36-9606-27bb9c28ef9d" CreationDate="2014-04-23T17:53:55.487" UserId="1151" Text="&lt;arduino-uno&gt;" />
  <row Id="3622" PostHistoryTypeId="5" PostId="1267" RevisionGUID="efb6b181-a19e-472c-80a0-66c421e24b75" CreationDate="2014-04-23T19:02:36.953" UserId="337" Comment="Format code." Text="I am able to control my monitor and most other applications by giving serial input to python through arduino.&#xD;&#xA;Arduino code:&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;     {&#xD;&#xA;      &#xD;&#xA;      pinMode(2, INPUT); &#xD;&#xA;      pinMode(3, INPUT);&#xD;&#xA;      pinMode(4, INPUT);&#xD;&#xA;      pinMode(5, INPUT);&#xD;&#xA;      pinMode(6, INPUT);&#xD;&#xA;      pinMode(7, INPUT);&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;     &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;      if(digitalRead(2) == HIGH)&#xD;&#xA;      {&#xD;&#xA;        delay(5);&#xD;&#xA;      }&#xD;&#xA;      else &#xD;&#xA;      {&#xD;&#xA;        Serial.println(&quot;up&quot;);&#xD;&#xA;      }&#xD;&#xA;      if(digitalRead(3) == HIGH)&#xD;&#xA;      {&#xD;&#xA;        delay(5);&#xD;&#xA;      }&#xD;&#xA;      else &#xD;&#xA;      {&#xD;&#xA;        Serial.println(&quot;down&quot;);&#xD;&#xA;      }&#xD;&#xA;      if(digitalRead(4) == HIGH)&#xD;&#xA;      {&#xD;&#xA;        delay(5);&#xD;&#xA;      }&#xD;&#xA;      else &#xD;&#xA;      {&#xD;&#xA;        Serial.println(&quot;left&quot;);&#xD;&#xA;      }&#xD;&#xA;      if(digitalRead(5) == HIGH)&#xD;&#xA;      {&#xD;&#xA;        delay(5);&#xD;&#xA;      }&#xD;&#xA;      else &#xD;&#xA;      {&#xD;&#xA;        Serial.println(&quot;right&quot;);&#xD;&#xA;      }&#xD;&#xA;      if(digitalRead(6)== HIGH)&#xD;&#xA;      {&#xD;&#xA;        delay(5);&#xD;&#xA;      } &#xD;&#xA;      else&#xD;&#xA;      {&#xD;&#xA;        Serial.println(&quot;space&quot;);//orange&#xD;&#xA;      }&#xD;&#xA;      if(digitalRead(7)==HIGH)&#xD;&#xA;      {&#xD;&#xA;         delay(5);&#xD;&#xA;      }   &#xD;&#xA;      else&#xD;&#xA;      {  &#xD;&#xA;        Serial.println(&quot;nitro&quot;);//brown&#xD;&#xA;      }  &#xD;&#xA;     }&#xD;&#xA;&#xD;&#xA;Python code:&#xD;&#xA;&#xD;&#xA;    import serial&#xD;&#xA;    from pymouse import PyMouse&#xD;&#xA;    from pykeyboard import PyKeyboard&#xD;&#xA;    &#xD;&#xA;    k = PyKeyboard()&#xD;&#xA;    &#xD;&#xA;    ser = serial.Serial('COM7', 9600)&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    #sp.write(&quot;AT\r\n&quot;.encode('ascii'))&#xD;&#xA;    &#xD;&#xA;    while True:&#xD;&#xA;        p=ser.readline()&#xD;&#xA;        print p&#xD;&#xA;        if ('up' in p):&#xD;&#xA;            k = PyKeyboard()&#xD;&#xA;            &#xD;&#xA;            k.tap_key(k.up_key)&#xD;&#xA;        &#xD;&#xA;        if ('down' in p):&#xD;&#xA;            k = PyKeyboard()&#xD;&#xA;            &#xD;&#xA;            k.tap_key(k.down_key)&#xD;&#xA;    &#xD;&#xA;        &#xD;&#xA;        if ('right' in p):&#xD;&#xA;            k = PyKeyboard()&#xD;&#xA;            &#xD;&#xA;            k.tap_key(k.right_key)&#xD;&#xA;     &#xD;&#xA;        &#xD;&#xA;        if ('left' in p):&#xD;&#xA;            k = PyKeyboard()&#xD;&#xA;            &#xD;&#xA;            k.tap_key(k.left_key)&#xD;&#xA;    &#xD;&#xA;        if ('space' in p):&#xD;&#xA;            k = PyKeyboard()&#xD;&#xA;            &#xD;&#xA;            k.tap_key(k.space_key)&#xD;&#xA;    &#xD;&#xA;        if ('nitro' in p):&#xD;&#xA;            k = PyKeyboard()&#xD;&#xA;            &#xD;&#xA;            k.tap_key(k.enter_key)    &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;My problem is that..I am not able to play games such as NFS and other similar games using these controls..&#xD;&#xA;What should i do??&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3623" PostHistoryTypeId="24" PostId="1267" RevisionGUID="efb6b181-a19e-472c-80a0-66c421e24b75" CreationDate="2014-04-23T19:02:36.953" Comment="Proposed by 337 approved by 84, 11 edit id of 287" />
  <row Id="3624" PostHistoryTypeId="5" PostId="1251" RevisionGUID="36f5827b-5b04-4d88-858c-08ea3c393714" CreationDate="2014-04-23T19:59:13.847" UserId="490" Comment="added 134 characters in body" Text="Does anyone know where I can find a Chlorine Sensor to use with the Arduino? It would need to be water proof. I've googled, but I couldn't find anything.&#xD;&#xA;&#xD;&#xA;**EDIT**&#xD;&#xA;Requirements: relatively inexpensive (under $100us), works with Arduino, waterproof and used to detect chlorine in water." />
  <row Id="3626" PostHistoryTypeId="2" PostId="1268" RevisionGUID="820281e3-f60f-45a9-a4bd-8e0d48ea26c8" CreationDate="2014-04-23T22:26:01.460" UserId="1157" Text="I'm a bit new to electronics/Arduino projects, so am looking for some help on some wiring needed for a project involving this Pull Chain: http://proto-pic.co.uk/pull-chain-switch/&#xD;&#xA;&#xD;&#xA;The chain works like a fan chain would.&#xD;&#xA;&#xD;&#xA;I am using an Arduino UNO&#xD;&#xA;&#xD;&#xA;I have wired up the pull chain to a mini breadboard with a light that turns on and off just to test it's working. What I want to do, is get an analog/digital read each time the chain is pulled?&#xD;&#xA;&#xD;&#xA;Is this possible? If so, would you be able to help me with how it would be wired up, as I am completely new to the electronics side of Arduino. I simply need to get a reading each time the chain is pulled, I don't need it to switch a light on. &#xD;&#xA;&#xD;&#xA;Thanks all!&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3627" PostHistoryTypeId="1" PostId="1268" RevisionGUID="820281e3-f60f-45a9-a4bd-8e0d48ea26c8" CreationDate="2014-04-23T22:26:01.460" UserId="1157" Text="Pull Chain Switch" />
  <row Id="3628" PostHistoryTypeId="3" PostId="1268" RevisionGUID="820281e3-f60f-45a9-a4bd-8e0d48ea26c8" CreationDate="2014-04-23T22:26:01.460" UserId="1157" Text="&lt;arduino-uno&gt;" />
  <row Id="3629" PostHistoryTypeId="2" PostId="1269" RevisionGUID="ac4ba636-b1ed-4a28-8876-68decfdc8040" CreationDate="2014-04-23T23:45:47.310" UserId="368" Text="Connect it between ground and an interrupt pin &lt;a href=&quot;http://arduino.cc/en/Reference/pinMode&quot;&gt;configured as an input with the pullup enabled&lt;/a&gt;. &lt;a href=&quot;http://arduino.cc/en/Reference/attachInterrupt&quot;&gt;Configure the interrupt&lt;/a&gt; to trigger on any state change. &lt;a href=&quot;http://arduino.cc/en/Reference/DigitalRead&quot;&gt;Check the digital value of the pin&lt;/a&gt; in the ISR." />
  <row Id="3630" PostHistoryTypeId="10" PostId="1263" RevisionGUID="43fc9d0a-4293-4919-835e-f1b2517a9954" CreationDate="2014-04-24T01:16:33.170" UserId="11" Comment="101" Text="{&quot;OriginalQuestionIds&quot;:[186],&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="3631" PostHistoryTypeId="36" PostId="1270" RevisionGUID="fd871bc3-a85a-431d-81ea-1d86588e99f7" CreationDate="2014-04-24T04:34:10.027" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/107625/super-slow-serial-uart-communication-on-arduino" />
  <row Id="3632" PostHistoryTypeId="36" PostId="1271" RevisionGUID="be986391-044d-418f-b643-a363f2d212de" CreationDate="2014-04-24T04:34:10.027" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/107625/super-slow-serial-uart-communication-on-arduino/107627#107627" />
  <row Id="3633" PostHistoryTypeId="2" PostId="1271" RevisionGUID="c799a8b3-8af5-42f2-8e93-927b0964e6f8" CreationDate="2014-04-23T04:56:45.323" UserId="83" Text="I think the problem is not so much in the update speed, but in the fact that you loose accuracy in your calculation. The following lines are the culprit:&#xD;&#xA;&#xD;&#xA;    int kphValue = 0;  // [-32768:32767]&#xD;&#xA;    int mphValue = 0;&#xD;&#xA;    mphValue = kphValue * 0.621371;&#xD;&#xA;&#xD;&#xA;Make sure the calculation will be entirely in integers to prevent calculation errors:&#xD;&#xA;&#xD;&#xA;    uint16_t kphValue = 0;  // [0:65535]&#xD;&#xA;    uint16_t mphValue = 0;&#xD;&#xA;    mphValue = ( kphValue * 621 ) / 1000;&#xD;&#xA;&#xD;&#xA;This limits kphValue to just over 100, if you want to go higher than that there are two option:&#xD;&#xA;&#xD;&#xA;- multiply by 62 and divide by 100;&#xD;&#xA;- use longer integers `int32_t` [-2147483648:2147483647], which comes with enough room for multiplying by 621371 and dividing by 1000000, but will perform slower and with a larger memory footprint. Do you really need that accuracy?" />
  <row Id="3634" PostHistoryTypeId="2" PostId="1270" RevisionGUID="10f13f05-3ca5-4cd6-9ffb-dec631296b30" CreationDate="2014-04-23T04:27:10.673" UserId="1144" Text="I am using this device for my Arduino that connects to the [OBD-II][1] port of my car to get various information such as speed, rpm, etc. I am using this for a digital [Nixie tube][2] speedometer using the smart Nixie tube from a [Kickstarter][3] project.&#xD;&#xA;&#xD;&#xA;I pass the information to the Nixie tubes through serial and get information from the OBD-II through serial as well. I am getting speed updates about every 20 seconds and that is incredibly slow when the device can supposedly update up to 100 times per second.&#xD;&#xA;&#xD;&#xA;I originally was using an [Arduino Uno][4] and using software serial for the tubes, but I figured the slowdown was due to interupts interfering with the hardware serial, so I switched to the [Arduino Mega 2560][5] to use a second hardware serial pin to hopefully fix the problem, yet the same issue is occurring.&#xD;&#xA;&#xD;&#xA;Here is my code... There must be something I'm doing wrong. Serial2 is for the Nixie tubes.&#xD;&#xA;&#xD;&#xA;    #import &lt;Arduino.h&gt;&#xD;&#xA;&#xD;&#xA;    #include &lt;OBD.h&gt;&#xD;&#xA;&#xD;&#xA;    int ones = 0;&#xD;&#xA;    int tens = 0;&#xD;&#xA;&#xD;&#xA;    int kphValue = 0;&#xD;&#xA;    int mphValue = 0;&#xD;&#xA;&#xD;&#xA;    int rpmValue = 0;&#xD;&#xA;&#xD;&#xA;    String onesString;&#xD;&#xA;    String tensString;&#xD;&#xA;    String payloadString;&#xD;&#xA;    String rpmString;&#xD;&#xA;    COBD obd;&#xD;&#xA;&#xD;&#xA;    void setup(){&#xD;&#xA;        Serial2.begin(9600);&#xD;&#xA;        obd.begin();&#xD;&#xA;&#xD;&#xA;        //Initiate OBD-II connection until success&#xD;&#xA;        while (!obd.init()){&#xD;&#xA;            Serial2.print(&quot;$0,Y,Y,255,255,000,000$0,Y,Y,255,255,000,000!&quot;);&#xD;&#xA;            delay(1000);&#xD;&#xA;            Serial2.print(&quot;$0,Y,Y,000,000,000,000$0,Y,Y,000,000,000,000!&quot;);&#xD;&#xA;            delay(1000);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop(){&#xD;&#xA;        onesString = String(ones);&#xD;&#xA;        tensString = String(tens);&#xD;&#xA;        payloadString;&#xD;&#xA;        rpmString;&#xD;&#xA;&#xD;&#xA;        if(obd.read(PID_RPM, rpmValue)){&#xD;&#xA;            if (rpmValue &lt; 3000){&#xD;&#xA;                rpmString =&quot;,N,N,255,000,255,000&quot;;&#xD;&#xA;            }&#xD;&#xA;            else if (rpmValue &gt;= 5000){&#xD;&#xA;                rpmString = &quot;,N,N,255,255,000,000&quot;;&#xD;&#xA;            }&#xD;&#xA;            else if (rpmValue &gt;= 3000){&#xD;&#xA;                rpmString = &quot;,N,N,255,255,030,000&quot;;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;&#xD;&#xA;        if (obd.read(PID_SPEED, kphValue)){&#xD;&#xA;            kphToMPH();&#xD;&#xA;            payloadString = &quot;$&quot; + onesString + rpmString + &quot;$&quot; + tensString + &quot;rpmString&quot; + &quot;!&quot;;&#xD;&#xA;            Serial2.print(payloadString);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void splitDigits(int input_number)&#xD;&#xA;    {&#xD;&#xA;        ones = (input_number%10);&#xD;&#xA;        tens = ((input_number/10)%10);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void kphToMPH()&#xD;&#xA;    {&#xD;&#xA;        mphValue = kphValue * 0.621371;&#xD;&#xA;        splitDigits(mphValue);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/On-board_diagnostics#OBD-II&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Nixie_tube&#xD;&#xA;  [3]: http://en.wikipedia.org/wiki/Kickstarter&#xD;&#xA;  [4]: http://arduino.cc/en/Main/ArduinoBoardUno&#xD;&#xA;  [5]: http://arduino.cc/en/Main/arduinoBoardMega2560&#xD;&#xA;" />
  <row Id="3635" PostHistoryTypeId="1" PostId="1270" RevisionGUID="10f13f05-3ca5-4cd6-9ffb-dec631296b30" CreationDate="2014-04-23T04:27:10.673" UserId="1144" Text="Super slow serial (UART) communication on Arduino" />
  <row Id="3636" PostHistoryTypeId="3" PostId="1270" RevisionGUID="10f13f05-3ca5-4cd6-9ffb-dec631296b30" CreationDate="2014-04-23T04:27:10.673" UserId="1144" Text="&lt;serial&gt;&lt;uart&gt;" />
  <row Id="3637" PostHistoryTypeId="2" PostId="1272" RevisionGUID="5fb716fa-6c61-46f6-927d-dcdf7cad0489" CreationDate="2014-04-24T07:26:04.390" UserId="1143" Text="I got a `String` which as I understand is an Arduino object, and got some C++ code:&#xD;&#xA;&#xD;&#xA;    #include &lt;Wire.h&gt; &#xD;&#xA;    #include &lt;LiquidCrystal_I2C.h&gt;&#xD;&#xA;    #include &lt;string.h&gt;&#xD;&#xA;    &#xD;&#xA;    LiquidCrystal_I2C lcd(0x20,16,2); &#xD;&#xA;    &#xD;&#xA;    boolean borrar = false;&#xD;&#xA;    String IP;&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      lcd.init();&#xD;&#xA;      lcd.backlight();&#xD;&#xA;      pinMode(13,OUTPUT);&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      Serial1.begin(9600);&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      &#xD;&#xA;      while (Serial1.available()) { &#xD;&#xA;    &#xD;&#xA;        char caracter = Serial1.read(); //Comprobamos el caracter &#xD;&#xA;    &#xD;&#xA;        switch(caracter) {&#xD;&#xA;    &#xD;&#xA;        default:&#xD;&#xA;                    if (borrar) { &#xD;&#xA;                                  IP = &quot;&quot;; &#xD;&#xA;                                  lcd.clear();&#xD;&#xA;                    }&#xD;&#xA;                    &#xD;&#xA;                    lcd.print(caracter);&#xD;&#xA;                    delay(125);&#xD;&#xA;                    borrar = false;&#xD;&#xA;                    &#xD;&#xA;                    IP.concat(caracter);&#xD;&#xA;                    break;  &#xD;&#xA;                    &#xD;&#xA;        case '\r':                &#xD;&#xA;        case 0x0F:&#xD;&#xA;        case 0x0A:  &#xD;&#xA;        &#xD;&#xA;                    String res = &quot;&quot;;&#xD;&#xA;                    borrar = true;&#xD;&#xA;                    int num= atoi(IP.c_str());&#xD;&#xA;                    if (num &lt; 127) &#xD;&#xA;                      res=&quot;Clase A&quot;;&#xD;&#xA;                    if (num == 127) &#xD;&#xA;                      res=&quot;Direccion reservada&quot;;&#xD;&#xA;                    if (num &gt; 127 &amp;&amp; num &lt; 192)&#xD;&#xA;                      res=&quot;Clase B &quot;;&#xD;&#xA;                    if (num &gt;= 192 &amp;&amp; num &lt; 224)&#xD;&#xA;                      res=&quot;Clase C &quot;;&#xD;&#xA;                    if (num &gt;= 224 &amp;&amp; num &lt; 240)&#xD;&#xA;                      res=&quot;Clase D &quot;;&#xD;&#xA;                    if (num &gt;= 240 &amp;&amp; num &lt; 255)&#xD;&#xA;                      res=&quot;Clase E &quot;;&#xD;&#xA;                    break;  &#xD;&#xA;        &#xD;&#xA;      } //fin switch&#xD;&#xA;    &#xD;&#xA;    }//serial disponible&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    }//fin programa&#xD;&#xA;&#xD;&#xA;However, this won't compile because of this line:&#xD;&#xA;&#xD;&#xA;    int num= atoi(IP.c_str())&#xD;&#xA;&#xD;&#xA;As IP is a **`String`** and such method works for **`string`**. How can I make it compatible (convert it)?" />
  <row Id="3638" PostHistoryTypeId="1" PostId="1272" RevisionGUID="5fb716fa-6c61-46f6-927d-dcdf7cad0489" CreationDate="2014-04-24T07:26:04.390" UserId="1143" Text="How can I convert Arduino String to C string type?" />
  <row Id="3639" PostHistoryTypeId="3" PostId="1272" RevisionGUID="5fb716fa-6c61-46f6-927d-dcdf7cad0489" CreationDate="2014-04-24T07:26:04.390" UserId="1143" Text="&lt;c++&gt;&lt;data-type&gt;" />
  <row Id="3640" PostHistoryTypeId="2" PostId="1273" RevisionGUID="65018056-2a77-4a56-aee5-e860b0316b7f" CreationDate="2014-04-24T08:30:57.550" UserId="1162" Text="Try&#xD;&#xA;    &#xD;&#xA;    char z[100];&#xD;&#xA;    IP.getBytes(z, 100);&#xD;&#xA;    z[IP.length()] = 0;&#xD;&#xA;    int n = atoi(z);&#xD;&#xA;&#xD;&#xA;To retrieve bytes inside the string. This assumes IP string's length is shorter than 100. " />
  <row Id="3641" PostHistoryTypeId="2" PostId="1274" RevisionGUID="a43d3687-78e0-42ee-b7d6-9dade1dd3d89" CreationDate="2014-04-24T08:32:23.310" UserId="42" Text="Try updating to the latest version of the Arduino libraries/IDE.&#xD;&#xA;&#xD;&#xA;The `c_str()` method was introduced to the Arduino String class quite recently, I believe. That line of code certainly works fine for me on Arduino IDE 1.0.5." />
  <row Id="3643" PostHistoryTypeId="5" PostId="1273" RevisionGUID="e857d7dd-cee3-4442-92b9-ef7f5e505ed2" CreationDate="2014-04-24T08:44:08.980" UserId="1162" Comment="added 9 characters in body" Text="Try&#xD;&#xA;    &#xD;&#xA;    unsigned char z[100];&#xD;&#xA;    IP.getBytes(z, 100);&#xD;&#xA;    z[IP.length()] = 0;&#xD;&#xA;    int n = atoi(z);&#xD;&#xA;&#xD;&#xA;To retrieve bytes inside the string. This assumes IP string's length is shorter than 100. " />
  <row Id="3645" PostHistoryTypeId="5" PostId="1193" RevisionGUID="06d99daf-c81f-44b2-836e-ef0f5b5a38f6" CreationDate="2014-04-24T15:45:29.460" UserId="1072" Comment="added 573 characters in body" Text="I've succeeded to get an Arduino to work with a pressure sensor.&#xD;&#xA;&#xD;&#xA;What I want to do is &#xD;&#xA;&#xD;&#xA; - when I put pressure on the sensor, after 5 minutes the led lights on.&#xD;&#xA; - it starts over again if there's no pressure on the sensor.&#xD;&#xA;&#xD;&#xA;Here's the program:&#xD;&#xA;&#xD;&#xA;    // FSR is verbonden met analoog 0 &#xD;&#xA;    int fsrAnalogePin = 0; &#xD;&#xA;    // De LED is verbonden met pin 11 (pmw pin) &#xD;&#xA;    int LEDpin = 11; &#xD;&#xA;    // De analoge waarde van de fsr spanningdeler &#xD;&#xA;    int fsrWaarde; &#xD;&#xA;    // De helderheid van de led tussen 0 en 255 &#xD;&#xA;    int LEDhelderheid; &#xD;&#xA;    &#xD;&#xA;    void setup() { &#xD;&#xA;        // start de serial monitor &#xD;&#xA;        Serial.begin(9600); &#xD;&#xA;        pinMode(LEDpin, OUTPUT); &#xD;&#xA;    } &#xD;&#xA;    &#xD;&#xA;    void loop() { &#xD;&#xA;        fsrWaarde = analogRead(fsrAnalogePin); &#xD;&#xA;        // print ‘Analoge waarde’ &#xD;&#xA;        Serial.print(“Analoge waarde = “); &#xD;&#xA;        // print de fsrwaarde op de monitor &#xD;&#xA;        Serial.println(fsrWaarde); &#xD;&#xA;    &#xD;&#xA;        // maak van getallen tussen 0 en 1023 getallen tussen 0 en 255 &#xD;&#xA;        LEDhelderheid = map(fsrWaarde, 0, 50, 0, 255); &#xD;&#xA;        analogWrite(LEDpin, LEDhelderheid); &#xD;&#xA;        delay(100); &#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I've got this for the pressure sensor... now I need to combine it with 5 minutes and the led lights on when it's reached that 5 min of pressure.&#xD;&#xA;&#xD;&#xA;i managed to do this but it aint enough...&#xD;&#xA;&#xD;&#xA;    unsigned long currentTime;&#xD;&#xA;    unsigned long startTime;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      // put your setup code here, to run once:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      currentTime = millis();&#xD;&#xA;      startTime = currentTime;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;        void loop() {&#xD;&#xA;      currentTime = millis();&#xD;&#xA;      // put your main code here, to run repeatedly: &#xD;&#xA;      Serial.println(currentTime);&#xD;&#xA;      delay(1000); &#xD;&#xA;&#xD;&#xA;      if(currentTime-startTime &gt; 6000) {&#xD;&#xA;    Serial.println(&quot;1 minuut voorbij&quot;);&#xD;&#xA;    startTime = currentTime;&#xD;&#xA;      }&#xD;&#xA;    }" />
  <row Id="3647" PostHistoryTypeId="36" PostId="1276" RevisionGUID="a2533d90-63f7-4266-82e2-e4df48a26fc2" CreationDate="2014-04-24T16:04:25.877" UserId="-1" Comment="from http://stackoverflow.com/questions/23161113/curve-fit-on-arduino" />
  <row Id="3648" PostHistoryTypeId="2" PostId="1276" RevisionGUID="a96bd0cf-8743-495d-abf8-435504544c9c" CreationDate="2014-04-18T19:43:28.380" UserId="1272" UserDisplayName="user3550036" Text="It is possible to put this library and function on an Arduino?&#xD;&#xA;&#xD;&#xA;http://rosettacode.org/wiki/Polynomial_regression#C&#xD;&#xA;&#xD;&#xA;I need to curve fit 5 points.&#xD;&#xA;&#xD;&#xA;Has anyone done this before? This was the best I could come up with after searching online." />
  <row Id="3649" PostHistoryTypeId="1" PostId="1276" RevisionGUID="a96bd0cf-8743-495d-abf8-435504544c9c" CreationDate="2014-04-18T19:43:28.380" UserId="1272" UserDisplayName="user3550036" Text="Curve Fit on Arduino" />
  <row Id="3650" PostHistoryTypeId="3" PostId="1276" RevisionGUID="a96bd0cf-8743-495d-abf8-435504544c9c" CreationDate="2014-04-18T19:43:28.380" UserId="1272" UserDisplayName="user3550036" Text="&lt;c&gt;&lt;arduino-uno&gt;" />
  <row Id="3651" PostHistoryTypeId="2" PostId="1277" RevisionGUID="f504662f-0a74-4122-a5c3-325296e60209" CreationDate="2014-04-24T16:25:03.380" UserId="1170" Text="A friend and I are working on building a smartwatch on a budget, so it’s a (very) low power project, but we are currently having a problem with the power supplying.&#xD;&#xA;We already chose this board, because of its size and the BLE chip: **RFduino BLE SMT**&#xD;&#xA;For now on, we are planning to use this battery [500 mAh LiPo battery](http://www.adafruit.com/products/1578) (approx. 4V at full charge) with this voltage regulator [Micrel MIC5209-3.6YS](http://www.mouser.fr/ProductDetail/Micrel/MIC5209-36YS/?qs=sGAEpiMZZMsGz1a6aV8DcP%252b6ey5cUOYkLdhn%252b123Ics=) (the board supports 3.6V max.).&#xD;&#xA; &#xD;&#xA;But the problem is that the Voltage Regulator will apparently drain by itself too much energy from the battery (by heating), reducing drastically the autonomy.&#xD;&#xA; &#xD;&#xA;So we would like to know if you guys can help us, if you can tell us exactly what (type of) regulator would be the best or if we need to find another battery.&#xD;&#xA; &#xD;&#xA;Thanks :)" />
  <row Id="3652" PostHistoryTypeId="1" PostId="1277" RevisionGUID="f504662f-0a74-4122-a5c3-325296e60209" CreationDate="2014-04-24T16:25:03.380" UserId="1170" Text="Which Voltage Regulator use?" />
  <row Id="3653" PostHistoryTypeId="3" PostId="1277" RevisionGUID="f504662f-0a74-4122-a5c3-325296e60209" CreationDate="2014-04-24T16:25:03.380" UserId="1170" Text="&lt;battery&gt;&lt;bluetooth&gt;" />
  <row Id="3654" PostHistoryTypeId="2" PostId="1278" RevisionGUID="cb15421a-6b8a-464f-94b7-31fd4ff82bc7" CreationDate="2014-04-24T16:38:46.137" UserId="756" Text="At the moment I'm using two softserials to connect to a GPS and an GSM module. &#xD;&#xA;&#xD;&#xA;It seems not possible to have two open software-serials. So I was looking for an solution&#xD;&#xA;&#xD;&#xA;After the initial-setup, the GPS module is only needed to be read from; while the GSM module needs to be bidirectional. So:&#xD;&#xA;&#xD;&#xA;    GPS &gt; listen only&#xD;&#xA;    GSM &gt; listen and write&#xD;&#xA;&#xD;&#xA;Now I came across the [GPS library from Adafruit][1], which uses an interrupt to receive data. Is this _instead_ of a software serial. Or do I again run into the limitation?&#xD;&#xA;&#xD;&#xA;An other solution might be to use the D0 and D1 to attach eg the GSM module. But than I won't be able to see the debug messages in my serial monitor. Is that correct?&#xD;&#xA;&#xD;&#xA;Sorry in advance for these n00b questions. But I'm frustrated the things dont work as I want :)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/adafruit/Adafruit-GPS-Library" />
  <row Id="3655" PostHistoryTypeId="1" PostId="1278" RevisionGUID="cb15421a-6b8a-464f-94b7-31fd4ff82bc7" CreationDate="2014-04-24T16:38:46.137" UserId="756" Text="Simultanous read and read/write on two serial connections" />
  <row Id="3656" PostHistoryTypeId="3" PostId="1278" RevisionGUID="cb15421a-6b8a-464f-94b7-31fd4ff82bc7" CreationDate="2014-04-24T16:38:46.137" UserId="756" Text="&lt;arduino-uno&gt;&lt;serial&gt;&lt;pins&gt;&lt;interrupt&gt;&lt;softwareserial&gt;" />
  <row Id="3657" PostHistoryTypeId="2" PostId="1279" RevisionGUID="c86f50d2-72cf-4ebe-9db8-42a90811e808" CreationDate="2014-04-24T16:53:02.413" UserId="83" Text="[`Adafruit_GPS.h`](https://github.com/adafruit/Adafruit-GPS-Library/blob/master/Adafruit_GPS.h) (line 132-), which is included in [`Adafruit_GPS.cpp`](https://github.com/adafruit/Adafruit-GPS-Library/blob/master/Adafruit_GPS.cpp) (line 13) refers in turn to the SoftwareSerial library on AVR platform and Arduino IDE version &gt; 100.&#xD;&#xA;&#xD;&#xA;    #ifdef __AVR__&#xD;&#xA;    #if ARDUINO &gt;= 100&#xD;&#xA;        SoftwareSerial *gpsSwSerial;&#xD;&#xA;    #else&#xD;&#xA;        NewSoftSerial *gpsSwSerial;&#xD;&#xA;    #endif&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;This means it uses software serial on an Uno. It also means if your problem is indeed with Software Serial, that is the library to check for bugs / updates or commit a patch to." />
  <row Id="3658" PostHistoryTypeId="5" PostId="1278" RevisionGUID="ddfc2547-7f5e-4c07-832b-a3aab72778d7" CreationDate="2014-04-24T17:05:39.707" UserId="756" Comment="added 339 characters in body" Text="At the moment I'm using two softserials to connect to a GPS and an GSM module. &#xD;&#xA;&#xD;&#xA;It seems not possible to have two open software-serials. So I was looking for an solution&#xD;&#xA;&#xD;&#xA;After the initial-setup, the GPS module is only needed to be read from; while the GSM module needs to be bidirectional. So:&#xD;&#xA;&#xD;&#xA;    GPS &gt; listen only&#xD;&#xA;    GSM &gt; listen and write&#xD;&#xA;&#xD;&#xA;Now I came across the [GPS library from Adafruit][1], which uses an interrupt to receive data. Is this _instead_ of a software serial. Or do I again run into the limitation?&#xD;&#xA;&#xD;&#xA;An other solution might be to use the D0 and D1 to attach eg the GSM module. But than I won't be able to see the debug messages in my serial monitor. Is that correct?&#xD;&#xA;&#xD;&#xA;Sorry in advance for these n00b questions. But I'm frustrated the things dont work as I want :)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;[This is the adafruit GPS board][2].&#xD;&#xA;And the board with whom it is connected: [Gboard][3]&#xD;&#xA;&#xD;&#xA;The Sim900 is connected to D2/D3 and the GPS is connected to A2/A3.&#xD;&#xA;&#xD;&#xA;D0/D1 are connected to a FTDI breakout board, which is plugged into my USB.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/adafruit/Adafruit-GPS-Library&#xD;&#xA;  [2]: http://www.adafruit.com/products/746&#xD;&#xA;  [3]: http://imall.iteadstudio.com/im120411004.html" />
  <row Id="3659" PostHistoryTypeId="5" PostId="1277" RevisionGUID="0c9f11d3-8c1b-4ff9-90dd-572b3da8627f" CreationDate="2014-04-24T17:05:47.770" UserId="83" Comment="added 56 characters in body" Text="A friend and I are working on building a smartwatch on a budget, so it’s a (very) low power project, but we are currently having a problem with the power supplying.&#xD;&#xA;We already chose this board, because of its size and the BLE chip: [RFduino BLE SMT](http://www.rfduino.com/product/rfd22301-rfduino-ble-smt/)&#xD;&#xA;For now on, we are planning to use this battery [500 mAh LiPo battery](http://www.adafruit.com/products/1578) (approx. 4V at full charge) with this voltage regulator [Micrel MIC5209-3.6YS](http://www.mouser.com/ds/2/495/mic5209-239527.pdf) (the board supports 3.6V max.).&#xD;&#xA; &#xD;&#xA;But the problem is that the Voltage Regulator will apparently drain by itself too much energy from the battery (by heating), reducing drastically the autonomy.&#xD;&#xA; &#xD;&#xA;So we would like to know if you guys can help us, if you can tell us exactly what (type of) regulator would be the best or if we need to find another battery.&#xD;&#xA; &#xD;&#xA;Thanks :)" />
  <row Id="3660" PostHistoryTypeId="5" PostId="1278" RevisionGUID="91424b0c-5d5c-40ce-b26e-409b1dc91b62" CreationDate="2014-04-24T17:11:41.423" UserId="756" Comment="added 19 characters in body" Text="At the moment I'm using two softserials to connect to a GPS and an GSM module. &#xD;&#xA;&#xD;&#xA;It seems not possible to have two open software-serials. So I was looking for an solution&#xD;&#xA;&#xD;&#xA;After the initial-setup, the GPS module is only needed to be read from; while the GSM module needs to be bidirectional. So:&#xD;&#xA;&#xD;&#xA;    GPS &gt; listen only&#xD;&#xA;    GSM &gt; listen and write&#xD;&#xA;&#xD;&#xA;Now I came across the [GPS library from Adafruit][1], which uses an interrupt to receive data. Is this _instead_ of a software serial. Or do I again run into the limitation?&#xD;&#xA;&#xD;&#xA;An other solution might be to use the D0 and D1 to attach eg the GSM module. But than I won't be able to see the debug messages in my serial monitor. Is that correct?&#xD;&#xA;&#xD;&#xA;Sorry in advance for these n00b questions. But I'm frustrated the things dont work as I want :)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**edit**   &#xD;&#xA;&#xD;&#xA;* [This is the adafruit GPS board][2].&#xD;&#xA;* And the board with whom it is connected: [Gboard][3]&#xD;&#xA;* The Sim900 is connected to D2/D3 and the GPS is connected to A2/A3.&#xD;&#xA;* D0/D1 are connected to a FTDI breakout board, which is plugged into my USB.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/adafruit/Adafruit-GPS-Library&#xD;&#xA;  [2]: http://www.adafruit.com/products/746&#xD;&#xA;  [3]: http://imall.iteadstudio.com/im120411004.html" />
  <row Id="3661" PostHistoryTypeId="2" PostId="1280" RevisionGUID="2cc36a33-bea0-4607-b5ea-bd1fbbad8b6c" CreationDate="2014-04-24T17:14:52.090" UserId="83" Text="I&lt;sub&gt;GND&lt;/sub&gt; which is mentioned on page 4 of the datasheet is apparently proportional to the output current. This accounts for about 2-5% of the total current drawn by the regulator, depending on its load. With the maximum voltage drop of 4 - 3.6 = 400mV, a switching regulator will make no real difference. I think your only option is to find another regulator that has better efficiency." />
  <row Id="3662" PostHistoryTypeId="10" PostId="1277" RevisionGUID="99d3f919-e141-4d4a-a377-c97d82fbef7d" CreationDate="2014-04-24T18:04:54.703" UserId="11" Comment="102" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="3663" PostHistoryTypeId="5" PostId="1278" RevisionGUID="bd595128-9d0e-49b6-b144-9bb32ce25331" CreationDate="2014-04-24T18:59:18.110" UserId="756" Comment="edited body" Text="At the moment I'm using two softserials to connect to a GPS and an GSM module. &#xD;&#xA;&#xD;&#xA;It seems not possible to have two open software-serials. So I was looking for an solution&#xD;&#xA;&#xD;&#xA;After the initial-setup, the GPS module is only needed to be read from; while the GSM module needs to be bidirectional. So:&#xD;&#xA;&#xD;&#xA;    GPS &gt; listen only&#xD;&#xA;    GSM &gt; listen and write&#xD;&#xA;&#xD;&#xA;Now I came across the [GPS library from Adafruit][1], which uses an interrupt to receive data. Is this _instead_ of a software serial. Or do I again run into the limitation?&#xD;&#xA;&#xD;&#xA;An other solution might be to use the D0 and D1 to attach eg the GPS module. But than I won't be able to see the debug messages in my serial monitor. Is that correct?&#xD;&#xA;&#xD;&#xA;Sorry in advance for these n00b questions. But I'm frustrated the things dont work as I want :)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**edit**   &#xD;&#xA;&#xD;&#xA;* [This is the adafruit GPS board][2].&#xD;&#xA;* And the board with whom it is connected: [Gboard][3]&#xD;&#xA;* The Sim900 is connected to D2/D3 and the GPS is connected to A2/A3.&#xD;&#xA;* D0/D1 are connected to a FTDI breakout board, which is plugged into my USB.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/adafruit/Adafruit-GPS-Library&#xD;&#xA;  [2]: http://www.adafruit.com/products/746&#xD;&#xA;  [3]: http://imall.iteadstudio.com/im120411004.html" />
  <row Id="3664" PostHistoryTypeId="2" PostId="1281" RevisionGUID="de013e4d-56ab-4057-80c9-649366979986" CreationDate="2014-04-24T19:37:30.180" UserId="1172" Text="I am new to the arduino world and wanted to start playing with the micro controllers, I am a .NET developer by trade so not completely new to this kind of world.&#xD;&#xA;&#xD;&#xA;I purchased a seeedduino v3 and a Grove started kit (No soldering skills here) and can't even get the basics to work.&#xD;&#xA;&#xD;&#xA;I am setting up a simple button to light up the LED program. I have had it run once or twice but it seems really hit or miss on whether or not the Arduino IDE actually gets the program onto the seeedduino.&#xD;&#xA;&#xD;&#xA;***Arduino IDE (1.5.6-r2) set-up:***&#xD;&#xA;Followed setup instructions found here: [SeeedDuino v3][1]&#xD;&#xA;&#xD;&#xA; - Board: Arduino Duemilanove or Diecimila &#xD;&#xA; - Processor: ATmega328&#xD;&#xA; - Port: COM4 [this is what popped up once device was plugged in]&#xD;&#xA; - Button is installed on D3&#xD;&#xA; - LED is installed on D7&#xD;&#xA;&#xD;&#xA;***Program:***&#xD;&#xA;&#xD;&#xA;    int button = 3;&#xD;&#xA;    int LED = 7;&#xD;&#xA;    &#xD;&#xA;    void setup() &#xD;&#xA;    {&#xD;&#xA;      pinMode(button, INPUT); //define button on INPUT devices&#xD;&#xA;      pinMode(LED, OUTPUT);   //define LED on OUTPUT device&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() &#xD;&#xA;    {&#xD;&#xA;      int buttonState = digitalRead(button); //read the status of hte button&#xD;&#xA;      &#xD;&#xA;      if(buttonState == HIGH) //also used (buttonState == 1)&#xD;&#xA;      {&#xD;&#xA;        digitalWrite(LED, HIGH); //also used digitalWrite(LED, 1)  &#xD;&#xA;      }&#xD;&#xA;      else&#xD;&#xA;      {&#xD;&#xA;        digitalWrite(LED, LOW); //also used digitalWrite(LED, 0)&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Upload Verbose Message:&#xD;&#xA;&#xD;&#xA;    avrdude: verifying ...&#xD;&#xA;    avrdude: 1070 bytes of flash verified&#xD;&#xA;    avrdude: Send: Q [51]   [20] &#xD;&#xA;    avrdude: Recv: . [14] &#xD;&#xA;    avrdude: Recv: . [10] &#xD;&#xA;    &#xD;&#xA;    avrdude done.  Thank you.&#xD;&#xA;&#xD;&#xA;I have only had the LED from this program turn on twice, then reloading it ruins it.&#xD;&#xA;&#xD;&#xA;***SIDE NOTE***&#xD;&#xA;&#xD;&#xA;If I try and run Burn BootLoader I get this message-&#xD;&#xA;&#xD;&#xA;    avrdude: Version 5.11, compiled on Sep  2 2011 at 19:38:36&#xD;&#xA;             Copyright (c) 2000-2005 Brian Dean, http://www.bdmicro.com/&#xD;&#xA;             Copyright (c) 2007-2009 Joerg Wunsch&#xD;&#xA;    &#xD;&#xA;             System wide configuration file is &quot;C:\Program Files (x86)\Arduino/hardware/tools/avr/etc/avrdude.conf&quot;&#xD;&#xA;    &#xD;&#xA;             Using Port                    : usb&#xD;&#xA;             Using Programmer              : stk500v2&#xD;&#xA;    avrdude: usbdev_open(): did not find any USB device &quot;usb&quot;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.seeedstudio.com/wiki/Seeeduino_v3.0#How_do_I_configure_the_Arduino_IDE.3F" />
  <row Id="3665" PostHistoryTypeId="1" PostId="1281" RevisionGUID="de013e4d-56ab-4057-80c9-649366979986" CreationDate="2014-04-24T19:37:30.180" UserId="1172" Text="SeeedDuino/Grove and the story of not being able to upload programs" />
  <row Id="3666" PostHistoryTypeId="3" PostId="1281" RevisionGUID="de013e4d-56ab-4057-80c9-649366979986" CreationDate="2014-04-24T19:37:30.180" UserId="1172" Text="&lt;uploading&gt;&lt;bootloader&gt;" />
  <row Id="3667" PostHistoryTypeId="2" PostId="1282" RevisionGUID="3668d4bf-679d-4f69-bb7c-ed415ab2f1b0" CreationDate="2014-04-24T21:02:43.783" UserId="1172" Text="OK mystery solved!&#xD;&#xA;&#xD;&#xA;I ended up getting [Visual Micro Debugger][1] plug-in for my Visual Studio 2013 since I am native .NET programmer. I could see that the code was indeed loaded onto the board and when I pressed the button it was indeed getting to the line of code for setting the digital LED to HIGH.&#xD;&#xA;&#xD;&#xA;It was a very unfortunate case of trying different components and learning I actually had 3 dead LEDs and one bad cable. After getting functioning ones it's all good. :) unlucky me just had 4 bad parts in my kit.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Output from Visual Studio Debugging:&#xD;&#xA;&#xD;&#xA;    Legend:&#xD;&#xA;    line 12 = button state check&#xD;&#xA;    line 16 = button pressed turn on LED&#xD;&#xA;    line 20 = button not pressed turn off LED&#xD;&#xA;    &#xD;&#xA;    =================OUTPUT====================&#xD;&#xA;    14:01:04.372 SeeedDuinoPlayground.ino, line 12	loop() &#xD;&#xA;    14:01:04.372 SeeedDuinoPlayground.ino, line 16	loop() &#xD;&#xA;    14:01:04.481 SeeedDuinoPlayground.ino, line 10&#xD;&#xA;    14:01:04.481 SeeedDuinoPlayground.ino, line 12	loop()&#xD;&#xA;    14:01:04.592 SeeedDuinoPlayground.ino, line 16	loop()&#xD;&#xA;    14:01:04.592 SeeedDuinoPlayground.ino, line 10&#xD;&#xA;    14:01:04.696 SeeedDuinoPlayground.ino, line 12	loop()&#xD;&#xA;    14:01:04.697 SeeedDuinoPlayground.ino, line 20	loop()&#xD;&#xA;    14:01:04.804 SeeedDuinoPlayground.ino, line 10&#xD;&#xA;    14:01:04.804 SeeedDuinoPlayground.ino, line 12	loop()&#xD;&#xA;    14:01:04.912 SeeedDuinoPlayground.ino, line 20	loop()&#xD;&#xA;&#xD;&#xA;  [1]: http://www.visualmicro.com/" />
  <row Id="3668" PostHistoryTypeId="2" PostId="1283" RevisionGUID="9ff57fe2-8ec4-44f4-b758-58d037ca9126" CreationDate="2014-04-24T21:02:48.340" UserId="756" Text="I would like to test the contents of data received over a serial connection. In my loop() I store the data in bffr; and afterwards I would like to test to see if there are some predefined words in it.&#xD;&#xA;&#xD;&#xA;    #define BFFSZ 90&#xD;&#xA;    char bffr[BFFSZ];&#xD;&#xA;    char bffridx; &#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;       readline();&#xD;&#xA;      &#xD;&#xA;       //- Test the bffr&#xD;&#xA;           if(strstr(bffr, &quot;CLOSED&quot;)){&#xD;&#xA;              Serial.println(&quot;&gt; conn. closed&quot;);&#xD;&#xA;              digitalWrite(A1, HIGH); &#xD;&#xA;           }else if(strstr(bffr, &quot;RING&quot;)){&#xD;&#xA;              Serial.println(&quot;&gt; Someone is ringing&quot;);&#xD;&#xA;              digitalWrite(A2, HIGH);&#xD;&#xA;           }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void readline()&#xD;&#xA;    {&#xD;&#xA;       memset(bffr,0,sizeof(bffr));&#xD;&#xA;       char c;&#xD;&#xA;       int i =0;&#xD;&#xA;       bffridx = 0; // start at begninning&#xD;&#xA;   &#xD;&#xA;   &#xD;&#xA;       long previousMillis = millis();&#xD;&#xA;       while (1) {&#xD;&#xA;         unsigned long currentMillis = millis();&#xD;&#xA;         if(currentMillis - previousMillis &gt; 20000) {&#xD;&#xA;           Serial.println(&quot;TIMEOUT&quot;);&#xD;&#xA;           return;&#xD;&#xA;         }&#xD;&#xA;         delay(2);&#xD;&#xA;     &#xD;&#xA;         c=gsm.SimpleRead2();&#xD;&#xA;         //- debug only, to see if there is something received.     &#xD;&#xA;         Serial.write(c);&#xD;&#xA;     &#xD;&#xA;         if (c == -1)&#xD;&#xA;           continue;&#xD;&#xA;         if (c == '\n')&#xD;&#xA;           continue;&#xD;&#xA;         if ((bffridx == BFFSZ-1) || (c == '\r')) {&#xD;&#xA;           bffr[bffridx] = 0;&#xD;&#xA;           return;&#xD;&#xA;         }&#xD;&#xA;        &#xD;&#xA;         bffr[bffridx++]= c;&#xD;&#xA;         delay(2);&#xD;&#xA;       }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The debug-line makes that I can see the data flowwing, eg when I phone the SIM. &#xD;&#xA;&#xD;&#xA;But it looks like the buffer isn't tested. The pin isn't pulled high, nor the line is printed.&#xD;&#xA;&#xD;&#xA;Does anyone know the answer to this?&#xD;&#xA;&#xD;&#xA;  " />
  <row Id="3669" PostHistoryTypeId="1" PostId="1283" RevisionGUID="9ff57fe2-8ec4-44f4-b758-58d037ca9126" CreationDate="2014-04-24T21:02:48.340" UserId="756" Text="Check contents of buffer after serial read" />
  <row Id="3670" PostHistoryTypeId="3" PostId="1283" RevisionGUID="9ff57fe2-8ec4-44f4-b758-58d037ca9126" CreationDate="2014-04-24T21:02:48.340" UserId="756" Text="&lt;arduino-uno&gt;&lt;programming&gt;&lt;sketch&gt;&lt;testing&gt;" />
  <row Id="3671" PostHistoryTypeId="5" PostId="1283" RevisionGUID="af49074d-3c16-42c5-a786-a020e8670bde" CreationDate="2014-04-24T21:24:25.010" UserId="756" Comment="added 441 characters in body; edited tags" Text="I would like to test the contents of data received over a serial connection. In my loop() I store the data in bffr; and afterwards I would like to test to see if there are some predefined words in it.&#xD;&#xA;&#xD;&#xA;    #define BFFSZ 90&#xD;&#xA;    char bffr[BFFSZ];&#xD;&#xA;    char bffridx; &#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;       readline();&#xD;&#xA;      &#xD;&#xA;       //- Test the bffr&#xD;&#xA;           if(strstr(bffr, &quot;CLOSED&quot;)){ //- WORKS&#xD;&#xA;              Serial.println(&quot;&gt; conn. closed&quot;);&#xD;&#xA;              digitalWrite(A1, HIGH); &#xD;&#xA;           }else if(strstr(bffr, &quot;RING&quot;)){ //- WORKS&#xD;&#xA;              Serial.println(&quot;&gt; Someone is ringing&quot;);&#xD;&#xA;              digitalWrite(A2, HIGH);&#xD;&#xA;           }else if(strstr(bffr, &quot;0,7,j,BLINK&quot;)){ //- Doesn't work&#xD;&#xA;              Serial.println(&quot;&gt; Blink&quot;);&#xD;&#xA;              digitalWrite(A2, HIGH);&#xD;&#xA;              delay(300);&#xD;&#xA;              digitalWrite(A2, LOW);&#xD;&#xA;           }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void readline()&#xD;&#xA;    {&#xD;&#xA;       memset(bffr,0,sizeof(bffr));&#xD;&#xA;       char c;&#xD;&#xA;       int i =0;&#xD;&#xA;       bffridx = 0; // start at beginning&#xD;&#xA;   &#xD;&#xA;   &#xD;&#xA;       long previousMillis = millis();&#xD;&#xA;       while (1) {&#xD;&#xA;         unsigned long currentMillis = millis();&#xD;&#xA;         if(currentMillis - previousMillis &gt; 20000) {&#xD;&#xA;           Serial.println(&quot;TIMEOUT&quot;);&#xD;&#xA;           return;&#xD;&#xA;         }&#xD;&#xA;         delay(2);&#xD;&#xA;     &#xD;&#xA;         c=gsm.SimpleRead2();&#xD;&#xA;         //- debug only, to see if there is something received.     &#xD;&#xA;         Serial.write(c);&#xD;&#xA;     &#xD;&#xA;         if (c == -1)&#xD;&#xA;           continue;&#xD;&#xA;         if (c == '\n')&#xD;&#xA;           continue;&#xD;&#xA;         if ((bffridx == BFFSZ-1) || (c == '\r')) {&#xD;&#xA;           bffr[bffridx] = 0;&#xD;&#xA;           return;&#xD;&#xA;         }&#xD;&#xA;        &#xD;&#xA;         bffr[bffridx++]= c;&#xD;&#xA;         delay(2);&#xD;&#xA;       }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The debug-line makes that I can see the data flowing, eg when I phone the SIM. &#xD;&#xA;&#xD;&#xA;But it looks like the buffer isn't tested properly. The first two will work, but the last test fails. It is part of a larger string: `$0,7,j,BLINK,567^` But I thought the `strstr(1,2)` searches for 2 in 1. And as `0,7,j,BLINK,` is within the haystack I assume it wil return true. But apparently not...&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Does anyone know the answer to this?&#xD;&#xA;&#xD;&#xA;  " />
  <row Id="3672" PostHistoryTypeId="6" PostId="1283" RevisionGUID="af49074d-3c16-42c5-a786-a020e8670bde" CreationDate="2014-04-24T21:24:25.010" UserId="756" Comment="added 441 characters in body; edited tags" Text="&lt;arduino-uno&gt;&lt;programming&gt;&lt;sketch&gt;&lt;string&gt;&lt;testing&gt;" />
  <row Id="3673" PostHistoryTypeId="2" PostId="1284" RevisionGUID="07a5cd55-e1a5-4abd-b06f-62599a10526d" CreationDate="2014-04-24T21:29:11.230" UserId="220" Text="After a `serial.read();`, the data [as far as I can tell] is pretty much destroyed. You have two main options to accomplish this:&#xD;&#xA;&#xD;&#xA; - Store the data in a string when read and then reference this later. I'd do this with a *global variable*, that is declared outside of a method and accessible throughout your whole sketch.&#xD;&#xA; - I haven't read throughout your whole code, but, if you only need to read one character, you can use [`serial.peek();`](http://arduino.cc/en/Serial/Peek). **This only works if you need the first character of the buffer.**&#xD;&#xA;&#xD;&#xA;Most likely, your only option would be the first bullet. I'd implement this by adding a method something like this:&#xD;&#xA;&#xD;&#xA;    String buffer_string_serial;&#xD;&#xA;    &#xD;&#xA;    void setup() { //code here }&#xD;&#xA;    &#xD;&#xA;    void loop() { //code here }&#xD;&#xA;    &#xD;&#xA;    int serial_read_buffer() {&#xD;&#xA;      while(serial.avaliable() &gt; 0) {&#xD;&#xA;        buffer_string_serial = buffer_string_serial + serial.peek();&#xD;&#xA;        return serial.read();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Then, just use `serial_read_buffer();`. That will act similar to `serial.read();`. The only difference is it will fill up the `buffer_string_serial` string. You'll have to clear that out after you used all the data so it doesn't get full." />
  <row Id="3674" PostHistoryTypeId="2" PostId="1285" RevisionGUID="fdddb51e-99c9-42cb-b9de-8e861280423b" CreationDate="2014-04-25T01:37:05.237" UserId="1144" Text="So I am working on speeding up a nixie tube speedometer, in this question: , but this brought up another question.  Would having matching baud rates for multiple external devices speed up processes. &#xD;&#xA;&#xD;&#xA; In the case of the other question the OBD-II device is running at 38400 where the Nixie Tubes are running at 9600.  Since I'm taking the info from the OBD-II connector and doing a little math and sending it to the Nixie Tubes, would it be beneficial to have the same baud rate for both devices?&#xD;&#xA;&#xD;&#xA;Now... before you down-vote this question for making some sort of &quot;duplicate&quot; this also answers a question about having a &quot;master&quot; serial hub and having communication between different &quot;slave&quot; serial devices." />
  <row Id="3675" PostHistoryTypeId="1" PostId="1285" RevisionGUID="fdddb51e-99c9-42cb-b9de-8e861280423b" CreationDate="2014-04-25T01:37:05.237" UserId="1144" Text="Matching Baud Rates" />
  <row Id="3676" PostHistoryTypeId="3" PostId="1285" RevisionGUID="fdddb51e-99c9-42cb-b9de-8e861280423b" CreationDate="2014-04-25T01:37:05.237" UserId="1144" Text="&lt;arduino-uno&gt;&lt;serial&gt;&lt;uart&gt;" />
  <row Id="3677" PostHistoryTypeId="2" PostId="1286" RevisionGUID="c450d1b2-00bf-4c6a-89bc-7a448701c3e5" CreationDate="2014-04-25T01:53:27.307" UserId="368" Text="It all depends on how often speed is being reported via the OBD-II connection. If the report rate is faster than the update rate of the tubes then yes, increasing the speed of the tube circuit (not necessarily the connection itself) can have an effect (as long as the tubes themselves can keep up, of course). If the speed is being reported slower than the tubes then don't bother unless you have *other* reasons for increasing it, since both bit rates are already so much faster than the human mind can see, much less process." />
  <row Id="3678" PostHistoryTypeId="2" PostId="1287" RevisionGUID="82cc0d28-8788-4891-b78d-51a4af3eaa10" CreationDate="2014-04-25T05:12:10.080" UserId="84" Text="Your code could be improved by removing the use of `IP` string altogether, and directly calculating its numeric value while characters come in through `Serial1`:&#xD;&#xA;&#xD;&#xA;    ...&#xD;&#xA;    boolean borrar = false;&#xD;&#xA;    int IP = 0;&#xD;&#xA;    ...&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      while (Serial1.available()) { &#xD;&#xA;        char caracter = Serial1.read(); //Comprobamos el caracter &#xD;&#xA;        switch(caracter) {&#xD;&#xA;&#xD;&#xA;        // NOTE it is better to replace default by the list of all digits...    &#xD;&#xA;        case '0':&#xD;&#xA;        case '1':&#xD;&#xA;        case '2':&#xD;&#xA;        case '3':&#xD;&#xA;        case '4':&#xD;&#xA;        case '5':&#xD;&#xA;        case '6':&#xD;&#xA;        case '7':&#xD;&#xA;        case '8':&#xD;&#xA;        case '9':&#xD;&#xA;                    if (borrar) { &#xD;&#xA;                                  IP = 0; &#xD;&#xA;                                  lcd.clear();&#xD;&#xA;                    }&#xD;&#xA;                    &#xD;&#xA;                    lcd.print(caracter);&#xD;&#xA;                    delay(125);&#xD;&#xA;                    borrar = false;&#xD;&#xA;&#xD;&#xA;                    IP *= 10;&#xD;&#xA;                    IP += (int) (caracter - '0');&#xD;&#xA;                    break;  &#xD;&#xA;                    &#xD;&#xA;        case '\r':                &#xD;&#xA;        case 0x0F:&#xD;&#xA;        case 0x0A:  &#xD;&#xA;        &#xD;&#xA;                    String res = &quot;&quot;;&#xD;&#xA;                    borrar = true;&#xD;&#xA;                    int num= IP;&#xD;&#xA;                    if (num &lt; 127) &#xD;&#xA;                      res=&quot;Clase A&quot;;&#xD;&#xA;                    if (num == 127) &#xD;&#xA;                      res=&quot;Direccion reservada&quot;;&#xD;&#xA;                    if (num &gt; 127 &amp;&amp; num &lt; 192)&#xD;&#xA;                      res=&quot;Clase B &quot;;&#xD;&#xA;                    if (num &gt;= 192 &amp;&amp; num &lt; 224)&#xD;&#xA;                      res=&quot;Clase C &quot;;&#xD;&#xA;                    if (num &gt;= 224 &amp;&amp; num &lt; 240)&#xD;&#xA;                      res=&quot;Clase D &quot;;&#xD;&#xA;                    if (num &gt;= 240 &amp;&amp; num &lt; 255)&#xD;&#xA;                      res=&quot;Clase E &quot;;&#xD;&#xA;                    break;  &#xD;&#xA;        &#xD;&#xA;      } //fin switch&#xD;&#xA;    &#xD;&#xA;    }//serial disponible&#xD;&#xA;    &#xD;&#xA;    }//fin programa&#xD;&#xA;&#xD;&#xA;This way would bring you 2 advantages:&#xD;&#xA;&#xD;&#xA;1. a bit faster than working with `String`&#xD;&#xA;2. no dynamic memory allocation/deallocation (`String` does a lot of these) which might lead your program to **[heap fragmentation][1]** and eventually crash.&#xD;&#xA;&#xD;&#xA;Note that I have not further refactored your code as I guessed it was just a snippet, not the complete code for your program. Otherwise, I would have performed further refinement like:&#xD;&#xA;&#xD;&#xA;- remove `num` variable since it is the same as `IP` now&#xD;&#xA;- replace `res` from `String` to `const char*` (to further reduce heap fragmentation due to `String` usage)&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.stackexchange.com/questions/763/im-using-too-much-ram-how-can-this-be-measured/787#787" />
  <row Id="3679" PostHistoryTypeId="2" PostId="1288" RevisionGUID="a94f0926-ec23-4c6d-9654-23532689943b" CreationDate="2014-04-25T08:05:46.710" UserId="1178" Text="I am planning to build a device able to detect and tell a server via wifi if a chair is occupied. How would you do it? And how cheap do you think the device could be?" />
  <row Id="3680" PostHistoryTypeId="1" PostId="1288" RevisionGUID="a94f0926-ec23-4c6d-9654-23532689943b" CreationDate="2014-04-25T08:05:46.710" UserId="1178" Text="Detect and stream if a chair is occupied" />
  <row Id="3681" PostHistoryTypeId="3" PostId="1288" RevisionGUID="a94f0926-ec23-4c6d-9654-23532689943b" CreationDate="2014-04-25T08:05:46.710" UserId="1178" Text="&lt;sensors&gt;&lt;wifi&gt;" />
  <row Id="3682" PostHistoryTypeId="2" PostId="1289" RevisionGUID="dd329927-02d6-40a1-b5cc-9403da953384" CreationDate="2014-04-25T08:43:37.010" UserId="1155" Text="The solution to your problem might be to combine [AltSoftSerial][1] with SoftwareSerial. I haven't done it myself (yet) but I have the same problem as yours.&#xD;&#xA;&#xD;&#xA;SoftwareSerial does busy wait for counting time between two bits, so it can't read simultaneously from two ports (some bits could be lost).&#xD;&#xA;&#xD;&#xA;AltSoftSerial was created to overcome some of these limitations. It's interrupt-based. Unfortunately, it's harwired for one port (and pins 7 &amp; 8). My understanding is that you can combine it with SoftwareSerial to read from 2 simultaneous ports. Pins 7 &amp; 8 aren't what you need, from the description of the GBoard, but AltSoftSerial is open source, you can change the pin numbers (and possibly some masks) in the source code.&#xD;&#xA;&#xD;&#xA;Hope this helps.&#xD;&#xA;&#xD;&#xA;  [1]: https://www.pjrc.com/teensy/td_libs_AltSoftSerial.html" />
  <row Id="3683" PostHistoryTypeId="5" PostId="1283" RevisionGUID="107038c5-4b65-4a67-9786-7a1653532402" CreationDate="2014-04-25T09:12:14.927" UserId="756" Comment="Added the simpleread functions" Text="I would like to test the contents of data received over a serial connection. In my loop() I store the data in bffr; and afterwards I would like to test to see if there are some predefined words in it.&#xD;&#xA;&#xD;&#xA;    #define BFFSZ 90&#xD;&#xA;    char bffr[BFFSZ];&#xD;&#xA;    char bffridx; &#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;       readline();&#xD;&#xA;      &#xD;&#xA;       //- Test the bffr&#xD;&#xA;           if(strstr(bffr, &quot;CLOSED&quot;)){ //- WORKS&#xD;&#xA;              Serial.println(&quot;&gt; conn. closed&quot;);&#xD;&#xA;              digitalWrite(A1, HIGH); &#xD;&#xA;           }else if(strstr(bffr, &quot;RING&quot;)){ //- WORKS&#xD;&#xA;              Serial.println(&quot;&gt; Someone is ringing&quot;);&#xD;&#xA;              digitalWrite(A2, HIGH);&#xD;&#xA;           }else if(strstr(bffr, &quot;0,7,j,BLINK&quot;)){ //- Doesn't work&#xD;&#xA;              Serial.println(&quot;&gt; Blink&quot;);&#xD;&#xA;              digitalWrite(A2, HIGH);&#xD;&#xA;              delay(300);&#xD;&#xA;              digitalWrite(A2, LOW);&#xD;&#xA;           }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    void readline()&#xD;&#xA;    {&#xD;&#xA;       memset(bffr,0,sizeof(bffr));&#xD;&#xA;       char c;&#xD;&#xA;       int i =0;&#xD;&#xA;       bffridx = 0; // start at beginning&#xD;&#xA;   &#xD;&#xA;   &#xD;&#xA;       long previousMillis = millis();&#xD;&#xA;       while (1) {&#xD;&#xA;         unsigned long currentMillis = millis();&#xD;&#xA;         if(currentMillis - previousMillis &gt; 20000) {&#xD;&#xA;           Serial.println(&quot;TIMEOUT&quot;);&#xD;&#xA;           return;&#xD;&#xA;         }&#xD;&#xA;         delay(2);&#xD;&#xA;     &#xD;&#xA;         c=gsm.SimpleRead2();&#xD;&#xA;         //- debug only, to see if there is something received.     &#xD;&#xA;         Serial.write(c);&#xD;&#xA;     &#xD;&#xA;         if (c == -1)&#xD;&#xA;           continue;&#xD;&#xA;         if (c == '\n')&#xD;&#xA;           continue;&#xD;&#xA;         if ((bffridx == BFFSZ-1) || (c == '\r')) {&#xD;&#xA;           bffr[bffridx] = 0;&#xD;&#xA;           return;&#xD;&#xA;         }&#xD;&#xA;        &#xD;&#xA;         bffr[bffridx++]= c;&#xD;&#xA;         delay(2);&#xD;&#xA;       }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The debug-line makes that I can see the data flowing, eg when I phone the SIM. &#xD;&#xA;&#xD;&#xA;But it looks like the buffer isn't tested properly. The first two will work, but the last test fails. It is part of a larger string: `$0,7,j,BLINK,567^` But I thought the `strstr(1,2)` searches for 2 in 1. And as `0,7,j,BLINK,` is within the haystack I assume it wil return true. But apparently not...&#xD;&#xA;&#xD;&#xA;The `gsm.SimpleRead2()` comes from [GSMlib][1] and is my altered version of gsm.SimpleRead(). Instead of printing the char, I just return it so we can buffer it in the `readline` function.&#xD;&#xA;&#xD;&#xA;    void SIMCOM900::SimpleRead()&#xD;&#xA;    {&#xD;&#xA;  &#xD;&#xA;     char datain;&#xD;&#xA;     if(_cell.available()&gt;0){&#xD;&#xA;       datain=_cell.read();&#xD;&#xA;       if(datain&gt;0){&#xD;&#xA;         Serial.print(datain);&#xD;&#xA;       }&#xD;&#xA;     }&#xD;&#xA;    }&#xD;&#xA;    char SIMCOM900::SimpleRead2()&#xD;&#xA;    {&#xD;&#xA;  &#xD;&#xA;     char datain;&#xD;&#xA;     if(_cell.available()&gt;0){&#xD;&#xA;       datain=_cell.read();&#xD;&#xA;       if(datain&gt;0){&#xD;&#xA;         return datain;&#xD;&#xA;       }&#xD;&#xA;     }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Does anyone know the answer to this?&#xD;&#xA;&#xD;&#xA;  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.gsmlib.org/download.html" />
  <row Id="3684" PostHistoryTypeId="2" PostId="1290" RevisionGUID="350ad83c-e6dc-4622-b631-48421f7640b9" CreationDate="2014-04-25T11:51:00.940" UserId="973" Text="Stepper would be heavy and battery consuming, as Ignacio says.&#xD;&#xA;&#xD;&#xA;Pololu makes an encoder for a wheel: http://www.pololu.com/product/1217, but obviously you can implement this in other ways too.  &#xD;&#xA;" />
  <row Id="3685" PostHistoryTypeId="2" PostId="1291" RevisionGUID="4543ba25-a7c5-4e03-a9fb-5aa996023bad" CreationDate="2014-04-25T12:54:16.797" UserId="37" Text="I'm not going to answer this directly, because then you wouldn't learn anything! However, here are a few suggestions:&#xD;&#xA;&#xD;&#xA; - Use a pressure sensor on the seat of the chair or&#xD;&#xA; - Put a distance sensor (IR or ultrasonic) pointing at the chair.&#xD;&#xA; - Use the official [Arduino WiFi shield][1].&#xD;&#xA;&#xD;&#xA; &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoWiFiShield" />
  <row Id="3686" PostHistoryTypeId="2" PostId="1292" RevisionGUID="9f9ab73a-c1a0-474f-a3b5-9667baaa1bd8" CreationDate="2014-04-25T13:50:17.587" UserId="313" Text="For a soft seat you could sense occupancy with an LED and photo-sensor at opposite ends of a short somewhat flexible tube that gets flexed when the cushion compresses, interrupting the light. That or a microswitch would have to be the cheapest means of sensing. &#xD;&#xA;&#xD;&#xA;Getting from there to the server depends a little on how much work you're willing to do, from rolling your own micro-controller+WiFi PCB to purchasing off the shelf parts, which may in turn, depend on whether you need to monitor one chair or a whole auditorium." />
  <row Id="3687" PostHistoryTypeId="5" PostId="1277" RevisionGUID="18ff4955-d2d3-440f-a5ee-bc3117c392c8" CreationDate="2014-04-25T14:43:04.680" UserId="37" Comment="removed thanks; improved title; added electronics tag because the question is specifically about electronics, not programming" Text="A friend and I are working on building a smartwatch on a budget, so it’s a (very) low power project, but we are currently having a problem with the power supplying.&#xD;&#xA;We already chose this board, because of its size and the BLE chip: [RFduino BLE SMT](http://www.rfduino.com/product/rfd22301-rfduino-ble-smt/)&#xD;&#xA;For now on, we are planning to use this battery [500 mAh LiPo battery](http://www.adafruit.com/products/1578) (approx. 4V at full charge) with this voltage regulator [Micrel MIC5209-3.6YS](http://www.mouser.com/ds/2/495/mic5209-239527.pdf) (the board supports 3.6V max.).&#xD;&#xA; &#xD;&#xA;But the problem is that the Voltage Regulator will apparently drain by itself too much energy from the battery (by heating), reducing drastically the autonomy.&#xD;&#xA; &#xD;&#xA;So we would like to know if you guys can help us, if you can tell us exactly what (type of) regulator would be the best or if we need to find another battery." />
  <row Id="3688" PostHistoryTypeId="4" PostId="1277" RevisionGUID="18ff4955-d2d3-440f-a5ee-bc3117c392c8" CreationDate="2014-04-25T14:43:04.680" UserId="37" Comment="removed thanks; improved title; added electronics tag because the question is specifically about electronics, not programming" Text="Which voltage regulator should I use?" />
  <row Id="3689" PostHistoryTypeId="6" PostId="1277" RevisionGUID="18ff4955-d2d3-440f-a5ee-bc3117c392c8" CreationDate="2014-04-25T14:43:04.680" UserId="37" Comment="removed thanks; improved title; added electronics tag because the question is specifically about electronics, not programming" Text="&lt;battery&gt;&lt;bluetooth&gt;&lt;electronics&gt;" />
  <row Id="3690" PostHistoryTypeId="24" PostId="1277" RevisionGUID="18ff4955-d2d3-440f-a5ee-bc3117c392c8" CreationDate="2014-04-25T14:43:04.680" Comment="Proposed by 37 approved by 46, 83 edit id of 289" />
  <row Id="3691" PostHistoryTypeId="2" PostId="1293" RevisionGUID="7994bcba-1810-408c-819a-be28ac6e590b" CreationDate="2014-04-25T15:43:04.290" UserId="1182" Text="I am currently using an Arduino Mega 2560 to run this stepper motor driver (Big Easy Driver, ROB-11876 from sparkfun) https://www.sparkfun.com/products/11876. &#xD;&#xA;&#xD;&#xA;I am trying to use the sleep or enable function on this chip to decrease the power consumption when I am not using the motor. I have all the rest of the driver working properly (steps, direction etc.) but when I hook up a wire to either the sleep or enable section and send a respective high or low it doesn't appear to do anything. (Chip works as normal, power consumption stays the same). &#xD;&#xA;&#xD;&#xA;I have tested to see that the Arduino is outputting correctly and it seems to be. But other than this I'm kinda at a loss on what might be wrong.&#xD;&#xA;&#xD;&#xA;Does anyone have any suggestions on why this might be or other things to test to try to narrow down the problem?" />
  <row Id="3692" PostHistoryTypeId="1" PostId="1293" RevisionGUID="7994bcba-1810-408c-819a-be28ac6e590b" CreationDate="2014-04-25T15:43:04.290" UserId="1182" Text="How to test the sleep / enable function of Stepper Driver?" />
  <row Id="3693" PostHistoryTypeId="3" PostId="1293" RevisionGUID="7994bcba-1810-408c-819a-be28ac6e590b" CreationDate="2014-04-25T15:43:04.290" UserId="1182" Text="&lt;pins&gt;&lt;arduino-mega&gt;&lt;motor&gt;" />
  <row Id="3700" PostHistoryTypeId="2" PostId="1295" RevisionGUID="a688d11d-53ab-43ec-8aa5-7c9cb4e26899" CreationDate="2014-04-25T17:12:09.500" UserId="1184" Text="Your best bet would probably be to interface with a colorimeter.  There is a tutorial for an open source colorimeter here:&#xD;&#xA;&#xD;&#xA;http://www.appropedia.org/Open-source_colorimeter&#xD;&#xA;&#xD;&#xA;IORodeo also sells a shield:&#xD;&#xA;&#xD;&#xA;http://www.iorodeo.com/colorimeter&#xD;&#xA;&#xD;&#xA;Vernier sells a colorimeter that may be suitable for your project &amp; Sparkfun sells a shield to interface with Vernier sensors.  &#xD;&#xA;&#xD;&#xA;If a colorimeter doesn't work you would have to use an electrode, which is pretty expensive and has a shelf life." />
  <row Id="3701" PostHistoryTypeId="5" PostId="1293" RevisionGUID="cb8725ce-2c54-46bd-977e-a4a574b192de" CreationDate="2014-04-25T17:17:48.967" UserId="1182" Comment="added 958 characters in body; edited title" Text="I am currently using an Arduino Mega 2560 to run this stepper motor driver (Big Easy Driver, ROB-11876 from sparkfun) https://www.sparkfun.com/products/11876. &#xD;&#xA;&#xD;&#xA;I am trying to use the sleep or enable function on this chip to decrease the power consumption when I am not using the motor. I have all the rest of the driver working properly (steps, direction etc.) but when I hook up a wire to either the sleep or enable section and send a respective high or low it doesn't appear to do anything. (Chip works as normal, power consumption stays the same). &#xD;&#xA;&#xD;&#xA;I have tested to see that the Arduino is outputting correctly and it seems to be. But other than this I'm kinda at a loss on what might be wrong.&#xD;&#xA;&#xD;&#xA;Does anyone have any suggestions on why this might be or other things to test to try to narrow down the problem?&#xD;&#xA;&#xD;&#xA;---------------------------&#xD;&#xA;Since I can't put an answer in until 8 hrs after I asked I'll put it here.&#xD;&#xA;&#xD;&#xA;Just for future reference if anyone needs it I got the following from SparkFun:&#xD;&#xA;&#xD;&#xA;&gt;On the Big Easy Driver Board, the Step, Dir, Sleep, Reset, and the Microstep pins are all &gt;pulled high with 20kΩ resistors, while Enable is pulled low with the same. So sleep is &gt;disabled (until explicitly enabled) and the stepper is enabled (until explicitly disabled). &#xD;&#xA;&gt;&#xD;&#xA;&gt;For much of the use of this board, there is no real need to adjust these settings, but If you &gt;want to achieve a low-power state you would pull the sleep pin low. This should disable much &gt;of the internal circuitry on the IC. In order to reduce power, Enable should be pulled high &gt;to disable the output FETs. &#xD;&#xA;&#xD;&#xA;To test that the sleep function is working on the chip you can just jump it to low (ground). For me it turned out to be an error with the Arduino code rather than the chip.&#xD;&#xA;Here is also a good reference about pull-down / pull-up resistors. http://www.bit-101.com/blog/?p=3813 " />
  <row Id="3702" PostHistoryTypeId="4" PostId="1293" RevisionGUID="cb8725ce-2c54-46bd-977e-a4a574b192de" CreationDate="2014-04-25T17:17:48.967" UserId="1182" Comment="added 958 characters in body; edited title" Text="How to test the sleep / enable function of Stepper Driver? (SOLVED)" />
  <row Id="3703" PostHistoryTypeId="2" PostId="1296" RevisionGUID="d6c3ad6d-00d8-45df-805b-550c2338b396" CreationDate="2014-04-25T18:18:22.567" UserId="40" Text="As you've discovered, there are a lot of variables involved, so you need *some* sort of feedback.  A popular way to do this is with an encoder, but depending on your needs, other kinds of sensors can make do.  For example, if your problem is keeping the robot going in a straight line, an electronic compass can help.  For a line following robot, the line sensors are usually enough.  Range sensors can track your distance.  You get the idea." />
  <row Id="3704" PostHistoryTypeId="2" PostId="1297" RevisionGUID="49a6b026-413e-4f86-8626-d6b8cea93886" CreationDate="2014-04-25T18:31:59.893" UserId="40" Text="Some shields let you use jumpers or something to change the pin assignments, but I don't believe the Seed motor shield does.  What you can use is a [go-between shield](https://www.sparkfun.com/products/11002) between the two shields to remap the pins on the top shield.  Then in your code, you just initialize the second instance using different pins.  You just have to make sure the alternate pins have the features you need, like pwm." />
  <row Id="3705" PostHistoryTypeId="4" PostId="1293" RevisionGUID="3764c0c1-5a4b-40ab-8bde-83a01521fcda" CreationDate="2014-04-25T18:52:55.223" UserId="11" Comment="edited title" Text="How to test the sleep / enable function of Stepper Driver?" />
  <row Id="3706" PostHistoryTypeId="2" PostId="1298" RevisionGUID="921c6fa0-f7c7-464e-b151-0d8a512ea252" CreationDate="2014-04-25T21:40:44.983" UserId="1185" Text="I recently started messing around with an Arduino and I have made a few &quot;gadgets&quot; using shields. I then wondered how I would go about using things I can't find shields for.&#xD;&#xA;&#xD;&#xA;One specific thing I want to do is to be able to use the larger e-paper displays from Pervasive Displays (7'' and 10'') but a brief consultation with Google found no Arduino kits or shields. I then looked through the documentation of the timing controller for the 7'' display and found the information required to be able to use it (initiation, sending data to be drawn, opcodes, etc.). I then decided to check the Github repo for the examples for the 2'' displays and they seem to just do what the documentation says to do.&#xD;&#xA;&#xD;&#xA;Is my observation naive here? Is it really as straightforward as following the documentation? No magic sauce?&#xD;&#xA;&#xD;&#xA;Note: I don't have a clue how complex using the 7'' display actually is, I just used it as an example because I had just looked it up..." />
  <row Id="3707" PostHistoryTypeId="1" PostId="1298" RevisionGUID="921c6fa0-f7c7-464e-b151-0d8a512ea252" CreationDate="2014-04-25T21:40:44.983" UserId="1185" Text="How to use components that don't have a shield?" />
  <row Id="3708" PostHistoryTypeId="3" PostId="1298" RevisionGUID="921c6fa0-f7c7-464e-b151-0d8a512ea252" CreationDate="2014-04-25T21:40:44.983" UserId="1185" Text="&lt;shields&gt;" />
  <row Id="3709" PostHistoryTypeId="2" PostId="1299" RevisionGUID="f528fe6f-c9b0-4130-b6ed-3479d27f10e8" CreationDate="2014-04-25T22:30:26.307" UserId="1186" Text="If you are using different serial ports for each device (eg: using software serial for at least one of them on a Uno, or using separate hardware serial on a Mega2560), then it really doesn't matter whether they use the same baud rate or not.  &#xD;&#xA;&#xD;&#xA;If you are somehow multiplexing the same serial port (eg: input only from one device, output only to the other; or some external multiplexing hardware) then there might be a slight gain in not needing to change the baud rate when switching between devices, but probably not noticable. &#xD;&#xA;&#xD;&#xA;If either or both devices have some option to communicate faster, that might speed up your system - independent of whether they use the SAME rate.&#xD;&#xA;" />
  <row Id="3710" PostHistoryTypeId="2" PostId="1300" RevisionGUID="2c2b81eb-37c7-4368-9e28-54a42fcfbd96" CreationDate="2014-04-25T22:56:06.937" UserId="1186" Text="So you want three serial ports: upload/debug (hardware serial), GSM (software serial) and GPS (software serial).  Unfortunately, two SoftSerial ports are not going to work at the same time (or even send and receive at the same time on one SoftSerial port).  In your current configuration it's not going to be solvable.&#xD;&#xA;&#xD;&#xA;If you can wire the GPS to different pins, there are a couple of options to try.  One would be to disconnect the FTDI when running (reconnect to program) so you can use the hardware serial port for either GSM or GPS (probably the former).  If you need some print statements for debugging, you could use SoftSerial or AltSoftSerial (and connect the FTDI differently).  Reconnecting between upload/debug and run phases would be a pain but it comes with the platform you are choosing and the number of serial ports you need; you might be able to wire up a DPDT switch externally to do the switching rapidly.&#xD;&#xA;&#xD;&#xA;The other and perhaps easier approach would be to connect the GPS to pins 8 and 9, and use AltSoftSerial for the GPS; as long as your baud rate to the GSM is high enough that might work.  (SoftSerial for the GSM will turn off interrupts for excessive periods of time at low baud rates).  Using AltSoftSerial makes use of the single 16 bit timer (Timer1), so this won't work if you use any other library which requires Timer1.&#xD;&#xA;" />
  <row Id="3711" PostHistoryTypeId="2" PostId="1301" RevisionGUID="ecbd9de7-3765-4c1c-895b-b274a5305992" CreationDate="2014-04-25T23:00:47.790" UserId="11" Text="Your observation is correct. Everything breaks down to some number of physical connections and some protocol for communicating with the device. Shields and libraries associated with them do most of the work for you, but not everything comes in a shield.&#xD;&#xA;&#xD;&#xA;There are some common protocols for interfacing with devices, including [SPI][1] and [I2C][2]. From a quick peek at the [driver interface sheet][3], it looks like they're using SPI. Well, your [Arduino already supports that][4] so you can hit the ground running with this display. You just need to know what commands to send to it, which you can find from the display's datasheet.&#xD;&#xA;&#xD;&#xA;**Note:** It looks like the 2&quot; screen requires 3.3V while the 7&quot; one supports up to 7V.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/I%C2%B2C&#xD;&#xA;  [3]: http://www.pervasivedisplays.com/products/2inch&#xD;&#xA;  [4]: http://arduino.cc/en/Reference/SPI" />
  <row Id="3712" PostHistoryTypeId="5" PostId="1220" RevisionGUID="4a84dabe-cc7c-479e-90bb-6e8c8f128d2a" CreationDate="2014-04-25T23:11:52.833" UserId="973" Comment="added 18 characters in body" Text="A way to proceed is to create a spreadsheet showing the pin positions used by this board, and the Arduino shield signals they plug into. Next to these, you need columns showing the actual signals on the ATMega2560 (for Mega2560) and ATMega328 (for Uno) that these shield pins attach to. You can get this info from the Uno and Mega2560 schematic drawings.&#xD;&#xA;&#xD;&#xA;In a quick look, it seems that the Arduino shield pin names for Uno and Mega are the same: for example, shield pin '0' (digital zero) is in the same location on both boards, and likewise for other pins. &#xD;&#xA;&#xD;&#xA;However, on the Uno digital-0 attaches to ATMega328 Port D bit 0, while on the Mega2560, it attaches to ATMega2560 Port E bit 0. And things get more obtuse with digital 2..7.&#xD;&#xA;&#xD;&#xA;Now, when twiddling bits individually using digitalWrite(pin, value), the Arduino library no doubt takes care of translating to the appropriate port/bits that need to be set for the ATMega chip and Arduino board that's in use. However, libraries that use lower-level functions (especially if they need to write entire bytes to ports, as a fast LCD library might) will need to take their own steps to make this translation.&#xD;&#xA;&#xD;&#xA;So... first step is to determine whether there is a separate LCD driver library for Mega2560. &#xD;&#xA;&#xD;&#xA;Next, investigate whether the library you have has initialization code that is supposed to determine what board it's running on (and is your board included?), or requires you to set some flag to tell it what board is in use.&#xD;&#xA;&#xD;&#xA;Failing that, you _could_ create a mess of jumpers or some other wiring scheme to jumper the Mega's ATMega2560's signals so that it's wired up like a Uno would be. It's not clear that this is possible, since some of ATMega2560's Port D is not even wired to a header.&#xD;&#xA;&#xD;&#xA;Or you could look at the source code for the library and see what it's actually doing, and what it would need to do different to operate the ATMega 2560 pins that the shield does connect to." />
  <row Id="3713" PostHistoryTypeId="2" PostId="1302" RevisionGUID="67d62d3b-b956-46d2-81bb-32ee90eabc89" CreationDate="2014-04-25T23:31:38.560" UserId="1186" Text="When you mentions &quot;loud sounds (i.e, a mic reading of ~600)&quot; I'm guessing that means you've successfully connected the mic to an ADC input and you are referring to analog readings, right?  (If not you may need to clarify).  I won't worry about scaling or offset biasing the inputs, assuming you have that part down and you can test the Analog input to detect loudness.&#xD;&#xA;&#xD;&#xA;If your Arduino can be dedicated to making this measurement (ie: doesn't need to do anything else while doing it), then the simplest solution might be a loop comparing the ADC input with some threshold you have determined, and using micros() to check the time different.  The micros() function has only 4 uS resolution, but the loop time will add more time than that anyway, and actually the limited bandwidth of your audio signals (speaker and mic both) will make any microsecond level measurement suspect anyway.  So the simple loop might be as accurate as you need.&#xD;&#xA;&#xD;&#xA;For example:&#xD;&#xA;&#xD;&#xA;    const int THRESHOLD = 600; // adjust&#xD;&#xA;    const int MINDELAY = 1000;  // adjust&#xD;&#xA;    &#xD;&#xA;    long &#xD;&#xA;    takeMeasurement() {&#xD;&#xA;        while(analogRead(A4) &lt; THRESHOLD); // wait for first trigger&#xD;&#xA;        long start = micros();&#xD;&#xA;        delayMicroseconds(MINDELAY); // let first noise die down&#xD;&#xA;        while(analogRead(A4) &lt; THRESHOLD); // wait for second trigger&#xD;&#xA;        return micros() - start;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;You would call this function when you were ready to take a measurement.  To keep the loop time short (when it's waiting for a loud sound), it has no timeout, so it won't return until it does detect two loud sounds.  Depending on your need, you might need to change that and have an escape from the loops.  There are several ways that might be done:&#xD;&#xA;&#xD;&#xA;* test for micros() exceeding some timeout within the loop&#xD;&#xA;&#xD;&#xA;* decrement a counter in the loop and exit if it goes to zero (or if the sound is detected)&#xD;&#xA;&#xD;&#xA;* test a flag (volatile byte) in the loop, which gets set by a timer interrrupt&#xD;&#xA;&#xD;&#xA;Which is best depends on other aspects of your overall design." />
  <row Id="3714" PostHistoryTypeId="2" PostId="1303" RevisionGUID="df2ca205-bb10-432e-8dd6-9580e10f2f39" CreationDate="2014-04-26T00:08:31.313" UserId="973" Text="Your examples of sending input to the Arduino IDE monitor and to Python involve the Arduino sending data via &quot;Serial over USB&quot; convention. However this is not seen by the operating system (Windows, MacOS) as legitimate keyboard/mouse/joystick input.&#xD;&#xA;&#xD;&#xA;There are separate USB conventions (device types) for keyboard/mouse/joystick. Only Arduinos where the USB interface is programmable are able to present those conventions, and some more easily than others, and require understanding some USB client libraries.  The link provided by Chris Stratton has some useful background.&#xD;&#xA;&#xD;&#xA;A particularly easy way to get into this is with the PJRC Teensy, https://www.pjrc.com/teensy/, which comes with libraries and examples that let you do this out-of-the-box. See the &quot;Teensyduino&quot; section of their website for USB Keyboard, Mouse, Joystick and so on. These pages are useful background even if not using Teensy. It has attracted a small following of users interested in this area. Plus the various Teensies are conveniently small boards that fits nicely in some user-interface device you might want to build.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3715" PostHistoryTypeId="5" PostId="43" RevisionGUID="8022a0a5-7f4c-4e6c-94b5-17dce32c0d0e" CreationDate="2014-04-26T00:09:34.580" UserId="1186" Comment="Corrected a typo (office-&gt;official), then expanded the description slightly.  I was temporarily thrown off by &quot;Office Site&quot; so I thought it might be confusing for others" Text="There is an [Arduino Eclipse plugin][1]! And Eclipse is an awesome cross-plateform open-source IDE!&#xD;&#xA;&#xD;&#xA;[Stino][2] is good. Requires [Sublime Text 2][3] which has an indefinite free trial.&#xD;&#xA;&#xD;&#xA;For More Go to [The Official Arduino Site][4] &#xD;&#xA;&#xD;&#xA;For development on Windows, there is a special edition from Arduino official IDE called [arduino-erw][5], This edition much better the last one because it fixed a lot of lagging and stability issues!&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Code/Eclipse&#xD;&#xA;  [2]: https://github.com/Robot-Will/Stino&#xD;&#xA;  [3]: http://www.sublimetext.com/2&#xD;&#xA;  [4]: http://playground.arduino.cc/Main/DevelopmentTools&#xD;&#xA;  [5]: https://code.google.com/p/arduino-erw/" />
  <row Id="3716" PostHistoryTypeId="24" PostId="43" RevisionGUID="8022a0a5-7f4c-4e6c-94b5-17dce32c0d0e" CreationDate="2014-04-26T00:09:34.580" Comment="Proposed by 1186 approved by 11 edit id of 290" />
  <row Id="3717" PostHistoryTypeId="5" PostId="1259" RevisionGUID="1320542b-b58b-4229-b98e-c8b8661fcd8f" CreationDate="2014-04-26T10:32:13.917" UserId="973" Comment="Warning that this answer could harm OP's computer" Text="[Edit from gwideman: WARNING: The advise contained here appears to violate USB 2.0 specs, with consequences that could damage OP's computer. See my comment below.]&#xD;&#xA;&#xD;&#xA;In electronics, as usual in situations where a cricuit is misbehaving and we don't understand why, a solution that generally works is to add a **decoupling cap** between `+5V` and `GND`. &#xD;&#xA;&#xD;&#xA;In your case, I would put at least **220uF**; that would ensure two things:&#xD;&#xA;&#xD;&#xA;- the voltage used to control the servo never drops&#xD;&#xA;- the voltage brought to Arduino by the USB does not drop either (which would have very bad impact on the Arduino, probably resetting it)&#xD;&#xA;&#xD;&#xA;Electrolytic caps are a **must-have** for every electronics hobbyist (and professional as well, of course).&#xD;&#xA;&#xD;&#xA;You can read more about decoupling capacitors on [Wikipedia][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Decoupling_capacitor" />
  <row Id="3718" PostHistoryTypeId="24" PostId="1259" RevisionGUID="1320542b-b58b-4229-b98e-c8b8661fcd8f" CreationDate="2014-04-26T10:32:13.917" Comment="Proposed by 973 approved by 46, -1 edit id of 288" />
  <row Id="3719" PostHistoryTypeId="5" PostId="1259" RevisionGUID="105097c1-4e1e-4bca-8205-171a43bba626" CreationDate="2014-04-26T10:32:13.917" UserId="84" Comment="Warning that this answer could harm OP's computer" Text="In electronics, as usual in situations where a cricuit is misbehaving and we don't understand why, a solution that generally works is to add a **decoupling cap** between `+5V` and `GND`. &#xD;&#xA;&#xD;&#xA;In your case, I would put at least **220uF**; that would ensure two things:&#xD;&#xA;&#xD;&#xA;- the voltage used to control the servo never drops&#xD;&#xA;- the voltage brought to Arduino by the USB does not drop either (which would have very bad impact on the Arduino, probably resetting it)&#xD;&#xA;&#xD;&#xA;Electrolytic caps are a **must-have** for every electronics hobbyist (and professional as well, of course).&#xD;&#xA;&#xD;&#xA;You can read more about decoupling capacitors on [Wikipedia][1].&#xD;&#xA;&#xD;&#xA;**Edit:**&#xD;&#xA;&#xD;&#xA;According to @gwideman comment, it seems that using a decoupling capacitance **above 10uF** in a USB 2.0 device would violate USB specs and ***may damage*** the USB host controller on the computer.&#xD;&#xA;&#xD;&#xA;I was not aware of this limitation but I have already used decoupling capacitance up to 100uF in my circuits and never got any issue with my USB computer port.&#xD;&#xA;&#xD;&#xA;It might be due to extra electronics on the Arduino board that would &quot;isolate&quot; USB power from Arduino +5V anf d GND pins, I don't know (**that should probably be the topic of a specific question**); or maybe I have just been lucky all this time...&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Decoupling_capacitor" />
  <row Id="3720" PostHistoryTypeId="2" PostId="1304" RevisionGUID="70abdf5a-1c6d-4760-8764-a01cee63c0bb" CreationDate="2014-04-26T21:38:54.610" UserId="1192" Text="I am creating a wireless sensor using an Attiny85.  I want to send the data to an arduino uno, so I purchased the 315mhz rf link kit from spark fun.  Since the Attiny85 does not have a TX I decided to use the Manchester library however it won't compile on the Attiny85.&#xD;&#xA;&#xD;&#xA;I followed the steps from this blog :&#xD;&#xA;http://mchr3k-arduino.blogspot.mx/2012/01/wireless-sensor-node-part-2.html?showComment=1338749638806#c853067277980266192&#xD;&#xA;&#xD;&#xA;Here is the code I am using:&#xD;&#xA;        &#xD;&#xA;        #include &lt;WProgram.h&gt; //otherwise it says it can't find Arduino.h&#xD;&#xA;        #include &lt;Manchester.h&gt; //include the library to comunicate&#xD;&#xA;        #define TxPin 2 //the pin that is used to send data&#xD;&#xA;&#xD;&#xA;     int sensorPin = 4;&#xD;&#xA;     int ledPin = 3;&#xD;&#xA;     int count = 50;&#xD;&#xA;&#xD;&#xA;     void setup(){&#xD;&#xA;      pinMode (ledPin, OUTPUT);&#xD;&#xA;      man.workAround1MhzTinyCore(); //add this in order for transmitter to work with 1Mhz Attiny85/84&#xD;&#xA;      man.setupTransmit(TxPin, MAN_1200); //set transimt pin&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop(){&#xD;&#xA;      if (count == 50){&#xD;&#xA;       digitalWrite (ledPin, HIGH);&#xD;&#xA;       count = 0;&#xD;&#xA;       }&#xD;&#xA;       int data = analogRead(sensorPin);&#xD;&#xA;       man.transmit(data); //transmits and reads the data&#xD;&#xA;       delay (100);&#xD;&#xA;       count ++;&#xD;&#xA;     }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Here is the error message:&#xD;&#xA;&#xD;&#xA;      Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp: In function 'void MANRX_SetupReceive(uint8_t)':&#xD;&#xA;/Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:366: error: 'TCCR2A' was not declared in this scope&#xD;&#xA;/Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:366: error: 'WGM21' was not declared in this scope&#xD;&#xA;/Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:368: error: 'TCCR2B' was not declared in this scope&#xD;&#xA;/Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:368: error: 'CS21' was not declared in this scope&#xD;&#xA;/Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:369: error: 'OCR2A' was not declared in this scope&#xD;&#xA;/Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:379: error: 'TIMSK2' was not declared in this scope&#xD;&#xA;/Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:379: error: 'OCIE2A' was not declared in this scope&#xD;&#xA;/Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:380: error: 'TCNT2' was not declared in this scope&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Thanks for all help,&#xD;&#xA;Joel" />
  <row Id="3721" PostHistoryTypeId="1" PostId="1304" RevisionGUID="70abdf5a-1c6d-4760-8764-a01cee63c0bb" CreationDate="2014-04-26T21:38:54.610" UserId="1192" Text="Manchester Library Won't Compile for Attiny85" />
  <row Id="3722" PostHistoryTypeId="3" PostId="1304" RevisionGUID="70abdf5a-1c6d-4760-8764-a01cee63c0bb" CreationDate="2014-04-26T21:38:54.610" UserId="1192" Text="&lt;programming&gt;&lt;arduino-ide&gt;&lt;compile&gt;&lt;attiny&gt;&lt;rf&gt;" />
  <row Id="3723" PostHistoryTypeId="5" PostId="1304" RevisionGUID="f3c1e7e8-df1f-4c2e-ad85-a94cddb0e8a2" CreationDate="2014-04-26T21:50:46.713" UserId="11" Comment="deleted 1 character in body" Text="I am creating a wireless sensor using an Attiny85.  I want to send the data to an arduino uno, so I purchased the 315mhz rf link kit from spark fun.  Since the Attiny85 does not have a TX I decided to use the Manchester library however it won't compile on the Attiny85.&#xD;&#xA;&#xD;&#xA;I followed the steps from this blog :&#xD;&#xA;http://mchr3k-arduino.blogspot.mx/2012/01/wireless-sensor-node-part-2.html?showComment=1338749638806#c853067277980266192&#xD;&#xA;&#xD;&#xA;Here is the code I am using:&#xD;&#xA;        &#xD;&#xA;        #include &lt;WProgram.h&gt; //otherwise it says it can't find Arduino.h&#xD;&#xA;        #include &lt;Manchester.h&gt; //include the library to comunicate&#xD;&#xA;        #define TxPin 2 //the pin that is used to send data&#xD;&#xA;&#xD;&#xA;     int sensorPin = 4;&#xD;&#xA;     int ledPin = 3;&#xD;&#xA;     int count = 50;&#xD;&#xA;&#xD;&#xA;     void setup(){&#xD;&#xA;      pinMode (ledPin, OUTPUT);&#xD;&#xA;      man.workAround1MhzTinyCore(); //add this in order for transmitter to work with 1Mhz Attiny85/84&#xD;&#xA;      man.setupTransmit(TxPin, MAN_1200); //set transimt pin&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop(){&#xD;&#xA;      if (count == 50){&#xD;&#xA;       digitalWrite (ledPin, HIGH);&#xD;&#xA;       count = 0;&#xD;&#xA;       }&#xD;&#xA;       int data = analogRead(sensorPin);&#xD;&#xA;       man.transmit(data); //transmits and reads the data&#xD;&#xA;       delay (100);&#xD;&#xA;       count ++;&#xD;&#xA;     }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Here is the error message:&#xD;&#xA;&#xD;&#xA;    /Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp: In function 'void MANRX_SetupReceive(uint8_t)':&#xD;&#xA;    /Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:366: error: 'TCCR2A' was not declared in this scope&#xD;&#xA;    /Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:366: error: 'WGM21' was not declared in this scope&#xD;&#xA;    /Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:368: error: 'TCCR2B' was not declared in this scope&#xD;&#xA;    /Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:368: error: 'CS21' was not declared in this scope&#xD;&#xA;    /Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:369: error: 'OCR2A' was not declared in this scope&#xD;&#xA;    /Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:379: error: 'TIMSK2' was not declared in this scope&#xD;&#xA;    /Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:379: error: 'OCIE2A' was not declared in this scope&#xD;&#xA;    /Users/joelsimonoff/Documents/Arduino/libraries/MANCHESTER/Manchester.cpp:380: error: 'TCNT2' was not declared in this scope&#xD;&#xA;" />
  <row Id="3724" PostHistoryTypeId="2" PostId="1305" RevisionGUID="3ff923b2-cb2b-4d2d-8d1c-2e451440f41a" CreationDate="2014-04-26T22:28:06.293" UserId="1006" Text="I have got Arduino Mega 2560, Arduino WiFi Shield and resistor 1.5K. Now PWM 2 is attached to Res. then attached GND. 5V is attached between PWM2 and resistor's up point. I want to read Arduino Mega's A7 Analog Input point in order to print this value on Android Phone's web browser. But, I get zero value everytime surprisingly. It should be like 235, 350 something like integer or float kinds as usual. According to Android Phone's Google Chrome Web Browser Page, why there are too many zeros in the HTML? It should be different from zeros because I have already added a short wire to Analog A7 so as to make an antenna. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![My workside][1]&#xD;&#xA;![Android Phone Screen][2]&#xD;&#xA;![Arduino IDE &amp; Serial Monitor][3]&#xD;&#xA;   &#xD;&#xA;     &#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;WiFi.h&gt;&#xD;&#xA;    &#xD;&#xA;    char ssid[] = &quot;Connectify-me&quot;;     //  your network SSID (name) &#xD;&#xA;    char pass[] = &quot;rilekez5&quot;;    // your network password&#xD;&#xA;    int status = WL_IDLE_STATUS;&#xD;&#xA;    float PPG = analogRead(A7);&#xD;&#xA;    boolean door_status = false;&#xD;&#xA;    WiFiServer server(80);&#xD;&#xA;    void setup() {&#xD;&#xA;    &#xD;&#xA;      // start serial port for debugging purposes&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      // Attach interrupt to pin 2&#xD;&#xA;      //attachInterrupt(0, setDoorStatus, RISING);&#xD;&#xA;      // attempt to connect to Wifi network:&#xD;&#xA;      while ( status != WL_CONNECTED) { &#xD;&#xA;        Serial.print(&quot;Yazdigin SSID araniyor: &quot;);&#xD;&#xA;        Serial.println(ssid);&#xD;&#xA;        status = WiFi.begin(ssid, pass);&#xD;&#xA;        // wait 10 seconds for connection:&#xD;&#xA;        delay(10000);&#xD;&#xA;      } &#xD;&#xA;      server.begin();&#xD;&#xA;      // you're connected now, so print out the status:&#xD;&#xA;      printWifiStatus();&#xD;&#xA;    }&#xD;&#xA;    void loop() {       &#xD;&#xA;      // listen for incoming clients&#xD;&#xA;      WiFiClient client = server.available();&#xD;&#xA;      if (client) {&#xD;&#xA;        Serial.println(&quot;Deger gonderildi&quot;);&#xD;&#xA;        Serial.print(PPG);&#xD;&#xA;        // an http request ends with a blank line&#xD;&#xA;        boolean currentLineIsBlank = true;&#xD;&#xA;        while (client.connected() &amp; client.available()) {&#xD;&#xA;            // client.println(&quot;HTTP/1.1 200 OK&quot;);&#xD;&#xA;             //client.println(&quot;Content-Type: text/html&quot;);&#xD;&#xA;             // client.println(&quot;&lt;!DOCTYPE HTML&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;html&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;body&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;meta http-equiv=\&quot;refresh\&quot; content=\&quot;1\&quot;&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;li&gt;&quot;);&#xD;&#xA;              client.print(PPG);  //The value should different from zeros&#xD;&#xA;              client.println(&quot;&lt;/li&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;/body&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;/html&gt;&quot;);&#xD;&#xA;    &#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;        // give the web browser time to receive the data&#xD;&#xA;        delay(3000);&#xD;&#xA;          // close the connection:&#xD;&#xA;          client.stop();&#xD;&#xA;          Serial.println(&quot;client disonnected&quot;);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void printWifiStatus() {&#xD;&#xA;      // print the SSID of the network you're attached to:&#xD;&#xA;      Serial.print(&quot;Baglandigimiz SSID: &quot;);&#xD;&#xA;      Serial.println(WiFi.SSID());&#xD;&#xA;    &#xD;&#xA;      // print your WiFi shield's IP address:&#xD;&#xA;      IPAddress ip = WiFi.localIP();&#xD;&#xA;      Serial.print(&quot;IP Addressi browserda ac: &quot;);&#xD;&#xA;      Serial.println(ip);&#xD;&#xA;    &#xD;&#xA;      // print the received signal strength:&#xD;&#xA;      long rssi = WiFi.RSSI();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/MFCwt.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/tH4Jq.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/vba5T.png" />
  <row Id="3725" PostHistoryTypeId="1" PostId="1305" RevisionGUID="3ff923b2-cb2b-4d2d-8d1c-2e451440f41a" CreationDate="2014-04-26T22:28:06.293" UserId="1006" Text="Arduino Mega &amp; WiFi Shield; why webserver everytime says my A7 pin reads 0V?" />
  <row Id="3726" PostHistoryTypeId="3" PostId="1305" RevisionGUID="3ff923b2-cb2b-4d2d-8d1c-2e451440f41a" CreationDate="2014-04-26T22:28:06.293" UserId="1006" Text="&lt;arduino-mega&gt;&lt;shields&gt;&lt;wifi&gt;&lt;web-server&gt;&lt;web-service&gt;" />
  <row Id="3727" PostHistoryTypeId="2" PostId="1306" RevisionGUID="6ad7c8dc-6019-4b91-a5ac-8daa711fb074" CreationDate="2014-04-26T22:38:22.607" UserId="368" Text="&lt;a href=&quot;https://github.com/damellis/attiny/&quot;&gt;attiny&lt;/a&gt; is missing an option required to allow the Manchester library to function properly on ATtinyX5 devices, specifically definition of `__AVR_ATtinyX5__` when a device is selected. In fact, it's missing quite a few things. &#xD;&#xA;&#xD;&#xA;The package I use for ATtinyX5 support is &lt;a href=&quot;http://code.google.com/p/arduino-tiny/&quot;&gt;arduino-tiny&lt;/a&gt;. I have verified that it defines that symbol properly. I recommend that you dump your current support package and install arduino-tiny instead." />
  <row Id="3728" PostHistoryTypeId="2" PostId="1307" RevisionGUID="236e179c-1953-444d-a481-2eb9796e51f2" CreationDate="2014-04-26T22:49:55.700" UserId="368" Text="The capacitor in the sample-and-hold circuit in the ADC frontend is tied to ground and it is *very* leaky. Unless you have a low or medium impedance output connected to it, you will always read the ground value. An antenna is a *very* high impedance device." />
  <row Id="3729" PostHistoryTypeId="2" PostId="1308" RevisionGUID="8ffbe2d9-bcbe-4e51-b59c-e29147df54e3" CreationDate="2014-04-27T01:38:18.417" UserId="1194" Text="Oh wow, so many ways you could do this.  To start, get an arduino with a wifi shield to transmit and read data.  Familiarize yourself with how the arduino works with the shield, and how to read it on the other end.  Then it's time to look at sensors you could use.  Here's a couple ideas, I would recommend using more than one and cross-checking:&#xD;&#xA;&#xD;&#xA; 1. Force sensor on base of chair: Can tell you how much weight is on a chair (Sparkfun SEN-09376)&#xD;&#xA; 2. IR or sonic sensor on back of chair to detect distance ([example][2])&#xD;&#xA; 3. Vibration/shock sensor to detect if someone has sit down ([example][3])&#xD;&#xA; 4. Load sensor: literally a scale in a sensor. (Sparkfun SEN-10245)&#xD;&#xA;&#xD;&#xA;The optimal solution if you had the cash would be to put all of them on the chair and use the arduino to compute all of the sensor values into one boolean.  However, if you only could have one sensor I would recommend the load sensor which would definitely be the most reliable of all the examples I gave.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [2]: https://www.sparkfun.com/products/242&#xD;&#xA;  [3]: https://www.sparkfun.com/products/9197&#xD;&#xA;" />
  <row Id="3730" PostHistoryTypeId="5" PostId="1305" RevisionGUID="48f62c63-56ee-4b4c-a492-6a9644c6549e" CreationDate="2014-04-27T09:45:40.227" UserId="756" Comment="blurred password" Text="I have got Arduino Mega 2560, Arduino WiFi Shield and resistor 1.5K. Now PWM 2 is attached to Res. then attached GND. 5V is attached between PWM2 and resistor's up point. I want to read Arduino Mega's A7 Analog Input point in order to print this value on Android Phone's web browser. But, I get zero value everytime surprisingly. It should be like 235, 350 something like integer or float kinds as usual. According to Android Phone's Google Chrome Web Browser Page, why there are too many zeros in the HTML? It should be different from zeros because I have already added a short wire to Analog A7 so as to make an antenna. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![My workside][1]&#xD;&#xA;![Android Phone Screen][2]&#xD;&#xA;![Arduino IDE &amp; Serial Monitor][3]&#xD;&#xA;   &#xD;&#xA;     &#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;WiFi.h&gt;&#xD;&#xA;    &#xD;&#xA;    char ssid[] = &quot;Connectify-me&quot;;     //  your network SSID (name) &#xD;&#xA;    char pass[] = &quot;**********&quot;;    // your network password&#xD;&#xA;    int status = WL_IDLE_STATUS;&#xD;&#xA;    float PPG = analogRead(A7);&#xD;&#xA;    boolean door_status = false;&#xD;&#xA;    WiFiServer server(80);&#xD;&#xA;    void setup() {&#xD;&#xA;    &#xD;&#xA;      // start serial port for debugging purposes&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      // Attach interrupt to pin 2&#xD;&#xA;      //attachInterrupt(0, setDoorStatus, RISING);&#xD;&#xA;      // attempt to connect to Wifi network:&#xD;&#xA;      while ( status != WL_CONNECTED) { &#xD;&#xA;        Serial.print(&quot;Yazdigin SSID araniyor: &quot;);&#xD;&#xA;        Serial.println(ssid);&#xD;&#xA;        status = WiFi.begin(ssid, pass);&#xD;&#xA;        // wait 10 seconds for connection:&#xD;&#xA;        delay(10000);&#xD;&#xA;      } &#xD;&#xA;      server.begin();&#xD;&#xA;      // you're connected now, so print out the status:&#xD;&#xA;      printWifiStatus();&#xD;&#xA;    }&#xD;&#xA;    void loop() {       &#xD;&#xA;      // listen for incoming clients&#xD;&#xA;      WiFiClient client = server.available();&#xD;&#xA;      if (client) {&#xD;&#xA;        Serial.println(&quot;Deger gonderildi&quot;);&#xD;&#xA;        Serial.print(PPG);&#xD;&#xA;        // an http request ends with a blank line&#xD;&#xA;        boolean currentLineIsBlank = true;&#xD;&#xA;        while (client.connected() &amp; client.available()) {&#xD;&#xA;            // client.println(&quot;HTTP/1.1 200 OK&quot;);&#xD;&#xA;             //client.println(&quot;Content-Type: text/html&quot;);&#xD;&#xA;             // client.println(&quot;&lt;!DOCTYPE HTML&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;html&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;body&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;meta http-equiv=\&quot;refresh\&quot; content=\&quot;1\&quot;&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;li&gt;&quot;);&#xD;&#xA;              client.print(PPG);  //The value should different from zeros&#xD;&#xA;              client.println(&quot;&lt;/li&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;/body&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;/html&gt;&quot;);&#xD;&#xA;    &#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;        // give the web browser time to receive the data&#xD;&#xA;        delay(3000);&#xD;&#xA;          // close the connection:&#xD;&#xA;          client.stop();&#xD;&#xA;          Serial.println(&quot;client disonnected&quot;);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void printWifiStatus() {&#xD;&#xA;      // print the SSID of the network you're attached to:&#xD;&#xA;      Serial.print(&quot;Baglandigimiz SSID: &quot;);&#xD;&#xA;      Serial.println(WiFi.SSID());&#xD;&#xA;    &#xD;&#xA;      // print your WiFi shield's IP address:&#xD;&#xA;      IPAddress ip = WiFi.localIP();&#xD;&#xA;      Serial.print(&quot;IP Addressi browserda ac: &quot;);&#xD;&#xA;      Serial.println(ip);&#xD;&#xA;    &#xD;&#xA;      // print the received signal strength:&#xD;&#xA;      long rssi = WiFi.RSSI();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/MFCwt.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/tH4Jq.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/vba5T.png" />
  <row Id="3731" PostHistoryTypeId="24" PostId="1305" RevisionGUID="48f62c63-56ee-4b4c-a492-6a9644c6549e" CreationDate="2014-04-27T09:45:40.227" Comment="Proposed by 756 approved by -1 edit id of 291" />
  <row Id="3732" PostHistoryTypeId="5" PostId="1305" RevisionGUID="6ad9013c-e74b-467d-8a6e-cf2321463f0c" CreationDate="2014-04-27T09:45:40.227" UserId="1006" Comment="blurred password" Text="I have got Arduino Mega 2560, Arduino WiFi Shield and resistor 1.5K. Now PWM 2 is attached to Res. then attached GND. 5V is attached between PWM2 and resistor's up point. I want to read Arduino Mega's A7 Analog Input point in order to print this value on Android Phone's web browser. But, I get zero value everytime surprisingly. It should be like 235, 350 something like integer or float kinds as usual. According to Android Phone's Google Chrome Web Browser Page, why there are too many zeros in the HTML? It should be different from zeros because I have already added a short wire to Analog A7 so as to make an antenna. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![My workside][1]&#xD;&#xA;![Android Phone Screen][2]&#xD;&#xA;![Arduino IDE &amp; Serial Monitor][3]&#xD;&#xA;   &#xD;&#xA;     &#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;WiFi.h&gt;&#xD;&#xA;    &#xD;&#xA;    char ssid[] = &quot;Connectify-me&quot;;     //  your network SSID (name) &#xD;&#xA;    char pass[] = &quot;***&quot;;    // your network password whatever it is&#xD;&#xA;    int status = WL_IDLE_STATUS;&#xD;&#xA;    float PPG = analogRead(A7);&#xD;&#xA;    boolean door_status = false;&#xD;&#xA;    WiFiServer server(80);&#xD;&#xA;    void setup() {&#xD;&#xA;    &#xD;&#xA;      // start serial port for debugging purposes&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      // Attach interrupt to pin 2&#xD;&#xA;      //attachInterrupt(0, setDoorStatus, RISING);&#xD;&#xA;      // attempt to connect to Wifi network:&#xD;&#xA;      while ( status != WL_CONNECTED) { &#xD;&#xA;        Serial.print(&quot;Yazdigin SSID araniyor: &quot;);&#xD;&#xA;        Serial.println(ssid);&#xD;&#xA;        status = WiFi.begin(ssid, pass);&#xD;&#xA;        // wait 10 seconds for connection:&#xD;&#xA;        delay(10000);&#xD;&#xA;      } &#xD;&#xA;      server.begin();&#xD;&#xA;      // you're connected now, so print out the status:&#xD;&#xA;      printWifiStatus();&#xD;&#xA;    }&#xD;&#xA;    void loop() {       &#xD;&#xA;      // listen for incoming clients&#xD;&#xA;      WiFiClient client = server.available();&#xD;&#xA;      if (client) {&#xD;&#xA;        Serial.println(&quot;Deger gonderildi&quot;);&#xD;&#xA;        Serial.print(PPG);&#xD;&#xA;        // an http request ends with a blank line&#xD;&#xA;        boolean currentLineIsBlank = true;&#xD;&#xA;        while (client.connected() &amp; client.available()) {&#xD;&#xA;            // client.println(&quot;HTTP/1.1 200 OK&quot;);&#xD;&#xA;             //client.println(&quot;Content-Type: text/html&quot;);&#xD;&#xA;             // client.println(&quot;&lt;!DOCTYPE HTML&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;html&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;body&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;meta http-equiv=\&quot;refresh\&quot; content=\&quot;1\&quot;&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;li&gt;&quot;);&#xD;&#xA;              client.print(PPG);  //The value should different from zeros&#xD;&#xA;              client.println(&quot;&lt;/li&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;/body&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;/html&gt;&quot;);&#xD;&#xA;    &#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;        // give the web browser time to receive the data&#xD;&#xA;        delay(3000);&#xD;&#xA;          // close the connection:&#xD;&#xA;          client.stop();&#xD;&#xA;          Serial.println(&quot;client disonnected&quot;);&#xD;&#xA;      }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void printWifiStatus() {&#xD;&#xA;      // print the SSID of the network you're attached to:&#xD;&#xA;      Serial.print(&quot;Baglandigimiz SSID: &quot;);&#xD;&#xA;      Serial.println(WiFi.SSID());&#xD;&#xA;    &#xD;&#xA;      // print your WiFi shield's IP address:&#xD;&#xA;      IPAddress ip = WiFi.localIP();&#xD;&#xA;      Serial.print(&quot;IP Addressi browserda ac: &quot;);&#xD;&#xA;      Serial.println(ip);&#xD;&#xA;    &#xD;&#xA;      // print the received signal strength:&#xD;&#xA;      long rssi = WiFi.RSSI();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/MFCwt.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/tH4Jq.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/vba5T.png" />
  <row Id="3733" PostHistoryTypeId="2" PostId="1309" RevisionGUID="acb69c05-5a06-44d7-a4a7-502728497961" CreationDate="2014-04-27T10:39:30.683" UserId="1197" Text="Is it possible to cinnect the Arduino with a fischertechnik TX Controller? Maybe with I²C, but i want to use I²C for something else on the arduino. So are there multiple I²C Ports on the Arduino (I haven't got one yet)?" />
  <row Id="3734" PostHistoryTypeId="1" PostId="1309" RevisionGUID="acb69c05-5a06-44d7-a4a7-502728497961" CreationDate="2014-04-27T10:39:30.683" UserId="1197" Text="Connect Arduino with fischertechnik TX Controller" />
  <row Id="3735" PostHistoryTypeId="3" PostId="1309" RevisionGUID="acb69c05-5a06-44d7-a4a7-502728497961" CreationDate="2014-04-27T10:39:30.683" UserId="1197" Text="&lt;robotics&gt;&lt;i2c&gt;" />
  <row Id="3736" PostHistoryTypeId="2" PostId="1310" RevisionGUID="a4689255-a642-488e-ba37-fb77317b65ff" CreationDate="2014-04-27T11:17:30.260" UserId="84" Text="As described in the [Wire library][1] that brings supports I²C support to Arduino, except for the **DUE** that has 2 pairs of pins for 2 I²C buses, **other Arduino boards support one I²C connection**.&#xD;&#xA;&#xD;&#xA;However, this is when you want to use hardware facilities of ATMEL chips that these limitations apply; there is a [software I²C library][2] exists that allows using other pins for I²C. One major drawback, though, is that it is very slow; not sure if this is a problem in your situation.&#xD;&#xA;&#xD;&#xA;One important thing though: the principle of I²C is to be able to plug several slave devices (more than 100) to one master device. In general, Arduino is the master device, but the Wire library can be used as master or slave. Wouldn't that fit your requirements?&#xD;&#xA;&#xD;&#xA;In this situation, you could just use the same I²C bus for everything, including connection to Fischertechnik TX controller.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Reference/Wire&#xD;&#xA;  [2]: http://playground.arduino.cc/Main/SoftwareI2CLibrary" />
  <row Id="3737" PostHistoryTypeId="2" PostId="1311" RevisionGUID="8f13554f-aa1c-4fe9-a462-64686ad48809" CreationDate="2014-04-27T16:19:01.773" UserId="83" Text="You are reading the input pin `float PPG = analogRead(A7);` only in the startup code of your program. Move that into the loop to have it updated before using it." />
  <row Id="3738" PostHistoryTypeId="12" PostId="1307" RevisionGUID="0058b70c-62d4-4548-ad5a-e8f5d160cdc2" CreationDate="2014-04-27T16:38:43.153" UserId="368" Comment="via Vote" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:368,&quot;DisplayName&quot;:&quot;Ignacio Vazquez-Abrams&quot;}]}" />
  <row Id="3739" PostHistoryTypeId="2" PostId="1312" RevisionGUID="e4c21229-2199-4a89-9341-636d69732d7d" CreationDate="2014-04-27T17:35:01.970" UserId="1200" Text="I have started to play with and arduino UNO quite recently (without any prior experience with micro-controllers). I would like to use emacs instead of the IDE, and I'd also like to know what the IDE does under the hood, in order to be able to write my own makefile. The tutorials I've found are either outdated, or are presented as a series of steps without any explanation. I'd appreciate it if someone could explain to me how the whole compliation/linking/upload process works using gcc-avr and avr-dude, and how it is used by the IDE." />
  <row Id="3740" PostHistoryTypeId="1" PostId="1312" RevisionGUID="e4c21229-2199-4a89-9341-636d69732d7d" CreationDate="2014-04-27T17:35:01.970" UserId="1200" Text="not using the IDE and understanding the compilation/linking/upload process" />
  <row Id="3741" PostHistoryTypeId="3" PostId="1312" RevisionGUID="e4c21229-2199-4a89-9341-636d69732d7d" CreationDate="2014-04-27T17:35:01.970" UserId="1200" Text="&lt;ide&gt;&lt;avrdude&gt;" />
  <row Id="3742" PostHistoryTypeId="5" PostId="1305" RevisionGUID="76065efa-0aba-420c-9f33-7a7003957d4f" CreationDate="2014-04-27T17:41:37.100" UserId="1006" Comment="I have shorten the codes" Text="I have got Arduino Mega 2560, Arduino WiFi Shield and resistor 1.5K. Now PWM 2 is attached to Res. then attached GND. 5V is attached between PWM2 and resistor's up point. I want to read Arduino Mega's A7 Analog Input point in order to print this value on Android Phone's web browser. But, I get zero value everytime surprisingly. It should be like 235, 350 something like integer or float kinds as usual. According to Android Phone's Google Chrome Web Browser Page, why there are too many zeros in the HTML? It should be different from zeros because I have already added a short wire to Analog A7 so as to make an antenna. &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![My workside][1]&#xD;&#xA;![Android Phone Screen][2]&#xD;&#xA;![Arduino IDE &amp; Serial Monitor][3]&#xD;&#xA;   &#xD;&#xA;     &#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;WiFi.h&gt;&#xD;&#xA;    &#xD;&#xA;    char ssid[] = &quot;Connectify-me&quot;;      &#xD;&#xA;    char pass[] = &quot;***&quot;;    &#xD;&#xA;    int status = WL_IDLE_STATUS;&#xD;&#xA;    float PPG = analogRead(A7);&#xD;&#xA;    boolean door_status = false;&#xD;&#xA;    WiFiServer server(80);&#xD;&#xA;    void setup() {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      while ( status != WL_CONNECTED) { &#xD;&#xA;        Serial.print(&quot;Yazdigin SSID araniyor: &quot;);&#xD;&#xA;        Serial.println(ssid);&#xD;&#xA;        status = WiFi.begin(ssid, pass);&#xD;&#xA;        delay(10000);&#xD;&#xA;      } &#xD;&#xA;      server.begin();&#xD;&#xA;      printWifiStatus();&#xD;&#xA;    }&#xD;&#xA;    void loop() {       &#xD;&#xA;      WiFiClient client = server.available();&#xD;&#xA;      if (client) {&#xD;&#xA;        Serial.println(&quot;Deger gonderildi&quot;);&#xD;&#xA;        Serial.print(PPG);&#xD;&#xA;        while (client.connected() &amp; client.available()) {&#xD;&#xA;              client.println(&quot;&lt;html&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;body&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;li&gt;&quot;);&#xD;&#xA;              client.print(PPG);  //The value should different from zeros but everytime 0&#xD;&#xA;              client.println(&quot;&lt;/li&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;br /&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;/body&gt;&quot;);&#xD;&#xA;              client.println(&quot;&lt;/html&gt;&quot;);&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;        delay(3000);&#xD;&#xA;          client.stop();&#xD;&#xA;          Serial.println(&quot;client disonnected&quot;);&#xD;&#xA;      }&#xD;&#xA;      void printWifiStatus() {&#xD;&#xA;      Serial.print(&quot;Baglandigimiz SSID: &quot;);&#xD;&#xA;      Serial.println(WiFi.SSID());&#xD;&#xA;      IPAddress ip = WiFi.localIP();&#xD;&#xA;      Serial.print(&quot;IP Addressi browserda ac: &quot;);&#xD;&#xA;      Serial.println(ip);&#xD;&#xA;      long rssi = WiFi.RSSI();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/MFCwt.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/tH4Jq.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/vba5T.png" />
  <row Id="3743" PostHistoryTypeId="2" PostId="1313" RevisionGUID="492ac0ad-fd0e-446f-8b25-ec51e382bbf3" CreationDate="2014-04-27T17:53:51.597" UserId="368" Text="If you want an *exact* duplication of what the IDE does but want it driven from the command line, that's what &lt;a href=&quot;http://inotool.org/&quot;&gt;Ino&lt;/a&gt; is for. The full Arduino build process involves copying a lot of files from a lot of places, and is generally not trivial to duplicate.&#xD;&#xA;&#xD;&#xA;If you're ready to let go of .ino files and the Arduino libraries, you get a much simpler toolset. avr-gcc compiles, avrdude uploads, and you're done. Here's one of my makefiles from a simple project:&#xD;&#xA;&#xD;&#xA;    CC=avr-gcc&#xD;&#xA;    CXX=avr-c++&#xD;&#xA;    CXXFLAGS=-Wall -Wextra -mmcu=atmega1284p -Os&#xD;&#xA;    CFLAGS=$(CXXFLAGS)&#xD;&#xA;    BINARY=ledmatrix&#xD;&#xA;    OBJECTS=&#xD;&#xA;    &#xD;&#xA;    all: $(BINARY)&#xD;&#xA;    ↹@avr-size $&lt;&#xD;&#xA;    &#xD;&#xA;    $(BINARY): $(OBJECTS)&#xD;&#xA;    &#xD;&#xA;    clean:&#xD;&#xA;    ↹@rm -f $(BINARY) $(BINARY).hex $(OBJECTS)&#xD;&#xA;    &#xD;&#xA;    upload: $(BINARY).hex&#xD;&#xA;    ↹@avrdude -c usbasp -p m1284p -U flash:w:$&lt;:i&#xD;&#xA;        &#xD;&#xA;    %.hex: %&#xD;&#xA;    ↹@avr-objcopy -j .text -j .data -O ihex $&lt; $@&#xD;&#xA;    &#xD;&#xA;    .PHONY: all clean upload fuses&#xD;&#xA;&#xD;&#xA;If copying-and-pasting, be sure to replace all &quot;↹&quot; with tab characters.&#xD;&#xA;" />
  <row Id="3744" PostHistoryTypeId="13" PostId="1307" RevisionGUID="d6d6163d-00ad-4de5-b834-eaf13fd8fe5d" CreationDate="2014-04-27T17:59:06.653" UserId="368" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:368,&quot;DisplayName&quot;:&quot;Ignacio Vazquez-Abrams&quot;}]}" />
  <row Id="3745" PostHistoryTypeId="2" PostId="1314" RevisionGUID="d275fb87-f9a7-474b-b395-9eb88e68525e" CreationDate="2014-04-27T19:12:11.227" UserId="1202" Text="I'm working on building my first robot—indeed, this is my first foray into DIY electronics.  I already have a Arduino uno, and I have ordered the [Tamiya double gearbox][1] here. My goal is to control the gearbox to move the robot, but from what I've already read, I need to have something between the ardunio and the motors. It seems like people have trouble doing that because the included motors are low voltage, so the Ardunio motor shield won't easily work.  &#xD;&#xA;&#xD;&#xA;I'm looking for a clear solution to making this thing run, in the simplest way possible. One thing I'm considering is replacing the motors in the gearbox [with these motors][3]. If I do that, am I right in thinking I could run them from the arduino motor shield? &#xD;&#xA;&#xD;&#xA;If there is a simpler (or cheaper!) way of making it work than being stuck on the Arduino Motor shield, I'm game for that—I've just gravitated to that solution because it seems simpler as an electronics noob. (I haven't bought that shield yet.) But I'm really open to other solutions, so if you can, I'd appreciate the advice!  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.pololu.com/product/114&#xD;&#xA;  [3]: http://www.amazon.com/dp/B00JR6IY4M/ref=wl_it_dp_o_pC_S_ttl?_encoding=UTF8&amp;colid=FUN60MOL7TVV&amp;coliid=I4943V9GBF96U" />
  <row Id="3746" PostHistoryTypeId="1" PostId="1314" RevisionGUID="d275fb87-f9a7-474b-b395-9eb88e68525e" CreationDate="2014-04-27T19:12:11.227" UserId="1202" Text="How can I connect the Tamiya double gearbox to Ardunio uno?" />
  <row Id="3747" PostHistoryTypeId="3" PostId="1314" RevisionGUID="d275fb87-f9a7-474b-b395-9eb88e68525e" CreationDate="2014-04-27T19:12:11.227" UserId="1202" Text="&lt;arduino-uno&gt;&lt;shields&gt;&lt;motor&gt;" />
  <row Id="3748" PostHistoryTypeId="5" PostId="1313" RevisionGUID="543ec55d-2069-4745-ab0c-1ce3140ace54" CreationDate="2014-04-27T19:25:20.953" UserId="368" Comment="deleted 6 characters in body" Text="If you want an *exact* duplication of what the IDE does but want it driven from the command line, that's what &lt;a href=&quot;http://inotool.org/&quot;&gt;Ino&lt;/a&gt; is for. The full Arduino build process involves copying a lot of files from a lot of places, and is generally not trivial to duplicate.&#xD;&#xA;&#xD;&#xA;If you're ready to let go of .ino files and the Arduino libraries, you get a much simpler toolset. avr-gcc compiles, avrdude uploads, and you're done. Here's one of my makefiles from a simple project:&#xD;&#xA;&#xD;&#xA;    CC=avr-gcc&#xD;&#xA;    CXX=avr-c++&#xD;&#xA;    CXXFLAGS=-Wall -Wextra -mmcu=atmega1284p -Os&#xD;&#xA;    CFLAGS=$(CXXFLAGS)&#xD;&#xA;    BINARY=ledmatrix&#xD;&#xA;    OBJECTS=&#xD;&#xA;    &#xD;&#xA;    all: $(BINARY)&#xD;&#xA;    ↹@avr-size $&lt;&#xD;&#xA;    &#xD;&#xA;    $(BINARY): $(OBJECTS)&#xD;&#xA;    &#xD;&#xA;    clean:&#xD;&#xA;    ↹@rm -f $(BINARY) $(BINARY).hex $(OBJECTS)&#xD;&#xA;    &#xD;&#xA;    upload: $(BINARY).hex&#xD;&#xA;    ↹@avrdude -c usbasp -p m1284p -U flash:w:$&lt;:i&#xD;&#xA;        &#xD;&#xA;    %.hex: %&#xD;&#xA;    ↹@avr-objcopy -j .text -j .data -O ihex $&lt; $@&#xD;&#xA;    &#xD;&#xA;    .PHONY: all clean upload&#xD;&#xA;&#xD;&#xA;If copying-and-pasting, be sure to replace all &quot;↹&quot; with tab characters.&#xD;&#xA;" />
  <row Id="3749" PostHistoryTypeId="6" PostId="1314" RevisionGUID="743235af-3108-4eef-9d7f-b4eef9bace6c" CreationDate="2014-04-27T19:26:46.407" UserId="220" Comment="edited tags" Text="&lt;arduino-uno&gt;&lt;shields&gt;&lt;motor&gt;&lt;arduino-motor-shield&gt;" />
  <row Id="3750" PostHistoryTypeId="2" PostId="1315" RevisionGUID="b11fdda6-633d-4f74-8880-f896524a0b68" CreationDate="2014-04-27T19:47:05.840" UserId="220" Text="Here's what I've found about both the motor shield and the motors:&#xD;&#xA;&#xD;&#xA; - Motors are 3-6V and will use a lot of amperage. **This may be a problem with a mobile robot.** You'll have to figure out a power source that can provide 4+ amps... on battery power that's a lot. Personally, I would go with a continuous rotation servo for a compact, light robot.&#xD;&#xA; - Motor sheild can provide 2x 2A channels at 5-12 V ([Source](http://www.makershed.com/Official_Arduino_Motor_Shield_p/mksp12.htm?gclid=CIyNjIKygb4CFe5aMgodpQcAuw)) using the two `+` and `-` terminals on the bottom left side of the shield. You must connect external power, because USB can't provide enough power. I can't find if the motor shield will limit current if it goes over, but if you do use the gearbox, I'd recommend another route for control that's 1/6rd the price.&#xD;&#xA;&#xD;&#xA;[This chip was recommended by Pololu on the product page.](http://www.pololu.com/product/2130)&#xD;&#xA;&#xD;&#xA;![][1]&#xD;&#xA;&#xD;&#xA;**Time to whip out your soldering iron!** Really, soldering is a great investment and you'll get to a point soon where you'll *need* one; there will be no other alternative. Luck for you, you only have to solder 16 joints. Headers are included.&#xD;&#xA;&#xD;&#xA;Diagrams from Pololu's site:&#xD;&#xA;&#xD;&#xA;&gt;![][2]&#xD;&#xA;&#xD;&#xA;&gt;![][3]&#xD;&#xA;&#xD;&#xA;&gt;&lt;a href=&quot;http://i.stack.imgur.com/DyuR1.png&quot;&gt;![][4]&lt;/a&gt;&#xD;&#xA;*(Click to enlarge ^^^)**&#xD;&#xA;&#xD;&#xA;&lt;sub&gt;*I added a little text to this image.&lt;/sub&gt;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/adDy1.jpg&#xD;&#xA;  [2]: http://i.stack.imgur.com/t7iEx.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/vwiM4.jpg&#xD;&#xA;  [4]: http://i.stack.imgur.com/DyuR1.png" />
  <row Id="3755" PostHistoryTypeId="2" PostId="1317" RevisionGUID="c6bfa0e6-a20d-4f05-9cb3-c566632578b3" CreationDate="2014-04-28T01:47:42.227" UserId="1210" Text="My project sends temperature sensor data to a phone using GSM module 900. But also on receiving some specific command from a number it switches ON or OFF some pins(see the 'fan()' function). The problem is that when I don't connect my GSM Module to Arduino, it works perfectly fine. but when I connect it to the module, it doesnt work properly. I guess its due to data coming from Module other than the command I sent is causing trouble. Please tell me how to filter out the data. Here is the code :&#xD;&#xA;&#xD;&#xA;    double tempD,tempA;&#xD;&#xA;    char inchar;&#xD;&#xA;    long prevtime=0;&#xD;&#xA;    ////////////////////////////////////////////////////////&#xD;&#xA;    void setup()&#xD;&#xA;    { &#xD;&#xA;      Serial.begin(9600);  &#xD;&#xA;      pinMode(12, OUTPUT);&#xD;&#xA;      pinMode(11, OUTPUT);&#xD;&#xA;      Serial.println(&quot;AT+CSMS=1\r&quot;); &#xD;&#xA;     delay(200);&#xD;&#xA;      Serial.print(&quot;AT+CNMI=2,2,0,0,0&quot;); &#xD;&#xA;      delay(300);&#xD;&#xA;      Serial.print('\n');&#xD;&#xA;      delay(1000);&#xD;&#xA;    }&#xD;&#xA;    /////////////////////////////////////////////////////////&#xD;&#xA;    /////////////////////////////////////////////////////////&#xD;&#xA;    void loop()&#xD;&#xA;    { unsigned long time = millis();&#xD;&#xA;     if(time-prevtime&gt;100000)&#xD;&#xA;     { prevtime=time;&#xD;&#xA;       message();&#xD;&#xA;     }&#xD;&#xA;    fan();&#xD;&#xA;    delay(500);&#xD;&#xA;    }&#xD;&#xA;    /////////////////////////////////////////////////////////&#xD;&#xA;      void message()&#xD;&#xA;    { temperature();&#xD;&#xA;      Serial.print(&quot;\r&quot;);&#xD;&#xA;      delay(1000);                  &#xD;&#xA;      Serial.print(&quot;AT+CMGF=1\r&quot;);    &#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.print(&quot;AT+CMGS=\&quot;+917709777239\&quot;\r&quot;);&#xD;&#xA;      delay(1000);&#xD;&#xA;      Serial.println('\r');&#xD;&#xA;      Serial.print(&quot;\n&quot;);&#xD;&#xA;      Serial.print(&quot;Temperature=&quot;);&#xD;&#xA;      Serial.println(tempD);&#xD;&#xA;      Serial.print('\r');&#xD;&#xA;      Serial.print(&quot;---REPLY---&quot;);&#xD;&#xA;      Serial.print('\n');&#xD;&#xA;      Serial.print(&quot;'1' for FAN ON, Motor ON&quot;);&#xD;&#xA;         Serial.print('\n');&#xD;&#xA;         Serial.print(&quot;'2' for FAN ON, Motor OFF&quot;);&#xD;&#xA;         Serial.print('\n');&#xD;&#xA;         Serial.print(&quot;'3' for FAN OFF, Motor ON&quot;);&#xD;&#xA;         Serial.print('\n');&#xD;&#xA;         Serial.print(&quot;'0' for FAN OFF, Motor OFF&quot;);&#xD;&#xA;         Serial.print('\n');&#xD;&#xA;      delay(800);&#xD;&#xA;      Serial.write(0x1A);&#xD;&#xA;    }&#xD;&#xA;    //////////////////////////////////////////////////////////////////&#xD;&#xA;    void fan()&#xD;&#xA;    {  &#xD;&#xA;       if(Serial.available()&gt;0)&#xD;&#xA;      {  inchar=Serial.read(); &#xD;&#xA;        if (inchar=='1')&#xD;&#xA;        {&#xD;&#xA;          digitalWrite(12, HIGH);&#xD;&#xA;          delay(500);&#xD;&#xA;          digitalWrite(13,HIGH);&#xD;&#xA;         }&#xD;&#xA;        else if (inchar=='2')&#xD;&#xA;         {&#xD;&#xA;         digitalWrite(12, HIGH);&#xD;&#xA;          delay(500);&#xD;&#xA;         digitalWrite(13, LOW);&#xD;&#xA;        }&#xD;&#xA;         else if (inchar=='3')&#xD;&#xA;         {&#xD;&#xA;          digitalWrite(12, LOW);&#xD;&#xA;          delay(500);&#xD;&#xA;         digitalWrite(13, HIGH);&#xD;&#xA;        }&#xD;&#xA;         else if (inchar=='0')&#xD;&#xA;         { digitalWrite(12, LOW);&#xD;&#xA;          delay(500);&#xD;&#xA;         digitalWrite(13, LOW);&#xD;&#xA;        }&#xD;&#xA;        else if (inchar=='M' || inchar=='m')&#xD;&#xA;        {&#xD;&#xA;          message();&#xD;&#xA;        }&#xD;&#xA;       Serial.println(&quot;AT+CMGR=1\r&quot;);&#xD;&#xA;      delay(2000);&#xD;&#xA;    }&#xD;&#xA;    }&#xD;&#xA;    ////////////////////////////////////////////////////////////////////////////////////////////&#xD;&#xA;    double temperature()&#xD;&#xA;    {&#xD;&#xA;      tempA=analogRead(A0);&#xD;&#xA;      tempD = (5.0 *tempA * 100.0) / 1023;&#xD;&#xA;      return tempD;  &#xD;&#xA;    }" />
  <row Id="3756" PostHistoryTypeId="1" PostId="1317" RevisionGUID="c6bfa0e6-a20d-4f05-9cb3-c566632578b3" CreationDate="2014-04-28T01:47:42.227" UserId="1210" Text="Arduino Serial Communication code problem" />
  <row Id="3757" PostHistoryTypeId="3" PostId="1317" RevisionGUID="c6bfa0e6-a20d-4f05-9cb3-c566632578b3" CreationDate="2014-04-28T01:47:42.227" UserId="1210" Text="&lt;arduino-uno&gt;&lt;serial&gt;&lt;gsm&gt;" />
  <row Id="3758" PostHistoryTypeId="36" PostId="1318" RevisionGUID="52334a1b-5661-4f01-883c-0420176e4a2b" CreationDate="2014-04-28T02:34:34.537" UserId="-1" Comment="from http://electronics.stackexchange.com/questions/108191/level-detection-of-3-3v-from-5v-arduino" />
  <row Id="3759" PostHistoryTypeId="2" PostId="1318" RevisionGUID="18af76c5-1506-4863-a8b9-a38be45a1e15" CreationDate="2014-04-28T02:18:55.963" UserId="1213" UserDisplayName="David Norman" Text="A quick question about microcontroller digital level on I/O pins. I have a photo interrupter which is powered at 3.3V which is interfaced to Arduino UNO running at 5V.&#xD;&#xA;&#xD;&#xA;For microcontroller to detect high or low level is determined by signal higher than 5V*(2/3) = 3.33V is high and signal lower than 5V*(1/3) is low. What I don't understand is that arduino is able to detect the level change from the photo interrupter. Doesn't the supply on pins have to be greater than (2/3) or Vcc in order for it to detect logic high? The circuit works and I am able to count pulses from the interrupter but I want to know why that works considering the photo interrupt only gets about 3.23V.&#xD;&#xA;&#xD;&#xA;Please clarify" />
  <row Id="3760" PostHistoryTypeId="1" PostId="1318" RevisionGUID="18af76c5-1506-4863-a8b9-a38be45a1e15" CreationDate="2014-04-28T02:18:55.963" UserId="1213" UserDisplayName="David Norman" Text="Level detection of 3.3V from 5V arduino" />
  <row Id="3761" PostHistoryTypeId="3" PostId="1318" RevisionGUID="18af76c5-1506-4863-a8b9-a38be45a1e15" CreationDate="2014-04-28T02:18:55.963" UserId="1213" UserDisplayName="David Norman" Text="&lt;untagged&gt;" />
  <row Id="3762" PostHistoryTypeId="2" PostId="1319" RevisionGUID="9e790227-501a-49bf-8a58-de4069e75a44" CreationDate="2014-04-28T02:39:11.007" UserId="368" Text="You've... misread the datasheet. The '328 input high voltage (V&lt;sub&gt;IH&lt;/sub&gt;) for most pins is 0.6V&lt;sub&gt;CC&lt;/sub&gt; minimum for devices with a 2.4-5.5V supply. This means that a 5V device has a 3V threshold." />
  <row Id="3764" PostHistoryTypeId="2" PostId="1321" RevisionGUID="87de2f3f-94fe-4460-b2ab-57fe62bb5854" CreationDate="2014-04-28T05:27:02.187" UserId="1215" Text="I have an Arduino Uno R3 board and after some time not in use it seems to have corrupted. My code is below, basically I want to rotate a servo 90 degrees every 12 hours but as soon as I plug it in the servo starts rotating non-stop. Have tried multiple delay steps and shortening and lengthening the write but the same effect happens.&#xD;&#xA;&#xD;&#xA;    #include &lt;Servo.h&gt;&#xD;&#xA;&#xD;&#xA;    Servo myservo;&#xD;&#xA;&#xD;&#xA;    void setup {&#xD;&#xA;&#xD;&#xA;      myservo.attach(10);&#xD;&#xA;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;&#xD;&#xA;    {&#xD;&#xA;&#xD;&#xA;      myservo.write(90); &#xD;&#xA;&#xD;&#xA;      delay(3600000);&#xD;&#xA;&#xD;&#xA;    }" />
  <row Id="3765" PostHistoryTypeId="1" PostId="1321" RevisionGUID="87de2f3f-94fe-4460-b2ab-57fe62bb5854" CreationDate="2014-04-28T05:27:02.187" UserId="1215" Text="Servo won't stop rotating" />
  <row Id="3766" PostHistoryTypeId="3" PostId="1321" RevisionGUID="87de2f3f-94fe-4460-b2ab-57fe62bb5854" CreationDate="2014-04-28T05:27:02.187" UserId="1215" Text="&lt;arduino-uno&gt;" />
  <row Id="3768" PostHistoryTypeId="6" PostId="1318" RevisionGUID="e8e883f3-622f-44bc-b9b6-233a42e83b64" CreationDate="2014-04-28T07:46:55.523" UserId="1162" Comment="added some tags" Text="&lt;voltage-level&gt;" />
  <row Id="3769" PostHistoryTypeId="24" PostId="1318" RevisionGUID="e8e883f3-622f-44bc-b9b6-233a42e83b64" CreationDate="2014-04-28T07:46:55.523" Comment="Proposed by 1162 approved by 83, 1213 edit id of 292" />
  <row Id="3772" PostHistoryTypeId="2" PostId="1322" RevisionGUID="875f93c4-3ec2-445d-8dcc-4a4f61d57b74" CreationDate="2014-04-28T08:52:37.410" UserId="1219" Text="Your code includes the duration of the output in subsequent measurements. Thus depending on the length of the output you will measure different times. This can be fixed by formating to fixed length output.&#xD;&#xA;&#xD;&#xA;The next issue is that the UNO has a very poor timebase. Have a look here for a [comparison of different Arduino types vs. the DCF77 time reference.][1]&#xD;&#xA;&#xD;&#xA;Conclusion: if you need precise timing either get an Arduino with crystal or go for an RTC. I can highly recommend DS3231 / DS3232 RTCs since these usually achieve 2 ppm accuracy out of the box.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://blog.blinkenlight.net/experiments/dcf77/dcf77-scope/" />
  <row Id="3773" PostHistoryTypeId="2" PostId="1323" RevisionGUID="e937ea5c-5068-4379-93ed-e96ec6c357bf" CreationDate="2014-04-28T09:51:39.767" UserId="1220" Text="I'm trying to implement a card reader (i.e. credit cards) for shopping purposes, and AFAIK those cards are ISO 14443-A compliant (Mifare Classic 1K). I already made an Android app that can send custom APDU to read specific sectors by using raw SendBytes().&#xD;&#xA;&#xD;&#xA;Since I need to build a circuit with a custom antenna, I chose Arduino-uno with a NFC module (was thinking about StrongLink SL013), I wanted to know if it's possible to send raw bytes and receive the response from the tag. I only found some higher-level implementation (readSector, writeSector and so on).&#xD;&#xA;&#xD;&#xA;Thanks in advance.&#xD;&#xA;Mattia" />
  <row Id="3774" PostHistoryTypeId="1" PostId="1323" RevisionGUID="e937ea5c-5068-4379-93ed-e96ec6c357bf" CreationDate="2014-04-28T09:51:39.767" UserId="1220" Text="RFID/NFC (13.56 MHz), is it possible to send raw bytes and receive response?" />
  <row Id="3775" PostHistoryTypeId="3" PostId="1323" RevisionGUID="e937ea5c-5068-4379-93ed-e96ec6c357bf" CreationDate="2014-04-28T09:51:39.767" UserId="1220" Text="&lt;arduino-uno&gt;" />
  <row Id="3776" PostHistoryTypeId="5" PostId="1321" RevisionGUID="a3738870-500e-4cc2-b812-e24f8a9f486b" CreationDate="2014-04-28T11:48:25.710" UserId="46" Comment="Removed blank lines from code, just to tidy it up." Text="I have an Arduino Uno R3 board and after some time not in use it seems to have corrupted. My code is below, basically I want to rotate a servo 90 degrees every 12 hours but as soon as I plug it in the servo starts rotating non-stop. Have tried multiple delay steps and shortening and lengthening the write but the same effect happens.&#xD;&#xA;&#xD;&#xA;    #include &lt;Servo.h&gt;&#xD;&#xA;&#xD;&#xA;    Servo myservo;&#xD;&#xA;&#xD;&#xA;    void setup {&#xD;&#xA;      myservo.attach(10);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      myservo.write(90); &#xD;&#xA;      delay(3600000);&#xD;&#xA;    }&#xD;&#xA;" />
  <row Id="3777" PostHistoryTypeId="5" PostId="1323" RevisionGUID="c8f742fb-a4ff-491b-ae65-997a701c0880" CreationDate="2014-04-28T11:51:07.023" UserId="46" Comment="Welcome new user! I have edited your question (which, for our standards was already great!) so it follows our site standards a little closer. I've removed the thankyou line as we show appreciation by upvoting and accepting answers. I've removed the signature as the site stamps it on the bottom-right" Text="I'm trying to implement a card reader (i.e. credit cards) for shopping purposes, and AFAIK those cards are ISO 14443-A compliant (Mifare Classic 1K). I already made an Android app that can send custom APDU to read specific sectors by using raw SendBytes().&#xD;&#xA;&#xD;&#xA;Since I need to build a circuit with a custom antenna, I chose Arduino-uno with a NFC module (was thinking about StrongLink SL013), I wanted to know if it's possible to send raw bytes and receive the response from the tag. I only found some higher-level implementation (readSector, writeSector and so on).&#xD;&#xA;" />
  <row Id="3778" PostHistoryTypeId="6" PostId="1323" RevisionGUID="c8f742fb-a4ff-491b-ae65-997a701c0880" CreationDate="2014-04-28T11:51:07.023" UserId="46" Comment="Welcome new user! I have edited your question (which, for our standards was already great!) so it follows our site standards a little closer. I've removed the thankyou line as we show appreciation by upvoting and accepting answers. I've removed the signature as the site stamps it on the bottom-right" Text="&lt;arduino-uno&gt;&lt;rf&gt;&lt;rfid&gt;" />
  <row Id="3779" PostHistoryTypeId="2" PostId="1324" RevisionGUID="341a1c86-744b-4c61-969d-30993abe4ac6" CreationDate="2014-04-28T12:47:44.907" UserId="1224" Text="The designed threshold of the '328 logic is 45% of Vcc for all supply voltages, except the tolerance reduces from +/-25% of Vcc {&lt;3V} to +/-15% of Vcc{&gt;3}  This tolerance is due to temperature and process variation.&#xD;&#xA;&#xD;&#xA;Keep in mind that the smaller the difference between the &quot;actual&quot; threshold and your input is your immunity to noise and it will work if there is low noise. Thus 45+15% = 60%* 5V=3V is guaranteed.  What is not guaranteed, is the accuracy of your 5V regulator which if say 10% high will increase the threshold 10% above  3V.  So then 3.23 would not be guaranteed. So ensure accuracy of 5 V meets your noise immunity requirements." />
  <row Id="3780" PostHistoryTypeId="5" PostId="1324" RevisionGUID="7f39f36c-70e3-40e2-8267-248437c93e16" CreationDate="2014-04-28T12:55:58.287" UserId="1224" Comment="added 22 characters in body" Text="The designed threshold of the '328 logic is 45% of Vcc for all supply voltages, except the tolerance reduces from +/-25% of Vcc {&lt;3V} to +/-15% of Vcc{&gt;3}  This tolerance is due to temperature and process variation.&#xD;&#xA;&#xD;&#xA;Keep in mind that the smaller the difference between the &quot;actual&quot; threshold and your input is your immunity to noise and it will work if there is low noise. Thus 45+15% = 60%* 5V=3V is guaranteed.  What is not guaranteed, is the accuracy of your 5V regulator which if say 10% high will increase the threshold 10% above  3V or 3.3V.   So then 3.1 would not be guaranteed. So ensure accuracy of 5 V is below 5.04 minus your noise immunity requirements." />
  <row Id="3781" PostHistoryTypeId="2" PostId="1325" RevisionGUID="ea78a61b-45f4-4cac-ab13-123b5e89d7db" CreationDate="2014-04-28T15:58:36.257" UserId="1228" Text="I have very weird problem with a library I am creating. The library will be used to communicate between Arduino modules using XBee Series 1 modules. Library is very simple wrapper library around Arduino XBee library.&#xD;&#xA;&#xD;&#xA;I have one function that reads received packet and sends it back. At the moment it is implemented as a simple &quot;echo&quot; service - the function just displays the data received and sends it back to per-defined address. &#xD;&#xA;&#xD;&#xA;At the moment I have three versions of this function, out of which one is not working.&#xD;&#xA;&#xD;&#xA; 1. A function taking no arguments: void processPacket()&#xD;&#xA; 2. A function taking structure as a value as an argument: void processPacket(valuesStruct valuesStructData) - THIS VERSION OF THE FUNCTION IS NOT WORKING!&#xD;&#xA; 3. A function taking pointer to the structure as an argument: void processPacket(valuesStruct* valuesStructData)&#xD;&#xA;&#xD;&#xA;At this moment I noticed strange behavior in the 2nd version of the function. I do nothing with the passed argument - the content of all three functions is **the same.** In 2nd case the function reads wrong values from received XBee packet. In the 1st and 3rd case the function performs correctly.&#xD;&#xA;&#xD;&#xA;Code:&#xD;&#xA;&#xD;&#xA;**ExampleLib.h**&#xD;&#xA;&#xD;&#xA;    #ifndef ExampleLib_h&#xD;&#xA;    #define ExampleLib_h&#xD;&#xA;    &#xD;&#xA;    #include &quot;Arduino.h&quot;&#xD;&#xA;    #include &lt;XBee.h&gt;&#xD;&#xA;    &#xD;&#xA;    #define ADDRESS_BROADCAST 0xffff&#xD;&#xA;    #define ADDRESS_PC 0x3333&#xD;&#xA;    &#xD;&#xA;    typedef struct&#xD;&#xA;      {&#xD;&#xA;        int valA;&#xD;&#xA;        int valB;&#xD;&#xA;        int valC;&#xD;&#xA;      } valuesStruct;&#xD;&#xA;    &#xD;&#xA;    class ExampleLib&#xD;&#xA;    {&#xD;&#xA;    public:&#xD;&#xA;        ExampleLib();&#xD;&#xA;        void setSerial(Stream &amp;serial);&#xD;&#xA;        boolean tryReceivePacket();&#xD;&#xA;        void processPacket();&#xD;&#xA;        // THIS FUNCTION IS NOT WORKING!&#xD;&#xA;        void processPacket(valuesStruct valuesStructData);&#xD;&#xA;        void processPacket(valuesStruct* valuesStructData);&#xD;&#xA;    private:&#xD;&#xA;        XBee xbee;&#xD;&#xA;        Rx16Response rx16;&#xD;&#xA;    };&#xD;&#xA;    &#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**ExampleLib.cpp**&#xD;&#xA;&#xD;&#xA;The value read in line `byte* packetData = rx16.getData();` is wrong when we trigger `processPacket(valuesStruct valuesStructData)` function. In other cases the behavior is correct.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    #include &quot;Arduino.h&quot;&#xD;&#xA;    #include &lt;XBee.h&gt;&#xD;&#xA;    #include &quot;ExampleLib.h&quot;&#xD;&#xA;    &#xD;&#xA;    ExampleLib::ExampleLib()&#xD;&#xA;    {&#xD;&#xA;    	xbee = XBee();&#xD;&#xA;    	rx16 = Rx16Response();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void ExampleLib::setSerial(Stream &amp;serial)&#xD;&#xA;    {&#xD;&#xA;    	xbee.setSerial(serial);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    boolean ExampleLib::tryReceivePacket()&#xD;&#xA;    {&#xD;&#xA;    	xbee.readPacket();&#xD;&#xA;    &#xD;&#xA;      if (xbee.getResponse().isAvailable()) {&#xD;&#xA;        // got something&#xD;&#xA;    &#xD;&#xA;        if (xbee.getResponse().getApiId() == RX_16_RESPONSE) {&#xD;&#xA;          // got a rx packet&#xD;&#xA;    &#xD;&#xA;          xbee.getResponse().getRx16Response(rx16);&#xD;&#xA;          return true;&#xD;&#xA;        } &#xD;&#xA;        else {&#xD;&#xA;          return false;&#xD;&#xA;        }&#xD;&#xA;      } &#xD;&#xA;      else if (xbee.getResponse().isError()) {&#xD;&#xA;        //nss.print(&quot;Error reading packet.  Error code: &quot;);  &#xD;&#xA;        //nss.println(xbee.getResponse().getErrorCode());&#xD;&#xA;        // or flash error led&#xD;&#xA;        return false;&#xD;&#xA;      } &#xD;&#xA;      &#xD;&#xA;      return false;&#xD;&#xA;    }&#xD;&#xA;    void ExampleLib::processPacket()&#xD;&#xA;    {&#xD;&#xA;      byte* packetData = rx16.getData();&#xD;&#xA;      byte dataLength = rx16.getDataLength();&#xD;&#xA;      Serial.print(&quot;START L:&quot;);&#xD;&#xA;      Serial.println(dataLength);&#xD;&#xA;      for (int i = 0; i &lt; dataLength; i++) { &#xD;&#xA;        Serial.print(packetData[i]);&#xD;&#xA;    	Serial.print(&quot; - &quot;); &#xD;&#xA;      }&#xD;&#xA;      Serial.println(&quot;END&quot;);&#xD;&#xA;      &#xD;&#xA;      //16-bit addressing: Enter address of remote XBee, typically the coordinator&#xD;&#xA;      Tx16Request tx = Tx16Request(ADDRESS_PC, packetData, sizeof(packetData));&#xD;&#xA;      xbee.send(tx);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void ExampleLib::processPacket(valuesStruct valuesStructData)&#xD;&#xA;    {&#xD;&#xA;      processPacket();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void ExampleLib::processPacket(valuesStruct* valuesStructData)&#xD;&#xA;    {&#xD;&#xA;      processPacket();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;**Arduino sketch**&#xD;&#xA;&#xD;&#xA;    #include &lt;XBee.h&gt;&#xD;&#xA;    #include &lt;ExampleLib.h&gt;&#xD;&#xA;    &#xD;&#xA;    ExampleLib exampleLibObj = ExampleLib();&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      exampleLibObj.setSerial(Serial);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;    &#xD;&#xA;      boolean isPacketReceived = exampleLibObj.tryReceivePacket();&#xD;&#xA;    &#xD;&#xA;      if (isPacketReceived) {&#xD;&#xA;        // leave only one section, the rest should be commented&#xD;&#xA;        &#xD;&#xA;        //Section 1: working&#xD;&#xA;        exampleLibObj.processPacket();&#xD;&#xA;        &#xD;&#xA;        //Section 2: not working&#xD;&#xA;    //    valuesStruct test;&#xD;&#xA;    //    test.valA = 0;&#xD;&#xA;    //    test.valB = 0;&#xD;&#xA;    //    test.valC = 0;&#xD;&#xA;    //    exampleLibObj.processPacket(test);&#xD;&#xA;    &#xD;&#xA;        //Section 3: working&#xD;&#xA;    //  valuesStruct* test;&#xD;&#xA;    //  test-&gt;valA = 0;&#xD;&#xA;    //  test-&gt;valB = 0;&#xD;&#xA;    //  test-&gt;valC = 0;&#xD;&#xA;    //  exampleLibObj.processPacket(test);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;I am really puzzled why in this one case function is performing differently. Looking forward to any suggestions to that issue.&#xD;&#xA;&#xD;&#xA;Thanks!" />
  <row Id="3782" PostHistoryTypeId="1" PostId="1325" RevisionGUID="ea78a61b-45f4-4cac-ab13-123b5e89d7db" CreationDate="2014-04-28T15:58:36.257" UserId="1228" Text="XBee, external libraries and passing structures as arguments" />
  <row Id="3783" PostHistoryTypeId="3" PostId="1325" RevisionGUID="ea78a61b-45f4-4cac-ab13-123b5e89d7db" CreationDate="2014-04-28T15:58:36.257" UserId="1228" Text="&lt;c++&gt;&lt;library&gt;&lt;xbee&gt;&lt;struct&gt;" />
  <row Id="3784" PostHistoryTypeId="2" PostId="1326" RevisionGUID="22977699-da61-468c-a44b-bef35a92385c" CreationDate="2014-04-28T18:26:53.427" UserId="84" Text="I suppose you are using a continuous servo otherwise you won't be able to make it turn 90° more than twice (a normal servo has a varying angle of only 180°).&#xD;&#xA;&#xD;&#xA;Now if you are using a continuous servo, you have to be aware that the value you pass to `myservo.write()` does not represent an angle anymore!&#xD;&#xA;&#xD;&#xA;With a continuous servo, the value passed to `myservo.write()` now means a speed of rotation where, but the rnage of acceptable values is the same as for a normal servo, i.e. `[0; 180]`:&#xD;&#xA;&#xD;&#xA;- `0` means max speed clockwise&#xD;&#xA;- `90` means no motion&#xD;&#xA;- `180` means max speed counter-clockwise&#xD;&#xA;&#xD;&#xA;Now if you want to turn the servo exactly 90°, then you must know the max speed of the servo, and from that, compute the time during which you must let it turn:&#xD;&#xA;&#xD;&#xA;    // Start turning clockwise&#xD;&#xA;    myservo.write(0);&#xD;&#xA;    // Go on turning for the right duration&#xD;&#xA;    delay(TURN_TIME);&#xD;&#xA;    // Stop turning&#xD;&#xA;    myservo.write(90);&#xD;&#xA;&#xD;&#xA;The problem here is to compute `TURN_TIME`. For this, you must check the datasheet of your servo.&#xD;&#xA;&#xD;&#xA;On my own servo, a [Feetech Micro 1.3kg Continuous Rotation Servo FS90R][1], the max speed is:&#xD;&#xA;&#xD;&#xA;- 0.12s/60° when powered with 4.8V&#xD;&#xA;- 0.10s/60° when powered with 6V&#xD;&#xA;&#xD;&#xA;However, with the Arduino UNO, the supplied voltage should be **exactly 5V, neither 4.8V, nor 6V**.&#xD;&#xA;&#xD;&#xA;If we take a linear approximation, then we can apply the following formula to find out the speed `T` (in **s/60°**):&#xD;&#xA;&#xD;&#xA;    T = (0.12 - 0.10) * (V - 4.8) / (4.8 - 6.0) + 0.12&#xD;&#xA;&#xD;&#xA;Hence, for 5V, we can take it for granted that the max speed should be:&#xD;&#xA;&#xD;&#xA;    T = (0.12 - 0.10) * (5.0 - 4.8) / (4.8 - 6.0) + 0.12 = 0.116667&#xD;&#xA;&#xD;&#xA;Since we need 90°, this means we must run the servo at its max speed during:&#xD;&#xA;&#xD;&#xA;    T' = T * 1.5 = 0.175s&#xD;&#xA;&#xD;&#xA;Hence we now have the following program:&#xD;&#xA;&#xD;&#xA;    #include &lt;Servo.h&gt;&#xD;&#xA;    &#xD;&#xA;    #define TURN_TIME 175&#xD;&#xA;&#xD;&#xA;    Servo myservo;&#xD;&#xA;    &#xD;&#xA;    void setup {&#xD;&#xA;        myservo.attach(10);&#xD;&#xA;        // Initially the servo must be stopped &#xD;&#xA;        myservo.write(90);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        // Start turning clockwise&#xD;&#xA;        myservo.write(0);&#xD;&#xA;        // Go on turning for the right duration&#xD;&#xA;        delay(TURN_TIME);&#xD;&#xA;        // Stop turning&#xD;&#xA;        myservo.write(90);&#xD;&#xA;&#xD;&#xA;        // Wait for 12h&#xD;&#xA;        delay(12 * 3600 * 1000);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Of course, you will need some eperiments to find the **exact** right values; you may also find out that the servo may be sensitive to noise and even when it should not move (value = `90`), it does move (not fast, but still it moves).&#xD;&#xA;&#xD;&#xA;  [1]: http://www.feetechrc.com/product/analog-servo/micro-1-3kg-cm-360-degree-continuous-rotation-servo-fs90r/&#xD;&#xA;" />
  <row Id="3785" PostHistoryTypeId="2" PostId="1327" RevisionGUID="5705ba7f-d254-4083-a1d5-c2c3187d6ba5" CreationDate="2014-04-28T18:44:01.620" UserId="1229" Text="I'm trying to set up an Arduino Cellular Shield SM5100B to send SMS. &#xD;&#xA;&#xD;&#xA;My setup is:&#xD;&#xA;&#xD;&#xA;Arduino UNO R2&#xD;&#xA;SM5100B&#xD;&#xA;&quot;Movistar&quot; SIM Card (Chile)&#xD;&#xA;I've uploaded a code similar to the one described here, but when communication is supposed to star it cannot find a network. I suspect the problem is I haven't setup correctly the GSM band. But when I issue the command (AT+SBAND=7, same as in the US), it doesn't respond. How can I check in what band I'm on? And change the band?&#xD;&#xA;&#xD;&#xA;I'm sorry if the question seems basic, but I don't know much about Arduino programming.&#xD;&#xA;" />
  <row Id="3786" PostHistoryTypeId="1" PostId="1327" RevisionGUID="5705ba7f-d254-4083-a1d5-c2c3187d6ba5" CreationDate="2014-04-28T18:44:01.620" UserId="1229" Text="Set up an Arduino Cellular Shield SM5100B" />
  <row Id="3787" PostHistoryTypeId="3" PostId="1327" RevisionGUID="5705ba7f-d254-4083-a1d5-c2c3187d6ba5" CreationDate="2014-04-28T18:44:01.620" UserId="1229" Text="&lt;gsm&gt;" />
  <row Id="3788" PostHistoryTypeId="5" PostId="1327" RevisionGUID="3a1b556c-3220-48f9-a248-ecbc563c438d" CreationDate="2014-04-28T18:46:08.390" UserId="11" Comment="added 8 characters in body" Text="I'm trying to set up an Arduino Cellular Shield SM5100B to send SMS. &#xD;&#xA;&#xD;&#xA;My setup is:&#xD;&#xA;&#xD;&#xA;- Arduino UNO R2&#xD;&#xA;- SM5100B&#xD;&#xA;- &quot;Movistar&quot; SIM Card (Chile)&#xD;&#xA;&#xD;&#xA;I've uploaded a code similar to the one described here, but when communication is supposed to star it cannot find a network. I suspect the problem is I haven't setup correctly the GSM band. But when I issue the command (AT+SBAND=7, same as in the US), it doesn't respond. How can I check in what band I'm on? And change the band?&#xD;&#xA;&#xD;&#xA;I'm sorry if the question seems basic, but I don't know much about Arduino programming.&#xD;&#xA;" />
  <row Id="3789" PostHistoryTypeId="2" PostId="1328" RevisionGUID="ea0083aa-26e3-49cb-8298-846fe5d6e5bb" CreationDate="2014-04-28T19:59:16.433" UserId="1230" Text="I have a cute robot built on Arduino Uno and Ardumoto, and I am trying to reverse engineer it first, and to add some new sensors afterwards.&#xD;&#xA;&#xD;&#xA;I am stuck at how to deal with its program. I don't have the source code but I do not want to loose the program, yet in order to reverse engineer it I must write my own code and see if I can make it work.&#xD;&#xA;&#xD;&#xA;Beware, I am a n00b to microcontrolers, and pretty lame to electronics (full of enthusiasm though)." />
  <row Id="3790" PostHistoryTypeId="1" PostId="1328" RevisionGUID="ea0083aa-26e3-49cb-8298-846fe5d6e5bb" CreationDate="2014-04-28T19:59:16.433" UserId="1230" Text="is it possible to backup an uploaded program?" />
  <row Id="3791" PostHistoryTypeId="3" PostId="1328" RevisionGUID="ea0083aa-26e3-49cb-8298-846fe5d6e5bb" CreationDate="2014-04-28T19:59:16.433" UserId="1230" Text="&lt;arduino-uno&gt;&lt;uploading&gt;&lt;bootloader&gt;" />
  <row Id="3792" PostHistoryTypeId="10" PostId="1328" RevisionGUID="3b333320-8c10-4579-8e89-bb3c724a5694" CreationDate="2014-04-28T20:42:03.633" UserId="220" Comment="101" Text="{&quot;OriginalQuestionIds&quot;:[179],&quot;Voters&quot;:[{&quot;Id&quot;:220,&quot;DisplayName&quot;:&quot;Annonomus Person&quot;}]}" />
  <row Id="3793" PostHistoryTypeId="2" PostId="1329" RevisionGUID="b26a70b9-67cd-401f-9ab3-8fb193fbb44b" CreationDate="2014-04-28T23:41:49.340" UserId="1233" Text="I am working on a project for my local Makerspace, we have limited budget so I was hoping to use the RFID-RC522 el'cheap'o RFID/NFC readers on eBay, I received a couple of SPI based boards, they work, however the code examples for them are limited.&#xD;&#xA;&#xD;&#xA;I have found several different libraries and settled on this one: https://github.com/ljos/MFRC522&#xD;&#xA;&#xD;&#xA;The trouble is that all the code available online seem to spawn from some Chinese guys Python code that people have translated, and hacked into an Arduino library.&#xD;&#xA;&#xD;&#xA;The code works, but Mifare cards are meant to have 4, 7 or 10 byte UIDs and the example/library is returning a 5 byte serial number.&#xD;&#xA;&#xD;&#xA;There is no documentation and the [NXP datasheet][1] is incomprehensible... Additionally it seems to work with most cards, but it doesn't work with Mastercard PayWave cards which conform to the ISO 14443 standard. The more expensive RDM880 reader which is based on the MFRC500 works fine and has a nice library but the cost makes the implementation impossible.&#xD;&#xA;&#xD;&#xA;So, can someone help me to get this NXP MFRC522 based unit reading the UID from all ISO 14443 cards.&#xD;&#xA;&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;MFRC522.h&gt;&#xD;&#xA;    &#xD;&#xA;    #define RFID_SS  10&#xD;&#xA;    #define RFID_RST 5&#xD;&#xA;    &#xD;&#xA;    MFRC522 rfid( RFID_SS, RFID_RST );&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      SPI.begin();&#xD;&#xA;      Serial.begin(115200);&#xD;&#xA;      rfid.begin();&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      byte data[MAX_LEN];&#xD;&#xA;      byte uid[5];&#xD;&#xA;    &#xD;&#xA;      if ( rfid.requestTag( MF1_REQIDL, data ) == MI_OK ) {&#xD;&#xA;        if ( rfid.antiCollision( data ) == MI_OK ) {&#xD;&#xA;          memcpy( uid, data, 5 );&#xD;&#xA;          for ( int i = 0; i &lt; 5; i++ ) {&#xD;&#xA;            Serial.print( uid[i], HEX );&#xD;&#xA;            Serial.print( ' ' );&#xD;&#xA;          }&#xD;&#xA;          Serial.println();&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;  [1]: http://www.nxp.com/documents/data_sheet/MFRC500.pdf&#xD;&#xA;" />
  <row Id="3794" PostHistoryTypeId="1" PostId="1329" RevisionGUID="b26a70b9-67cd-401f-9ab3-8fb193fbb44b" CreationDate="2014-04-28T23:41:49.340" UserId="1233" Text="How do I use RFID-RC522 with an Arduino?" />
  <row Id="3795" PostHistoryTypeId="3" PostId="1329" RevisionGUID="b26a70b9-67cd-401f-9ab3-8fb193fbb44b" CreationDate="2014-04-28T23:41:49.340" UserId="1233" Text="&lt;rfid&gt;" />
  <row Id="3796" PostHistoryTypeId="2" PostId="1330" RevisionGUID="8ad301ef-f861-4c6d-ae20-9b8b281d7bb2" CreationDate="2014-04-29T01:10:24.173" UserId="931" Text="I'm trying to establish a USB connection between an android smartphone/tablet and an arduino uno/intel galileo. I don't know where to start. Do you guys have any suggestions? I'm just exploring, so I don't have a specific problem statement. I just want to able to transmit characters both ways. Thank you in advance!" />
  <row Id="3797" PostHistoryTypeId="1" PostId="1330" RevisionGUID="8ad301ef-f861-4c6d-ae20-9b8b281d7bb2" CreationDate="2014-04-29T01:10:24.173" UserId="931" Text="USB Communication between android and Arduino/Galileo" />
  <row Id="3798" PostHistoryTypeId="3" PostId="1330" RevisionGUID="8ad301ef-f861-4c6d-ae20-9b8b281d7bb2" CreationDate="2014-04-29T01:10:24.173" UserId="931" Text="&lt;arduino-uno&gt;&lt;arduino-galileo&gt;" />
  <row Id="3799" PostHistoryTypeId="5" PostId="1327" RevisionGUID="92c789b0-4bf3-46c3-a6be-939455778df0" CreationDate="2014-04-29T01:54:07.060" UserId="-1" Comment="correct broken link" Text="I'm trying to set up an Arduino Cellular Shield SM5100B to send SMS. &#xD;&#xA;&#xD;&#xA;My setup is:&#xD;&#xA;&#xD;&#xA;- Arduino UNO R2&#xD;&#xA;- SM5100B&#xD;&#xA;- &quot;Movistar&quot; SIM Card (Chile)&#xD;&#xA;&#xD;&#xA;I've uploaded a code similar to the one described [here][1], but when communication is supposed to star it cannot find a network. I suspect the problem is I haven't setup correctly the GSM band. But when I issue the command (AT+SBAND=7, same as in the US), it doesn't respond. How can I check in what band I'm on? And change the band?&#xD;&#xA;&#xD;&#xA;I'm sorry if the question seems basic, but I don't know much about Arduino programming.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.instructables.com/id/Arduino-Cellular-Shield-Tutorial/?lang=en" />
  <row Id="3800" PostHistoryTypeId="24" PostId="1327" RevisionGUID="92c789b0-4bf3-46c3-a6be-939455778df0" CreationDate="2014-04-29T01:54:07.060" Comment="Proposed by 201.220.243.35|13e0853d-8295-4d33-9720-3aedc2ce7fff approved by -1 edit id of 293" />
  <row Id="3801" PostHistoryTypeId="5" PostId="1327" RevisionGUID="a868f9b7-b60e-4046-a669-e93c5a61b773" CreationDate="2014-04-29T01:54:07.060" UserId="220" Comment="Removed unnecessary text" Text="I'm trying to set up an Arduino Cellular Shield SM5100B to send SMS. &#xD;&#xA;&#xD;&#xA;My setup is:&#xD;&#xA;&#xD;&#xA;- Arduino UNO R2&#xD;&#xA;- SM5100B&#xD;&#xA;- &quot;Movistar&quot; SIM Card (Chile)&#xD;&#xA;&#xD;&#xA;I've uploaded a code similar to the one described [here][1], but when communication is supposed to star it cannot find a network. I suspect the problem is I haven't setup correctly the GSM band. But when I issue the command (AT+SBAND=7, same as in the US), it doesn't respond. How can I check in what band I'm on? And change the band?&#xD;&#xA;&#xD;&#xA;  [1]: http://www.instructables.com/id/Arduino-Cellular-Shield-Tutorial/?lang=en" />
  <row Id="3803" PostHistoryTypeId="5" PostId="1248" RevisionGUID="2b734192-9f65-4910-901a-a0f736a77fbb" CreationDate="2014-04-29T09:11:48.617" UserId="1136" Comment="added 93 characters in body" Text="It looks like your sketch runs in slow motion.&#xD;&#xA;&#xD;&#xA;Check if you wrote delay(150) or have an additional delay in your loop.&#xD;&#xA;Check twice and - just to make sure - upload the corrected sketch again.&#xD;&#xA;&#xD;&#xA;**Edit:**&#xD;&#xA;If possible, test with another servo and even test with another Arduino board.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3804" PostHistoryTypeId="2" PostId="1331" RevisionGUID="cea56324-e965-4342-88fc-a83c065a55d1" CreationDate="2014-04-29T09:32:03.897" UserId="794" Text="I've finally found that when the MCU  to which Arduino is talking to was initialized, it would send spurious data to the Serial - I guess it would start first with a lower baud rate, and then switch to the programmed baud rate of 115200.&#xD;&#xA;&#xD;&#xA;To fix this, I had to ```flush``` the Arduino serial RX before sending any data. So:&#xD;&#xA;&#xD;&#xA;    byte streamReadResponse;&#xD;&#xA;    Serial1.begin(115200);&#xD;&#xA;    Serial1.setTimeout(9000);&#xD;&#xA;    while (Serial1.read() &gt;= 0)&#xD;&#xA;               ; // do nothing&#xD;&#xA;    Serial1.print(cmd);&#xD;&#xA;    Serial1.print('\r');&#xD;&#xA;    Serial1.flush();  //wait for all the data to be sent to the serial&#xD;&#xA;    streamReadResponse = Serial1.readBytesUntil('&gt;', data, dataLength);&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3805" PostHistoryTypeId="2" PostId="1332" RevisionGUID="657b68d3-cba9-40e3-a6c4-1fa8659d9307" CreationDate="2014-04-29T12:16:21.570" UserId="1238" Text="I am tracking a bug in the [Marlin][1] source code. &#xD;&#xA;&#xD;&#xA;**Background**&#xD;&#xA;&#xD;&#xA;Just for those who is not familiar with Reprap 3D printer and G-code. Marlin is a firmware that control a Reprap 3D printer. It receives G-code from a host computer (or read from SD card). Here the important thing is that if you send &quot;M114&quot; command it would report information about axis positions. Here, I extended this command to make it print some internal variable as well.&#xD;&#xA;&#xD;&#xA;**The Problem** &#xD;&#xA;&#xD;&#xA;In Marlin.ino file there is a line says:&#xD;&#xA;&#xD;&#xA;    volatile int extrudemultiply=100; //100-&gt;1 200-&gt;2&#xD;&#xA;&#xD;&#xA;However my Reprap keep extruding (and worse, ejecting back) a huge amount of filament. So I added some debug output for `M114` command to output this value. It turn out this value is not the default value 100, but something like 12374.&#xD;&#xA;&#xD;&#xA;I thought somewhere inside `setup()` function this value might changed. So I defined another variable&#xD;&#xA;&#xD;&#xA;    volatile int orig_extrudemultiply=100;&#xD;&#xA;&#xD;&#xA;and then at the first line of `setup()` function I add the following line&#xD;&#xA;&#xD;&#xA;    orig_extrudemultiply = extrudemultiply;&#xD;&#xA;&#xD;&#xA;Finally I output this value for `M114` command. Still, it is not 100. So it looks like the default value is not effective.&#xD;&#xA;&#xD;&#xA;**The Question**&#xD;&#xA;&#xD;&#xA;Although I have experience in C programming, I am new to the Arduino development. So my question is: how global variable being initialized in Arduino? In my case, what is the proper way to initialize this value?  &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/ErikZalm/Marlin" />
  <row Id="3806" PostHistoryTypeId="1" PostId="1332" RevisionGUID="657b68d3-cba9-40e3-a6c4-1fa8659d9307" CreationDate="2014-04-29T12:16:21.570" UserId="1238" Text="Default value of global variables not set" />
  <row Id="3807" PostHistoryTypeId="3" PostId="1332" RevisionGUID="657b68d3-cba9-40e3-a6c4-1fa8659d9307" CreationDate="2014-04-29T12:16:21.570" UserId="1238" Text="&lt;programming&gt;&lt;variables&gt;" />
  <row Id="3808" PostHistoryTypeId="5" PostId="180" RevisionGUID="ac1f0bb3-368e-4312-8bbc-b9065fa48ad6" CreationDate="2014-04-29T13:56:28.503" UserId="46" Comment="added 3 characters in body" Text="It should be possible as long as the security bit isn't set. This question was asked on EE a while back. &#xD;&#xA;&#xD;&#xA;[Is it possible to extract code from an arduino board?][1]&#xD;&#xA;&#xD;&#xA;But you won't get the Arduino code you wrote back. The code is compiled into assembly and you'll have to convert that back to C yourself.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://electronics.stackexchange.com/questions/61079/is-it-possible-to-extract-code-from-an-arduino-board" />
  <row Id="3809" PostHistoryTypeId="2" PostId="1333" RevisionGUID="d0049b02-b0bf-4818-8763-4fba560c433f" CreationDate="2014-04-29T15:19:59.803" UserId="1242" Text="You could use [the awesome CapSense-Library][1]. Additionally to the Library you only need a thin piece of conducting material e.g. aluminium foil and two pins on your arduino. The only thing you have to do is experiment with different resistors to reliably distinguish between someone sitting on the chair or not. Advantages of this method are:&#xD;&#xA;&#xD;&#xA; - virtually no costs at all &#xD;&#xA; - easy to implement&#xD;&#xA; - not subject to wear and    tear&#xD;&#xA; - should work with any kind of chair independent of material e.g.   &#xD;&#xA;   hard or soft surface&#xD;&#xA;&#xD;&#xA;  [1]: http://playground.arduino.cc/Main/CapacitiveSensor?from=Main.CapSense" />
  <row Id="3810" PostHistoryTypeId="5" PostId="1333" RevisionGUID="758c79af-84dc-421e-9844-71dccc30b967" CreationDate="2014-04-29T18:06:37.920" UserId="1242" Comment="added more bullet points to the list of advantages" Text="You could use [the awesome CapSense-Library][1]. Additionally to the Library you only need a thin piece of conducting material e.g. aluminium foil and two pins on your arduino. The only thing you have to do is experiment with different resistors to reliably distinguish between someone sitting on the chair or not. Advantages of this method are:&#xD;&#xA;&#xD;&#xA; - virtually no costs at all &#xD;&#xA; - easy to implement&#xD;&#xA; - not subject to wear and    tear&#xD;&#xA; - should work with any kind of chair independent of material e.g.   &#xD;&#xA;   hard or soft surface&#xD;&#xA; - consumes next to no power (I assume the whole device runs on battery since it's attached to a movable chair)&#xD;&#xA; - could even sense a person in the process of seating her-/himself and enable you to start the music faster (my stereo for example takes a second or so to start up)&#xD;&#xA;  [1]: http://playground.arduino.cc/Main/CapacitiveSensor?from=Main.CapSense" />
  <row Id="3811" PostHistoryTypeId="2" PostId="1334" RevisionGUID="4062733b-16b1-4f6b-8065-db49c76c56ec" CreationDate="2014-04-29T18:37:39.887" UserId="1242" Text="I am in the process of building my own [sous vide machine][1] and like to replace the pump typically found in most commercial machines with a magnetic stirrer unit. I figured the easiest way would be to use a motor to spin a permanent magnet (instead of creating a strong rotating magnetic field electrically). I first started experimenting with some 12V DC fans leftover from an old computer. By either lowering the input voltage or via PWM I was able to obtain appropriate rotational speed (don't ask me about exact speeds, I guess around 300rpm or so). With the project maturing I am not sure which motor (type and/or exact model) to use. I hoped some of you might point me in the right direction for the type of motor or even better, could suggest a specific model. I considered continuous stepper motors or geared servo motors. My criteria for the motor are:&#xD;&#xA;&#xD;&#xA; -  easy to control rotational speed between 0 and around 500 or so rpm (for ramp up and variation of speed to increase turbulent flow)&#xD;&#xA; - ability to rotate both clockwise and counter clockwise&#xD;&#xA; - enough torque at all speeds to spin a disk with magnets attached (weight and inertia probably negligible, the to be used alnico magnets create a field strong enough to lift 0,4kg each)&#xD;&#xA; - small axial dimensions&#xD;&#xA; - reasonably priced and long lasting&#xD;&#xA; - quiet &#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Sous-vide" />
  <row Id="3812" PostHistoryTypeId="1" PostId="1334" RevisionGUID="4062733b-16b1-4f6b-8065-db49c76c56ec" CreationDate="2014-04-29T18:37:39.887" UserId="1242" Text="Which motor (type) to use for an arduino controlled magnetic stirrer?" />
  <row Id="3813" PostHistoryTypeId="3" PostId="1334" RevisionGUID="4062733b-16b1-4f6b-8065-db49c76c56ec" CreationDate="2014-04-29T18:37:39.887" UserId="1242" Text="&lt;motor&gt;" />
  <row Id="3814" PostHistoryTypeId="2" PostId="1335" RevisionGUID="3ec61d52-b3c7-42e2-9401-f4639990fc8d" CreationDate="2014-04-29T19:05:46.410" UserId="84" Text="This variable is declared `volatile` which is generally meaning that it can be modified by an **Interrupt Service Routine** (**ISR**).&#xD;&#xA;&#xD;&#xA;So it is perfectly possible that this ISR gets called before your `setup()` function gets called and then it may modify this variable.&#xD;&#xA;&#xD;&#xA;In C and C++, variables defined as `type variable = xxx;` are guaranteed to be initialized before any of your code starts to run.&#xD;&#xA;&#xD;&#xA;So this means you must look for the root of the problem somewhere else.&#xD;&#xA;&#xD;&#xA;Don't forget that it is perfectly possible that some code gets run before `setup()` is called." />
  <row Id="3815" PostHistoryTypeId="5" PostId="1334" RevisionGUID="43eeba37-2571-4cd2-b78f-ca214de4c210" CreationDate="2014-04-29T20:37:50.803" UserId="1242" Comment="adde a photo of a commercial device" Text="I am in the process of building my own [sous vide machine][1] and like to replace the pump typically found in most commercial machines with a magnetic stirrer unit. I figured the easiest way would be to use a motor to spin a permanent magnet (instead of creating a strong rotating magnetic field electrically). I first started experimenting with some 12V DC fans leftover from an old computer. By either lowering the input voltage or via PWM I was able to obtain appropriate rotational speed (don't ask me about exact speeds, I guess around 300rpm or so). With the project maturing I am not sure which motor (type and/or exact model) to use. I hoped some of you might point me in the right direction for the type of motor or even better, could suggest a specific model. I considered continuous stepper motors or geared servo motors. My criteria for the motor are:&#xD;&#xA;&#xD;&#xA; -  easy to control rotational speed between 0 and around 500 or so rpm (for ramp up and variation of speed to increase turbulent flow)&#xD;&#xA; - ability to rotate both clockwise and counter clockwise&#xD;&#xA; - enough torque at all speeds to spin a disk with magnets attached (weight and inertia probably negligible, the to be used alnico magnets create a field strong enough to lift 0,4kg each)&#xD;&#xA; - small axial dimensions&#xD;&#xA; - reasonably priced and long lasting&#xD;&#xA; - quiet &#xD;&#xA;&#xD;&#xA;The following picture shows a commercial magnetic stirrer found in your average laboratory. The blurry white object in the glass beaker is the the so called stir bar or &quot;fish&quot;, a PTFE coated permanent magnet. It spins due to the rotating magnetic field created by the actual device underneath the beaker. &#xD;&#xA;![Photo of a commercial magnetic stirrer used in laboratories][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Sous-vide&#xD;&#xA;  [2]: http://i.stack.imgur.com/ysulU.jpg" />
  <row Id="3816" PostHistoryTypeId="5" PostId="1334" RevisionGUID="71d58bbb-90b8-485d-bb52-ea987523aa9d" CreationDate="2014-04-29T20:46:20.380" UserId="1242" Comment="added explanatory wikipedia link" Text="I am in the process of building my own [sous vide machine][1] and like to replace the pump typically found in most commercial machines with a [magnetic stirrer unit][2]. I figured the easiest way would be to use a motor to spin a permanent magnet (instead of creating a strong rotating magnetic field electrically). I first started experimenting with some 12V DC fans leftover from an old computer. By either lowering the input voltage or via PWM I was able to obtain appropriate rotational speed (don't ask me about exact speeds, I guess around 300rpm or so). With the project maturing I am not sure which motor (type and/or exact model) to use. I hoped some of you might point me in the right direction for the type of motor or even better, could suggest a specific model. I considered stepper motors or continuous  servo motors. My criteria for the motor are:&#xD;&#xA;&#xD;&#xA; -  easy to control rotational speed between 0 and around 500 or so rpm (for ramp up and variation of speed to increase turbulent flow)&#xD;&#xA; - ability to rotate both clockwise and counter clockwise&#xD;&#xA; - enough torque at all speeds to spin a disk with magnets attached (weight and inertia probably negligible, the to be used alnico magnets create a field strong enough to lift 0,4kg each)&#xD;&#xA; - small axial dimensions&#xD;&#xA; - reasonably priced and long lasting&#xD;&#xA; - quiet &#xD;&#xA;&#xD;&#xA;The following picture shows a commercial magnetic stirrer found in your average laboratory. The blurry white object in the glass beaker is the the so called stir bar or &quot;fish&quot;, a PTFE coated permanent magnet. It spins due to the rotating magnetic field created by the actual device underneath the beaker. &#xD;&#xA;![Photo of a commercial magnetic stirrer used in laboratories][3]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/Sous-vide&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Magnetic_stirrer&#xD;&#xA;  [3]: http://i.stack.imgur.com/ysulU.jpg" />
  <row Id="3817" PostHistoryTypeId="2" PostId="1336" RevisionGUID="0039b0da-1507-4b17-a9fc-d9b16aaedec2" CreationDate="2014-04-29T20:46:49.193" UserId="220" Text="I'd personally recommend a continuous rotation servo or a brushed DC motor. Personally, for this kind of load, I think it would be easier and cheaper to go with the brushed DC motor. You have to remember a continuous rotation servo is a DC motor with some circuitry so you can send pulses to it to control the speed (although it's not directly proportional to the signal you send).&#xD;&#xA;&#xD;&#xA;A servo is the only other option besides a brushless motor; both require a little more circuitry than the brushed motor/continuous servo. The additionally cost more. [This blog post covers the differences between brushed and brushless motors](http://quantumdevices.wordpress.com/2010/08/27/brushless-motors-vs-brush-motors-whats-the-difference/).&#xD;&#xA;&#xD;&#xA;For driving a continuous, you hook it up to power [depends on your servo voltage], ground, and another Arduino pin and use the [servo library](http://arduino.cc/en/reference/servo) to send a signal as a degree (90 = no speed, 180 = full speed forward, 0 = full speed backward).&#xD;&#xA;&#xD;&#xA;A brushed you would need a h-bridge that allows you to either send voltage, send no voltage, or send reverse voltage (for backward). [This chip (~$5)](http://www.pololu.com/product/2130) does that for two motors and allows PWM for different speeds. It also includes a brake function, although that doesn't seem necessary for you. It can handle up to a &quot;2.4 A continuous (4 A peak).&quot; I talk about this in [this answer of mine](http://arduino.stackexchange.com/questions/1314/how-can-i-connect-the-tamiya-double-gearbox-to-ardunio-uno/1315#1315).&#xD;&#xA;&#xD;&#xA;Quick note, if you want to control the *exact* RPM of the device and not just manually adjust it to a good rate, you'll need some sort of a rotary encoder or similar. A reed switch (sends current depending on magnetic fields) would work perfectly for this purpose, just mount it below the magnets and figure out the degrees rotated by the motor for each &quot;pulse.&quot;" />
  <row Id="3818" PostHistoryTypeId="2" PostId="1337" RevisionGUID="d4aea88c-81e1-4584-902e-4332374a7d94" CreationDate="2014-04-29T21:23:55.607" UserId="1249" Text="Is it possible to increase the size of an NFC antenna? Possibly creating a loop antenna whereby the tag could be read from anywhere inside the loop.&#xD;&#xA;&#xD;&#xA;I was thinking maybe if that isn't possible, it might be better to create an antenna array spanning the size of the area needed. Though I may have problems with overlap or double reads this way.&#xD;&#xA;&#xD;&#xA;Has anyone attempted this before?&#xD;&#xA;&#xD;&#xA;Note: I am not worried about increasing the z distance from the plane, just the x/y range. In fact, I still want the z distance to be very short as to not interfere with other antennas nearby." />
  <row Id="3819" PostHistoryTypeId="1" PostId="1337" RevisionGUID="d4aea88c-81e1-4584-902e-4332374a7d94" CreationDate="2014-04-29T21:23:55.607" UserId="1249" Text="Larger NFC antenna?" />
  <row Id="3820" PostHistoryTypeId="3" PostId="1337" RevisionGUID="d4aea88c-81e1-4584-902e-4332374a7d94" CreationDate="2014-04-29T21:23:55.607" UserId="1249" Text="&lt;sensors&gt;&lt;proximity&gt;" />
  <row Id="3821" PostHistoryTypeId="2" PostId="1338" RevisionGUID="d20bc036-12e6-4eec-aaad-5384cd49c051" CreationDate="2014-04-29T22:18:31.973" UserId="1252" Text="This may be a better question for [the Physics StackExchange][1] so tell me if I should move the question.&#xD;&#xA;&#xD;&#xA;I have a pretty simple script that I'm using to control the RPM of my stepper motor:&#xD;&#xA;&#xD;&#xA;    void loop(){ &#xD;&#xA;      digitalWrite(PIN, HIGH);&#xD;&#xA;      delayMicroseconds(wait);&#xD;&#xA;      digitalWrite(PIN, LOW);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;as you can see it's just producing a pretty standard pulse, I have my Arduino connected to a driver that manages the motor. The `wait` variable comes from a second order equation I derived from measuring the RPM with a Tachometer and tweaking the value.&#xD;&#xA;&#xD;&#xA;    // From data RPM = 31729/x + 17.327 thus x = 31729/(RPM-17.527)&#xD;&#xA;    wait = M/(RPM-C);&#xD;&#xA;&#xD;&#xA;It works pretty well, I get readings consistently within only 1 - 2 rotations off. But the slope and intercept seem completely arbitrary to me. Is there a chance it has to do with the clock speed of the Arduino? I'm using an Uno and from playing around with the numbers I can't seem to find a relationship. From what I can tell, the driver looks hardwired so I don't think it has much to do with the equation.&#xD;&#xA;&#xD;&#xA;Any idea what these values, the slope/intercept mean?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://physics.stackexchange.com/&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3822" PostHistoryTypeId="1" PostId="1338" RevisionGUID="d20bc036-12e6-4eec-aaad-5384cd49c051" CreationDate="2014-04-29T22:18:31.973" UserId="1252" Text="Understanding the relationship of Pulse and Stepper RPM" />
  <row Id="3823" PostHistoryTypeId="3" PostId="1338" RevisionGUID="d20bc036-12e6-4eec-aaad-5384cd49c051" CreationDate="2014-04-29T22:18:31.973" UserId="1252" Text="&lt;arduino-uno&gt;&lt;motor&gt;" />
  <row Id="3824" PostHistoryTypeId="5" PostId="1338" RevisionGUID="dc03d7fc-bab2-46be-9310-1d8bc52440a0" CreationDate="2014-04-30T00:36:50.710" UserId="1252" Comment="added 57 characters in body" Text="This may be a better question for [the Physics StackExchange][1] so tell me if I should move the question.&#xD;&#xA;&#xD;&#xA;I have a pretty simple script that I'm using to control the RPM of my stepper motor:&#xD;&#xA;&#xD;&#xA;    void loop(){ &#xD;&#xA;      digitalWrite(PIN, HIGH);&#xD;&#xA;      delayMicroseconds(wait);&#xD;&#xA;      digitalWrite(PIN, LOW);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;as you can see it's just producing a pretty standard pulse, I have my Arduino connected to a driver that manages the motor. The `wait` variable comes from a second order equation I derived from measuring the RPM with a Tachometer and tweaking the value.&#xD;&#xA;&#xD;&#xA;    // From data RPM = 31729/x + 17.327 thus x = 31729/(RPM-17.527)&#xD;&#xA;    wait = M/(RPM-C);&#xD;&#xA;&#xD;&#xA;It works pretty well, I get readings consistently within only 1 - 2 rotations off. But the slope and intercept seem completely arbitrary to me. Is there a chance it has to do with the clock speed of the Arduino? I'm using an Uno and from playing around with the numbers I can't seem to find a relationship. From what I can tell, the driver looks hardwired so I don't think it has much to do with the equation.&#xD;&#xA;&#xD;&#xA;Any idea what these values, the slope/intercept mean?&#xD;&#xA;&#xA;Equation: `RPM=31729/wait + 17.327` M:`31729` and C:`17.327`&#xA;&#xA;&#xD;&#xA;  [1]: http://physics.stackexchange.com/" />
  <row Id="3825" PostHistoryTypeId="2" PostId="1339" RevisionGUID="748a75c2-4c28-4319-8628-a6bd1e076f96" CreationDate="2014-04-30T05:14:47.363" UserId="83" Text="In general the size and geometry of the antenna is directly related to the carrier frequency. The antenna is tuned to the output signal of the transmitter/receiver. If you change an optimized antenna, it is no longer optimized and its performance will drop. So you can't keep extending an antenna, trying to improve its range. &#xD;&#xA;&#xD;&#xA;The important question to be asked is if the existing antenna is already optimally sized for the transmitter/receiver. With these small things transmitter/receiver and antenna are usually closely matched. Even if the antenna is smaller than expected by math, the transmitter/receiver connected to it may be compensated for that.&#xD;&#xA;&#xD;&#xA;With a receiver or a **low**&lt;sup&gt;*&lt;/sup&gt; power transmitter, there is no harm in testing another antenna, but you'll probably won't improve performance much.&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;&lt;sup&gt;*)&lt;/sup&gt; Notice that a high power transmitter can blow its output stage when connected to an unmatched load/antenna, but that is unlikely with NFC." />
  <row Id="3826" PostHistoryTypeId="2" PostId="1340" RevisionGUID="2367c678-5d1a-4759-9879-033c08cad3a3" CreationDate="2014-04-30T07:28:08.467" UserId="89" Text="If you need to rotate huge loads, a permanent magnet coupled to the axis of a brushless DC motor, driven by an electronic speed controller (used for model aircrafts, multicopters, etc.) could be an option. This is the mechanical principle used in standard magnetic stirrers used in the lab, particularly when the stirrer has an additional heating.&#xD;&#xA;&#xD;&#xA;Small (and flat) magnetic stirrers without heating, similar to the one in your image, however often have no (rotating) mechanical parts at all, but use a set of coils periodically powered in sequence. Here, the only mechanically rotating part is the stirring bar itself. A commerically available model would be [this one](http://www.ika.de/owa/ika/catalog.product_detail?iProduct=3907500&amp;iCS=1&amp;iProductgroup=188&amp;iSubgroup=1)." />
  <row Id="3827" PostHistoryTypeId="2" PostId="1341" RevisionGUID="18707379-6d31-45b8-b639-c2bff0c9d330" CreationDate="2014-04-30T08:43:44.493" UserId="1256" Text="I want to make a drone project, and to that I will use arduino as the platform. My plane is to use a Play Station controller to control the Drone in the air. In addition to that I want to connect a GPS-module. My question goes, is it possible to transmit the longitude and latitude from the GPS via the RF 433MHz to the receiver? When received the longitude and latitude how can I transmit them further to the Smartphone and display the data on google maps? I suggest it could be possible through the Xbee, but I am not sure. &#xD;&#xA;&#xD;&#xA;I would like if someone can confirm my idea, if not bring me a better way to do that.&#xD;&#xA;&#xD;&#xA;In the image below, you can see the diagram of my design.&#xD;&#xA;&#xD;&#xA;![Image][1]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/qorvn.png" />
  <row Id="3828" PostHistoryTypeId="1" PostId="1341" RevisionGUID="18707379-6d31-45b8-b639-c2bff0c9d330" CreationDate="2014-04-30T08:43:44.493" UserId="1256" Text="Is it possible to transmit Longitude and Latitude via RF433MHz?" />
  <row Id="3829" PostHistoryTypeId="3" PostId="1341" RevisionGUID="18707379-6d31-45b8-b639-c2bff0c9d330" CreationDate="2014-04-30T08:43:44.493" UserId="1256" Text="&lt;arduino-uno&gt;&lt;sensors&gt;&lt;xbee&gt;&lt;android&gt;&lt;map&gt;" />
  <row Id="3830" PostHistoryTypeId="2" PostId="1342" RevisionGUID="c3050873-c25d-44f1-9077-f158c145cc44" CreationDate="2014-04-30T09:04:30.140" UserId="831" Text="If you are using Xbee modules in your project, why add 433MHz RF, just for the sole purpose of transmitting the location?  With the 433Mhz, you will have to implement error-correction yourself." />
  <row Id="3831" PostHistoryTypeId="5" PostId="1332" RevisionGUID="d0bc1777-61ad-47c6-9bf0-d86a94520cdf" CreationDate="2014-04-30T10:14:24.283" UserId="1238" Comment="added 1189 characters in body" Text="I am tracking a bug in the [Marlin][1] source code. &#xD;&#xA;&#xD;&#xA;**Background**&#xD;&#xA;&#xD;&#xA;Just for those who is not familiar with Reprap 3D printer and G-code. Marlin is a firmware that control a Reprap 3D printer. It receives G-code from a host computer (or read from SD card). Here the important thing is that if you send &quot;M114&quot; command it would report information about axis positions. Here, I extended this command to make it print some internal variable as well.&#xD;&#xA;&#xD;&#xA;**The Problem** &#xD;&#xA;&#xD;&#xA;In Marlin.ino file there is a line says:&#xD;&#xA;&#xD;&#xA;    volatile int extrudemultiply=100; //100-&gt;1 200-&gt;2&#xD;&#xA;&#xD;&#xA;However my Reprap keep extruding (and worse, ejecting back) a huge amount of filament. So I added some debug output for `M114` command to output this value. It turn out this value is not the default value 100, but something like 12374.&#xD;&#xA;&#xD;&#xA;I thought somewhere inside `setup()` function this value might changed. So I defined another variable&#xD;&#xA;&#xD;&#xA;    volatile int orig_extrudemultiply=100;&#xD;&#xA;&#xD;&#xA;and then at the first line of `setup()` function I add the following line&#xD;&#xA;&#xD;&#xA;    orig_extrudemultiply = extrudemultiply;&#xD;&#xA;&#xD;&#xA;Finally I output this value for `M114` command. Still, it is not 100. So it looks like the default value is not effective.&#xD;&#xA;&#xD;&#xA;**The Question**&#xD;&#xA;&#xD;&#xA;Although I have experience in C programming, I am new to the Arduino development. So my question is: how global variable being initialized in Arduino? In my case, what is the proper way to initialize this value?&#xD;&#xA;&#xD;&#xA;**Versioning**&#xD;&#xA;&#xD;&#xA;I originally posted the official [Marlin][2] link for the reference. However,&#xD;&#xA;the version I actually use is [this fork][1] from Reprap Pro team. I was just following the [Melzi][3] entry of Reprap wiki, because my board is Melzi. I am not sure the weather the latest version of Marlin work for my board.&#xD;&#xA;&#xD;&#xA;**Further detail**&#xD;&#xA;&#xD;&#xA;As the commenter said, the first thing I though of is memory corruption. So I wanted to narrow the problem down. Since that value is configurable through `M302 SXXX` command, I tested this command works without difficulty. This means there is nothing in the `loop` function or the ISRs can affect this value when it is running stably. So I consider the problem must be in `setup` function or earlier. &#xD;&#xA;&#xD;&#xA;Further test shows that setting this value at the end of `setup` or even at the beginning of `setup` still works fine. This means the `setup` function may not be the problematic one. The test in &quot;The Problem&quot; session was the last step, which, in my opinion, means the course of the problem must being run before entering `setup`.&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/reprappro/Marlin&#xD;&#xA;  [2]: https://github.com/ErikZalm/Marlin&#xD;&#xA;  [3]: http://reprap.org/wiki/Melzi#Melzi_Arduino_Pin_Numbers" />
  <row Id="3832" PostHistoryTypeId="5" PostId="1332" RevisionGUID="fa03e19f-e0e3-4c60-abcd-0ff1cf31e716" CreationDate="2014-04-30T12:04:03.377" UserId="1238" Comment="added 684 characters in body" Text="I am tracking a bug in the [Marlin][1] source code. &#xD;&#xA;&#xD;&#xA;**Background**&#xD;&#xA;&#xD;&#xA;Just for those who is not familiar with Reprap 3D printer and G-code. Marlin is a firmware that control a Reprap 3D printer. It receives G-code from a host computer (or read from SD card). Here the important thing is that if you send &quot;M114&quot; command it would report information about axis positions. Here, I extended this command to make it print some internal variable as well.&#xD;&#xA;&#xD;&#xA;**The Problem** &#xD;&#xA;&#xD;&#xA;In Marlin.ino file there is a line says:&#xD;&#xA;&#xD;&#xA;    volatile int extrudemultiply=100; //100-&gt;1 200-&gt;2&#xD;&#xA;&#xD;&#xA;However my Reprap keep extruding (and worse, ejecting back) a huge amount of filament. So I added some debug output for `M114` command to output this value. It turn out this value is not the default value 100, but something like 12374.&#xD;&#xA;&#xD;&#xA;I thought somewhere inside `setup()` function this value might changed. So I defined another variable&#xD;&#xA;&#xD;&#xA;    volatile int orig_extrudemultiply=100;&#xD;&#xA;&#xD;&#xA;and then at the first line of `setup()` function I add the following line&#xD;&#xA;&#xD;&#xA;    orig_extrudemultiply = extrudemultiply;&#xD;&#xA;&#xD;&#xA;Finally I output this value for `M114` command. Still, it is not 100. So it looks like the default value is not effective.&#xD;&#xA;&#xD;&#xA;**The Question**&#xD;&#xA;&#xD;&#xA;Although I have experience in C programming, I am new to the Arduino development. So my question is: how global variable being initialized in Arduino? In my case, what is the proper way to initialize this value?&#xD;&#xA;&#xD;&#xA;**Versioning**&#xD;&#xA;&#xD;&#xA;I originally posted the official [Marlin][2] link for the reference. However,&#xD;&#xA;the version I actually use is [this fork][1] from Reprap Pro team. I was just following the [Melzi][3] entry of Reprap wiki, because my board is Melzi. I am not sure the weather the latest version of Marlin work for my board.&#xD;&#xA;&#xD;&#xA;**Further detail**&#xD;&#xA;&#xD;&#xA;As the commenter said, the first thing I though of is memory corruption. So I wanted to narrow the problem down. Since that value is configurable through `M302 SXXX` command, I tested this command works without difficulty. This means there is nothing in the `loop` function or the ISRs can affect this value when it is running stably. So I consider the problem must be in `setup` function or earlier. &#xD;&#xA;&#xD;&#xA;Further test shows that setting this value at the end of `setup` or even at the beginning of `setup` still works fine. This means the `setup` function may not be the problematic one. The test in &quot;The Problem&quot; session was the last step, which, in my opinion, means the course of the problem must being run before entering `setup`.&#xD;&#xA;&#xD;&#xA;**UPDATE**&#xD;&#xA;&#xD;&#xA;Further examination shows that although it looks like works when I set the default value in the first line of `setup()`, but that it is just luckily being 100. So once I add more padding variables it stops working until I move the default setting after the following line in `setup()`:&#xD;&#xA;    &#xD;&#xA;    EEPROM_RetrieveSettings(); // loads data from EEPROM if available&#xD;&#xA;&#xD;&#xA;However, since I `grep`ed for `extrudemultiply` before any test and I didn't figure out this function, this function should not change this value. I guess there are some data overflow inside this function, so the value was changed expectationally.&#xD;&#xA;&#xD;&#xA;I got to figure out what is wrong in this function.&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/reprappro/Marlin&#xD;&#xA;  [2]: https://github.com/ErikZalm/Marlin&#xD;&#xA;  [3]: http://reprap.org/wiki/Melzi#Melzi_Arduino_Pin_Numbers" />
  <row Id="3833" PostHistoryTypeId="2" PostId="1343" RevisionGUID="ce14f1a5-41ef-4b70-8c3a-5610532d0bc0" CreationDate="2014-04-30T12:35:48.157" UserId="1238" Text="The problem of this version of Marlin can be shown in the following piece of code (which is inside `EEPROM_RetrieveSettings` function):&#xD;&#xA;&#xD;&#xA;      for (short i=0;i&lt;4;i++) &#xD;&#xA;      {&#xD;&#xA;        axis_steps_per_unit[i]=tmp1[i];  &#xD;&#xA;        max_feedrate[i]=tmp2[i];&#xD;&#xA;        max_acceleration_units_per_sq_second[i]=tmp3[i];&#xD;&#xA;        max_length[i]=tmp4[i];&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;Here `max_length` is an array of 3 elements, not 4, so the last statement in the loop overrides other variable.&#xD;&#xA;&#xD;&#xA;The solution is &#xD;&#xA;&#xD;&#xA;      for (short i=0;i&lt;4;i++) &#xD;&#xA;      {&#xD;&#xA;        axis_steps_per_unit[i]=tmp1[i];  &#xD;&#xA;        max_feedrate[i]=tmp2[i];&#xD;&#xA;        max_acceleration_units_per_sq_second[i]=tmp3[i];&#xD;&#xA;        if(i&lt;3)&#xD;&#xA;            max_length[i]=tmp4[i];&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;Or&#xD;&#xA;&#xD;&#xA;      for (short i=0;i&lt;4;i++) &#xD;&#xA;      {&#xD;&#xA;        axis_steps_per_unit[i]=tmp1[i];  &#xD;&#xA;        max_feedrate[i]=tmp2[i];&#xD;&#xA;        max_acceleration_units_per_sq_second[i]=tmp3[i];&#xD;&#xA;        if(i &lt; sizeof(tmp4)/sizeof(tmp4[0]))&#xD;&#xA;            max_length[i]=tmp4[i];&#xD;&#xA;      }&#xD;&#xA;" />
  <row Id="3834" PostHistoryTypeId="5" PostId="1343" RevisionGUID="771589d7-2fb2-4cba-b6a4-18a377449aa2" CreationDate="2014-04-30T12:43:44.107" UserId="1238" Comment="added 105 characters in body" Text="The problem of this version of Marlin can be shown in the following piece of code (which is inside `EEPROM_RetrieveSettings` function):&#xD;&#xA;&#xD;&#xA;      for (short i=0;i&lt;4;i++) &#xD;&#xA;      {&#xD;&#xA;        axis_steps_per_unit[i]=tmp1[i];  &#xD;&#xA;        max_feedrate[i]=tmp2[i];&#xD;&#xA;        max_acceleration_units_per_sq_second[i]=tmp3[i];&#xD;&#xA;        max_length[i]=tmp4[i];&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;Here `max_length` is an array of 3 elements, not 4, so the last statement in the loop overrides other variable.&#xD;&#xA;&#xD;&#xA;The solution is &#xD;&#xA;&#xD;&#xA;      for (short i=0;i&lt;4;i++) &#xD;&#xA;      {&#xD;&#xA;        axis_steps_per_unit[i]=tmp1[i];  &#xD;&#xA;        max_feedrate[i]=tmp2[i];&#xD;&#xA;        max_acceleration_units_per_sq_second[i]=tmp3[i];&#xD;&#xA;        if(i&lt;3)&#xD;&#xA;            max_length[i]=tmp4[i];&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;Or&#xD;&#xA;&#xD;&#xA;      for (short i=0;i&lt;4;i++) &#xD;&#xA;      {&#xD;&#xA;        axis_steps_per_unit[i]=tmp1[i];  &#xD;&#xA;        max_feedrate[i]=tmp2[i];&#xD;&#xA;        max_acceleration_units_per_sq_second[i]=tmp3[i];&#xD;&#xA;        if(i &lt; sizeof(tmp4)/sizeof(tmp4[0]))&#xD;&#xA;            max_length[i]=tmp4[i];&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;Greate thanks to the answer writer and commenter. Without your help I couldn't follow the right track. " />
  <row Id="3835" PostHistoryTypeId="2" PostId="1344" RevisionGUID="2df22b8e-f630-437b-920f-2bbe632cb9fc" CreationDate="2014-04-30T13:20:01.850" UserId="1258" Text="I'm having some conflicts between the core `HardwareSerial.cpp` and an external DMX library.&#xD;&#xA;&#xD;&#xA;For DMX I'm using the [Four Universes DMX 512 Library](http://www.deskontrol.net/blog/arduino-four-universes-dmx-512-library/). Using the library standalone, it all works perfectly. But when combining it with other libraries, I'm getting the error:&#xD;&#xA;&#xD;&#xA;`core.a(HardwareSerial.cpp.o): In function '__vector_36':&#xD;&#xA;C:\Program Files (x86)\Arduino\hardware\arduino\cores\arduino/HardwareSerial.cpp:147: multiple definition of '__vector_36'&#xD;&#xA;Dmx\lib_dmx.cpp.o:C:\Program Files (x86)\Arduino\libraries\Dmx/lib_dmx.cpp:206: first defined here`&#xD;&#xA;&#xD;&#xA;The DMX library uses the UART hardware to generate the DMX signals. It supports four universes on the Arduino Mega since that has four UART hardware parts. Now, I'd like to only use the second hardware part, so the UART1. In the DMX library this is easily adjusted in the .h-file, by commenting out the non-used serial ports.&#xD;&#xA;&#xD;&#xA;The line from `lib_dmx.cpp` that is conflicting is this line:&#xD;&#xA;&#xD;&#xA;    #if defined(USE_UART1)&#xD;&#xA;    ISR (SIG_USART1_RECV)&#xD;&#xA;    {&#xD;&#xA;      ArduinoDmx1.Process_ISR_RX(1);&#xD;&#xA;    }&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;The line from `hardwareSerial.cpp` that is conflicting is in the ISR here:&#xD;&#xA;&#xD;&#xA;    #if defined(USART1_RX_vect)&#xD;&#xA;      void serialEvent1() __attribute__((weak));&#xD;&#xA;      void serialEvent1() {}&#xD;&#xA;      #define serialEvent1_implemented&#xD;&#xA;      ISR(USART1_RX_vect)&#xD;&#xA;      {&#xD;&#xA;        if (bit_is_clear(UCSR1A, UPE1)) {&#xD;&#xA;          unsigned char c = UDR1;&#xD;&#xA;          store_char(c, &amp;rx_buffer1);&#xD;&#xA;        } else {&#xD;&#xA;          unsigned char c = UDR1;&#xD;&#xA;        };&#xD;&#xA;      }&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;I have been having issues with this for a very long time and don't have a solution at hand yet. It's also a but unclear to me how the interrupts on Arduino's are arranged. I've also included the .ino I'm using currently. I'm also using another Ethernet Library than the default, one that includes multicast UDP (found (here)[https://github.com/aallan/Arduino]).&#xD;&#xA;&#xD;&#xA;**lib_dmx.h**&#xD;&#xA;&#xD;&#xA;    &gt; /***************************************************************************&#xD;&#xA;    &gt; *&#xD;&#xA;    &gt; * Title          : Arduino DMX512 library. 4 input/output universes.&#xD;&#xA;    &gt; * Version        : v 0.3 beta&#xD;&#xA;    &gt; * Last updated   : 07.07.2012&#xD;&#xA;    &gt; * Target         : Arduino mega 2560, Arduino mega 1280, Arduino nano (1 universe)  &#xD;&#xA;    &gt; * Author         : Toni Merino - merino.toni at gmail.com&#xD;&#xA;    &gt; * Web            : www.deskontrol.net/blog&#xD;&#xA;    &gt; *&#xD;&#xA;    &gt; * Based on ATmega8515 Dmx library written by Hendrik Hoelscher, www.hoelscher-hi.de&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; ;***************************************************************************/&#xD;&#xA;    &gt; #ifndef __INC_DMX_H&#xD;&#xA;    &gt; #define __INC_DMX_H&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; #include &lt;avr/io.h&gt;&#xD;&#xA;    &gt; #include &lt;stdint.h&gt;&#xD;&#xA;    &gt; #include &lt;avr/interrupt.h&gt;&#xD;&#xA;    &gt; #include &lt;util/delay.h&gt;&#xD;&#xA;    &gt; #if ARDUINO &gt;= 100   #include &quot;Arduino.h&quot;&#xD;&#xA;    &gt; #else    #include &quot;WProgram.h&quot;&#xD;&#xA;    &gt; #endif&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; //#define        USE_INTERBYTE_DELAY     // rare cases of equipment&#xD;&#xA;    &gt; non full DMX-512 compliant, need this&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; // *** comment UARTs not used *** //#define        USE_UART0&#xD;&#xA;    &gt; #define        USE_UART1 //#define        USE_UART2 //#define        USE_UART3&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; // New DMX modes *** EXPERIMENTAL ***&#xD;&#xA;    &gt; #define        DMX512            (0)    // DMX-512 (250 kbaud - 512 channels) Standard USITT DMX-512&#xD;&#xA;    &gt; #define        DMX1024           (1)    // DMX-1024 (500 kbaud - 1024 channels) Completely non standard - TESTED ok&#xD;&#xA;    &gt; #define        DMX2048           (2)    // DMX-2048 (1000 kbaud - 2048 channels) called by manufacturers DMX1000K, DMX 4x or DMX 1M ???&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; // DMX-512  (250 kbaud - 512 channels) Standard USITT DMX-512&#xD;&#xA;    &gt; #define        IBG_512           (10)                      // interbyte gap [us]&#xD;&#xA;    &gt; #define        DMX_512           ((F_CPU/(250000*8))-1)    // 250 kbaud&#xD;&#xA;    &gt; #define        BREAK_512         ( F_CPU/(100000*8))       // 90.9 kbaud&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; // DMX-1024 (500 kbaud - 1024 channels) Completely non standard&#xD;&#xA;    &gt; #define        IBG_1024          (5)                       // interbyte gap [us]&#xD;&#xA;    &gt; #define        DMX_1024          ((F_CPU/(500000*8))-1)    // 500 kbaud&#xD;&#xA;    &gt; #define        BREAK_1024        ( F_CPU/(200000*8))       // 181.8 kbaud&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; // DMX-2048 (1000 kbaud - 2048 channels) Non standard, but used by&#xD;&#xA;    &gt; manufacturers as DMX1000K or DMX-4x or DMX 1M ???&#xD;&#xA;    &gt; #define        IBG_2048          (2)                       // interbyte gap [us] + nop's to reach 2.5 uS&#xD;&#xA;    &gt; #define        DMX_2048          ((F_CPU/(1000000*8))-1)   // 1000 kbaud&#xD;&#xA;    &gt; #define        BREAK_2048        ( F_CPU/(400000*8))       // 363.6 kbaud&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; // Inline assembly: do nothing for one clock cycle.&#xD;&#xA;    &gt; #define        nop()             __asm__ __volatile__(&quot;nop&quot;)&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; #ifdef __cplusplus extern &quot;C&quot; {&#xD;&#xA;    &gt; #endif   #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;    &gt;     #if defined(USE_UART0)&#xD;&#xA;    &gt;       void SIG_USART0_RECV  (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;       void SIG_USART0_TRANS (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;     #endif&#xD;&#xA;    &gt;     #if defined(USE_UART1)&#xD;&#xA;    &gt;       void SIG_USART1_RECV  (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;       void SIG_USART1_TRANS (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;     #endif&#xD;&#xA;    &gt;     #if defined(USE_UART2)  &#xD;&#xA;    &gt;       void SIG_USART2_RECV  (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;       void SIG_USART2_TRANS (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;     #endif&#xD;&#xA;    &gt;     #if defined(USE_UART3)  &#xD;&#xA;    &gt;       void SIG_USART3_RECV  (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;       void SIG_USART3_TRANS (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;     #endif   #elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)&#xD;&#xA;    &gt;     #if defined(USE_UART0)&#xD;&#xA;    &gt;       void USART_RX_vect    (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;       void USART_TX_vect    (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;     #endif   #endif&#xD;&#xA;    &gt; #ifdef __cplusplus };&#xD;&#xA;    &gt; #endif&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; class CArduinoDmx  {    #if defined(__AVR_ATmega1280__) ||&#xD;&#xA;    &gt; defined(__AVR_ATmega2560__)&#xD;&#xA;    &gt;     #if defined(USE_UART0)&#xD;&#xA;    &gt;       friend void SIG_USART0_RECV  (void);&#xD;&#xA;    &gt;       friend void SIG_USART0_TRANS (void);&#xD;&#xA;    &gt;     #endif&#xD;&#xA;    &gt;     #if defined(USE_UART1)&#xD;&#xA;    &gt;       friend void SIG_USART1_RECV  (void);&#xD;&#xA;    &gt;       friend void SIG_USART1_TRANS (void);&#xD;&#xA;    &gt;     #endif&#xD;&#xA;    &gt;     #if defined(USE_UART2)  &#xD;&#xA;    &gt;       friend void SIG_USART2_RECV  (void);&#xD;&#xA;    &gt;       friend void SIG_USART2_TRANS (void);&#xD;&#xA;    &gt;     #endif&#xD;&#xA;    &gt;     #if defined(USE_UART3)  &#xD;&#xA;    &gt;       friend void SIG_USART3_RECV  (void);&#xD;&#xA;    &gt;       friend void SIG_USART3_TRANS (void);&#xD;&#xA;    &gt;     #endif   #elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)&#xD;&#xA;    &gt;     #if defined(USE_UART0)&#xD;&#xA;    &gt;       friend void USART_RX_vect    (void);&#xD;&#xA;    &gt;       friend void USART_TX_vect    (void);&#xD;&#xA;    &gt;     #endif   #endif    public:    enum {IDLE, BREAK, STARTB, STARTADR};     // RX DMX states    enum {TXBREAK, TXSTARTB, TXDATA};  &#xD;&#xA;    &gt; // TX DMX states&#xD;&#xA;    &gt;       volatile uint8_t    *RxBuffer;            // array of RX DMX values    volatile uint8_t    *TxBuffer;            // array of TX DMX&#xD;&#xA;    &gt; values&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; private:    uint8_t     gRxState;    uint8_t    *gRxPnt;    uint8_t   &#xD;&#xA;    &gt; IndicatorCount;    uint8_t     USARTstate;		    uint8_t     RxByte;   &#xD;&#xA;    &gt; uint8_t     RxState;    uint8_t     mUART;    uint8_t     gTxState;   &#xD;&#xA;    &gt; uint16_t    RxCount;    uint16_t    gCurTxCh;		    uint16_t   &#xD;&#xA;    &gt; rx_channels;                  // rx channels number    uint16_t   &#xD;&#xA;    &gt; tx_channels;                  // tx channels number    uint16_t   &#xD;&#xA;    &gt; rx_address;                   // rx start address    uint16_t   &#xD;&#xA;    &gt; tx_address;                   // tx start address    int8_t     &#xD;&#xA;    &gt; rx_led;                       // rx indicator led pin    int8_t     &#xD;&#xA;    &gt; tx_led;                       // tx indicator led pin    int8_t     &#xD;&#xA;    &gt; control_pin;                  // max485 input/output selection pin   &#xD;&#xA;    &gt; uint8_t     dmx_mode;                     // Standard USITT DMX512 =&#xD;&#xA;    &gt; 0, non standard DMX1024 = 1, non standard DMX2048 (DMX1000K) = 2   &#xD;&#xA;    &gt; uint8_t     speed_dmx;    uint8_t     speed_break;    uint16_t   &#xD;&#xA;    &gt; CurTxCh;    uint8_t     TxState;    uint8_t    *RxPnt;&#xD;&#xA;    &gt;    &#xD;&#xA;    &gt; #if defined(USE_INTERBYTE_DELAY)       void        delay_gap          ();&#xD;&#xA;    &gt; #endif&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; public:    void        stop_dmx           ();    void        set_speed&#xD;&#xA;    &gt; (uint8_t mode);    void        set_control_pin    (int8_t  pin)       &#xD;&#xA;    &gt; { control_pin     = pin;      }    void        init_rx           &#xD;&#xA;    &gt; (uint8_t mode);  // Standard USITT DMX512 = 0, non standard DMX1024 =&#xD;&#xA;    &gt; 1, non standard DMX2048 (DMX1000K) = 2    void        set_rx_address  &#xD;&#xA;    &gt; (uint16_t address)   { rx_address      = address;  }    void       &#xD;&#xA;    &gt; set_rx_channels    (uint16_t channels)  { rx_channels     = channels;&#xD;&#xA;    &gt; }    void        init_tx            (uint8_t mode);  // Standard USITT&#xD;&#xA;    &gt; DMX512 = 0, non standard DMX1024 = 1, non standard DMX2048 (DMX1000K)&#xD;&#xA;    &gt; = 2    void        set_tx_address     (uint16_t address)   { tx_address      = address;  }    void        set_tx_channels   &#xD;&#xA;    &gt; (uint16_t channels)  { tx_channels     = channels; }&#xD;&#xA;    &gt; &#xD;&#xA;    &gt;    void        attachTXInterrupt  (void (*isr)(uint8_t uart))      {&#xD;&#xA;    &gt; TXisrCallback   = isr; }   // register the user TX callback    void   &#xD;&#xA;    &gt; attachRXInterrupt  (void (*isr)(uint8_t uart))      { RXisrCallback  &#xD;&#xA;    &gt; = isr; }   // register the user RX callback&#xD;&#xA;    &gt;        //void			Process_ISR_RX(uint8_t rx_isr_number);&#xD;&#xA;    &gt; &#xD;&#xA;    &gt;    void        (*TXisrCallback)   (uint8_t uart);    void       &#xD;&#xA;    &gt; (*RXisrCallback)   (uint8_t uart);&#xD;&#xA;    &gt; &#xD;&#xA;    &gt;    inline void Process_ISR_RX     (uint8_t  rx_isr_number);    inline&#xD;&#xA;    &gt; void Process_ISR_TX     (uint8_t  tx_isr_number);    public:   &#xD;&#xA;    &gt; CArduinoDmx                    (uint8_t uart)       { rx_address     &#xD;&#xA;    &gt; = 1; &#xD;&#xA;    &gt;                                                          rx_channels     = 8;&#xD;&#xA;    &gt;                                                          tx_address      = 1; &#xD;&#xA;    &gt;                                                          tx_channels     = 8;&#xD;&#xA;    &gt;                                                          mUART           = uart; }   };&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; #if defined(USE_UART0)   extern CArduinoDmx ArduinoDmx0;&#xD;&#xA;    &gt; #endif&#xD;&#xA;    &gt; #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)   #if defined(USE_UART1)&#xD;&#xA;    &gt;     extern CArduinoDmx ArduinoDmx1;   #endif   #if defined(USE_UART2)&#xD;&#xA;    &gt;     extern CArduinoDmx ArduinoDmx2;   #endif   #if defined(USE_UART3)&#xD;&#xA;    &gt;     extern CArduinoDmx ArduinoDmx3;   #endif&#xD;&#xA;    &gt; #endif&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; #endif&#xD;&#xA;&#xD;&#xA;**lib_dmx.cpp**&#xD;&#xA;&#xD;&#xA;    /***************************************************************************&#xD;&#xA;    *&#xD;&#xA;    * Title          : Arduino DMX512 library. 4 input/output universes.&#xD;&#xA;    * Version        : v 0.3 beta&#xD;&#xA;    * Last updated   : 07.07.2012&#xD;&#xA;    * Target         : Arduino mega 2560, Arduino mega 1280, Arduino nano (1 universe)  &#xD;&#xA;    * Author         : Toni Merino - merino.toni at gmail.com&#xD;&#xA;    * Web            : www.deskontrol.net/blog&#xD;&#xA;    *&#xD;&#xA;    * Based on ATmega8515 Dmx library written by Hendrik Hoelscher, www.hoelscher-hi.de&#xD;&#xA;    &#xD;&#xA;    ;***************************************************************************/&#xD;&#xA;    #include &quot;lib_dmx.h&quot;&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    &#xD;&#xA;    #if defined(USE_UART0)&#xD;&#xA;      CArduinoDmx ArduinoDmx0(0);&#xD;&#xA;    #endif&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;      #if defined(USE_UART1)&#xD;&#xA;        CArduinoDmx ArduinoDmx1(1);&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART2)&#xD;&#xA;        CArduinoDmx ArduinoDmx2(2);&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART3)&#xD;&#xA;        CArduinoDmx ArduinoDmx3(3);&#xD;&#xA;      #endif&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    // *************** DMX Transmision Initialisation ****************&#xD;&#xA;    void CArduinoDmx::init_tx(uint8_t mode)&#xD;&#xA;    {&#xD;&#xA;      cli();          //disable interrupts&#xD;&#xA;      stop_dmx();                         //stop uart&#xD;&#xA;      dmx_mode = mode;&#xD;&#xA;      set_speed(dmx_mode);&#xD;&#xA;      &#xD;&#xA;      if(control_pin != -1)&#xD;&#xA;      {&#xD;&#xA;        pinMode(control_pin,OUTPUT);        // max485 I/O control&#xD;&#xA;        digitalWrite(control_pin, HIGH);    // set 485 as output&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      if(mUART == 0)&#xD;&#xA;      {&#xD;&#xA;        pinMode(1, OUTPUT);&#xD;&#xA;        UBRR0H   = 0;&#xD;&#xA;        UBRR0L   = speed_dmx;  &#xD;&#xA;        UCSR0A  |= (1&lt;&lt;U2X0);&#xD;&#xA;        UCSR0C  |= (3&lt;&lt;UCSZ00)|(1&lt;&lt;USBS0);&#xD;&#xA;        UCSR0B  |= (1&lt;&lt;TXEN0) |(1&lt;&lt;TXCIE0);&#xD;&#xA;        UDR0     = 0;							          //start USART 0&#xD;&#xA;      }&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;      else if(mUART == 1)&#xD;&#xA;      {&#xD;&#xA;        pinMode(18, OUTPUT); &#xD;&#xA;        UBRR1H   = 0;&#xD;&#xA;        UBRR1L   = speed_dmx;   &#xD;&#xA;        UCSR1A  |= (1&lt;&lt;U2X1);&#xD;&#xA;        UCSR1C  |= (3&lt;&lt;UCSZ10)|(1&lt;&lt;USBS1);&#xD;&#xA;        UCSR1B  |= (1&lt;&lt;TXEN1) |(1&lt;&lt;TXCIE1);&#xD;&#xA;        UDR1     = 0;							          //start USART 1&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 2)&#xD;&#xA;      {&#xD;&#xA;        pinMode(16, OUTPUT); &#xD;&#xA;        UBRR2H   = 0;&#xD;&#xA;        UBRR2L   = speed_dmx;   &#xD;&#xA;        UCSR2A  |= (1&lt;&lt;U2X2);&#xD;&#xA;        UCSR2C  |= (3&lt;&lt;UCSZ20)|(1&lt;&lt;USBS2);&#xD;&#xA;        UCSR2B  |= (1&lt;&lt;TXEN2) |(1&lt;&lt;TXCIE2);&#xD;&#xA;        UDR2     = 0;							          //start USART 2&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 3)&#xD;&#xA;      {&#xD;&#xA;        pinMode(14, OUTPUT); &#xD;&#xA;        UBRR3H   = 0;&#xD;&#xA;        UBRR3L   = speed_dmx;    &#xD;&#xA;        UCSR3A  |= (1&lt;&lt;U2X3);&#xD;&#xA;        UCSR3C  |= (3&lt;&lt;UCSZ30)|(1&lt;&lt;USBS3);&#xD;&#xA;        UCSR3B  |= (1&lt;&lt;TXEN3) |(1&lt;&lt;TXCIE3);&#xD;&#xA;        UDR3     = 0;							          //start USART 3&#xD;&#xA;      }&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;      gTxState = BREAK;					                    // start with break&#xD;&#xA;      TxBuffer = (uint8_t*)malloc(tx_channels);     // allocate mem for buffer&#xD;&#xA;      memset((uint8_t*)TxBuffer, 0, tx_channels);   // fill buffer with 0's&#xD;&#xA;      sei();          //enable interrupts&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // ************************ DMX Stop ***************************&#xD;&#xA;    void CArduinoDmx::stop_dmx()&#xD;&#xA;    {&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;      if(mUART == 0)&#xD;&#xA;      {&#xD;&#xA;        UCSR0B &amp;= ~((1&lt;&lt;RXCIE0) | (1&lt;&lt;TXCIE0) | (1&lt;&lt;RXEN0) | (1&lt;&lt;TXEN0));&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 1)&#xD;&#xA;      {&#xD;&#xA;        UCSR1B &amp;= ~((1&lt;&lt;RXCIE1) | (1&lt;&lt;TXCIE1) | (1&lt;&lt;RXEN1) | (1&lt;&lt;TXEN1));&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 2)&#xD;&#xA;      {&#xD;&#xA;        UCSR2B &amp;= ~((1&lt;&lt;RXCIE2) | (1&lt;&lt;TXCIE2) | (1&lt;&lt;RXEN2) | (1&lt;&lt;TXEN2));&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 3)&#xD;&#xA;      {&#xD;&#xA;        UCSR3B &amp;= ~((1&lt;&lt;RXCIE3) | (1&lt;&lt;TXCIE3) | (1&lt;&lt;RXEN3) | (1&lt;&lt;TXEN3));&#xD;&#xA;      }&#xD;&#xA;    #elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)&#xD;&#xA;      if(mUART == 0)&#xD;&#xA;      {&#xD;&#xA;        UCSR0B &amp;= ~((1&lt;&lt;RXCIE0) | (1&lt;&lt;TXCIE0) | (1&lt;&lt;RXEN0) | (1&lt;&lt;TXEN0));&#xD;&#xA;      }&#xD;&#xA;    #endif&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // *************** DMX Reception Initialisation ****************&#xD;&#xA;    void CArduinoDmx::init_rx(uint8_t mode)&#xD;&#xA;    {&#xD;&#xA;      cli();          //disable interrupts&#xD;&#xA;      stop_dmx();&#xD;&#xA;      dmx_mode = mode;&#xD;&#xA;      set_speed(dmx_mode);&#xD;&#xA;      &#xD;&#xA;      if(control_pin != -1)&#xD;&#xA;      {&#xD;&#xA;        pinMode(control_pin,OUTPUT);        //max485 I/O control&#xD;&#xA;        digitalWrite(control_pin, LOW);     //set 485 as input&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      if(mUART == 0)&#xD;&#xA;      {&#xD;&#xA;        pinMode(0, INPUT); &#xD;&#xA;        UBRR0H   = 0;&#xD;&#xA;        UBRR0L   = speed_dmx;&#xD;&#xA;        UCSR0A  |= (1&lt;&lt;U2X0);&#xD;&#xA;        UCSR0C  |= (3&lt;&lt;UCSZ00)|(1&lt;&lt;USBS0);&#xD;&#xA;        UCSR0B  |= (1&lt;&lt;RXEN0) |(1&lt;&lt;RXCIE0);&#xD;&#xA;      }&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;      else if(mUART == 1)&#xD;&#xA;      {&#xD;&#xA;        pinMode(19, INPUT); &#xD;&#xA;        UBRR1H   = 0;&#xD;&#xA;        UBRR1L   = speed_dmx;&#xD;&#xA;        UCSR1A  |= (1&lt;&lt;U2X1);&#xD;&#xA;        UCSR1C  |= (3&lt;&lt;UCSZ10)|(1&lt;&lt;USBS1);&#xD;&#xA;        UCSR1B  |= (1&lt;&lt;RXEN1) |(1&lt;&lt;RXCIE1);&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 2)&#xD;&#xA;      {&#xD;&#xA;        pinMode(17, INPUT); &#xD;&#xA;        UBRR2H   = 0;&#xD;&#xA;        UBRR2L   = speed_dmx;&#xD;&#xA;        UCSR2A  |= (1&lt;&lt;U2X2); &#xD;&#xA;        UCSR2C  |= (3&lt;&lt;UCSZ20)|(1&lt;&lt;USBS2);&#xD;&#xA;        UCSR2B  |= (1&lt;&lt;RXEN2) |(1&lt;&lt;RXCIE2);&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 3)&#xD;&#xA;      {&#xD;&#xA;        pinMode(15, INPUT); &#xD;&#xA;        UBRR3H   = 0;&#xD;&#xA;        UBRR3L   = speed_dmx; &#xD;&#xA;        UCSR3A  |= (1&lt;&lt;U2X3);&#xD;&#xA;        UCSR3C  |= (3&lt;&lt;UCSZ30)|(1&lt;&lt;USBS3);&#xD;&#xA;        UCSR3B  |= (1&lt;&lt;RXEN3) |(1&lt;&lt;RXCIE3);&#xD;&#xA;      }&#xD;&#xA;    #endif&#xD;&#xA;      &#xD;&#xA;      gRxState = IDLE;&#xD;&#xA;      RxBuffer = (uint8_t*)malloc(rx_channels);   // allocate mem for buffer&#xD;&#xA;      memset((uint8_t*)RxBuffer, 0, rx_channels); // fill buffer with 0's&#xD;&#xA;      sei();          //enable interrupts&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // *************** DMX Reception ISR ****************&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;      #if defined(USE_UART0)&#xD;&#xA;        ISR (SIG_USART0_RECV)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx0.Process_ISR_RX(0);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART1)&#xD;&#xA;        ISR (SIG_USART1_RECV)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx1.Process_ISR_RX(1);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART2)&#xD;&#xA;        ISR (SIG_USART2_RECV)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx2.Process_ISR_RX(2);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART3)&#xD;&#xA;        ISR (SIG_USART3_RECV)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx3.Process_ISR_RX(3);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;    #elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)&#xD;&#xA;      #if defined(USE_UART0)&#xD;&#xA;        ISR (USART_RX_vect)&#xD;&#xA;        {&#xD;&#xA;    		ArduinoDmx0.Process_ISR_RX(0);&#xD;&#xA;    	} &#xD;&#xA;      #endif&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    void CArduinoDmx::Process_ISR_RX(uint8_t rx_isr_number)&#xD;&#xA;    {&#xD;&#xA;      if(rx_isr_number == 0)&#xD;&#xA;      {&#xD;&#xA;        USARTstate = UCSR0A;		          //get state&#xD;&#xA;        RxByte     = UDR0;                //get data&#xD;&#xA;        RxState    = gRxState;					  //just get once from SRAM!!!&#xD;&#xA;        if (USARTstate &amp;(1&lt;&lt;FE0))         //check for break&#xD;&#xA;        {					&#xD;&#xA;          UCSR0A  &amp;= ~(1&lt;&lt;FE0);				    //reset flag&#xD;&#xA;          RxCount  = rx_address;				  //reset frame counter&#xD;&#xA;          gRxState = BREAK;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;    &#xD;&#xA;      else if(rx_isr_number == 1)&#xD;&#xA;      {&#xD;&#xA;        USARTstate = UCSR1A;		          //get state&#xD;&#xA;        RxByte     = UDR1;                //get data&#xD;&#xA;        RxState    = gRxState;					  //just get once from SRAM!!!&#xD;&#xA;        if (USARTstate &amp;(1&lt;&lt;FE1))         //check for break&#xD;&#xA;        {					&#xD;&#xA;          UCSR1A  &amp;= ~(1&lt;&lt;FE1);				    //reset flag&#xD;&#xA;          RxCount  = rx_address;				  //reset frame counter&#xD;&#xA;          gRxState = BREAK;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      else if(rx_isr_number == 2)&#xD;&#xA;      {&#xD;&#xA;        USARTstate = UCSR2A;		          //get state&#xD;&#xA;        RxByte     = UDR2;                //get data&#xD;&#xA;        RxState    = gRxState;					  //just get once from SRAM!!!&#xD;&#xA;        if (USARTstate &amp;(1&lt;&lt;FE2))         //check for break&#xD;&#xA;        {					&#xD;&#xA;          UCSR2A  &amp;= ~(1&lt;&lt;FE2);				    //reset flag&#xD;&#xA;          RxCount  = rx_address;				  //reset frame counter&#xD;&#xA;          gRxState = BREAK;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      else if(rx_isr_number == 3)&#xD;&#xA;      {&#xD;&#xA;        USARTstate = UCSR3A;		          //get state&#xD;&#xA;        RxByte     = UDR3;                //get data&#xD;&#xA;        RxState    = gRxState;					  //just get once from SRAM!!!&#xD;&#xA;        if (USARTstate &amp;(1&lt;&lt;FE3))         //check for break&#xD;&#xA;        {					&#xD;&#xA;          UCSR3A  &amp;= ~(1&lt;&lt;FE3);				    //reset flag&#xD;&#xA;          RxCount  = rx_address;				  //reset frame counter&#xD;&#xA;          gRxState = BREAK;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;      if (RxState == BREAK)&#xD;&#xA;      {&#xD;&#xA;        if (RxByte == 0) &#xD;&#xA;        {&#xD;&#xA;          gRxState = STARTB;						  //normal start code detected&#xD;&#xA;          gRxPnt   = ((uint8_t*)RxBuffer + 1);&#xD;&#xA;        }&#xD;&#xA;        else &#xD;&#xA;          gRxState = IDLE;&#xD;&#xA;      }&#xD;&#xA;      else if (RxState == STARTB)&#xD;&#xA;      {&#xD;&#xA;        if (--RxCount == 0)						    //start address reached?&#xD;&#xA;        {&#xD;&#xA;          gRxState   = STARTADR;&#xD;&#xA;          RxBuffer[0]= RxByte;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      else if (RxState == STARTADR)&#xD;&#xA;      {&#xD;&#xA;        RxPnt  = gRxPnt;&#xD;&#xA;        *RxPnt = RxByte;&#xD;&#xA;        if (++RxPnt &gt;= (RxBuffer + rx_channels)) 	//all ch received?&#xD;&#xA;        {&#xD;&#xA;          gRxState= IDLE;&#xD;&#xA;          if (*RXisrCallback) RXisrCallback(mUART);   // fire callback for read data&#xD;&#xA;        }&#xD;&#xA;        else &#xD;&#xA;        {&#xD;&#xA;          gRxPnt = RxPnt;&#xD;&#xA;        }&#xD;&#xA;      }							&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // *************** DMX Transmision ISR ****************&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;      #if defined(USE_UART0)&#xD;&#xA;        ISR(SIG_USART0_TRANS)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx0.Process_ISR_TX(0);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART1)&#xD;&#xA;        ISR(SIG_USART1_TRANS)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx1.Process_ISR_TX(1);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART2)&#xD;&#xA;        ISR(SIG_USART2_TRANS)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx2.Process_ISR_TX(2);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART3)&#xD;&#xA;        ISR(SIG_USART3_TRANS)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx3.Process_ISR_TX(3);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;    #elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)&#xD;&#xA;      #if defined(USE_UART0)&#xD;&#xA;        ISR(USART_TX_vect)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx0.Process_ISR_TX(0);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void CArduinoDmx::Process_ISR_TX(uint8_t tx_isr_number)&#xD;&#xA;    {&#xD;&#xA;      TxState = gTxState;&#xD;&#xA;      &#xD;&#xA;      if(tx_isr_number == 0)&#xD;&#xA;      {&#xD;&#xA;        if (TxState == TXBREAK) //BREAK + MAB&#xD;&#xA;        {&#xD;&#xA;          UBRR0H   = 0;&#xD;&#xA;          UBRR0L   = speed_break;&#xD;&#xA;          UDR0     = 0;								    //send break&#xD;&#xA;          gTxState = TXSTARTB;&#xD;&#xA;        }&#xD;&#xA;        else if (TxState == TXSTARTB)&#xD;&#xA;        {&#xD;&#xA;          UBRR0H   = 0;&#xD;&#xA;          UBRR0L   = speed_dmx;&#xD;&#xA;          UDR0     = 0;								    //send start byte&#xD;&#xA;          gTxState = TXDATA;&#xD;&#xA;          gCurTxCh = 0;&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;          #if defined(USE_INTERBYTE_DELAY)&#xD;&#xA;            delay_gap();&#xD;&#xA;          #endif    &#xD;&#xA;          CurTxCh = gCurTxCh;&#xD;&#xA;          UDR0 = TxBuffer[CurTxCh++];				//send data&#xD;&#xA;          if (CurTxCh == tx_channels)&#xD;&#xA;          {&#xD;&#xA;            if (*TXisrCallback) TXisrCallback(0); // fire callback for update data&#xD;&#xA;            gTxState = TXBREAK;   // new break if all ch sent&#xD;&#xA;          }&#xD;&#xA;          else &#xD;&#xA;          {&#xD;&#xA;            gCurTxCh = CurTxCh;&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;    &#xD;&#xA;      else if(tx_isr_number == 1)&#xD;&#xA;      {&#xD;&#xA;        if (TxState == TXBREAK)&#xD;&#xA;        {&#xD;&#xA;          UBRR1H   = 0;&#xD;&#xA;          UBRR1L   = speed_break;&#xD;&#xA;          UDR1     = 0;								    //send break&#xD;&#xA;          gTxState = TXSTARTB;&#xD;&#xA;        }&#xD;&#xA;        else if (TxState == TXSTARTB)&#xD;&#xA;        {&#xD;&#xA;          UBRR1H   = 0;&#xD;&#xA;          UBRR1L   = speed_dmx;&#xD;&#xA;          UDR1     = 0;								    //send start byte&#xD;&#xA;          gTxState = TXDATA;&#xD;&#xA;          gCurTxCh = 0;&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;          #if defined(USE_INTERBYTE_DELAY)&#xD;&#xA;            delay_gap();&#xD;&#xA;          #endif    &#xD;&#xA;          CurTxCh = gCurTxCh;&#xD;&#xA;          UDR1 = TxBuffer[CurTxCh++];				//send data&#xD;&#xA;          if (CurTxCh == tx_channels)&#xD;&#xA;          {&#xD;&#xA;            if (*TXisrCallback) TXisrCallback(1); // fire callback for update data&#xD;&#xA;            gTxState = TXBREAK;   // new break if all ch sent&#xD;&#xA;          }&#xD;&#xA;          else &#xD;&#xA;          {&#xD;&#xA;            gCurTxCh = CurTxCh;&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      else if(tx_isr_number == 2)&#xD;&#xA;      {&#xD;&#xA;        if (TxState == TXBREAK)&#xD;&#xA;        {&#xD;&#xA;          UBRR2H   = 0;&#xD;&#xA;          UBRR2L   = speed_break;&#xD;&#xA;          UDR2     = 0;								    //send break&#xD;&#xA;          gTxState = TXSTARTB;&#xD;&#xA;        }&#xD;&#xA;        else if (TxState == TXSTARTB)&#xD;&#xA;        {&#xD;&#xA;          UBRR2H   = 0;&#xD;&#xA;          UBRR2L   = speed_dmx;&#xD;&#xA;          UDR2     = 0;								    //send start byte&#xD;&#xA;          gTxState = TXDATA;&#xD;&#xA;          gCurTxCh = 0;&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;          #if defined(USE_INTERBYTE_DELAY)&#xD;&#xA;            delay_gap();&#xD;&#xA;          #endif   &#xD;&#xA;          CurTxCh = gCurTxCh;&#xD;&#xA;          UDR2 = TxBuffer[CurTxCh++];				//send data&#xD;&#xA;          if (CurTxCh == tx_channels)&#xD;&#xA;          {&#xD;&#xA;            if (*TXisrCallback) TXisrCallback(2); // fire callback for update data&#xD;&#xA;            gTxState = TXBREAK;   // new break if all ch sent&#xD;&#xA;          }&#xD;&#xA;          else &#xD;&#xA;          {&#xD;&#xA;            gCurTxCh = CurTxCh;&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      else if(tx_isr_number == 3)&#xD;&#xA;      {&#xD;&#xA;        if (TxState == TXBREAK)&#xD;&#xA;        {&#xD;&#xA;          UBRR3H   = 0;&#xD;&#xA;          UBRR3L   = speed_break;&#xD;&#xA;          UDR3     = 0;								    //send break&#xD;&#xA;          gTxState = TXSTARTB;&#xD;&#xA;        }&#xD;&#xA;        else if (TxState == TXSTARTB)&#xD;&#xA;        {&#xD;&#xA;          UBRR3H   = 0;&#xD;&#xA;          UBRR3L   = speed_dmx;&#xD;&#xA;          UDR3     = 0;								    //send start byte&#xD;&#xA;          gTxState = TXDATA;&#xD;&#xA;          gCurTxCh = 0;&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;          #if defined(USE_INTERBYTE_DELAY)&#xD;&#xA;            delay_gap();&#xD;&#xA;          #endif&#xD;&#xA;          CurTxCh = gCurTxCh;&#xD;&#xA;          UDR3 = TxBuffer[CurTxCh++];				//send data&#xD;&#xA;          if (CurTxCh == tx_channels)&#xD;&#xA;          {&#xD;&#xA;            if (*TXisrCallback) TXisrCallback(3); // fire callback for update data&#xD;&#xA;            gTxState = TXBREAK;   // new break if all ch sent&#xD;&#xA;          }&#xD;&#xA;          else &#xD;&#xA;          {&#xD;&#xA;            gCurTxCh = CurTxCh;&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    #endif&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void CArduinoDmx::set_speed(uint8_t mode)&#xD;&#xA;    {&#xD;&#xA;      if(mode == 0)&#xD;&#xA;      {&#xD;&#xA;        speed_dmx   = DMX_512;    // DMX-512  (250 kbaud - 512 channels) Standard USITT DMX-512&#xD;&#xA;        speed_break = BREAK_512;&#xD;&#xA;      }&#xD;&#xA;      else if(mode == 1)&#xD;&#xA;      {&#xD;&#xA;        speed_dmx   = DMX_1024;	  // DMX-1024 (500 kbaud - 1024 channels) Completely non standard, but usefull ;)&#xD;&#xA;        speed_break = BREAK_1024;&#xD;&#xA;      }&#xD;&#xA;      else if(mode == 2)&#xD;&#xA;      {&#xD;&#xA;        speed_dmx   = DMX_2048;   // DMX-2048 (1000 kbaud - 2048 channels) Used by manufacturers as DMX1000K, DMX-4x or DMX-1M ???&#xD;&#xA;        speed_break = BREAK_2048;&#xD;&#xA;      }  &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    #if defined(USE_INTERBYTE_DELAY)&#xD;&#xA;    &#xD;&#xA;    void CArduinoDmx::delay_gap() // rare cases of equipment non full DMX-512 compliant, need this&#xD;&#xA;    {&#xD;&#xA;      if(dmx_mode == 0)&#xD;&#xA;      {&#xD;&#xA;        _delay_us(IBG_512);&#xD;&#xA;      }&#xD;&#xA;      else if(dmx_mode == 1)&#xD;&#xA;      {&#xD;&#xA;        _delay_us(IBG_1024);&#xD;&#xA;      }&#xD;&#xA;      else if(dmx_mode == 2)&#xD;&#xA;      {&#xD;&#xA;        _delay_us(IBG_2048);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;**myFile.ino**&#xD;&#xA;&#xD;&#xA;    /*-----------------------------------------------------------------------------&#xD;&#xA;    		include files&#xD;&#xA;    ------------------------------------------------------------------------------*/&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;Ethernet.h&gt;&#xD;&#xA;    #include &lt;EthernetUdp.h&gt;&#xD;&#xA;    #include &lt;lib_dmx.h&gt;&#xD;&#xA;    &#xD;&#xA;    #define DMX512  (0)&#xD;&#xA;    &#xD;&#xA;    byte mac[] = { 0xDD, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };&#xD;&#xA;    IPAddress ip(10,0,0,2); // TODO: assign ip address from DHCP&#xD;&#xA;    unsigned int multicastPort = 8888;&#xD;&#xA;    IPAddress multicastIp(239,0,0,57);&#xD;&#xA;    &#xD;&#xA;    char packetBuffer[UDP_TX_PACKET_MAX_SIZE];&#xD;&#xA;    &#xD;&#xA;    EthernetUDP Udp;&#xD;&#xA;    &#xD;&#xA;    int sensorValue = 0;&#xD;&#xA;    int ledState = 0;&#xD;&#xA;    int DMXPin = 0;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      &#xD;&#xA;      // DMX&#xD;&#xA;      ArduinoDmx1.set_control_pin(DMXPin);&#xD;&#xA;      ArduinoDmx1.set_rx_channels(1);&#xD;&#xA;      ArduinoDmx1.set_tx_channels(5);&#xD;&#xA;      ArduinoDmx1.init_tx(DMX512);&#xD;&#xA;      &#xD;&#xA;      Ethernet.begin(mac,ip);&#xD;&#xA;      Udp.beginMulti( multicastIp, multicastPort );&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      int packetSize = Udp.parsePacket();&#xD;&#xA;      if(packetSize){&#xD;&#xA;        Serial.print(&quot;Received packet of size &quot;);&#xD;&#xA;        Serial.println(packetSize);&#xD;&#xA;        Serial.print(&quot;From &quot;);&#xD;&#xA;        IPAddress remote = Udp.remoteIP();&#xD;&#xA;        for (int i =0; i &lt; 4; i++){&#xD;&#xA;          Serial.print(remote[i], DEC);&#xD;&#xA;          if (i &lt; 3){&#xD;&#xA;            Serial.print(&quot;.&quot;);&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;        Serial.print(&quot;, port &quot;);&#xD;&#xA;        Serial.println(Udp.remotePort());&#xD;&#xA;    &#xD;&#xA;        Udp.read(packetBuffer,UDP_TX_PACKET_MAX_SIZE);&#xD;&#xA;        Serial.println(&quot;Contents:&quot;);&#xD;&#xA;        Serial.println(packetBuffer[0]);&#xD;&#xA;        &#xD;&#xA;        ArduinoDmx1.TxBuffer[0] = (int)packetBuffer;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3836" PostHistoryTypeId="1" PostId="1344" RevisionGUID="2df22b8e-f630-437b-920f-2bbe632cb9fc" CreationDate="2014-04-30T13:20:01.850" UserId="1258" Text="Multiple definition of '__vector_36' (intterupts)" />
  <row Id="3837" PostHistoryTypeId="3" PostId="1344" RevisionGUID="2df22b8e-f630-437b-920f-2bbe632cb9fc" CreationDate="2014-04-30T13:20:01.850" UserId="1258" Text="&lt;arduino-mega&gt;&lt;interrupt&gt;" />
  <row Id="3838" PostHistoryTypeId="2" PostId="1345" RevisionGUID="91d8f0bb-e67e-4878-9783-222d4d202f7a" CreationDate="2014-04-30T15:55:48.770" UserId="1182" Text="Just for future reference if anyone needs it I got the following from SparkFun:&#xD;&#xA;&#xD;&#xA;On the Big Easy Driver Board, the Step, Dir, Sleep, Reset, and the Microstep pins are all &gt;pulled high with 20kΩ resistors, while Enable is pulled low with the same. So sleep is &gt;disabled (until explicitly enabled) and the stepper is enabled (until explicitly disabled).&#xD;&#xA;&#xD;&#xA;For much of the use of this board, there is no real need to adjust these settings, but If you &gt;want to achieve a low-power state you would pull the sleep pin low. This should disable much &gt;of the internal circuitry on the IC. In order to reduce power, Enable should be pulled high &gt;to disable the output FETs.&#xD;&#xA;To test that the sleep function is working on the chip you can just jump it to low (ground). For me it turned out to be an error with the Arduino code rather than the chip. Here is also a good reference about pull-down / pull-up resistors. http://www.bit-101.com/blog/?p=3813" />
  <row Id="3839" PostHistoryTypeId="5" PostId="1293" RevisionGUID="588b7a02-0bca-404b-a81f-86e3908c464d" CreationDate="2014-04-30T15:56:52.823" UserId="1182" Comment="deleted 989 characters in body" Text="I am currently using an Arduino Mega 2560 to run this stepper motor driver (Big Easy Driver, ROB-11876 from sparkfun) https://www.sparkfun.com/products/11876. &#xD;&#xA;&#xD;&#xA;I am trying to use the sleep or enable function on this chip to decrease the power consumption when I am not using the motor. I have all the rest of the driver working properly (steps, direction etc.) but when I hook up a wire to either the sleep or enable section and send a respective high or low it doesn't appear to do anything. (Chip works as normal, power consumption stays the same). &#xD;&#xA;&#xD;&#xA;I have tested to see that the Arduino is outputting correctly and it seems to be. But other than this I'm kinda at a loss on what might be wrong.&#xD;&#xA;&#xD;&#xA;Does anyone have any suggestions on why this might be or other things to test to try to narrow down the problem?&#xD;&#xA;&#xD;&#xA;---------------------------&#xD;&#xA;Found my answer from Sparkfun - see below" />
  <row Id="3840" PostHistoryTypeId="10" PostId="1337" RevisionGUID="8a4581d7-958b-43e8-8b13-b3eb5d7754f7" CreationDate="2014-04-30T16:27:46.103" UserId="11" Comment="102" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:65,&quot;DisplayName&quot;:&quot;AsheeshR&quot;},{&quot;Id&quot;:46,&quot;DisplayName&quot;:&quot;Ricardo&quot;},{&quot;Id&quot;:37,&quot;DisplayName&quot;:&quot;The Guy with The Hat&quot;},{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="3841" PostHistoryTypeId="5" PostId="1344" RevisionGUID="819a1934-feb3-4097-8147-ffe629bcc471" CreationDate="2014-04-30T16:27:58.773" UserId="37" Comment="improved formatting" Text="I'm having some conflicts between the core `HardwareSerial.cpp` and an external DMX library.&#xD;&#xA;&#xD;&#xA;For DMX I'm using the [Four Universes DMX 512 Library](http://www.deskontrol.net/blog/arduino-four-universes-dmx-512-library/). Using the library standalone, it all works perfectly. But when combining it with other libraries, I'm getting the error:&#xD;&#xA;&#xD;&#xA;    core.a(HardwareSerial.cpp.o): In function '__vector_36':&#xD;&#xA;    C:\Program Files (x86)\Arduino\hardware\arduino\cores\arduino/HardwareSerial.cpp:147: multiple definition of '__vector_36'&#xD;&#xA;    Dmx\lib_dmx.cpp.o:C:\Program Files (x86)\Arduino\libraries\Dmx/lib_dmx.cpp:206: first defined here&#xD;&#xA;&#xD;&#xA;The DMX library uses the UART hardware to generate the DMX signals. It supports four universes on the Arduino Mega since that has four UART hardware parts. Now, I'd like to only use the second hardware part, so the UART1. In the DMX library this is easily adjusted in the .h-file, by commenting out the non-used serial ports.&#xD;&#xA;&#xD;&#xA;The line from `lib_dmx.cpp` that is conflicting is this line:&#xD;&#xA;&#xD;&#xA;    #if defined(USE_UART1)&#xD;&#xA;    ISR (SIG_USART1_RECV)&#xD;&#xA;    {&#xD;&#xA;      ArduinoDmx1.Process_ISR_RX(1);&#xD;&#xA;    }&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;The line from `hardwareSerial.cpp` that is conflicting is in the ISR here:&#xD;&#xA;&#xD;&#xA;    #if defined(USART1_RX_vect)&#xD;&#xA;      void serialEvent1() __attribute__((weak));&#xD;&#xA;      void serialEvent1() {}&#xD;&#xA;      #define serialEvent1_implemented&#xD;&#xA;      ISR(USART1_RX_vect)&#xD;&#xA;      {&#xD;&#xA;        if (bit_is_clear(UCSR1A, UPE1)) {&#xD;&#xA;          unsigned char c = UDR1;&#xD;&#xA;          store_char(c, &amp;rx_buffer1);&#xD;&#xA;        } else {&#xD;&#xA;          unsigned char c = UDR1;&#xD;&#xA;        };&#xD;&#xA;      }&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;I have been having issues with this for a very long time and don't have a solution at hand yet. It's also a but unclear to me how the interrupts on Arduinos are arranged. I've also included the .ino I'm using currently. I'm also using another Ethernet Library than the default, one that includes multicast UDP (found [here][1]).&#xD;&#xA;&#xD;&#xA;**lib_dmx.h**&#xD;&#xA;&#xD;&#xA;    &gt; /***************************************************************************&#xD;&#xA;    &gt; *&#xD;&#xA;    &gt; * Title          : Arduino DMX512 library. 4 input/output universes.&#xD;&#xA;    &gt; * Version        : v 0.3 beta&#xD;&#xA;    &gt; * Last updated   : 07.07.2012&#xD;&#xA;    &gt; * Target         : Arduino mega 2560, Arduino mega 1280, Arduino nano (1 universe)  &#xD;&#xA;    &gt; * Author         : Toni Merino - merino.toni at gmail.com&#xD;&#xA;    &gt; * Web            : www.deskontrol.net/blog&#xD;&#xA;    &gt; *&#xD;&#xA;    &gt; * Based on ATmega8515 Dmx library written by Hendrik Hoelscher, www.hoelscher-hi.de&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; ;***************************************************************************/&#xD;&#xA;    &gt; #ifndef __INC_DMX_H&#xD;&#xA;    &gt; #define __INC_DMX_H&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; #include &lt;avr/io.h&gt;&#xD;&#xA;    &gt; #include &lt;stdint.h&gt;&#xD;&#xA;    &gt; #include &lt;avr/interrupt.h&gt;&#xD;&#xA;    &gt; #include &lt;util/delay.h&gt;&#xD;&#xA;    &gt; #if ARDUINO &gt;= 100   #include &quot;Arduino.h&quot;&#xD;&#xA;    &gt; #else    #include &quot;WProgram.h&quot;&#xD;&#xA;    &gt; #endif&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; //#define        USE_INTERBYTE_DELAY     // rare cases of equipment&#xD;&#xA;    &gt; non full DMX-512 compliant, need this&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; // *** comment UARTs not used *** //#define        USE_UART0&#xD;&#xA;    &gt; #define        USE_UART1 //#define        USE_UART2 //#define        USE_UART3&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; // New DMX modes *** EXPERIMENTAL ***&#xD;&#xA;    &gt; #define        DMX512            (0)    // DMX-512 (250 kbaud - 512 channels) Standard USITT DMX-512&#xD;&#xA;    &gt; #define        DMX1024           (1)    // DMX-1024 (500 kbaud - 1024 channels) Completely non standard - TESTED ok&#xD;&#xA;    &gt; #define        DMX2048           (2)    // DMX-2048 (1000 kbaud - 2048 channels) called by manufacturers DMX1000K, DMX 4x or DMX 1M ???&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; // DMX-512  (250 kbaud - 512 channels) Standard USITT DMX-512&#xD;&#xA;    &gt; #define        IBG_512           (10)                      // interbyte gap [us]&#xD;&#xA;    &gt; #define        DMX_512           ((F_CPU/(250000*8))-1)    // 250 kbaud&#xD;&#xA;    &gt; #define        BREAK_512         ( F_CPU/(100000*8))       // 90.9 kbaud&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; // DMX-1024 (500 kbaud - 1024 channels) Completely non standard&#xD;&#xA;    &gt; #define        IBG_1024          (5)                       // interbyte gap [us]&#xD;&#xA;    &gt; #define        DMX_1024          ((F_CPU/(500000*8))-1)    // 500 kbaud&#xD;&#xA;    &gt; #define        BREAK_1024        ( F_CPU/(200000*8))       // 181.8 kbaud&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; // DMX-2048 (1000 kbaud - 2048 channels) Non standard, but used by&#xD;&#xA;    &gt; manufacturers as DMX1000K or DMX-4x or DMX 1M ???&#xD;&#xA;    &gt; #define        IBG_2048          (2)                       // interbyte gap [us] + nop's to reach 2.5 uS&#xD;&#xA;    &gt; #define        DMX_2048          ((F_CPU/(1000000*8))-1)   // 1000 kbaud&#xD;&#xA;    &gt; #define        BREAK_2048        ( F_CPU/(400000*8))       // 363.6 kbaud&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; // Inline assembly: do nothing for one clock cycle.&#xD;&#xA;    &gt; #define        nop()             __asm__ __volatile__(&quot;nop&quot;)&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; #ifdef __cplusplus extern &quot;C&quot; {&#xD;&#xA;    &gt; #endif   #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;    &gt;     #if defined(USE_UART0)&#xD;&#xA;    &gt;       void SIG_USART0_RECV  (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;       void SIG_USART0_TRANS (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;     #endif&#xD;&#xA;    &gt;     #if defined(USE_UART1)&#xD;&#xA;    &gt;       void SIG_USART1_RECV  (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;       void SIG_USART1_TRANS (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;     #endif&#xD;&#xA;    &gt;     #if defined(USE_UART2)  &#xD;&#xA;    &gt;       void SIG_USART2_RECV  (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;       void SIG_USART2_TRANS (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;     #endif&#xD;&#xA;    &gt;     #if defined(USE_UART3)  &#xD;&#xA;    &gt;       void SIG_USART3_RECV  (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;       void SIG_USART3_TRANS (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;     #endif   #elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)&#xD;&#xA;    &gt;     #if defined(USE_UART0)&#xD;&#xA;    &gt;       void USART_RX_vect    (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;       void USART_TX_vect    (void) __attribute__((__always_inline__));&#xD;&#xA;    &gt;     #endif   #endif&#xD;&#xA;    &gt; #ifdef __cplusplus };&#xD;&#xA;    &gt; #endif&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; class CArduinoDmx  {    #if defined(__AVR_ATmega1280__) ||&#xD;&#xA;    &gt; defined(__AVR_ATmega2560__)&#xD;&#xA;    &gt;     #if defined(USE_UART0)&#xD;&#xA;    &gt;       friend void SIG_USART0_RECV  (void);&#xD;&#xA;    &gt;       friend void SIG_USART0_TRANS (void);&#xD;&#xA;    &gt;     #endif&#xD;&#xA;    &gt;     #if defined(USE_UART1)&#xD;&#xA;    &gt;       friend void SIG_USART1_RECV  (void);&#xD;&#xA;    &gt;       friend void SIG_USART1_TRANS (void);&#xD;&#xA;    &gt;     #endif&#xD;&#xA;    &gt;     #if defined(USE_UART2)  &#xD;&#xA;    &gt;       friend void SIG_USART2_RECV  (void);&#xD;&#xA;    &gt;       friend void SIG_USART2_TRANS (void);&#xD;&#xA;    &gt;     #endif&#xD;&#xA;    &gt;     #if defined(USE_UART3)  &#xD;&#xA;    &gt;       friend void SIG_USART3_RECV  (void);&#xD;&#xA;    &gt;       friend void SIG_USART3_TRANS (void);&#xD;&#xA;    &gt;     #endif   #elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)&#xD;&#xA;    &gt;     #if defined(USE_UART0)&#xD;&#xA;    &gt;       friend void USART_RX_vect    (void);&#xD;&#xA;    &gt;       friend void USART_TX_vect    (void);&#xD;&#xA;    &gt;     #endif   #endif    public:    enum {IDLE, BREAK, STARTB, STARTADR};     // RX DMX states    enum {TXBREAK, TXSTARTB, TXDATA};  &#xD;&#xA;    &gt; // TX DMX states&#xD;&#xA;    &gt;       volatile uint8_t    *RxBuffer;            // array of RX DMX values    volatile uint8_t    *TxBuffer;            // array of TX DMX&#xD;&#xA;    &gt; values&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; private:    uint8_t     gRxState;    uint8_t    *gRxPnt;    uint8_t   &#xD;&#xA;    &gt; IndicatorCount;    uint8_t     USARTstate;		    uint8_t     RxByte;   &#xD;&#xA;    &gt; uint8_t     RxState;    uint8_t     mUART;    uint8_t     gTxState;   &#xD;&#xA;    &gt; uint16_t    RxCount;    uint16_t    gCurTxCh;		    uint16_t   &#xD;&#xA;    &gt; rx_channels;                  // rx channels number    uint16_t   &#xD;&#xA;    &gt; tx_channels;                  // tx channels number    uint16_t   &#xD;&#xA;    &gt; rx_address;                   // rx start address    uint16_t   &#xD;&#xA;    &gt; tx_address;                   // tx start address    int8_t     &#xD;&#xA;    &gt; rx_led;                       // rx indicator led pin    int8_t     &#xD;&#xA;    &gt; tx_led;                       // tx indicator led pin    int8_t     &#xD;&#xA;    &gt; control_pin;                  // max485 input/output selection pin   &#xD;&#xA;    &gt; uint8_t     dmx_mode;                     // Standard USITT DMX512 =&#xD;&#xA;    &gt; 0, non standard DMX1024 = 1, non standard DMX2048 (DMX1000K) = 2   &#xD;&#xA;    &gt; uint8_t     speed_dmx;    uint8_t     speed_break;    uint16_t   &#xD;&#xA;    &gt; CurTxCh;    uint8_t     TxState;    uint8_t    *RxPnt;&#xD;&#xA;    &gt;    &#xD;&#xA;    &gt; #if defined(USE_INTERBYTE_DELAY)       void        delay_gap          ();&#xD;&#xA;    &gt; #endif&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; public:    void        stop_dmx           ();    void        set_speed&#xD;&#xA;    &gt; (uint8_t mode);    void        set_control_pin    (int8_t  pin)       &#xD;&#xA;    &gt; { control_pin     = pin;      }    void        init_rx           &#xD;&#xA;    &gt; (uint8_t mode);  // Standard USITT DMX512 = 0, non standard DMX1024 =&#xD;&#xA;    &gt; 1, non standard DMX2048 (DMX1000K) = 2    void        set_rx_address  &#xD;&#xA;    &gt; (uint16_t address)   { rx_address      = address;  }    void       &#xD;&#xA;    &gt; set_rx_channels    (uint16_t channels)  { rx_channels     = channels;&#xD;&#xA;    &gt; }    void        init_tx            (uint8_t mode);  // Standard USITT&#xD;&#xA;    &gt; DMX512 = 0, non standard DMX1024 = 1, non standard DMX2048 (DMX1000K)&#xD;&#xA;    &gt; = 2    void        set_tx_address     (uint16_t address)   { tx_address      = address;  }    void        set_tx_channels   &#xD;&#xA;    &gt; (uint16_t channels)  { tx_channels     = channels; }&#xD;&#xA;    &gt; &#xD;&#xA;    &gt;    void        attachTXInterrupt  (void (*isr)(uint8_t uart))      {&#xD;&#xA;    &gt; TXisrCallback   = isr; }   // register the user TX callback    void   &#xD;&#xA;    &gt; attachRXInterrupt  (void (*isr)(uint8_t uart))      { RXisrCallback  &#xD;&#xA;    &gt; = isr; }   // register the user RX callback&#xD;&#xA;    &gt;        //void			Process_ISR_RX(uint8_t rx_isr_number);&#xD;&#xA;    &gt; &#xD;&#xA;    &gt;    void        (*TXisrCallback)   (uint8_t uart);    void       &#xD;&#xA;    &gt; (*RXisrCallback)   (uint8_t uart);&#xD;&#xA;    &gt; &#xD;&#xA;    &gt;    inline void Process_ISR_RX     (uint8_t  rx_isr_number);    inline&#xD;&#xA;    &gt; void Process_ISR_TX     (uint8_t  tx_isr_number);    public:   &#xD;&#xA;    &gt; CArduinoDmx                    (uint8_t uart)       { rx_address     &#xD;&#xA;    &gt; = 1; &#xD;&#xA;    &gt;                                                          rx_channels     = 8;&#xD;&#xA;    &gt;                                                          tx_address      = 1; &#xD;&#xA;    &gt;                                                          tx_channels     = 8;&#xD;&#xA;    &gt;                                                          mUART           = uart; }   };&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; #if defined(USE_UART0)   extern CArduinoDmx ArduinoDmx0;&#xD;&#xA;    &gt; #endif&#xD;&#xA;    &gt; #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)   #if defined(USE_UART1)&#xD;&#xA;    &gt;     extern CArduinoDmx ArduinoDmx1;   #endif   #if defined(USE_UART2)&#xD;&#xA;    &gt;     extern CArduinoDmx ArduinoDmx2;   #endif   #if defined(USE_UART3)&#xD;&#xA;    &gt;     extern CArduinoDmx ArduinoDmx3;   #endif&#xD;&#xA;    &gt; #endif&#xD;&#xA;    &gt; &#xD;&#xA;    &gt; #endif&#xD;&#xA;&#xD;&#xA;**lib_dmx.cpp**&#xD;&#xA;&#xD;&#xA;    /***************************************************************************&#xD;&#xA;    *&#xD;&#xA;    * Title          : Arduino DMX512 library. 4 input/output universes.&#xD;&#xA;    * Version        : v 0.3 beta&#xD;&#xA;    * Last updated   : 07.07.2012&#xD;&#xA;    * Target         : Arduino mega 2560, Arduino mega 1280, Arduino nano (1 universe)  &#xD;&#xA;    * Author         : Toni Merino - merino.toni at gmail.com&#xD;&#xA;    * Web            : www.deskontrol.net/blog&#xD;&#xA;    *&#xD;&#xA;    * Based on ATmega8515 Dmx library written by Hendrik Hoelscher, www.hoelscher-hi.de&#xD;&#xA;    &#xD;&#xA;    ;***************************************************************************/&#xD;&#xA;    #include &quot;lib_dmx.h&quot;&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    &#xD;&#xA;    #if defined(USE_UART0)&#xD;&#xA;      CArduinoDmx ArduinoDmx0(0);&#xD;&#xA;    #endif&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;      #if defined(USE_UART1)&#xD;&#xA;        CArduinoDmx ArduinoDmx1(1);&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART2)&#xD;&#xA;        CArduinoDmx ArduinoDmx2(2);&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART3)&#xD;&#xA;        CArduinoDmx ArduinoDmx3(3);&#xD;&#xA;      #endif&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    // *************** DMX Transmision Initialisation ****************&#xD;&#xA;    void CArduinoDmx::init_tx(uint8_t mode)&#xD;&#xA;    {&#xD;&#xA;      cli();          //disable interrupts&#xD;&#xA;      stop_dmx();                         //stop uart&#xD;&#xA;      dmx_mode = mode;&#xD;&#xA;      set_speed(dmx_mode);&#xD;&#xA;      &#xD;&#xA;      if(control_pin != -1)&#xD;&#xA;      {&#xD;&#xA;        pinMode(control_pin,OUTPUT);        // max485 I/O control&#xD;&#xA;        digitalWrite(control_pin, HIGH);    // set 485 as output&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      if(mUART == 0)&#xD;&#xA;      {&#xD;&#xA;        pinMode(1, OUTPUT);&#xD;&#xA;        UBRR0H   = 0;&#xD;&#xA;        UBRR0L   = speed_dmx;  &#xD;&#xA;        UCSR0A  |= (1&lt;&lt;U2X0);&#xD;&#xA;        UCSR0C  |= (3&lt;&lt;UCSZ00)|(1&lt;&lt;USBS0);&#xD;&#xA;        UCSR0B  |= (1&lt;&lt;TXEN0) |(1&lt;&lt;TXCIE0);&#xD;&#xA;        UDR0     = 0;							          //start USART 0&#xD;&#xA;      }&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;      else if(mUART == 1)&#xD;&#xA;      {&#xD;&#xA;        pinMode(18, OUTPUT); &#xD;&#xA;        UBRR1H   = 0;&#xD;&#xA;        UBRR1L   = speed_dmx;   &#xD;&#xA;        UCSR1A  |= (1&lt;&lt;U2X1);&#xD;&#xA;        UCSR1C  |= (3&lt;&lt;UCSZ10)|(1&lt;&lt;USBS1);&#xD;&#xA;        UCSR1B  |= (1&lt;&lt;TXEN1) |(1&lt;&lt;TXCIE1);&#xD;&#xA;        UDR1     = 0;							          //start USART 1&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 2)&#xD;&#xA;      {&#xD;&#xA;        pinMode(16, OUTPUT); &#xD;&#xA;        UBRR2H   = 0;&#xD;&#xA;        UBRR2L   = speed_dmx;   &#xD;&#xA;        UCSR2A  |= (1&lt;&lt;U2X2);&#xD;&#xA;        UCSR2C  |= (3&lt;&lt;UCSZ20)|(1&lt;&lt;USBS2);&#xD;&#xA;        UCSR2B  |= (1&lt;&lt;TXEN2) |(1&lt;&lt;TXCIE2);&#xD;&#xA;        UDR2     = 0;							          //start USART 2&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 3)&#xD;&#xA;      {&#xD;&#xA;        pinMode(14, OUTPUT); &#xD;&#xA;        UBRR3H   = 0;&#xD;&#xA;        UBRR3L   = speed_dmx;    &#xD;&#xA;        UCSR3A  |= (1&lt;&lt;U2X3);&#xD;&#xA;        UCSR3C  |= (3&lt;&lt;UCSZ30)|(1&lt;&lt;USBS3);&#xD;&#xA;        UCSR3B  |= (1&lt;&lt;TXEN3) |(1&lt;&lt;TXCIE3);&#xD;&#xA;        UDR3     = 0;							          //start USART 3&#xD;&#xA;      }&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;      gTxState = BREAK;					                    // start with break&#xD;&#xA;      TxBuffer = (uint8_t*)malloc(tx_channels);     // allocate mem for buffer&#xD;&#xA;      memset((uint8_t*)TxBuffer, 0, tx_channels);   // fill buffer with 0's&#xD;&#xA;      sei();          //enable interrupts&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // ************************ DMX Stop ***************************&#xD;&#xA;    void CArduinoDmx::stop_dmx()&#xD;&#xA;    {&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;      if(mUART == 0)&#xD;&#xA;      {&#xD;&#xA;        UCSR0B &amp;= ~((1&lt;&lt;RXCIE0) | (1&lt;&lt;TXCIE0) | (1&lt;&lt;RXEN0) | (1&lt;&lt;TXEN0));&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 1)&#xD;&#xA;      {&#xD;&#xA;        UCSR1B &amp;= ~((1&lt;&lt;RXCIE1) | (1&lt;&lt;TXCIE1) | (1&lt;&lt;RXEN1) | (1&lt;&lt;TXEN1));&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 2)&#xD;&#xA;      {&#xD;&#xA;        UCSR2B &amp;= ~((1&lt;&lt;RXCIE2) | (1&lt;&lt;TXCIE2) | (1&lt;&lt;RXEN2) | (1&lt;&lt;TXEN2));&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 3)&#xD;&#xA;      {&#xD;&#xA;        UCSR3B &amp;= ~((1&lt;&lt;RXCIE3) | (1&lt;&lt;TXCIE3) | (1&lt;&lt;RXEN3) | (1&lt;&lt;TXEN3));&#xD;&#xA;      }&#xD;&#xA;    #elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)&#xD;&#xA;      if(mUART == 0)&#xD;&#xA;      {&#xD;&#xA;        UCSR0B &amp;= ~((1&lt;&lt;RXCIE0) | (1&lt;&lt;TXCIE0) | (1&lt;&lt;RXEN0) | (1&lt;&lt;TXEN0));&#xD;&#xA;      }&#xD;&#xA;    #endif&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // *************** DMX Reception Initialisation ****************&#xD;&#xA;    void CArduinoDmx::init_rx(uint8_t mode)&#xD;&#xA;    {&#xD;&#xA;      cli();          //disable interrupts&#xD;&#xA;      stop_dmx();&#xD;&#xA;      dmx_mode = mode;&#xD;&#xA;      set_speed(dmx_mode);&#xD;&#xA;      &#xD;&#xA;      if(control_pin != -1)&#xD;&#xA;      {&#xD;&#xA;        pinMode(control_pin,OUTPUT);        //max485 I/O control&#xD;&#xA;        digitalWrite(control_pin, LOW);     //set 485 as input&#xD;&#xA;      }&#xD;&#xA;      &#xD;&#xA;      if(mUART == 0)&#xD;&#xA;      {&#xD;&#xA;        pinMode(0, INPUT); &#xD;&#xA;        UBRR0H   = 0;&#xD;&#xA;        UBRR0L   = speed_dmx;&#xD;&#xA;        UCSR0A  |= (1&lt;&lt;U2X0);&#xD;&#xA;        UCSR0C  |= (3&lt;&lt;UCSZ00)|(1&lt;&lt;USBS0);&#xD;&#xA;        UCSR0B  |= (1&lt;&lt;RXEN0) |(1&lt;&lt;RXCIE0);&#xD;&#xA;      }&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;      else if(mUART == 1)&#xD;&#xA;      {&#xD;&#xA;        pinMode(19, INPUT); &#xD;&#xA;        UBRR1H   = 0;&#xD;&#xA;        UBRR1L   = speed_dmx;&#xD;&#xA;        UCSR1A  |= (1&lt;&lt;U2X1);&#xD;&#xA;        UCSR1C  |= (3&lt;&lt;UCSZ10)|(1&lt;&lt;USBS1);&#xD;&#xA;        UCSR1B  |= (1&lt;&lt;RXEN1) |(1&lt;&lt;RXCIE1);&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 2)&#xD;&#xA;      {&#xD;&#xA;        pinMode(17, INPUT); &#xD;&#xA;        UBRR2H   = 0;&#xD;&#xA;        UBRR2L   = speed_dmx;&#xD;&#xA;        UCSR2A  |= (1&lt;&lt;U2X2); &#xD;&#xA;        UCSR2C  |= (3&lt;&lt;UCSZ20)|(1&lt;&lt;USBS2);&#xD;&#xA;        UCSR2B  |= (1&lt;&lt;RXEN2) |(1&lt;&lt;RXCIE2);&#xD;&#xA;      }&#xD;&#xA;      else if(mUART == 3)&#xD;&#xA;      {&#xD;&#xA;        pinMode(15, INPUT); &#xD;&#xA;        UBRR3H   = 0;&#xD;&#xA;        UBRR3L   = speed_dmx; &#xD;&#xA;        UCSR3A  |= (1&lt;&lt;U2X3);&#xD;&#xA;        UCSR3C  |= (3&lt;&lt;UCSZ30)|(1&lt;&lt;USBS3);&#xD;&#xA;        UCSR3B  |= (1&lt;&lt;RXEN3) |(1&lt;&lt;RXCIE3);&#xD;&#xA;      }&#xD;&#xA;    #endif&#xD;&#xA;      &#xD;&#xA;      gRxState = IDLE;&#xD;&#xA;      RxBuffer = (uint8_t*)malloc(rx_channels);   // allocate mem for buffer&#xD;&#xA;      memset((uint8_t*)RxBuffer, 0, rx_channels); // fill buffer with 0's&#xD;&#xA;      sei();          //enable interrupts&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // *************** DMX Reception ISR ****************&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;      #if defined(USE_UART0)&#xD;&#xA;        ISR (SIG_USART0_RECV)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx0.Process_ISR_RX(0);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART1)&#xD;&#xA;        ISR (SIG_USART1_RECV)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx1.Process_ISR_RX(1);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART2)&#xD;&#xA;        ISR (SIG_USART2_RECV)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx2.Process_ISR_RX(2);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART3)&#xD;&#xA;        ISR (SIG_USART3_RECV)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx3.Process_ISR_RX(3);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;    #elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)&#xD;&#xA;      #if defined(USE_UART0)&#xD;&#xA;        ISR (USART_RX_vect)&#xD;&#xA;        {&#xD;&#xA;    		ArduinoDmx0.Process_ISR_RX(0);&#xD;&#xA;    	} &#xD;&#xA;      #endif&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    void CArduinoDmx::Process_ISR_RX(uint8_t rx_isr_number)&#xD;&#xA;    {&#xD;&#xA;      if(rx_isr_number == 0)&#xD;&#xA;      {&#xD;&#xA;        USARTstate = UCSR0A;		          //get state&#xD;&#xA;        RxByte     = UDR0;                //get data&#xD;&#xA;        RxState    = gRxState;					  //just get once from SRAM!!!&#xD;&#xA;        if (USARTstate &amp;(1&lt;&lt;FE0))         //check for break&#xD;&#xA;        {					&#xD;&#xA;          UCSR0A  &amp;= ~(1&lt;&lt;FE0);				    //reset flag&#xD;&#xA;          RxCount  = rx_address;				  //reset frame counter&#xD;&#xA;          gRxState = BREAK;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;    &#xD;&#xA;      else if(rx_isr_number == 1)&#xD;&#xA;      {&#xD;&#xA;        USARTstate = UCSR1A;		          //get state&#xD;&#xA;        RxByte     = UDR1;                //get data&#xD;&#xA;        RxState    = gRxState;					  //just get once from SRAM!!!&#xD;&#xA;        if (USARTstate &amp;(1&lt;&lt;FE1))         //check for break&#xD;&#xA;        {					&#xD;&#xA;          UCSR1A  &amp;= ~(1&lt;&lt;FE1);				    //reset flag&#xD;&#xA;          RxCount  = rx_address;				  //reset frame counter&#xD;&#xA;          gRxState = BREAK;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      else if(rx_isr_number == 2)&#xD;&#xA;      {&#xD;&#xA;        USARTstate = UCSR2A;		          //get state&#xD;&#xA;        RxByte     = UDR2;                //get data&#xD;&#xA;        RxState    = gRxState;					  //just get once from SRAM!!!&#xD;&#xA;        if (USARTstate &amp;(1&lt;&lt;FE2))         //check for break&#xD;&#xA;        {					&#xD;&#xA;          UCSR2A  &amp;= ~(1&lt;&lt;FE2);				    //reset flag&#xD;&#xA;          RxCount  = rx_address;				  //reset frame counter&#xD;&#xA;          gRxState = BREAK;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      else if(rx_isr_number == 3)&#xD;&#xA;      {&#xD;&#xA;        USARTstate = UCSR3A;		          //get state&#xD;&#xA;        RxByte     = UDR3;                //get data&#xD;&#xA;        RxState    = gRxState;					  //just get once from SRAM!!!&#xD;&#xA;        if (USARTstate &amp;(1&lt;&lt;FE3))         //check for break&#xD;&#xA;        {					&#xD;&#xA;          UCSR3A  &amp;= ~(1&lt;&lt;FE3);				    //reset flag&#xD;&#xA;          RxCount  = rx_address;				  //reset frame counter&#xD;&#xA;          gRxState = BREAK;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;      if (RxState == BREAK)&#xD;&#xA;      {&#xD;&#xA;        if (RxByte == 0) &#xD;&#xA;        {&#xD;&#xA;          gRxState = STARTB;						  //normal start code detected&#xD;&#xA;          gRxPnt   = ((uint8_t*)RxBuffer + 1);&#xD;&#xA;        }&#xD;&#xA;        else &#xD;&#xA;          gRxState = IDLE;&#xD;&#xA;      }&#xD;&#xA;      else if (RxState == STARTB)&#xD;&#xA;      {&#xD;&#xA;        if (--RxCount == 0)						    //start address reached?&#xD;&#xA;        {&#xD;&#xA;          gRxState   = STARTADR;&#xD;&#xA;          RxBuffer[0]= RxByte;&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      else if (RxState == STARTADR)&#xD;&#xA;      {&#xD;&#xA;        RxPnt  = gRxPnt;&#xD;&#xA;        *RxPnt = RxByte;&#xD;&#xA;        if (++RxPnt &gt;= (RxBuffer + rx_channels)) 	//all ch received?&#xD;&#xA;        {&#xD;&#xA;          gRxState= IDLE;&#xD;&#xA;          if (*RXisrCallback) RXisrCallback(mUART);   // fire callback for read data&#xD;&#xA;        }&#xD;&#xA;        else &#xD;&#xA;        {&#xD;&#xA;          gRxPnt = RxPnt;&#xD;&#xA;        }&#xD;&#xA;      }							&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // *************** DMX Transmision ISR ****************&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;      #if defined(USE_UART0)&#xD;&#xA;        ISR(SIG_USART0_TRANS)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx0.Process_ISR_TX(0);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART1)&#xD;&#xA;        ISR(SIG_USART1_TRANS)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx1.Process_ISR_TX(1);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART2)&#xD;&#xA;        ISR(SIG_USART2_TRANS)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx2.Process_ISR_TX(2);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;      #if defined(USE_UART3)&#xD;&#xA;        ISR(SIG_USART3_TRANS)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx3.Process_ISR_TX(3);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;    #elif defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__)&#xD;&#xA;      #if defined(USE_UART0)&#xD;&#xA;        ISR(USART_TX_vect)&#xD;&#xA;        {&#xD;&#xA;          ArduinoDmx0.Process_ISR_TX(0);&#xD;&#xA;        }&#xD;&#xA;      #endif&#xD;&#xA;    #endif&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void CArduinoDmx::Process_ISR_TX(uint8_t tx_isr_number)&#xD;&#xA;    {&#xD;&#xA;      TxState = gTxState;&#xD;&#xA;      &#xD;&#xA;      if(tx_isr_number == 0)&#xD;&#xA;      {&#xD;&#xA;        if (TxState == TXBREAK) //BREAK + MAB&#xD;&#xA;        {&#xD;&#xA;          UBRR0H   = 0;&#xD;&#xA;          UBRR0L   = speed_break;&#xD;&#xA;          UDR0     = 0;								    //send break&#xD;&#xA;          gTxState = TXSTARTB;&#xD;&#xA;        }&#xD;&#xA;        else if (TxState == TXSTARTB)&#xD;&#xA;        {&#xD;&#xA;          UBRR0H   = 0;&#xD;&#xA;          UBRR0L   = speed_dmx;&#xD;&#xA;          UDR0     = 0;								    //send start byte&#xD;&#xA;          gTxState = TXDATA;&#xD;&#xA;          gCurTxCh = 0;&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;          #if defined(USE_INTERBYTE_DELAY)&#xD;&#xA;            delay_gap();&#xD;&#xA;          #endif    &#xD;&#xA;          CurTxCh = gCurTxCh;&#xD;&#xA;          UDR0 = TxBuffer[CurTxCh++];				//send data&#xD;&#xA;          if (CurTxCh == tx_channels)&#xD;&#xA;          {&#xD;&#xA;            if (*TXisrCallback) TXisrCallback(0); // fire callback for update data&#xD;&#xA;            gTxState = TXBREAK;   // new break if all ch sent&#xD;&#xA;          }&#xD;&#xA;          else &#xD;&#xA;          {&#xD;&#xA;            gCurTxCh = CurTxCh;&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)&#xD;&#xA;    &#xD;&#xA;      else if(tx_isr_number == 1)&#xD;&#xA;      {&#xD;&#xA;        if (TxState == TXBREAK)&#xD;&#xA;        {&#xD;&#xA;          UBRR1H   = 0;&#xD;&#xA;          UBRR1L   = speed_break;&#xD;&#xA;          UDR1     = 0;								    //send break&#xD;&#xA;          gTxState = TXSTARTB;&#xD;&#xA;        }&#xD;&#xA;        else if (TxState == TXSTARTB)&#xD;&#xA;        {&#xD;&#xA;          UBRR1H   = 0;&#xD;&#xA;          UBRR1L   = speed_dmx;&#xD;&#xA;          UDR1     = 0;								    //send start byte&#xD;&#xA;          gTxState = TXDATA;&#xD;&#xA;          gCurTxCh = 0;&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;          #if defined(USE_INTERBYTE_DELAY)&#xD;&#xA;            delay_gap();&#xD;&#xA;          #endif    &#xD;&#xA;          CurTxCh = gCurTxCh;&#xD;&#xA;          UDR1 = TxBuffer[CurTxCh++];				//send data&#xD;&#xA;          if (CurTxCh == tx_channels)&#xD;&#xA;          {&#xD;&#xA;            if (*TXisrCallback) TXisrCallback(1); // fire callback for update data&#xD;&#xA;            gTxState = TXBREAK;   // new break if all ch sent&#xD;&#xA;          }&#xD;&#xA;          else &#xD;&#xA;          {&#xD;&#xA;            gCurTxCh = CurTxCh;&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      else if(tx_isr_number == 2)&#xD;&#xA;      {&#xD;&#xA;        if (TxState == TXBREAK)&#xD;&#xA;        {&#xD;&#xA;          UBRR2H   = 0;&#xD;&#xA;          UBRR2L   = speed_break;&#xD;&#xA;          UDR2     = 0;								    //send break&#xD;&#xA;          gTxState = TXSTARTB;&#xD;&#xA;        }&#xD;&#xA;        else if (TxState == TXSTARTB)&#xD;&#xA;        {&#xD;&#xA;          UBRR2H   = 0;&#xD;&#xA;          UBRR2L   = speed_dmx;&#xD;&#xA;          UDR2     = 0;								    //send start byte&#xD;&#xA;          gTxState = TXDATA;&#xD;&#xA;          gCurTxCh = 0;&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;          #if defined(USE_INTERBYTE_DELAY)&#xD;&#xA;            delay_gap();&#xD;&#xA;          #endif   &#xD;&#xA;          CurTxCh = gCurTxCh;&#xD;&#xA;          UDR2 = TxBuffer[CurTxCh++];				//send data&#xD;&#xA;          if (CurTxCh == tx_channels)&#xD;&#xA;          {&#xD;&#xA;            if (*TXisrCallback) TXisrCallback(2); // fire callback for update data&#xD;&#xA;            gTxState = TXBREAK;   // new break if all ch sent&#xD;&#xA;          }&#xD;&#xA;          else &#xD;&#xA;          {&#xD;&#xA;            gCurTxCh = CurTxCh;&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;      else if(tx_isr_number == 3)&#xD;&#xA;      {&#xD;&#xA;        if (TxState == TXBREAK)&#xD;&#xA;        {&#xD;&#xA;          UBRR3H   = 0;&#xD;&#xA;          UBRR3L   = speed_break;&#xD;&#xA;          UDR3     = 0;								    //send break&#xD;&#xA;          gTxState = TXSTARTB;&#xD;&#xA;        }&#xD;&#xA;        else if (TxState == TXSTARTB)&#xD;&#xA;        {&#xD;&#xA;          UBRR3H   = 0;&#xD;&#xA;          UBRR3L   = speed_dmx;&#xD;&#xA;          UDR3     = 0;								    //send start byte&#xD;&#xA;          gTxState = TXDATA;&#xD;&#xA;          gCurTxCh = 0;&#xD;&#xA;        }&#xD;&#xA;        else&#xD;&#xA;        {&#xD;&#xA;          #if defined(USE_INTERBYTE_DELAY)&#xD;&#xA;            delay_gap();&#xD;&#xA;          #endif&#xD;&#xA;          CurTxCh = gCurTxCh;&#xD;&#xA;          UDR3 = TxBuffer[CurTxCh++];				//send data&#xD;&#xA;          if (CurTxCh == tx_channels)&#xD;&#xA;          {&#xD;&#xA;            if (*TXisrCallback) TXisrCallback(3); // fire callback for update data&#xD;&#xA;            gTxState = TXBREAK;   // new break if all ch sent&#xD;&#xA;          }&#xD;&#xA;          else &#xD;&#xA;          {&#xD;&#xA;            gCurTxCh = CurTxCh;&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    #endif&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void CArduinoDmx::set_speed(uint8_t mode)&#xD;&#xA;    {&#xD;&#xA;      if(mode == 0)&#xD;&#xA;      {&#xD;&#xA;        speed_dmx   = DMX_512;    // DMX-512  (250 kbaud - 512 channels) Standard USITT DMX-512&#xD;&#xA;        speed_break = BREAK_512;&#xD;&#xA;      }&#xD;&#xA;      else if(mode == 1)&#xD;&#xA;      {&#xD;&#xA;        speed_dmx   = DMX_1024;	  // DMX-1024 (500 kbaud - 1024 channels) Completely non standard, but usefull ;)&#xD;&#xA;        speed_break = BREAK_1024;&#xD;&#xA;      }&#xD;&#xA;      else if(mode == 2)&#xD;&#xA;      {&#xD;&#xA;        speed_dmx   = DMX_2048;   // DMX-2048 (1000 kbaud - 2048 channels) Used by manufacturers as DMX1000K, DMX-4x or DMX-1M ???&#xD;&#xA;        speed_break = BREAK_2048;&#xD;&#xA;      }  &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    #if defined(USE_INTERBYTE_DELAY)&#xD;&#xA;    &#xD;&#xA;    void CArduinoDmx::delay_gap() // rare cases of equipment non full DMX-512 compliant, need this&#xD;&#xA;    {&#xD;&#xA;      if(dmx_mode == 0)&#xD;&#xA;      {&#xD;&#xA;        _delay_us(IBG_512);&#xD;&#xA;      }&#xD;&#xA;      else if(dmx_mode == 1)&#xD;&#xA;      {&#xD;&#xA;        _delay_us(IBG_1024);&#xD;&#xA;      }&#xD;&#xA;      else if(dmx_mode == 2)&#xD;&#xA;      {&#xD;&#xA;        _delay_us(IBG_2048);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    #endif&#xD;&#xA;&#xD;&#xA;**myFile.ino**&#xD;&#xA;&#xD;&#xA;    /*-----------------------------------------------------------------------------&#xD;&#xA;    		include files&#xD;&#xA;    ------------------------------------------------------------------------------*/&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;    #include &lt;Ethernet.h&gt;&#xD;&#xA;    #include &lt;EthernetUdp.h&gt;&#xD;&#xA;    #include &lt;lib_dmx.h&gt;&#xD;&#xA;    &#xD;&#xA;    #define DMX512  (0)&#xD;&#xA;    &#xD;&#xA;    byte mac[] = { 0xDD, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };&#xD;&#xA;    IPAddress ip(10,0,0,2); // TODO: assign ip address from DHCP&#xD;&#xA;    unsigned int multicastPort = 8888;&#xD;&#xA;    IPAddress multicastIp(239,0,0,57);&#xD;&#xA;    &#xD;&#xA;    char packetBuffer[UDP_TX_PACKET_MAX_SIZE];&#xD;&#xA;    &#xD;&#xA;    EthernetUDP Udp;&#xD;&#xA;    &#xD;&#xA;    int sensorValue = 0;&#xD;&#xA;    int ledState = 0;&#xD;&#xA;    int DMXPin = 0;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;      &#xD;&#xA;      // DMX&#xD;&#xA;      ArduinoDmx1.set_control_pin(DMXPin);&#xD;&#xA;      ArduinoDmx1.set_rx_channels(1);&#xD;&#xA;      ArduinoDmx1.set_tx_channels(5);&#xD;&#xA;      ArduinoDmx1.init_tx(DMX512);&#xD;&#xA;      &#xD;&#xA;      Ethernet.begin(mac,ip);&#xD;&#xA;      Udp.beginMulti( multicastIp, multicastPort );&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;      int packetSize = Udp.parsePacket();&#xD;&#xA;      if(packetSize){&#xD;&#xA;        Serial.print(&quot;Received packet of size &quot;);&#xD;&#xA;        Serial.println(packetSize);&#xD;&#xA;        Serial.print(&quot;From &quot;);&#xD;&#xA;        IPAddress remote = Udp.remoteIP();&#xD;&#xA;        for (int i =0; i &lt; 4; i++){&#xD;&#xA;          Serial.print(remote[i], DEC);&#xD;&#xA;          if (i &lt; 3){&#xD;&#xA;            Serial.print(&quot;.&quot;);&#xD;&#xA;          }&#xD;&#xA;        }&#xD;&#xA;        Serial.print(&quot;, port &quot;);&#xD;&#xA;        Serial.println(Udp.remotePort());&#xD;&#xA;    &#xD;&#xA;        Udp.read(packetBuffer,UDP_TX_PACKET_MAX_SIZE);&#xD;&#xA;        Serial.println(&quot;Contents:&quot;);&#xD;&#xA;        Serial.println(packetBuffer[0]);&#xD;&#xA;        &#xD;&#xA;        ArduinoDmx1.TxBuffer[0] = (int)packetBuffer;&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/aallan/Arduino" />
  <row Id="3842" PostHistoryTypeId="24" PostId="1344" RevisionGUID="819a1934-feb3-4097-8147-ffe629bcc471" CreationDate="2014-04-30T16:27:58.773" Comment="Proposed by 37 approved by 46, 11 edit id of 294" />
  <row Id="3843" PostHistoryTypeId="5" PostId="1335" RevisionGUID="d91b1173-188d-46ac-bf80-42f9a9c59701" CreationDate="2014-04-30T18:43:34.997" UserId="84" Comment="added 707 characters in body" Text="This variable is declared `volatile` which is generally meaning that it can be modified by an **Interrupt Service Routine** (**ISR**).&#xD;&#xA;&#xD;&#xA;So it is perfectly possible that this ISR gets called before your `setup()` function gets called and then it may modify this variable.&#xD;&#xA;&#xD;&#xA;In C and C++, variables defined as `type variable = xxx;` are guaranteed to be initialized before any of your code starts to run.&#xD;&#xA;&#xD;&#xA;So this means you must look for the root of the problem somewhere else.&#xD;&#xA;&#xD;&#xA;Don't forget that it is perfectly possible that some code gets run before `setup()` is called.&#xD;&#xA;&#xD;&#xA;You may try to search for the code that runs before `setup()`; unfortunately it can be hard to find out this code:&#xD;&#xA;&#xD;&#xA;Indeed, in C++, there are a lot of possibilities for code to execute even before the `main()` function gets called; for instance, declaring an instance of a class as a global variable, will call the class **constructor** before `main()`.&#xD;&#xA;&#xD;&#xA;So you would have to **find out all class instances declared as global variables** in all source files, and then check the class constructor that gets called for each instance.&#xD;&#xA;&#xD;&#xA;Another way could be to check the assembly produced for your program and find all calls occurring be fore `main()`, but it can be harder if you can't read assembly." />
  <row Id="3844" PostHistoryTypeId="2" PostId="1346" RevisionGUID="3914447e-6b89-43c9-b362-c9fd291005e5" CreationDate="2014-04-30T21:10:34.103" UserId="-1" Text="" />
  <row Id="3845" PostHistoryTypeId="2" PostId="1347" RevisionGUID="73afc116-f471-4b7b-947b-44628ad34908" CreationDate="2014-04-30T21:10:34.103" UserId="-1" Text="" />
  <row Id="3846" PostHistoryTypeId="2" PostId="1348" RevisionGUID="db0874c0-6fb2-4408-81aa-4bbfb60a00df" CreationDate="2014-04-30T21:32:45.820" UserId="1265" Text="According to [this][1]:&#xD;&#xA;&#xD;&#xA;&gt; The Servo library supports up to 12 motors on most Arduino boards and&#xD;&#xA;&gt; 48 on the Arduino Mega. On boards other than the Mega, use of the&#xD;&#xA;&gt; library disables analogWrite() (PWM) functionality on pins 9 and 10,&#xD;&#xA;&gt; whether or not there is a Servo on those pins. On the Mega, up to 12&#xD;&#xA;&gt; servos can be used without interfering with PWM functionality; use of&#xD;&#xA;&gt; 12 to 23 motors will disable PWM on pins 11 and 12.&#xD;&#xA;&#xD;&#xA;However, according to [this][2]:&#xD;&#xA;&#xD;&#xA;&gt; Digital I/O Pins 14 (of which 6 provide PWM output)&#xD;&#xA;&#xD;&#xA;So how can the Uno control more than 6 servos if it only has 6 digital I/O pins that can provide PWM output?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/reference/servo&#xD;&#xA;  [2]: http://arduino.cc/en/Main/ArduinoBoardUno" />
  <row Id="3847" PostHistoryTypeId="1" PostId="1348" RevisionGUID="db0874c0-6fb2-4408-81aa-4bbfb60a00df" CreationDate="2014-04-30T21:32:45.820" UserId="1265" Text="How can the Arduino Uno support up to 12 servos if it only has 6 digital PWM pins?" />
  <row Id="3848" PostHistoryTypeId="3" PostId="1348" RevisionGUID="db0874c0-6fb2-4408-81aa-4bbfb60a00df" CreationDate="2014-04-30T21:32:45.820" UserId="1265" Text="&lt;arduino-uno&gt;&lt;motor&gt;&lt;servo&gt;" />
  <row Id="3849" PostHistoryTypeId="6" PostId="1348" RevisionGUID="5f2efc68-37b3-4c4c-ab97-59e3653808b4" CreationDate="2014-04-30T21:44:14.990" UserId="1265" Comment="edited tags" Text="&lt;arduino-uno&gt;&lt;pins&gt;&lt;motor&gt;&lt;pwm&gt;&lt;servo&gt;" />
  <row Id="3850" PostHistoryTypeId="5" PostId="1347" RevisionGUID="1b25fd4c-7d0b-44c2-9741-449331cff8fe" CreationDate="2014-04-30T22:03:43.723" UserId="1263" Comment="added 357 characters in body" Text="Arduino Pro Mini is a microcontroller board based on the ATmega168. With 14 digital io pins. Eight are analog inputs, six are capable of PWM output. Programming and power is done via a six pin header which can be connected to a FTDI cable. The official board was designed and is manufactured by SparkFun Electronics, however there are many clones out there." />
  <row Id="3851" PostHistoryTypeId="24" PostId="1347" RevisionGUID="1b25fd4c-7d0b-44c2-9741-449331cff8fe" CreationDate="2014-04-30T22:03:43.723" Comment="Proposed by 1263 approved by 220 edit id of 295" />
  <row Id="3852" PostHistoryTypeId="2" PostId="1349" RevisionGUID="781abd90-4410-4502-9afe-5d99689d5a4e" CreationDate="2014-04-30T22:13:23.090" UserId="220" Text="Although I haven't looked at the source myself, in these types of situations they usually use the **[interrupt timers](http://playground.arduino.cc/Code/Timer1) *associated* with 9 and 10.** This would explain why you can't use pulse width modulation on those pins. In fact, you can use any of those three &quot;special register&quot; pins for [a digital pin, although it's not as good as the built in PWM options](http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM).&#xD;&#xA;&#xD;&#xA;&gt;&lt;img src=&quot;http://bansky.net/blog_stuff/images/servo_pulse_width.png&quot;&gt;&#xD;&#xA;&#xD;&#xA;*([Source](http://forum.arduino.cc/index.php/topic,14146.0.html))*&#xD;&#xA;&#xD;&#xA;The above image accurately describes how the signals are sent to the servo motor. Such a waveform is similar to a standard PWM. The servo library can translate a degree to a waveform that the servo's IC will be able to use to adjust the motor's position with it's motor and potentiometer." />
  <row Id="3853" PostHistoryTypeId="2" PostId="1350" RevisionGUID="2c5c92e7-4b54-4e09-a89b-b5996b18c254" CreationDate="2014-04-30T23:26:24.813" UserId="220" Text="Your design suffers several redundancies that should be fixed. First of all, you have an Xbee (only one, not a pair) *and* a a 433 MHz transmitter/receiver combo. **Why not just add another Xbee to the drone and remove the RF combo?** That would save a little battery life, and a lot of your time. You'll also get two way communication with error checking. Although it would increase your project size a little bit, if you manually wired it (3.3V), it would save a lot of space.&#xD;&#xA;&#xD;&#xA;As some people point out, Bluetooth is a viable option that's fairly small and low cost. However, it would suffer shorter ranges and it would need a special configuration on the host side for a BT stack." />
  <row Id="3854" PostHistoryTypeId="5" PostId="1349" RevisionGUID="02641e1e-8219-4729-87a3-f48f3c34a902" CreationDate="2014-05-01T00:34:50.723" UserId="353" Comment="Edited to clarify that there's a single timer controlling pins 9 and 10" Text="Although I haven't looked at the source myself, in these types of situations they usually use [interrupt timer 1](http://playground.arduino.cc/Code/Timer1), which in PWM mode would have been associated with pins 9 and 10. This would explain why you can't use pulse width modulation on those pins. In fact, you can use any of those three &quot;special register&quot; pins for [a digital pin, although it's not as good as the built in PWM options](http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM).&#xD;&#xA;&#xD;&#xA;&gt;&lt;img src=&quot;http://bansky.net/blog_stuff/images/servo_pulse_width.png&quot;&gt;&#xD;&#xA;&#xD;&#xA;*([Source](http://forum.arduino.cc/index.php/topic,14146.0.html))*&#xD;&#xA;&#xD;&#xA;The above image accurately describes how the signals are sent to the servo motor. Such a waveform is similar to a standard PWM. The servo library can translate a degree to a waveform that the servo's IC will be able to use to adjust the motor's position with it's motor and potentiometer." />
  <row Id="3855" PostHistoryTypeId="24" PostId="1349" RevisionGUID="02641e1e-8219-4729-87a3-f48f3c34a902" CreationDate="2014-05-01T00:34:50.723" Comment="Proposed by 353 approved by 220 edit id of 296" />
  <row Id="3856" PostHistoryTypeId="5" PostId="1349" RevisionGUID="16cff669-021d-4026-a279-5dcb13d17775" CreationDate="2014-05-01T00:38:45.490" UserId="220" Comment="deleted 6 characters in body" Text="Although I haven't looked at the source myself, in these types of situations they usually use [interrupt timer 1](http://playground.arduino.cc/Code/Timer1), which in PWM mode would have been associated with pins 9 and 10. This would explain why you can't use pulse width modulation on those pins. In fact, you can use any of those three PWM pins for PWM [on any digital pin, although it's not as good as the built in PWM options](http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM).&#xD;&#xA;&#xD;&#xA;&gt;&lt;img src=&quot;http://bansky.net/blog_stuff/images/servo_pulse_width.png&quot;&gt;&#xD;&#xA;&#xD;&#xA;*([Source](http://forum.arduino.cc/index.php/topic,14146.0.html))*&#xD;&#xA;&#xD;&#xA;The above image accurately describes how the signals are sent to the servo motor. Such a waveform is similar to a standard PWM. The servo library can translate a degree to a waveform that the servo's IC will be able to use to adjust the motor's position with it's motor and potentiometer." />
  <row Id="3857" PostHistoryTypeId="5" PostId="1349" RevisionGUID="b2f35222-90fe-415f-97ec-7a3add7d4f03" CreationDate="2014-05-01T00:52:51.767" UserId="353" Comment="Edited to clarify that it's timers, not &quot;PWM pins&quot;, that do PWM." Text="Although I haven't looked at the source myself, in these types of situations they usually use [interrupt timer 1](http://playground.arduino.cc/Code/Timer1), which in PWM mode would have been associated with pins 9 and 10. This would explain why you can't use pulse width modulation on those pins. In fact, you can use any of the three timers for PWM [on any digital pin, although it's not as good as the built in PWM options](http://arduino.cc/en/Tutorial/SecretsOfArduinoPWM).&#xD;&#xA;&#xD;&#xA;&gt;&lt;img src=&quot;http://bansky.net/blog_stuff/images/servo_pulse_width.png&quot;&gt;&#xD;&#xA;&#xD;&#xA;*([Source](http://forum.arduino.cc/index.php/topic,14146.0.html))*&#xD;&#xA;&#xD;&#xA;The above image accurately describes how the signals are sent to the servo motor. Such a waveform is similar to a standard PWM. The servo library can translate a degree to a waveform that the servo's IC will be able to use to adjust the motor's position with it's motor and potentiometer." />
  <row Id="3858" PostHistoryTypeId="24" PostId="1349" RevisionGUID="b2f35222-90fe-415f-97ec-7a3add7d4f03" CreationDate="2014-05-01T00:52:51.767" Comment="Proposed by 353 approved by 11 edit id of 297" />
  <row Id="3859" PostHistoryTypeId="5" PostId="1343" RevisionGUID="f3a6ebc1-e99e-4402-a498-50b1cc4d51ca" CreationDate="2014-05-01T11:09:14.633" UserId="1238" Comment="added 182 characters in body" Text="The problem of this version of Marlin can be shown in the following piece of code (which is inside `EEPROM_RetrieveSettings` function):&#xD;&#xA;&#xD;&#xA;      for (short i=0;i&lt;4;i++) &#xD;&#xA;      {&#xD;&#xA;        axis_steps_per_unit[i]=tmp1[i];  &#xD;&#xA;        max_feedrate[i]=tmp2[i];&#xD;&#xA;        max_acceleration_units_per_sq_second[i]=tmp3[i];&#xD;&#xA;        max_length[i]=tmp4[i];&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;Here `max_length` is an array of 3 elements, not 4 (the X,Y and Z axes have a max length to avoid hitting the edge, but the extrude axis do not have such a limit - you should be able to extrude as many filament as you can supply), so the last statement in the loop overrides other variable(s).&#xD;&#xA;&#xD;&#xA;The solution is &#xD;&#xA;&#xD;&#xA;      for (short i=0;i&lt;4;i++) &#xD;&#xA;      {&#xD;&#xA;        axis_steps_per_unit[i]=tmp1[i];  &#xD;&#xA;        max_feedrate[i]=tmp2[i];&#xD;&#xA;        max_acceleration_units_per_sq_second[i]=tmp3[i];&#xD;&#xA;        if(i&lt;3)&#xD;&#xA;            max_length[i]=tmp4[i];&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;Or&#xD;&#xA;&#xD;&#xA;      for (short i=0;i&lt;4;i++) &#xD;&#xA;      {&#xD;&#xA;        axis_steps_per_unit[i]=tmp1[i];  &#xD;&#xA;        max_feedrate[i]=tmp2[i];&#xD;&#xA;        max_acceleration_units_per_sq_second[i]=tmp3[i];&#xD;&#xA;        if(i &lt; sizeof(tmp4)/sizeof(tmp4[0]))&#xD;&#xA;            max_length[i]=tmp4[i];&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;Greate thanks to the answer writer and commenter. Without your help I couldn't follow the right track. " />
  <row Id="3860" PostHistoryTypeId="5" PostId="1332" RevisionGUID="13fa198d-275b-404c-bde1-a8aa4d4d10c9" CreationDate="2014-05-01T11:11:16.773" UserId="1238" Comment="deleted 4 characters in body" Text="I am tracking a bug in the [Marlin][1] source code. &#xD;&#xA;&#xD;&#xA;**Background**&#xD;&#xA;&#xD;&#xA;Just for those who is not familiar with Reprap 3D printer and G-code. Marlin is a firmware that control a Reprap 3D printer. It receives G-code from a host computer (or read from SD card). Here the important thing is that if you send &quot;M114&quot; command it would report information about axis positions. Here, I extended this command to make it print some internal variable as well.&#xD;&#xA;&#xD;&#xA;**The Problem** &#xD;&#xA;&#xD;&#xA;In Marlin.ino file there is a line says:&#xD;&#xA;&#xD;&#xA;    volatile int extrudemultiply=100; //100-&gt;1 200-&gt;2&#xD;&#xA;&#xD;&#xA;However my Reprap keep extruding (and worse, ejecting back) a huge amount of filament. So I added some debug output for `M114` command to output this value. It turn out this value is not the default value 100, but something like 12374.&#xD;&#xA;&#xD;&#xA;I thought somewhere inside `setup()` function this value might changed. So I defined another variable&#xD;&#xA;&#xD;&#xA;    volatile int orig_extrudemultiply=100;&#xD;&#xA;&#xD;&#xA;and then at the first line of `setup()` function I add the following line&#xD;&#xA;&#xD;&#xA;    orig_extrudemultiply = extrudemultiply;&#xD;&#xA;&#xD;&#xA;Finally I output this value for `M114` command. Still, it is not 100. So it looks like the default value is not effective.&#xD;&#xA;&#xD;&#xA;**The Question**&#xD;&#xA;&#xD;&#xA;Although I have experience in C programming, I am new to the Arduino development. So my question is: how global variable being initialized in Arduino? In my case, what is the proper way to initialize this value?&#xD;&#xA;&#xD;&#xA;**Versioning**&#xD;&#xA;&#xD;&#xA;I originally posted the official [Marlin][2] link for the reference. However,&#xD;&#xA;the version I actually use is [this fork][1] from Reprap Pro team. I was just following the [Melzi][3] entry of Reprap wiki, because my board is Melzi. I am not sure weather the latest version of Marlin work for my board.&#xD;&#xA;&#xD;&#xA;**Further detail**&#xD;&#xA;&#xD;&#xA;As the commenter said, the first thing I though of is memory corruption. So I wanted to narrow the problem down. Since that value is configurable through `M302 SXXX` command, I tested this command works without difficulty. This means there is nothing in the `loop` function or the ISRs can affect this value when it is running stably. So I consider the problem must be in `setup` function or earlier. &#xD;&#xA;&#xD;&#xA;Further test shows that setting this value at the end of `setup` or even at the beginning of `setup` still works fine. This means the `setup` function may not be the problematic one. The test in &quot;The Problem&quot; session was the last step, which, in my opinion, means the course of the problem must being run before entering `setup`.&#xD;&#xA;&#xD;&#xA;**UPDATE**&#xD;&#xA;&#xD;&#xA;Further examination shows that although it looks like works when I set the default value in the first line of `setup()`, but that it is just luckily being 100. So once I add more padding variables it stops working until I move the default setting after the following line in `setup()`:&#xD;&#xA;    &#xD;&#xA;    EEPROM_RetrieveSettings(); // loads data from EEPROM if available&#xD;&#xA;&#xD;&#xA;However, since I `grep`ed for `extrudemultiply` before any test and I didn't figure out this function, this function should not change this value. I guess there are some data overflow inside this function, so the value was changed expectationally.&#xD;&#xA;&#xD;&#xA;I got to figure out what is wrong in this function.&#xD;&#xA;&#xD;&#xA;  [1]: https://github.com/reprappro/Marlin&#xD;&#xA;  [2]: https://github.com/ErikZalm/Marlin&#xD;&#xA;  [3]: http://reprap.org/wiki/Melzi#Melzi_Arduino_Pin_Numbers" />
  <row Id="3861" PostHistoryTypeId="2" PostId="1351" RevisionGUID="ded6431b-3283-46fe-921c-a0b80fafa7b1" CreationDate="2014-05-01T13:24:37.817" UserId="1230" Text="My Arduino UNO board is part of a small robot that works when connected to the laptop by USB but it does not when plugged to the batteries. The baterries plug seems okay, it outputs 7.8 V. My UNO is connected to an ArduMoto board that manages the robot motors as well as a bluetooth chip. I have little experience with Arduino or electronics in general so I am stuck on the best course of action.&#xD;&#xA;&#xD;&#xA;1) Can I find out what is wrong with the power supply without completely isolating UNO from the robot?&#xD;&#xA;&#xD;&#xA;2) If I separate UNO, how can I find out with certainty if my UNO power supply is damaged or not? Is there something in particular that I could measure with my multimeter?" />
  <row Id="3862" PostHistoryTypeId="1" PostId="1351" RevisionGUID="ded6431b-3283-46fe-921c-a0b80fafa7b1" CreationDate="2014-05-01T13:24:37.817" UserId="1230" Text="Arduino Uno works from when connected to laptop but not from baterries" />
  <row Id="3863" PostHistoryTypeId="3" PostId="1351" RevisionGUID="ded6431b-3283-46fe-921c-a0b80fafa7b1" CreationDate="2014-05-01T13:24:37.817" UserId="1230" Text="&lt;arduino-uno&gt;&lt;power&gt;" />
  <row Id="3864" PostHistoryTypeId="2" PostId="1352" RevisionGUID="e9a305ea-56bc-4c79-aaca-1c19783cdf77" CreationDate="2014-05-01T13:45:07.680" UserId="353" Text="It seems that, from the discussion on the page you link to, the author of the DMX Library himself is not sure how to get this to run.&#xD;&#xA;&#xD;&#xA;The easiest solution, it seems to me, is to modify HardwareSerial.cpp in your Arduino core to no longer use that interrupt vector." />
  <row Id="3866" PostHistoryTypeId="2" PostId="1354" RevisionGUID="5d5daec1-2f0e-42db-8af5-7d5c5697f5a3" CreationDate="2014-05-01T16:23:45.310" UserId="497" Text="Try this:&#xD;&#xA;&#xD;&#xA;    unsigned long pressureOnTime; //millis() time when pressure switch is first turned on&#xD;&#xA;    &#xD;&#xA;    const unsigned long ledOnAfterTimeThreshold = 300000; //5 minutes * 60 sec * 1000 mSec&#xD;&#xA;    int pressureThreshold = 1; //minimum analog reading from pressure sensor considered to be &quot;on&quot;&#xD;&#xA;&#xD;&#xA;    const int fsrAnalogePin = 0; &#xD;&#xA;    const int ledPin = 11; &#xD;&#xA;    &#xD;&#xA;    int ledState = LOW;&#xD;&#xA;    int pressureState = LOW;&#xD;&#xA;    &#xD;&#xA;    void setup() {&#xD;&#xA;    	Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;    	checkPressureSwitch();	&#xD;&#xA;    &#xD;&#xA;    	//do other stuff here&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void checkPressureSwitch() {&#xD;&#xA;    	if( analogRead(fsrAnalogePin) &gt;=  pressureThreshold ) &#xD;&#xA;    	{&#xD;&#xA;    		handlePressureOn();&#xD;&#xA;    	}&#xD;&#xA;    	else &#xD;&#xA;    	{&#xD;&#xA;    		handlePressureOff();&#xD;&#xA;    	}&#xD;&#xA;    &#xD;&#xA;    	digitalWrite(ledPin, ledState);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void handlePressureOn() {&#xD;&#xA;    	if ( pressureState == LOW )&#xD;&#xA;    	{&#xD;&#xA;    		//pressure switch was off, but is now on&#xD;&#xA;    		pressureOnTime = millis();&#xD;&#xA;    		pressureState = HIGH;&#xD;&#xA;    	}&#xD;&#xA;    	&#xD;&#xA;    	else if ( millis() - pressureOnTime &gt;= ledOnAfterTimeTheshold ) &#xD;&#xA;    	{&#xD;&#xA;    		ledState = HIGH;&#xD;&#xA;    	}&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void handlePressureOff() {&#xD;&#xA;    	ledState = LOW;&#xD;&#xA;    	pressureState = LOW;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3867" PostHistoryTypeId="36" PostId="1355" RevisionGUID="7456453f-89fd-4dfb-91a3-162d2f388adc" CreationDate="2014-05-01T16:39:12.063" UserId="-1" Comment="from http://stackoverflow.com/questions/23275690/arduino-yun-console-clear" />
  <row Id="3868" PostHistoryTypeId="2" PostId="1355" RevisionGUID="8a58af3c-94ef-4744-be4c-d1833fa28cca" CreationDate="2014-04-24T17:22:35.997" UserDisplayName="Lasse" Text="I'm having a problem. I want to clear the screen on the connected console. And after the clear, I want to rerun my code. But i can't seem tu figure out how to do it. Below is some part of the code: &#xD;&#xA;&#xD;&#xA;    #include &lt;motorStyring.h&gt;&#xD;&#xA;    #include &lt;Bridge.h&gt;&#xD;&#xA;    #include &lt;YunServer.h&gt;&#xD;&#xA;    #include &lt;YunClient.h&gt;&#xD;&#xA;    #define PORT 6666&#xD;&#xA;    motorStyring mt;&#xD;&#xA;    int cm;&#xD;&#xA;&#xD;&#xA;      YunServer server(PORT);&#xD;&#xA;      const int pingPin = 9;&#xD;&#xA;      int led = 13;&#xD;&#xA;        void setup() {&#xD;&#xA;  &#xD;&#xA;        Serial.begin(115200);&#xD;&#xA;        Bridge.begin();&#xD;&#xA;        server.noListenOnLocalhost();&#xD;&#xA;        server.begin();&#xD;&#xA;     }&#xD;&#xA;        void loop() {&#xD;&#xA;        long duration, inches, cm;&#xD;&#xA;        pinMode(pingPin,OUTPUT);&#xD;&#xA;        digitalWrite(pingPin,LOW);&#xD;&#xA;        delayMicroseconds(2);&#xD;&#xA;        digitalWrite(pingPin, HIGH);&#xD;&#xA;        delayMicroseconds(5);&#xD;&#xA;        digitalWrite(pingPin,LOW);&#xD;&#xA;        pinMode(pingPin, INPUT);&#xD;&#xA;        duration = pulseIn(pingPin,HIGH);&#xD;&#xA;        cm = microsecondsToCentimeters(duration);&#xD;&#xA;        h();&#xD;&#xA;       }&#xD;&#xA;        void h()&#xD;&#xA;       {&#xD;&#xA;        YunClient client = server.accept();&#xD;&#xA;         if (client.connected()) {&#xD;&#xA;          String question = &quot;What would you like to drink?\nyou have 4    choises:\n1)Juice\n2)Vodca\n3)Soda\n4)Mix\n&quot;;&#xD;&#xA;    client.write((uint8_t*)&amp;question[0], question.length());    &#xD;&#xA;    String response;&#xD;&#xA;    while (client.connected()) {&#xD;&#xA;      if (client.available()) {&#xD;&#xA;        char cmd = client.read();&#xD;&#xA;        if (cmd == '\n') {&#xD;&#xA;          break;&#xD;&#xA;        } else {&#xD;&#xA;          response += String(cmd);&#xD;&#xA;        }&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    if (response == &quot;juice&quot;) {&#xD;&#xA;      juice();&#xD;&#xA;&#xD;&#xA;    } else if (response == &quot;vodka&quot;) {&#xD;&#xA;      vodka();&#xD;&#xA;&#xD;&#xA;    } else if (response == &quot;soda&quot;) {&#xD;&#xA;      soda();&#xD;&#xA;&#xD;&#xA;    } else if (response == &quot;mix&quot;) {&#xD;&#xA;      mix();&#xD;&#xA;&#xD;&#xA;    } else {&#xD;&#xA;&#xD;&#xA;      String error = &quot;you didn't select anything that corrospond to an option. \n try agin&quot;;&#xD;&#xA;      client.write((uint8_t*)&amp;error[0], error.length());&#xD;&#xA;     }&#xD;&#xA;       String awnser = &quot;Here is your &quot; + response;&#xD;&#xA;       client.write((uint8_t*)&amp;awnser[0], awnser.length());&#xD;&#xA;     }&#xD;&#xA;     delay(1000);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**...**&#xD;&#xA;&#xD;&#xA;Is there a way to clear the screen on the console, so that all of the text from the previous code is not disturbing the user ?" />
  <row Id="3869" PostHistoryTypeId="1" PostId="1355" RevisionGUID="8a58af3c-94ef-4744-be4c-d1833fa28cca" CreationDate="2014-04-24T17:22:35.997" UserDisplayName="Lasse" Text="Arduino Yun console clear" />
  <row Id="3870" PostHistoryTypeId="3" PostId="1355" RevisionGUID="8a58af3c-94ef-4744-be4c-d1833fa28cca" CreationDate="2014-04-24T17:22:35.997" UserDisplayName="Lasse" Text="&lt;untagged&gt;" />
  <row Id="3871" PostHistoryTypeId="36" PostId="1356" RevisionGUID="4e2d3bad-14c1-4d46-b1e5-05b9acebbe09" CreationDate="2014-05-01T16:42:42.683" UserId="-1" Comment="from http://stackoverflow.com/questions/23165387/communication-with-two-xbees-and-arduinos-over-serial" />
  <row Id="3872" PostHistoryTypeId="36" PostId="1357" RevisionGUID="714692e9-21eb-402b-8271-aebd8920ce50" CreationDate="2014-05-01T16:42:42.683" UserId="-1" Comment="from http://stackoverflow.com/questions/23165387/communication-with-two-xbees-and-arduinos-over-serial/23311591#23311591" />
  <row Id="3873" PostHistoryTypeId="2" PostId="1357" RevisionGUID="f263ac56-603f-4dfd-8de1-8572301efee5" CreationDate="2014-04-26T13:28:49.600" UserDisplayName="dax" Text="Did you set one of your modules into coordinator mode?&#xD;&#xA;Every xBee network needs a coordinator. Therefore, you need to put one of your Xbee modules into coordinator mode using the &quot;Function Set&quot; dropdown box in X-CTU. The coordinator has the fixed address 0, so you need to set DL and HL address parts of the other module to 0. On your coordinator, you can set DL to FFFF and HL to 0, which is the broadcast address.&#xD;&#xA;&#xD;&#xA;Softserial won't help you. It's just a way to use some of the pins as an additional serial port. Don't use that if you can use a hardware serial port." />
  <row Id="3874" PostHistoryTypeId="2" PostId="1356" RevisionGUID="518aec5f-280b-4028-a1c1-42789a5a98c6" CreationDate="2014-04-19T03:16:31.137" UserDisplayName="nathpilland" Text="I have two XBee's connected to two Arduino Uno boards (one for each XBee). I connected each XBee to the X-CTU software, and have set the following:&#xD;&#xA;&#xD;&#xA;_XBee 1_&#xD;&#xA;  &#xD;&#xA;`Pan ID = 4270 &#xD;&#xA;DL = 10 &#xD;&#xA;MY = 20` &#xD;&#xA; &#xD;&#xA;_XBee 2_  &#xD;&#xA;&#xD;&#xA;`Pan ID = 4270 &#xD;&#xA;DL = 20 &#xD;&#xA;MY = 10`&#xD;&#xA;&#xD;&#xA;_Both_&#xD;&#xA;&#xD;&#xA;`DD = 10000 &#xD;&#xA;IC = FF &#xD;&#xA;IR = 32`&#xD;&#xA;&#xD;&#xA;Therefore, they should be on the same network and see each other as the 'other person' each is talking to. I'm using the TX and RX pins of the arduino and the XBee to communicate over the serial port.&#xD;&#xA;&#xD;&#xA;When testing if each can hear the other, I loaded one arduino with this code:&#xD;&#xA;   &#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;    // put your setup code here, to run once:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;    }&#xD;&#xA;    void loop() {&#xD;&#xA;    // put your main code here, to run repeatedly:&#xD;&#xA;      Serial.print('x');&#xD;&#xA;      delay(1000);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Then another with this:&#xD;&#xA;&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;    // put your setup code here, to run once:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      pinMode(7,OUTPUT);&#xD;&#xA;      digitalWrite(7,LOW);&#xD;&#xA;    }&#xD;&#xA;    void loop() {&#xD;&#xA;    // put your main code here, to run repeatedly:&#xD;&#xA;      if(Serial.available())&#xD;&#xA;      {&#xD;&#xA;        char getData = Serial.read();&#xD;&#xA;        if(getData == 'x')&#xD;&#xA;        {&#xD;&#xA;          digitalWrite(7,HIGH);&#xD;&#xA;          delay(500);&#xD;&#xA;          digitalWrite(7,LOW);&#xD;&#xA;          delay(500);&#xD;&#xA;        }&#xD;&#xA;      Serial.print(getData);&#xD;&#xA;      getData = ' ';&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This works perfectly. One LED will light up on the correct arduino in half second intervals. However, when I try to make them both communicate at the same time to each other, nothing happens. Neither LED will light up. The code for both arduino's is:&#xD;&#xA;&#xD;&#xA;    #include &lt;SPI.h&gt;&#xD;&#xA;&#xD;&#xA;    void setup() {&#xD;&#xA;      // put your setup code here, to run once:&#xD;&#xA;      Serial.begin(9600);&#xD;&#xA;      pinMode(7,OUTPUT);&#xD;&#xA;      digitalWrite(7,LOW);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop() {&#xD;&#xA;      // put your main code here, to run repeatedly:&#xD;&#xA;      Serial.print('x');&#xD;&#xA;      delay(1000);&#xD;&#xA;      if(Serial.available())&#xD;&#xA;      {&#xD;&#xA;          char getData = Serial.read();&#xD;&#xA;          if(getData == 'y')&#xD;&#xA;          {&#xD;&#xA;            digitalWrite(7,HIGH);&#xD;&#xA;            delay(500);&#xD;&#xA;            digitalWrite(7,LOW);&#xD;&#xA;            delay(500);&#xD;&#xA;          }&#xD;&#xA;          Serial.print(getData);&#xD;&#xA;          getData = ' ';&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;But for one arduino I change the code to `Serial.print('y')` and `if(getData == 'x')` to listen for the other one. I also have tried delaying one arduino in the setup by one second to offset the sending and recieving, but that also doesn't help.&#xD;&#xA;&#xD;&#xA;I need them to be able to listen and talk to each other, maybe even at the same time like this example. I'm trying to create a proximity sensor in, lets say the 'back', area communicate with the 'front' area, and an accelerometer and two switches from the 'front' communicate with the 'back'.&#xD;&#xA;&#xD;&#xA;Is there any settings I can change in X-CTU, such as the baud rate or the amount of packets re-sent, to overcome this problem? Or is this merely a code issue?&#xD;&#xA;&#xD;&#xA;I do have the power connected to the 3.3V pin of the arduino, and I'm using 470/220 Ohm resistors as voltage dividers for the output pins from the arduino to the XBee, so I don't think voltage is an issue here.&#xD;&#xA;&#xD;&#xA;Also, I have disconnected the arduino from the computer. I'm powering it via the USB-A to USB-B cord -&gt; 13000 mAh 5V DC rechargeable battery, so there should be no interference with the serial data lines. Pin 2 (RX) of the XBee is connected to pin D0 (RX) of the arduino, and pin 3 (TX) of the XBee is connected to pin D1 (TX) of the arduino.&#xD;&#xA;&#xD;&#xA;Thanks for your help." />
  <row Id="3875" PostHistoryTypeId="1" PostId="1356" RevisionGUID="518aec5f-280b-4028-a1c1-42789a5a98c6" CreationDate="2014-04-19T03:16:31.137" UserDisplayName="nathpilland" Text="Communication with two XBee's and Arduinos over serial" />
  <row Id="3876" PostHistoryTypeId="3" PostId="1356" RevisionGUID="518aec5f-280b-4028-a1c1-42789a5a98c6" CreationDate="2014-04-19T03:16:31.137" UserDisplayName="nathpilland" Text="&lt;c++&gt;&lt;xbee&gt;" />
  <row Id="3877" PostHistoryTypeId="36" PostId="1358" RevisionGUID="90d1a1b7-6c3c-4691-9ff1-34884b8886eb" CreationDate="2014-05-01T16:43:07.630" UserId="-1" Comment="from http://stackoverflow.com/questions/22592167/arduino-serial-communication" />
  <row Id="3878" PostHistoryTypeId="2" PostId="1358" RevisionGUID="4618995e-c1d2-4d3e-b14f-993ee6e3b08d" CreationDate="2014-03-23T14:27:45.640" UserDisplayName="Bagrat" Text="I'm trying to communicate with the Arduino through the serial port to fade the LED. &#xD;&#xA;There's the code running on my Arduino:&#xD;&#xA;&#xD;&#xA;    #include &lt;aJSON.h&gt;&#xD;&#xA;    aJsonStream serial_stream(&amp;Serial);&#xD;&#xA;&#xD;&#xA;    const int localID = 1;&#xD;&#xA;    int intensity = 100;        // fadeTo value(0% - 100%)&#xD;&#xA;    int currentIntensity = 0;   // how bright the LED actually is (0-100%) &#xD;&#xA;    int time = 0;               // milliseconds&#xD;&#xA;    int color[] = {0, 255, 0};&#xD;&#xA;&#xD;&#xA;    int pinRed = 11;&#xD;&#xA;    int pinGreen = 10;&#xD;&#xA;    int pinBlue = 9;&#xD;&#xA;    int pinPower = 8;&#xD;&#xA;    &#xD;&#xA;    void fadeTo() {&#xD;&#xA;      if(intensity != currentIntensity) {&#xD;&#xA;        if(intensity &gt; currentIntensity)&#xD;&#xA;          currentIntensity+=1;&#xD;&#xA;        else&#xD;&#xA;          currentIntensity-=1;&#xD;&#xA;        &#xD;&#xA;        analogWrite(pinRed,255-currentIntensity);&#xD;&#xA;        analogWrite(pinGreen,255-currentIntensity);&#xD;&#xA;        analogWrite(pinBlue,255-currentIntensity);&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    aJsonObject *createMsg()&#xD;&#xA;    {&#xD;&#xA;        aJsonObject *orbData, *colorData;&#xD;&#xA;    &#xD;&#xA;        orbData = aJson.createObject();&#xD;&#xA;        aJson.addNumberToObject(orbData, &quot;id&quot;, (int)localID);&#xD;&#xA;    &#xD;&#xA;        aJson.addNumberToObject(orbData, &quot;currentIntensity&quot;, (int)currentIntensity);&#xD;&#xA;    &#xD;&#xA;        //aJson.addNumberToObject(orbData, &quot;time&quot;, (int)time);&#xD;&#xA;    &#xD;&#xA;        colorData = aJson.createIntArray(color, 3);&#xD;&#xA;        aJson.addItemToObject(orbData, &quot;color&quot;, colorData);&#xD;&#xA;    &#xD;&#xA;        return orbData;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    // echo {\&quot;id\&quot;:1, \&quot;intensity\&quot;:150, \&quot;time\&quot;:10} &gt;&gt; /dev/ttyACM0 in terminal&#xD;&#xA;    // {&quot;id&quot;:1, &quot;intensity&quot;:150, &quot;time&quot;:10} in Serial Monitor&#xD;&#xA;    void processMsg(aJsonObject *msg)&#xD;&#xA;    {&#xD;&#xA;        //Serial.println(&quot;Data succefully received.&quot;);&#xD;&#xA;        Serial.println(&quot;received message: &quot;);&#xD;&#xA;        aJson.print(msg, &amp;serial_stream);&#xD;&#xA;        &#xD;&#xA;        aJsonObject *idData = aJson.getObjectItem(msg, &quot;id&quot;);&#xD;&#xA;        if(idData != NULL) &#xD;&#xA;        {&#xD;&#xA;            Serial.println(&quot;ID data succefully received.&quot;);&#xD;&#xA;            if(localID == (idData-&gt;valueint)) {&#xD;&#xA;                &#xD;&#xA;                aJsonObject *intensityData = aJson.getObjectItem(msg, &quot;intensity&quot;);&#xD;&#xA;                if(intensityData != NULL) {&#xD;&#xA;                    if(intensityData-&gt;type != aJson_Int) {&#xD;&#xA;                        Serial.println(&quot;Invalid data type for Intensity&quot;);&#xD;&#xA;                        return;&#xD;&#xA;                    }&#xD;&#xA;    &#xD;&#xA;                    if(intensityData-&gt;valueint == currentIntensity) {&#xD;&#xA;                        Serial.println(&quot;The received intensity value is already the current LED intensity&quot;);&#xD;&#xA;                        return;&#xD;&#xA;                    }&#xD;&#xA;                    &#xD;&#xA;                    else {&#xD;&#xA;                        Serial.println(&quot;Intensity data succefully received&quot;);&#xD;&#xA;                        intensity = intensityData-&gt;valueint;&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;                else {&#xD;&#xA;                    Serial.println(&quot;No intensity value received.&quot;);&#xD;&#xA;                    return;&#xD;&#xA;                }&#xD;&#xA;                &#xD;&#xA;                aJsonObject *timeData = aJson.getObjectItem(msg, &quot;time&quot;);&#xD;&#xA;                if(timeData != NULL) {&#xD;&#xA;                    if(timeData-&gt;type != aJson_Int) {&#xD;&#xA;                        Serial.println(&quot;Invalid data type for time&quot;);&#xD;&#xA;                        return;&#xD;&#xA;                    }&#xD;&#xA;                    else {&#xD;&#xA;                        Serial.println(&quot;Time data succefully received&quot;);&#xD;&#xA;                        time = (timeData-&gt;valueint);&#xD;&#xA;                    }&#xD;&#xA;                }&#xD;&#xA;            }&#xD;&#xA;            &#xD;&#xA;            else {&#xD;&#xA;              Serial.println(&quot;The received ID is not mine.&quot;);&#xD;&#xA;              return;  &#xD;&#xA;            }  &#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        else {&#xD;&#xA;          Serial.println(&quot;No ID data received.&quot;);&#xD;&#xA;          return;&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        Serial.println(&quot;received message: &quot;);&#xD;&#xA;        aJson.print(msg, &amp;serial_stream);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        Serial.begin(9600);&#xD;&#xA;        &#xD;&#xA;        pinMode(pinRed,OUTPUT);&#xD;&#xA;        pinMode(pinGreen,OUTPUT);&#xD;&#xA;        pinMode(pinBlue,OUTPUT);&#xD;&#xA;        pinMode(pinPower,OUTPUT);&#xD;&#xA;        &#xD;&#xA;        digitalWrite(pinPower,HIGH);&#xD;&#xA;        digitalWrite(pinRed,HIGH);&#xD;&#xA;        digitalWrite(pinGreen,HIGH);&#xD;&#xA;        digitalWrite(pinBlue,HIGH);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        aJsonObject *orbData = createMsg();&#xD;&#xA;        &#xD;&#xA;        Serial.println(&quot;current status: &quot;);&#xD;&#xA;        aJson.print(orbData, &amp;serial_stream);&#xD;&#xA;        &#xD;&#xA;        Serial.println();&#xD;&#xA;    &#xD;&#xA;        aJson.deleteItem(orbData);&#xD;&#xA;        delay(100);&#xD;&#xA;        &#xD;&#xA;        fadeTo();&#xD;&#xA;        &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    &#xD;&#xA;    void serialEvent()&#xD;&#xA;    {&#xD;&#xA;        if(serial_stream.available())&#xD;&#xA;        {&#xD;&#xA;            // first, skip any accidental whitespace like newlines&#xD;&#xA;            serial_stream.skip();&#xD;&#xA;        }&#xD;&#xA;    &#xD;&#xA;        if(serial_stream.available())&#xD;&#xA;        {&#xD;&#xA;            aJsonObject *msg = aJson.parse(&amp;serial_stream);&#xD;&#xA;      &#xD;&#xA;            processMsg(msg);&#xD;&#xA;            &#xD;&#xA;            aJson.deleteItem(msg);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The problem is, I can open my Serial Monitor in the Arduino IDE and send json data to the Arduino and I see live the changes through the output and the LED on the board. I can also send data through terminal to /dev/ttyACM0 while running Serial Monitor in the IDE and it works fine too. But as soon as I close the Serial Monitor and send data to the device through terminal, it breaks down. I can then open Serial Monitor and every time I get the ERROR from json parser --&gt; (&quot;No ID data received.&quot;).&#xD;&#xA;&#xD;&#xA;Has anyone any idea why this is happening?" />
  <row Id="3879" PostHistoryTypeId="1" PostId="1358" RevisionGUID="4618995e-c1d2-4d3e-b14f-993ee6e3b08d" CreationDate="2014-03-23T14:27:45.640" UserDisplayName="Bagrat" Text="Arduino Serial Communication" />
  <row Id="3880" PostHistoryTypeId="3" PostId="1358" RevisionGUID="4618995e-c1d2-4d3e-b14f-993ee6e3b08d" CreationDate="2014-03-23T14:27:45.640" UserDisplayName="Bagrat" Text="&lt;untagged&gt;" />
  <row Id="3882" PostHistoryTypeId="2" PostId="1360" RevisionGUID="b877db92-6b1a-4ee5-aa4a-38265cd16697" CreationDate="2014-05-01T18:40:11.257" UserId="497" Text="try this:&#xD;&#xA;&#xD;&#xA;    #import &lt;Arduino.h&gt;&#xD;&#xA;    #include &lt;OBD.h&gt;&#xD;&#xA;    &#xD;&#xA;    int kphValue = 0;&#xD;&#xA;    int rpmValue = 0;&#xD;&#xA;    &#xD;&#xA;    COBD obd;&#xD;&#xA;    &#xD;&#xA;    //array of character arrays, see http://arduino.cc/en/Reference/string&#xD;&#xA;    const char* rpmStrings[] = {    &quot;,N,N,255,000,255,000&quot;, &#xD;&#xA;                                    &quot;,N,N,255,255,030,000&quot;, &#xD;&#xA;                                    &quot;,N,N,255,255,000,000&quot; }; &#xD;&#xA;    &#xD;&#xA;    void setup(){&#xD;&#xA;        Serial2.begin(9600);&#xD;&#xA;        obd.begin();&#xD;&#xA;    &#xD;&#xA;        //Initiate OBD-II connection until success&#xD;&#xA;        while ( !obd.init() ) {&#xD;&#xA;            Serial2.print(&quot;$0,Y,Y,255,255,000,000$0,Y,Y,255,255,000,000!&quot;);&#xD;&#xA;            delay(1000);&#xD;&#xA;            Serial2.print(&quot;$0,Y,Y,000,000,000,000$0,Y,Y,000,000,000,000!&quot;);&#xD;&#xA;            delay(1000);&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() {&#xD;&#xA;        if ( obd.read(PID_RPM, rpmValue) &amp;&amp; obd.read(PID_SPEED, kphValue) )&#xD;&#xA;        {&#xD;&#xA;            int rpmStringIndex = determineRpmIndex(rpmValue);&#xD;&#xA;            int mphValue = kphToMPH(kphValue);&#xD;&#xA;    &#xD;&#xA;            //payloadString = &quot;$&quot; + onesString + rpmString + &quot;$&quot; + tensString + &quot;rpmString&quot; + &quot;!&quot;;&#xD;&#xA;            //using Arduino String objects is generally not a good idea due to memory constraints&#xD;&#xA;            //it's probably ok, but I'd rather use character arrays and/or print a bit at a time rather than trying to assemble a giant string &#xD;&#xA;            Serial2.print(&quot;$&quot;);&#xD;&#xA;            Serial2.print(mphValue % 10); //ones&#xD;&#xA;            Serial2.print(rpmStrings[rpmStringIndex]);&#xD;&#xA;            Serial2.print(&quot;$&quot;);&#xD;&#xA;            Serial2.print(mphValue / 10); //tens - integer division, don't need modulo&#xD;&#xA;    &#xD;&#xA;            //do you really want to append the string &quot;rpmString!&quot; or did you want the contents of the variabe rmpString+&quot;!&quot; ?&#xD;&#xA;            //I'm pretty sure you meant the latter&#xD;&#xA;            Serial2.print(rpmStrings[rpmStringIndex]);&#xD;&#xA;            Serial2.print(&quot;!&quot;);&#xD;&#xA;        }&#xD;&#xA;        else &#xD;&#xA;        {&#xD;&#xA;            //obd read error&#xD;&#xA;            //add debugging output here to see if obd failed to respond correctly/on time&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int kphToMph( int kphValue ) {&#xD;&#xA;        //return a value rather than updating a global variable&#xD;&#xA;        return ( int ) ( kphValue * 0.621371 );&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    int determineRpmIndex( int rpmValue ) {&#xD;&#xA;        if ( rpmValue &gt;= 5000 )&#xD;&#xA;            return 2;&#xD;&#xA;    &#xD;&#xA;        if ( rpmValue &gt;= 3000 )&#xD;&#xA;            return 1;&#xD;&#xA;    &#xD;&#xA;        return 0;&#xD;&#xA;    }" />
  <row Id="3883" PostHistoryTypeId="5" PostId="1337" RevisionGUID="0a221783-9a08-47b4-94bc-69737f3ff047" CreationDate="2014-05-01T20:23:13.917" UserId="1249" Comment="Relating it to the Arduino project I'm working on." Text="Goal: I would like to be able to transfer some information to an Arduino Uno board via an NFC shield/antenna. The situation requires that the NFC tag may potentially hit anywhere within a circular area about a 12 inches in diameter.&#xD;&#xA;&#xD;&#xA;Is it possible to increase the size of an NFC antenna? Possibly creating a loop antenna whereby the tag could be read from anywhere inside the loop.&#xD;&#xA;&#xD;&#xA;I was thinking maybe if that isn't possible, it might be better to create an antenna array spanning the size of the area needed. Though I may have problems with overlap or double reads this way.&#xD;&#xA;&#xD;&#xA;Has anyone attempted this before?&#xD;&#xA;&#xD;&#xA;Note: I am not worried about increasing the z distance from the plane, just the x/y range. In fact, I still want the z distance to be very short as to not interfere with other antennas nearby.&#xD;&#xA;&#xD;&#xA;" />
  <row Id="3884" PostHistoryTypeId="6" PostId="1337" RevisionGUID="0a221783-9a08-47b4-94bc-69737f3ff047" CreationDate="2014-05-01T20:23:13.917" UserId="1249" Comment="Relating it to the Arduino project I'm working on." Text="&lt;arduino-uno&gt;&lt;sensors&gt;&lt;proximity&gt;" />
  <row Id="3885" PostHistoryTypeId="5" PostId="1350" RevisionGUID="9689212c-8812-484e-b231-2873dd3c572f" CreationDate="2014-05-01T20:40:13.730" UserId="220" Comment="added 50 characters in body" Text="Your design suffers several redundancies that should be fixed. First of all, you have an Xbee (only one, not a pair) *and* a a 433 MHz transmitter/receiver combo. **Why not just add another Xbee to the drone and remove the RF combo?** That would save a little battery life for the receiver end, and a lot of your time. You'll also get two way communication with error checking. Although an Xbee would increase your project size a *little*, if you manually wired the Xbee instead of a shield (3.3V), it would save a lot of space.&#xD;&#xA;&#xD;&#xA;As some people point out, Bluetooth is a viable option that's fairly small and low cost. However, it would suffer shorter ranges and it would need a special configuration on the host side for a BT stack." />
  <row Id="3887" PostHistoryTypeId="2" PostId="1361" RevisionGUID="e3aedb04-07ac-4680-b033-16371984f445" CreationDate="2014-05-01T23:16:35.097" UserId="-1" Text="" />
  <row Id="3888" PostHistoryTypeId="2" PostId="1362" RevisionGUID="84d5656a-ddb4-4672-bbf8-080a243a3a4e" CreationDate="2014-05-01T23:16:35.097" UserId="-1" Text="" />
  <row Id="3889" PostHistoryTypeId="2" PostId="1363" RevisionGUID="60fb4a2d-bd90-449e-8025-2075ad818246" CreationDate="2014-05-01T23:19:39.727" UserId="-1" Text="" />
  <row Id="3890" PostHistoryTypeId="2" PostId="1364" RevisionGUID="a373a740-444c-464a-b8bb-af8b1d33f896" CreationDate="2014-05-01T23:19:39.727" UserId="-1" Text="" />
  <row Id="3893" PostHistoryTypeId="2" PostId="1366" RevisionGUID="a10b3acf-3496-4000-af42-01880634823b" CreationDate="2014-05-01T23:29:04.590" UserId="-1" Text="" />
  <row Id="3894" PostHistoryTypeId="2" PostId="1367" RevisionGUID="ae57b9d0-3014-4edf-a361-5d9cd75bc4f7" CreationDate="2014-05-01T23:29:04.590" UserId="-1" Text="" />
  <row Id="3895" PostHistoryTypeId="2" PostId="1368" RevisionGUID="791f3a01-de44-4d52-93d9-6d97c84da436" CreationDate="2014-05-01T23:38:16.460" UserId="639" Text="Can a Arduino MEGA 2560 R3 provide enough current out of its pin to activate the [Songle srd-24vdc-sl-c relay][1]? Will powering the Arduino with an external power supply help?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.hebertech.com/view/3778-songle-srd-24vdc.pdf&#xD;&#xA;  [2]: http://i.stack.imgur.com/8zapx.png" />
  <row Id="3896" PostHistoryTypeId="1" PostId="1368" RevisionGUID="791f3a01-de44-4d52-93d9-6d97c84da436" CreationDate="2014-05-01T23:38:16.460" UserId="639" Text="Can Arduino Mega2560 Use this 24VDC Relay?" />
  <row Id="3897" PostHistoryTypeId="3" PostId="1368" RevisionGUID="791f3a01-de44-4d52-93d9-6d97c84da436" CreationDate="2014-05-01T23:38:16.460" UserId="639" Text="&lt;arduino-mega&gt;&lt;relay&gt;" />
  <row Id="3898" PostHistoryTypeId="5" PostId="1362" RevisionGUID="ad75249d-fc9f-4824-802d-5b4db2e9be0b" CreationDate="2014-05-02T00:13:05.767" UserId="1263" Comment="added 38 characters in body" Text="Radio-frequency identification (RFID) " />
  <row Id="3899" PostHistoryTypeId="24" PostId="1362" RevisionGUID="ad75249d-fc9f-4824-802d-5b4db2e9be0b" CreationDate="2014-05-02T00:13:05.767" Comment="Proposed by 1263 approved by 11 edit id of 299" />
  <row Id="3900" PostHistoryTypeId="5" PostId="1367" RevisionGUID="80b4ebf4-d704-4c23-8c3c-177244247c48" CreationDate="2014-05-02T00:13:13.703" UserId="1263" Comment="added 73 characters in body" Text="A gps library providing: position, date, time, altitude, speed and course" />
  <row Id="3901" PostHistoryTypeId="24" PostId="1367" RevisionGUID="80b4ebf4-d704-4c23-8c3c-177244247c48" CreationDate="2014-05-02T00:13:13.703" Comment="Proposed by 1263 approved by 11 edit id of 303" />
  <row Id="3902" PostHistoryTypeId="5" PostId="1366" RevisionGUID="50e356c3-d4f4-4553-990a-d8119fc68f0e" CreationDate="2014-05-02T00:13:30.190" UserId="1263" Comment="added 54 characters in body" Text="Official site http://arduiniana.org/libraries/tinygps/" />
  <row Id="3903" PostHistoryTypeId="24" PostId="1366" RevisionGUID="50e356c3-d4f4-4553-990a-d8119fc68f0e" CreationDate="2014-05-02T00:13:30.190" Comment="Proposed by 1263 approved by 11 edit id of 302" />
  <row Id="3904" PostHistoryTypeId="5" PostId="1364" RevisionGUID="373da203-2be8-440d-8e70-b2d68f4c302a" CreationDate="2014-05-02T00:13:36.967" UserId="1263" Comment="added 46 characters in body" Text="Programming utility for AVR micro-controllers." />
  <row Id="3905" PostHistoryTypeId="24" PostId="1364" RevisionGUID="373da203-2be8-440d-8e70-b2d68f4c302a" CreationDate="2014-05-02T00:13:36.967" Comment="Proposed by 1263 approved by 11 edit id of 301" />
  <row Id="3906" PostHistoryTypeId="5" PostId="1363" RevisionGUID="e509f8ee-de5d-4a5e-a14c-d731eef53bc8" CreationDate="2014-05-02T00:13:40.330" UserId="1263" Comment="added 45 characters in body" Text="Official site: http://www.nongnu.org/avrdude/" />
  <row Id="3907" PostHistoryTypeId="24" PostId="1363" RevisionGUID="e509f8ee-de5d-4a5e-a14c-d731eef53bc8" CreationDate="2014-05-02T00:13:40.330" Comment="Proposed by 1263 approved by 11 edit id of 300" />
  <row Id="3908" PostHistoryTypeId="4" PostId="1351" RevisionGUID="2c2f7202-213e-4752-be70-b55745e83239" CreationDate="2014-05-02T00:28:49.187" UserId="1230" Comment="edited title" Text="Arduino Uno works from USB when connected to laptop but not from baterries" />
  <row Id="3909" PostHistoryTypeId="6" PostId="1358" RevisionGUID="117753b9-d8d9-4a29-920f-3e3c7dbe632b" CreationDate="2014-05-02T02:07:05.117" UserId="612" Comment="This is a &quot;linux&quot; and even more so &quot;serial-port&quot; (at least on SO where it belongs) question as evidenced by the mention of /dev/ttyACM0" Text="&lt;linux&gt;" />
  <row Id="3910" PostHistoryTypeId="24" PostId="1358" RevisionGUID="117753b9-d8d9-4a29-920f-3e3c7dbe632b" CreationDate="2014-05-02T02:07:05.117" Comment="Proposed by 612 approved by 46, 220 edit id of 298" />
  <row Id="3911" PostHistoryTypeId="2" PostId="1369" RevisionGUID="8af15ca0-8fac-4b7d-95f7-63384fa9c2c8" CreationDate="2014-05-02T02:13:28.003" UserId="84" Text="This relay cannot be **directly** commanded by any Arduino because its coil require **24V voltage** to be able to switch the contact; Arduino Mega pins output voltage is **5V**.&#xD;&#xA;&#xD;&#xA;Regarding **current**, the **relay coil needs 15mA** (&quot;high sensitivity&quot; model) **or 18.7mA** (standard model), that would be OK for an Arduino Mega pin (**max current = 40mA**).&#xD;&#xA;&#xD;&#xA;Anyway, you would have to add some circuit to adapt voltage between the Arduino pin and the relay. For this, first of all **you will need to get a second power supply** (in addition to the Arduino 5V supply used for Arduino) that can supply 24V.&#xD;&#xA;&#xD;&#xA;Then you could use a [MOSFET][1] transistor between the Arduino pin and the relay. A MOSFET is also called a **Solid State Relay** (SSR) because it can do the same as a coil relay but is 100% electronic-based (no moving parts). You can check out [this question][2] to find out further information on MOSFET.&#xD;&#xA;&#xD;&#xA;Personnally, I would rather replace that relay with a 5V relay model, as that would make the circuit simpler, and would remove the need for a second power supply.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/MOSFET&#xD;&#xA;  [2]: http://arduino.stackexchange.com/questions/403/how-can-higher-current-devices-motors-solenoids-lights-etc-be-controlled-b" />
  <row Id="3912" PostHistoryTypeId="2" PostId="1370" RevisionGUID="cee4270c-be98-4030-a9e3-d6edea302483" CreationDate="2014-05-02T03:31:14.073" UserId="1049" Text="I have the [GSM shield][1] and is there any ways to get the stored contacts on the SIM card? It seems that [the GSM library][2] does not support writing data onto/ reading data from the SIM card?&#xD;&#xA;&#xD;&#xA;My aim is to store the SIM card's phone number and some variables onto the SIM card itself, such, I would not need to change the program from time to time.&#xD;&#xA;&#xD;&#xA;All I need to do is enter all the variables in the SIM card via any mobile phone (perhaps by storing the variables as contacts, as phone book function should be very common on phones).&#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/Main/ArduinoGSMShield&#xD;&#xA;  [2]: http://arduino.cc/en/Reference/GSM" />
  <row Id="3913" PostHistoryTypeId="1" PostId="1370" RevisionGUID="cee4270c-be98-4030-a9e3-d6edea302483" CreationDate="2014-05-02T03:31:14.073" UserId="1049" Text="Getting the contacts/ storing contacts to SIM card" />
  <row Id="3914" PostHistoryTypeId="3" PostId="1370" RevisionGUID="cee4270c-be98-4030-a9e3-d6edea302483" CreationDate="2014-05-02T03:31:14.073" UserId="1049" Text="&lt;gsm&gt;" />
  <row Id="3917" PostHistoryTypeId="5" PostId="1343" RevisionGUID="9d5d9005-1286-4323-8813-dac0558c8547" CreationDate="2014-05-02T05:24:05.557" UserId="1238" Comment="added 2 characters in body" Text="The problem of this version of Marlin can be shown in the following piece of code (which is inside `EEPROM_RetrieveSettings` function):&#xD;&#xA;&#xD;&#xA;      for (short i=0;i&lt;4;i++) &#xD;&#xA;      {&#xD;&#xA;        axis_steps_per_unit[i]=tmp1[i];  &#xD;&#xA;        max_feedrate[i]=tmp2[i];&#xD;&#xA;        max_acceleration_units_per_sq_second[i]=tmp3[i];&#xD;&#xA;        max_length[i]=tmp4[i];&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;Here `max_length` is an array of 3 elements, not 4 (the X,Y and Z axes have a max length to avoid hitting the edge, but the extrude axis does not have such a limit - you should be able to extrude as many filament as you can supply), so the last statement in the loop overrides other variable(s).&#xD;&#xA;&#xD;&#xA;The solution is &#xD;&#xA;&#xD;&#xA;      for (short i=0;i&lt;4;i++) &#xD;&#xA;      {&#xD;&#xA;        axis_steps_per_unit[i]=tmp1[i];  &#xD;&#xA;        max_feedrate[i]=tmp2[i];&#xD;&#xA;        max_acceleration_units_per_sq_second[i]=tmp3[i];&#xD;&#xA;        if(i&lt;3)&#xD;&#xA;            max_length[i]=tmp4[i];&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;Or&#xD;&#xA;&#xD;&#xA;      for (short i=0;i&lt;4;i++) &#xD;&#xA;      {&#xD;&#xA;        axis_steps_per_unit[i]=tmp1[i];  &#xD;&#xA;        max_feedrate[i]=tmp2[i];&#xD;&#xA;        max_acceleration_units_per_sq_second[i]=tmp3[i];&#xD;&#xA;        if(i &lt; sizeof(tmp4)/sizeof(tmp4[0]))&#xD;&#xA;            max_length[i]=tmp4[i];&#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;Greate thanks to the answer writer and commenter. Without your help I couldn't follow the right track. " />
  <row Id="3918" PostHistoryTypeId="2" PostId="1371" RevisionGUID="e4db455d-3bc4-4107-a76f-49369329f34a" CreationDate="2014-05-02T05:59:36.973" UserId="1275" Text="I am doing a project on arduino controlled light dimmer circuit....I have a separate circuit for zero crossing detector and IR receiver but when I am combining both of them in arduino then my IR receiver stops working and zero crossing interrupt is not detected....can anyone help me with this????" />
  <row Id="3919" PostHistoryTypeId="1" PostId="1371" RevisionGUID="e4db455d-3bc4-4107-a76f-49369329f34a" CreationDate="2014-05-02T05:59:36.973" UserId="1275" Text="IR controlled light dimmer" />
  <row Id="3920" PostHistoryTypeId="3" PostId="1371" RevisionGUID="e4db455d-3bc4-4107-a76f-49369329f34a" CreationDate="2014-05-02T05:59:36.973" UserId="1275" Text="&lt;programming&gt;&lt;arduino-due&gt;" />
  <row Id="3921" PostHistoryTypeId="2" PostId="1372" RevisionGUID="473cfa6d-b54d-43a0-9b31-f7d180c15f01" CreationDate="2014-05-02T11:31:16.227" UserId="304" Text="What you've described (without source code and/or a circuit diagram) sounds like you'll probably be using interrupts at least for the zero crossing detection. And probably the IR receiver too. The IR receiver is going to be your problem since the zero crossing is a very quick flag set and you're out of the interrupt. &#xD;&#xA;&#xD;&#xA;On the other hand, the IR detection is going to take time, and if you're doing THAT in an interrupt you're going to be missing dozens of crossings. &#xD;&#xA;&#xD;&#xA;To mix the two you can leave the zero crossing in it's own interrupt, but you're probably better off handling the IR in the loop via a state machine. &#xD;&#xA;&#xD;&#xA;Since you say that neither are working, I'm going to hazard a guess and you're using the same interrupt or badly implemented them (possibly a timer and interrupt clash) and until you post some code people here aren't going to be able to help you any more than that. " />
  <row Id="3922" PostHistoryTypeId="2" PostId="1373" RevisionGUID="41b71a9b-5a79-4dcc-9e9a-be3249a1b202" CreationDate="2014-05-02T11:49:43.687" UserId="304" Text="What have you researched so far? Following the link you have given for the shield, about the third line of the description is a reference to the [AT Command Set][1] used by the chip. &#xD;&#xA;&#xD;&#xA;I just did a couple of quick searches through it and found:&#xD;&#xA;&#xD;&#xA;&gt;`2.2.4  ATD&gt;&lt;n&gt;` Originate phone call to number in memory&#xD;&#xA;&#xD;&#xA;&gt;`3.2.26 AT+CPBF` Find phone book entries&#xD;&#xA;&#xD;&#xA;&gt;`3.2.27 AT+CPBR` Read current phone book entries&#xD;&#xA;&#xD;&#xA;&gt;`3.2.28 AT+CPBS` Select phone book memory storage&#xD;&#xA;&#xD;&#xA;probably a good place to start. &#xD;&#xA;&#xD;&#xA;  [1]: http://arduino.cc/en/uploads/Main/Quectel_M10_AT_commands.pdf" />
  <row Id="3924" PostHistoryTypeId="2" PostId="1374" RevisionGUID="f9535795-b221-43c0-b6c9-9b29a4e9054c" CreationDate="2014-05-02T13:30:23.127" UserId="889" Text="I'd like to write my sketches so that I can either build/upload them using the Arduino IDE, or optionally using GCC and a makefile.&#xD;&#xA;&#xD;&#xA;I know about including the function declarations at the top, but is there anything else to do in order for my sketch to be considered valid C++ by my compiler?" />
  <row Id="3925" PostHistoryTypeId="1" PostId="1374" RevisionGUID="f9535795-b221-43c0-b6c9-9b29a4e9054c" CreationDate="2014-05-02T13:30:23.127" UserId="889" Text="How to write makefile-compatible sketches?" />
  <row Id="3926" PostHistoryTypeId="3" PostId="1374" RevisionGUID="f9535795-b221-43c0-b6c9-9b29a4e9054c" CreationDate="2014-05-02T13:30:23.127" UserId="889" Text="&lt;programming&gt;&lt;c++&gt;" />
  <row Id="3927" PostHistoryTypeId="2" PostId="1375" RevisionGUID="7327bc18-33a2-4c45-a303-c0121a82b927" CreationDate="2014-05-02T14:04:55.427" UserId="313" Text="Are you powering the motors with a separate supply, and not direct from the Arduino? Motors should be powered separately and the power only switched by the Arduino. Otherwise, their current draw could be pulling down your battery voltage. And even with USB power, they could be drawing more current than spec'd for either the USB power source or the Arduino's regulator or output pins. The chip itself is spec'd for a maximum current of 40mA per pin and 200mA total." />
  <row Id="3928" PostHistoryTypeId="2" PostId="1376" RevisionGUID="9c19dec1-ced0-46d2-b149-f2de78d63e24" CreationDate="2014-05-02T14:11:30.250" UserId="889" Text="For a [class project](https://github.com/hoosierEE/MicroPiano/blob/master/keykey/my_functions.ino#L106-L115) I used a CD4024 and two Arduino pins to drive a 7-segment display.&#xD;&#xA;&#xD;&#xA;There are some caveats to this approach. For example, to write a `high` value to the first output of a ripple counter only requires a `reset` and toggling the clock pin twice. But if you want to write `high` to all n pins requires toggling the clock pin 2&lt;sup&gt;n&lt;/sup&gt; times, and during that time all the other pins are constantly toggling on and off.&#xD;&#xA;&#xD;&#xA;If your application can deal with these limitations and you're short on pins, it's another option.&#xD;&#xA;&#xD;&#xA;Bonus answer: there are a lot of examples of multiplexing inputs [here](http://www.openmusiclabs.com/learning/digital/input-matrix-scanning/), many of which also apply to multiplexing outputs." />
  <row Id="3929" PostHistoryTypeId="2" PostId="1377" RevisionGUID="ac447dd3-b676-4dfd-b41f-29abaca22b37" CreationDate="2014-05-02T15:02:42.630" UserId="-1" Text="" />
  <row Id="3930" PostHistoryTypeId="2" PostId="1378" RevisionGUID="a546ba9c-2f75-4863-97dc-fa1600aac227" CreationDate="2014-05-02T15:02:42.630" UserId="-1" Text="" />
  <row Id="3931" PostHistoryTypeId="2" PostId="1379" RevisionGUID="2aeb31ae-51ff-4d58-b24a-b4c9310dcb84" CreationDate="2014-05-02T15:08:51.920" UserId="304" Text="If it's all about LEDs,  what about WS2812B LED strips, or just the driver chips themselves? You can control a virtually unlimited number of LEDs using just one pin! &#xA;&#xA;Although people are use to these in strips, they are available as standalone LEDs (known as neo pixels on adafruit. Or if you're only driving a single colour, each WS2811 chip could control 3 LEDs by using each of the RGB outputs for a single LED each. &#xA;&#xA;I recently just created created a project that uses 5 such leds: Door1 ooen/closed, Door2 open/closed, motor1 active, motor2 active and power. The &quot;active&quot; leds are dual purpose since I have red being the input from active motor and green being active flag inside the arduino.  &#xA;&#xA;Point being, with 1 pin and the library installed, you can control any number of LEDs " />
  <row Id="3932" PostHistoryTypeId="2" PostId="1380" RevisionGUID="d5cf1ab2-7b05-4f61-805a-e32b99dabd51" CreationDate="2014-05-02T15:46:20.820" UserId="1277" Text="I recently bought an Arduino Micro to see what all the fuss was about and I figured I'd use it with Ubuntu on an older Dell Latitude. I was able to install all of the files using some tutorials but I have this problem uploading sketches. After plugging in the board, the green top LED is consistently flashing so it seems to be working, but when I try to upload a sketch I get the following error &#xD;&#xA;&#xD;&#xA;Connecting to programmer: .avrdude: Send: . [1b] &#xD;&#xA;avrdude: Send: S [53] &#xD;&#xA;avrdude: ser_recv(): programmer is not responding&#xD;&#xA;avrdude: butterfly_recv(): programmer is not responding&#xD;&#xA;&#xD;&#xA;Any ideas how to fix this? I tried pressing reset during the send as some forums have suggested but it doesnt seem to be working. &#xD;&#xA;&#xD;&#xA;" />
  <row Id="3933" PostHistoryTypeId="1" PostId="1380" RevisionGUID="d5cf1ab2-7b05-4f61-805a-e32b99dabd51" CreationDate="2014-05-02T15:46:20.820" UserId="1277" Text="Sketches not uploading to Micro from Ubuntu 14.04" />
  <row Id="3934" PostHistoryTypeId="3" PostId="1380" RevisionGUID="d5cf1ab2-7b05-4f61-805a-e32b99dabd51" CreationDate="2014-05-02T15:46:20.820" UserId="1277" Text="&lt;uploading&gt;&lt;ubuntu&gt;" />
  <row Id="3935" PostHistoryTypeId="2" PostId="1381" RevisionGUID="215d8b25-5e4f-4735-a899-3a722df0f73f" CreationDate="2014-05-02T16:51:46.767" UserId="1278" Text="I can't figure out why the next script is not working. I have attached the Arduino to one USB port of the raspberry pi, in which I've installed pyserial. I just want to turn off/on a led depending of the number I write on the Raspi console (1-&gt; on, 2-&gt; off).&#xD;&#xA;&#xD;&#xA;        int led=13;&#xD;&#xA;    &#xD;&#xA;    void setup(){&#xD;&#xA;      Serial.begin(115200);&#xD;&#xA;      pinMode(led,OUTPUT);&#xD;&#xA;    }&#xD;&#xA;    void loop(){&#xD;&#xA;      if(Serial.available()){    &#xD;&#xA;         mode(Serial.read() - '0');  &#xD;&#xA;      }&#xD;&#xA;    }  &#xD;&#xA;    void  mode(int n){&#xD;&#xA;        &#xD;&#xA;        if (n== 1){&#xD;&#xA;             digitalWrite(led,HIGH);&#xD;&#xA;        }    &#xD;&#xA;        if (n== 2){&#xD;&#xA;            digitalWrite(led,LOW);     &#xD;&#xA;        }   &#xD;&#xA;      }&#xD;&#xA;&#xD;&#xA;PS: I double checked and the baudrate is configured also at 115200 at the raspi side.&#xD;&#xA;In addition, if I place digitalWrite(led,HIGH) just before  the line  &quot;mode(Serial.read() - '0');&quot; the led turn on when I send some information from the raspi shell (so, works well). " />
  <row Id="3936" PostHistoryTypeId="1" PostId="1381" RevisionGUID="215d8b25-5e4f-4735-a899-3a722df0f73f" CreationDate="2014-05-02T16:51:46.767" UserId="1278" Text="Simple Script controlled by Raspberry not working" />
  <row Id="3937" PostHistoryTypeId="3" PostId="1381" RevisionGUID="215d8b25-5e4f-4735-a899-3a722df0f73f" CreationDate="2014-05-02T16:51:46.767" UserId="1278" Text="&lt;serial&gt;&lt;led&gt;" />
  <row Id="3938" PostHistoryTypeId="5" PostId="1369" RevisionGUID="a701904f-6ddb-4428-aaf7-0fcaa80eab21" CreationDate="2014-05-02T17:34:57.777" UserId="84" Comment="fixed SSR statement according to comments." Text="This relay cannot be **directly** commanded by any Arduino because its coil require **24V voltage** to be able to switch the contact; Arduino Mega pins output voltage is **5V**.&#xD;&#xA;&#xD;&#xA;Regarding **current**, the **relay coil needs 15mA** (&quot;high sensitivity&quot; model) **or 18.7mA** (standard model), that would be OK for an Arduino Mega pin (**max current = 40mA**).&#xD;&#xA;&#xD;&#xA;Anyway, you would have to add some circuit to adapt voltage between the Arduino pin and the relay. For this, first of all **you will need to get a second power supply** (in addition to the Arduino 5V supply used for Arduino) that can supply 24V.&#xD;&#xA;&#xD;&#xA;Then you could use a [MOSFET][1] transistor between the Arduino pin and the relay. A MOSFET is often used in so-called **Solid State Relay** ([SSR][2]) because it can almost do the same as a coil relay but is 100% electronic-based (no moving parts); however, contrarily to a coil relay, it does not provide galvanic isolation between the input and the output circuits. &#xD;&#xA;&#xD;&#xA;You can check out [this question][3] to find out further information on MOSFET.&#xD;&#xA;&#xD;&#xA;Personnally, I would rather replace that relay with a 5V relay model, as that would make the circuit simpler, and would remove the need for a second power supply.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://en.wikipedia.org/wiki/MOSFET&#xD;&#xA;  [2]: http://en.wikipedia.org/wiki/Solid-state_relay&#xD;&#xA;  [3]: http://arduino.stackexchange.com/questions/403/how-can-higher-current-devices-motors-solenoids-lights-etc-be-controlled-b" />
  <row Id="3939" PostHistoryTypeId="5" PostId="1378" RevisionGUID="dfbd7089-9891-45e5-8bf8-e83207ee5998" CreationDate="2014-05-02T18:52:57.793" UserId="1263" Comment="added 103 characters in body" Text="XBee is a family of form factor compatible radio modules. Most are based on the 802.15.4-2003 standard." />
  <row Id="3940" PostHistoryTypeId="24" PostId="1378" RevisionGUID="dfbd7089-9891-45e5-8bf8-e83207ee5998" CreationDate="2014-05-02T18:52:57.793" Comment="Proposed by 1263 approved by 11 edit id of 305" />
  <row Id="3941" PostHistoryTypeId="5" PostId="1377" RevisionGUID="d0d659ce-bc5b-4da8-b836-69f97dafa0ca" CreationDate="2014-05-02T18:53:03.797" UserId="1263" Comment="added 124 characters in body" Text="This chart graphs the differences between the different Digi XBee modules http://www.digi.com/pdf/chart_xbee_rf_features.pdf" />
  <row Id="3942" PostHistoryTypeId="24" PostId="1377" RevisionGUID="d0d659ce-bc5b-4da8-b836-69f97dafa0ca" CreationDate="2014-05-02T18:53:03.797" Comment="Proposed by 1263 approved by 11 edit id of 304" />
  <row Id="3943" PostHistoryTypeId="5" PostId="1380" RevisionGUID="cf33f2ba-5e73-4bb8-8789-37db49485142" CreationDate="2014-05-02T18:54:24.490" UserId="11" Comment="added 16 characters in body" Text="I recently bought an Arduino Micro to see what all the fuss was about and I figured I'd use it with Ubuntu on an older Dell Latitude. I was able to install all of the files using some tutorials but I have this problem uploading sketches. After plugging in the board, the green top LED is consistently flashing so it seems to be working, but when I try to upload a sketch I get the following error &#xD;&#xA;&#xD;&#xA;    Connecting to programmer: .avrdude: Send: . [1b] &#xD;&#xA;    avrdude: Send: S [53] &#xD;&#xA;    avrdude: ser_recv(): programmer is not responding&#xD;&#xA;    avrdude: butterfly_recv(): programmer is not responding&#xD;&#xA;&#xD;&#xA;Any ideas how to fix this? I tried pressing reset during the send as some forums have suggested but it doesnt seem to be working. &#xD;&#xA;&#xD;&#xA;" />
  <row Id="3944" PostHistoryTypeId="2" PostId="1382" RevisionGUID="f5a324ef-d4f4-4737-ad83-5a559f081dc5" CreationDate="2014-05-03T08:11:11.870" UserId="1278" Text="Finally I've found the error, it was the serial communication baud rate: 115200. It seems that at higher speeds it not works properly, lowering it to 9600 do the trick." />
  <row Id="3945" PostHistoryTypeId="5" PostId="387" RevisionGUID="1ecfbd08-6825-4422-a055-ab2c98a801ed" CreationDate="2014-05-03T09:18:16.280" UserId="84" Comment="code formatting; clarified loop() explanation." Text="This tag should be used when writing code for the Arduino specifically using the Arduino IDE.&#xD;&#xA;&#xD;&#xA;A sketch has the following structure:&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        ...&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        ...&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The `setup` function is run once when the sketch starts. The `loop` function then is called repeatedly until the board is either shut down or restarted.&#xD;&#xA;&#xD;&#xA;A sketch is saved with the `ino` extension." />
  <row Id="3946" PostHistoryTypeId="24" PostId="387" RevisionGUID="1ecfbd08-6825-4422-a055-ab2c98a801ed" CreationDate="2014-05-03T09:18:16.280" Comment="Proposed by 84 approved by 42 edit id of 309" />
  <row Id="3947" PostHistoryTypeId="5" PostId="391" RevisionGUID="6d1d7214-0bc2-4572-aa7c-c7185c7d5ea4" CreationDate="2014-05-03T09:18:55.797" UserId="84" Comment="Improved formatting; fixed typos and grammar; rephrased to clarify some points." Text="C++ is the standard language used to program the Arduino IDE. Most Arduino code online is written in this language.&#xD;&#xA;&#xD;&#xA;C++ is one of the most popular coding languages available, being highly cross-platform. However, transferring Arduino code to PC code (and vice versa) is very hard, even when ignoring the fact that your computer can't run a motor. For example, in C++ code, the first thing to be called is `main`. In Arduino C++, `main` is still called, however, **the Arduino libraries are called, not your sketch.** Those libraries *then* call `setup` and then `loop` repeatedly after finishing all the initialization tasks they must perform before the Arduino can run the code of your sketch.&#xD;&#xA;&#xD;&#xA;It is pronounced &quot;C plus plus.&quot;" />
  <row Id="3948" PostHistoryTypeId="24" PostId="391" RevisionGUID="6d1d7214-0bc2-4572-aa7c-c7185c7d5ea4" CreationDate="2014-05-03T09:18:55.797" Comment="Proposed by 84 approved by 42 edit id of 306" />
  <row Id="3949" PostHistoryTypeId="5" PostId="552" RevisionGUID="3d823f9d-1d58-46a1-a784-c35fb7236055" CreationDate="2014-05-03T09:19:09.813" UserId="84" Comment="Clarified importance of the bootloader." Text="Refers to the code burned on the Arduino flash memory that runs every time the board is powered up. It starts the execution of user-loaded programs and allows uploading sketches from a PC through the USB connection. This tag should be used for questions about modifying, changing, uploading the default bootloader." />
  <row Id="3950" PostHistoryTypeId="24" PostId="552" RevisionGUID="3d823f9d-1d58-46a1-a784-c35fb7236055" CreationDate="2014-05-03T09:19:09.813" Comment="Proposed by 84 approved by 42 edit id of 310" />
  <row Id="3951" PostHistoryTypeId="5" PostId="257" RevisionGUID="8ded74cd-cb8c-4300-894d-c018bfe6afec" CreationDate="2014-05-03T09:19:36.340" UserId="84" Comment="fixed typos, improved spec link, removed unfinished sentence." Text="The arduino DUE is different than most Arduino boards on the market since it runs at 3.3V. &#xD;&#xA;&#xD;&#xA;&gt; The Arduino Due is a microcontroller board based on the Atmel SAM3X8E ARM Cortex-M3 CPU. It is the first Arduino board based on a 32-bit ARM core microcontroller. It has 54 digital input/output pins (of which 12 can be used as PWM outputs), 12 analog inputs, 4 UARTs (hardware serial ports), a 84 MHz clock, an USB OTG capable connection, 2 DAC (digital to analog), 2 TWI, a power jack, an SPI header, a JTAG header, a reset button and an erase button.&#xD;&#xA;&#xD;&#xA;&gt; **Warning:** Unlike other Arduino boards, the Arduino Due board runs at 3.3V. The maximum voltage that the I/O pins can tolerate is 3.3V. Providing higher voltages, like 5V to an I/O pin could damage the board.&#xD;&#xA;&#xD;&#xA;&gt;The board contains everything needed to support the microcontroller; simply connect it to a computer with a micro-USB cable or power it with a AC-to-DC adapter or battery to get started. The Due is compatible with all Arduino shields that work at 3.3V and are compliant with the 1.0 Arduino pinout.&#xD;&#xA;The Due follows the 1.0 pinout:&#xD;&#xA;TWI: SDA and SCL pins that are near to the AREF pin.&#xD;&#xA;The IOREF pin which allows an attached shield with the proper configuration to adapt to the voltage provided by the board. This enables shield compatibility with a 3.3V board like the Due and AVR-based boards which operate at 5V.&#xD;&#xA;An unconnected pin, reserved for future use.&#xD;&#xA;&lt;img src=&quot;http://arduino.cc/en/uploads/Main/ArduinoDue_Front_450px.jpg&quot; &gt;&#xD;&#xA;&#xD;&#xA;[Full specs and information](http://arduino.cc/en/Main/ArduinoBoardDue).&#xD;&#xA;****&#xD;&#xA;**Other features:**&#xD;&#xA;&#xD;&#xA; - 32 bit microcontroller: 4 byte wide instructions during one CPU cycle.&#xD;&#xA; - 84 MHz MCU clock (Uno is 16 MHz on a less efficient architecture.)&#xD;&#xA; - 96KB SRAM&#xD;&#xA; - 512KB Flash&#xD;&#xA;&#xD;&#xA;This gives it much more power than a standard ATmega chip." />
  <row Id="3952" PostHistoryTypeId="24" PostId="257" RevisionGUID="8ded74cd-cb8c-4300-894d-c018bfe6afec" CreationDate="2014-05-03T09:19:36.340" Comment="Proposed by 84 approved by 42 edit id of 307" />
  <row Id="3953" PostHistoryTypeId="2" PostId="1383" RevisionGUID="5fe3cd9b-13ae-481e-8147-da2c4f761113" CreationDate="2014-05-03T09:19:54.167" UserId="562" Text="I've experienced same behavior with this type of servos. In my case it was easier to spot since Arduino frequently rebooted when servo was approaching the boundaries of the swing - so it was clear it was consuming too much power, and USB port was unable to deliver that.&#xD;&#xA;&#xD;&#xA;Cheap dedicated 9V 1A AC/DC converter usually solves the problem. But if you can't wait for one to get delivered, get an iPad USB charger (nowadays everyone has it or has a neighbor/friend who has one). It is rated 10W, and it doesn't suffer from voltage drops even under high loads. Power your setup from it, and if you'd see it moves smoothly, you will have your answer." />
  <row Id="3954" PostHistoryTypeId="2" PostId="1384" RevisionGUID="788b441d-9353-498d-8b1d-3a35e7370c4c" CreationDate="2014-05-03T12:26:07.773" UserId="1290" Text="I have a stepper motor connected to my Arduino like this:&#xA;&#xA;![Circuit Diagram][1]    &#xA;![Image][2]&#xA;(Ignore the potentiometer)&#xA;&#xA;And I have programmed it with the following code:&#xA;&#xA;    #include &lt;Stepper.h&gt;&#xA;&#xA;    int in1Pin = 22;&#xA;    int in2Pin = 23;&#xA;    int in3Pin = 24;&#xA;    int in4Pin = 25;&#xA;    &#xA;    Stepper motor(512, in1Pin, in2Pin, in3Pin, in4Pin);&#xA;&#xA;    void setup()&#xA;    {&#xA;        pinMode(in1Pin, OUTPUT);&#xA;        pinMode(in2Pin, OUTPUT);&#xA;        pinMode(in3Pin, OUTPUT);&#xA;        pinMode(in4Pin, OUTPUT);&#xA;      &#xA;        motor.setSpeed(25);&#xA;    }&#xA;&#xA;    void loop()&#xA;    {&#xA;        int steps = 360;&#xA;&#xA;        motor.step(steps);&#xA;        delay(500)&#xA;    }&#xA;&#xA;At the moment the motor rotates clockwise, how could I have it so it rotates in the opposite direction?&#xA;&#xA;[1]: http://arduino.cc/en/uploads/Reference/unipolar_stepper_four_pins.jpg&#xA;[2]: http://static.flickr.com/32/54357295_756c131217.jpg" />
  <row Id="3955" PostHistoryTypeId="1" PostId="1384" RevisionGUID="788b441d-9353-498d-8b1d-3a35e7370c4c" CreationDate="2014-05-03T12:26:07.773" UserId="1290" Text="Reverse turning of Stepper motor" />
  <row Id="3956" PostHistoryTypeId="3" PostId="1384" RevisionGUID="788b441d-9353-498d-8b1d-3a35e7370c4c" CreationDate="2014-05-03T12:26:07.773" UserId="1290" Text="&lt;motor&gt;" />
  <row Id="3957" PostHistoryTypeId="5" PostId="111" RevisionGUID="628ac00a-47dd-4238-9350-daa61d63e8f1" CreationDate="2014-05-03T12:33:31.970" UserId="84" Comment="fixed typos and formatting." Text="Uploading is the process of updating or changing the sketch on the Arduino board. It does not refer to uploading to a server or a website.&#xD;&#xA;&#xD;&#xA;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/ArduinoUnoB.jpg/799px-ArduinoUnoB.jpg&quot; &gt;&#xD;&#xA;*http://commons.wikimedia.org/wiki/File:ArduinoUnoB.jpg*&#xD;&#xA;&#xD;&#xA;&gt; ##Upload process:&#xD;&#xA;&gt; &#xD;&#xA;&gt; Sketches are uploaded by avrdude.&#xD;&#xA;&gt;&#xD;&#xA;&gt; The upload process is also controlled by variables in the boards and main preferences files. Those in the boards file include:&#xD;&#xA;&gt;&#xD;&#xA;&gt; &amp;lt;BOARD&gt;.upload.protocol: the protocol that avrdude should use to talk to the board (typically &quot;stk500&quot;).&#xD;&#xA;&gt;&#xD;&#xA;&gt; &amp;lt;BOARD&gt;.upload.speed: the speed (baud rate) avrdude should use when uploading sketches (typically &quot;19200&quot;).&#xD;&#xA;&gt;&#xD;&#xA;&gt; &amp;lt;BOARD&gt;.upload.maximum_size: the maximum size for a sketch on the&#xD;&#xA;&gt; board (dependent on the chip and the size of the bootloader). &#xD;&#xA;&gt;&#xD;&#xA;&gt; And in the main preferences file:&#xD;&#xA;&gt;&#xD;&#xA;&gt; upload.verbose: whether or not to dump debugging messages while upload a sketch to a board (defaults to &quot;false&quot;).&#xD;&#xA;&#xD;&#xA;*http://arduino.cc/en/Hacking/BuildProcess*&#xD;&#xA;&#xD;&#xA;Once the code is transferred to the board, then [if the board has auto-reset], the board will reset and the sketch will be run." />
  <row Id="3958" PostHistoryTypeId="24" PostId="111" RevisionGUID="628ac00a-47dd-4238-9350-daa61d63e8f1" CreationDate="2014-05-03T12:33:31.970" Comment="Proposed by 84 approved by 220 edit id of 308" />
  <row Id="3959" PostHistoryTypeId="6" PostId="1384" RevisionGUID="b24f657f-dd67-4dd7-96d8-52eb56a65d6f" CreationDate="2014-05-03T12:38:02.263" UserId="220" Comment="edited tags" Text="&lt;programming&gt;&lt;motor&gt;" />
  <row Id="3960" PostHistoryTypeId="2" PostId="1385" RevisionGUID="7d34e95e-d38c-49cc-af17-7406817aebc6" CreationDate="2014-05-03T12:40:37.393" UserId="220" Text="The answer is simple. Just pass a negative number of steps as an argument to `motor.step();`.&#xD;&#xA;&#xD;&#xA;Another note: You forgot a semicolon on your second to last line. IIRC this doesn't matter in C, but **it's just bad practice to do this.** If you add a line of code below that, then it won't work.&#xD;&#xA;&#xD;&#xA;Example code:&#xD;&#xA;&#xD;&#xA;    #include &lt;Stepper.h&gt;&#xD;&#xA;    &#xD;&#xA;    int in1Pin = 22;&#xD;&#xA;    int in2Pin = 23;&#xD;&#xA;    int in3Pin = 24;&#xD;&#xA;    int in4Pin = 25;&#xD;&#xA;    &#xD;&#xA;    Stepper motor(512, in1Pin, in2Pin, in3Pin, in4Pin);&#xD;&#xA;    &#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        pinMode(in1Pin, OUTPUT);&#xD;&#xA;        pinMode(in2Pin, OUTPUT);&#xD;&#xA;        pinMode(in3Pin, OUTPUT);&#xD;&#xA;        pinMode(in4Pin, OUTPUT);&#xD;&#xA;    &#xD;&#xA;        motor.setSpeed(25);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        int steps = 360;&#xD;&#xA;        motor.step(steps);&#xD;&#xA;        delay(100);&#xD;&#xA;        &#xD;&#xA;        steps = -360;&#xD;&#xA;        motor.step(steps);&#xD;&#xA;        delay(500); //Semicolon added&#xD;&#xA;    }" />
  <row Id="3961" PostHistoryTypeId="5" PostId="1384" RevisionGUID="de660260-8d18-4222-a1e2-29f16fe75422" CreationDate="2014-05-03T12:41:05.877" UserId="1290" Comment="added 1 character in body" Text="I have a stepper motor connected to my Arduino like this:&#xA;&#xA;![Circuit Diagram][1]    &#xA;![Image][2]&#xA;(Ignore the potentiometer)&#xA;&#xA;And I have programmed it with the following code:&#xA;&#xA;    #include &lt;Stepper.h&gt;&#xA;&#xA;    int in1Pin = 22;&#xA;    int in2Pin = 23;&#xA;    int in3Pin = 24;&#xA;    int in4Pin = 25;&#xA;    &#xA;    Stepper motor(512, in1Pin, in2Pin, in3Pin, in4Pin);&#xA;&#xA;    void setup()&#xA;    {&#xA;        pinMode(in1Pin, OUTPUT);&#xA;        pinMode(in2Pin, OUTPUT);&#xA;        pinMode(in3Pin, OUTPUT);&#xA;        pinMode(in4Pin, OUTPUT);&#xA;      &#xA;        motor.setSpeed(25);&#xA;    }&#xA;&#xA;    void loop()&#xA;    {&#xA;        int steps = 360;&#xA;&#xA;        motor.step(steps);&#xA;        delay(500);&#xA;    }&#xA;&#xA;At the moment the motor rotates clockwise, how could I have it so it rotates in the opposite direction?&#xA;&#xA;[1]: http://arduino.cc/en/uploads/Reference/unipolar_stepper_four_pins.jpg&#xA;[2]: http://static.flickr.com/32/54357295_756c131217.jpg" />
  <row Id="3962" PostHistoryTypeId="5" PostId="1351" RevisionGUID="95cf95ed-c11e-4c84-aabd-dfd41086ce23" CreationDate="2014-05-03T12:45:08.077" UserId="1230" Comment="added details of the behavior under fully charged baterries" Text="My Arduino UNO board is part of a small robot that works when connected to the laptop by USB but it does not when plugged to the batteries. The baterries plug seems okay, it outputs 7.8 V. My UNO is connected to an ArduMoto board that manages the robot motors as well as a bluetooth chip. I have little experience with Arduino or electronics in general so I am stuck on the best course of action.&#xD;&#xA;&#xD;&#xA;1) Can I find out what is wrong with the power supply without completely isolating UNO from the robot?&#xD;&#xA;&#xD;&#xA;2) If I separate UNO, how can I find out with certainty if my UNO power supply is damaged or not? Is there something in particular that I could measure with my multimeter?&#xD;&#xA;&#xD;&#xA;UPDATE&#xD;&#xA;&#xD;&#xA;After fully charging my batteries I observed that the LEDs attached to the motor outputs are blinking fast. They blink for about one minute then nothing happens anymore. On USB everything works as expected. Those LEDs show that signal is going towards the motors, but why is it so different to USB? On USB power, the LEDs blink only when I command the robot to move through the BT board while under baterries they blink furiously for a minute and that is all that happens.&#xD;&#xA;&#xD;&#xA;I also don't know what happened to the batteries, they seem to be fully drained in just one minute, but I don't know how to test that, they appear to still have high voltage.&#xD;&#xA;&#xD;&#xA;I use two LC 18650 4800 mAh 3.7 V UltraFire baterries. The motor shield is Ardumoto Keyes_L298P, very similar to [Sparkfun's Ardumoto shield][1].&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://www.sparkfun.com/products/9815" />
  <row Id="3963" PostHistoryTypeId="6" PostId="1351" RevisionGUID="95cf95ed-c11e-4c84-aabd-dfd41086ce23" CreationDate="2014-05-03T12:45:08.077" UserId="1230" Comment="added details of the behavior under fully charged baterries" Text="&lt;arduino-uno&gt;&lt;shields&gt;&lt;power&gt;&lt;arduino-motor-shield&gt;" />
  <row Id="3964" PostHistoryTypeId="5" PostId="1351" RevisionGUID="c37448b5-31a6-47b1-8014-aebac5085a66" CreationDate="2014-05-03T12:55:56.430" UserId="1230" Comment="added details of the behavior under fully charged batteries, and details for batteries, motor shield, robot and code" Text="My Arduino UNO board is part of a [small robot][1] that works when connected to the laptop by USB but it does not when plugged to the batteries. The baterries plug seems okay, it outputs 7.8 V. My UNO is connected to an ArduMoto board that manages the robot motors as well as a bluetooth chip. I have little experience with Arduino or electronics in general so I am stuck on the best course of action.&#xD;&#xA;&#xD;&#xA;1) Can I find out what is wrong with the power supply without completely isolating UNO from the robot?&#xD;&#xA;&#xD;&#xA;2) If I separate UNO, how can I find out with certainty if my UNO power supply is damaged or not? Is there something in particular that I could measure with my multimeter?&#xD;&#xA;&#xD;&#xA;UPDATE&#xD;&#xA;&#xD;&#xA;After fully charging my batteries I observed that the LEDs attached to the motor outputs are blinking fast. They blink for about one minute then nothing happens anymore. On USB everything works as expected. Those LEDs show that signal is going towards the motors, but why is it so different to USB? On USB power, the LEDs blink only when I command the robot to move through the BT board while under baterries they blink furiously for a minute and that is all that happens.&#xD;&#xA;&#xD;&#xA;I also don't know what happened to the batteries, they seem to be fully drained in just one minute, but I don't know how to test that, they appear to still have high voltage.&#xD;&#xA;&#xD;&#xA;I use two LC 18650 4800 mAh 3.7 V UltraFire baterries. The motor shield is Ardumoto Keyes_L298P, very similar to [Sparkfun's Ardumoto shield][2].&#xD;&#xA;&#xD;&#xA;I do not have the actual code that is on my Arduino. It must be similar to the code on [this page][3], since I am using their Android app for BT communication with my robot, and it works on USB power supply.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://www.hobbyking.com/hobbyking/store/__37893__Arduino_Tracked_Cellphone_Bluetooth_Robot_Kit.html&#xD;&#xA;  [2]: https://www.sparkfun.com/products/9815&#xD;&#xA;  [3]: http://www.mobot.es/MobotBTCar.html" />
  <row Id="3965" PostHistoryTypeId="5" PostId="1384" RevisionGUID="725f2c3d-68cc-43bc-96b1-0c4273be4948" CreationDate="2014-05-03T13:00:04.540" UserId="1290" Comment="added 111 characters in body; added 15 characters in body" Text="I have a stepper motor connected to my Arduino like this:&#xA;&#xA;![Circuit Diagram][1]    &#xA;![Image][2]&#xA;(Ignore the potentiometer)&#xA;&#xA;And I have programmed it with the following code:&#xA;&#xA;    #include &lt;Stepper.h&gt;&#xA;&#xA;    int in1Pin = 22;&#xA;    int in2Pin = 23;&#xA;    int in3Pin = 24;&#xA;    int in4Pin = 25;&#xA;    &#xA;    Stepper motor(512, in1Pin, in2Pin, in3Pin, in4Pin);&#xA;&#xA;    void setup()&#xA;    {&#xA;        pinMode(in1Pin, OUTPUT);&#xA;        pinMode(in2Pin, OUTPUT);&#xA;        pinMode(in3Pin, OUTPUT);&#xA;        pinMode(in4Pin, OUTPUT);&#xA;      &#xA;        motor.setSpeed(25);&#xA;    }&#xA;&#xA;    void loop()&#xA;    {&#xA;        int steps = 360;&#xA;&#xA;        motor.step(steps);&#xA;        delay(500);&#xA;    }&#xA;&#xA;At the moment the motor rotates clockwise, how could I have it so it rotates in the opposite direction?&#xA;&#xA;My code was copied and edited from &lt;url=learn.adafruit.com/adafruit-arduino-lesson-16-stepper-motors/arduino-code&gt;here&lt;/url&gt;&#xA;&#xA;[1]: http://arduino.cc/en/uploads/Reference/unipolar_stepper_four_pins.jpg&#xA;[2]: http://static.flickr.com/32/54357295_756c131217.jpg" />
  <row Id="3966" PostHistoryTypeId="5" PostId="1384" RevisionGUID="2d260a99-e121-491e-9232-e331673ab9f3" CreationDate="2014-05-03T13:01:55.577" UserId="220" Comment="Fixed link" Text="I have a stepper motor connected to my Arduino like this:&#xD;&#xA;&#xD;&#xA;![Circuit Diagram][1]    &#xD;&#xA;![Image][2]&#xD;&#xA;(Ignore the potentiometer)&#xD;&#xA;&#xD;&#xA;And I have programmed it with the following code:&#xD;&#xA;&#xD;&#xA;    #include &lt;Stepper.h&gt;&#xD;&#xA;&#xD;&#xA;    int in1Pin = 22;&#xD;&#xA;    int in2Pin = 23;&#xD;&#xA;    int in3Pin = 24;&#xD;&#xA;    int in4Pin = 25;&#xD;&#xA;    &#xD;&#xA;    Stepper motor(512, in1Pin, in2Pin, in3Pin, in4Pin);&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        pinMode(in1Pin, OUTPUT);&#xD;&#xA;        pinMode(in2Pin, OUTPUT);&#xD;&#xA;        pinMode(in3Pin, OUTPUT);&#xD;&#xA;        pinMode(in4Pin, OUTPUT);&#xD;&#xA;      &#xD;&#xA;        motor.setSpeed(25);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        int steps = 360;&#xD;&#xA;&#xD;&#xA;        motor.step(steps);&#xD;&#xA;        delay(500);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;At the moment the motor rotates clockwise, how could I have it so it rotates in the opposite direction?&#xD;&#xA;&#xD;&#xA;My code was copied and edited from [here](http://learn.adafruit.com/adafruit-arduino-lesson-16-stepper-motors/arduino-code).&#xD;&#xA;&#xD;&#xA;[1]: http://arduino.cc/en/uploads/Reference/unipolar_stepper_four_pins.jpg&#xD;&#xA;[2]: http://static.flickr.com/32/54357295_756c131217.jpg" />
  <row Id="3967" PostHistoryTypeId="4" PostId="1351" RevisionGUID="461b3e1b-0aa9-4d5c-b459-b3f6309acfae" CreationDate="2014-05-03T13:02:50.563" UserId="1230" Comment="edited title" Text="Arduino Uno + Ardumoto + BT robot works from USB but not from baterries" />
  <row Id="3968" PostHistoryTypeId="5" PostId="1384" RevisionGUID="eaf80add-26d9-4fd4-be85-206442ac4216" CreationDate="2014-05-03T13:05:29.587" UserId="1290" Comment="added 36 characters in body" Text="I have a stepper motor connected to my Arduino like this using the ULN2003A Darlington Array:&#xD;&#xA;&#xD;&#xA;![Circuit Diagram][1]    &#xD;&#xA;![Image][2]&#xD;&#xA;(Ignore the potentiometer)&#xD;&#xA;&#xD;&#xA;And I have programmed it with the following code:&#xD;&#xA;&#xD;&#xA;    #include &lt;Stepper.h&gt;&#xD;&#xA;&#xD;&#xA;    int in1Pin = 22;&#xD;&#xA;    int in2Pin = 23;&#xD;&#xA;    int in3Pin = 24;&#xD;&#xA;    int in4Pin = 25;&#xD;&#xA;    &#xD;&#xA;    Stepper motor(512, in1Pin, in2Pin, in3Pin, in4Pin);&#xD;&#xA;&#xD;&#xA;    void setup()&#xD;&#xA;    {&#xD;&#xA;        pinMode(in1Pin, OUTPUT);&#xD;&#xA;        pinMode(in2Pin, OUTPUT);&#xD;&#xA;        pinMode(in3Pin, OUTPUT);&#xD;&#xA;        pinMode(in4Pin, OUTPUT);&#xD;&#xA;      &#xD;&#xA;        motor.setSpeed(25);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    void loop()&#xD;&#xA;    {&#xD;&#xA;        int steps = 360;&#xD;&#xA;&#xD;&#xA;        motor.step(steps);&#xD;&#xA;        delay(500);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;At the moment the motor rotates clockwise, how could I have it so it rotates in the opposite direction?&#xD;&#xA;&#xD;&#xA;My code was copied and edited from [here](http://learn.adafruit.com/adafruit-arduino-lesson-16-stepper-motors/arduino-code).&#xD;&#xA;&#xD;&#xA;[1]: http://arduino.cc/en/uploads/Reference/unipolar_stepper_four_pins.jpg&#xD;&#xA;[2]: http://static.flickr.com/32/54357295_756c131217.jpg" />
  <row Id="3969" PostHistoryTypeId="2" PostId="1386" RevisionGUID="839f3039-0314-4975-a0ea-8898e27f36d6" CreationDate="2014-05-03T16:12:09.187" UserId="1112" Text="I'm using an Arduino Due with a logic level converter to interface with two different 5v sensors via I2C. Being of poor quality, these sensors have no data sheet. &#xD;&#xA;&#xD;&#xA;When either one of these sensors is plugged in, I am able to read from it without issue. The moment I plug the other one in as well, the I2C stops working and I just get 0. I know that its not an address collision issue because they have different addresses. &#xD;&#xA;&#xD;&#xA;I tried adding an additional set of pull up resistors (such that they are in parallel with the built-in ones) in order to counteract potentially increased bus capacitance but no dice.&#xD;&#xA;&#xD;&#xA;What could be causing this issue? I apologise for asking such a noob question. " />
  <row Id="3970" PostHistoryTypeId="1" PostId="1386" RevisionGUID="839f3039-0314-4975-a0ea-8898e27f36d6" CreationDate="2014-05-03T16:12:09.187" UserId="1112" Text="Adding devices makes I2C read 0" />
  <row Id="3971" PostHistoryTypeId="3" PostId="1386" RevisionGUID="839f3039-0314-4975-a0ea-8898e27f36d6" CreationDate="2014-05-03T16:12:09.187" UserId="1112" Text="&lt;arduino-due&gt;&lt;voltage-level&gt;&lt;i2c&gt;" />
  <row Id="3972" PostHistoryTypeId="2" PostId="1387" RevisionGUID="8d01b29e-d865-4507-80c9-7815172aa23c" CreationDate="2014-05-03T17:01:21.947" UserId="1294" Text="I wanted to take the audio from a device such as the PC, insert it through different ADC in arduino, processing them with DSP and DAC REnter all through to the other speakers, reading here and there on the internet but some people were put in difficulty because Arduino has a data bus to 10 bits. What problems can cause this? I can not send the same 10 bits at a time, until you arrive at 32?" />
  <row Id="3973" PostHistoryTypeId="1" PostId="1387" RevisionGUID="8d01b29e-d865-4507-80c9-7815172aa23c" CreationDate="2014-05-03T17:01:21.947" UserId="1294" Text="Arduino 1 can somehow support 32-bit audio?" />
  <row Id="3974" PostHistoryTypeId="3" PostId="1387" RevisionGUID="8d01b29e-d865-4507-80c9-7815172aa23c" CreationDate="2014-05-03T17:01:21.947" UserId="1294" Text="&lt;arduino-uno&gt;" />
  <row Id="3975" PostHistoryTypeId="2" PostId="1388" RevisionGUID="808829e7-14c3-48e9-ab58-54083772fbc7" CreationDate="2014-05-03T17:20:21.887" UserId="220" Text="First of all,*what is the point of this?* [I'm afraid this is a XY question](http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem). You won't get that good of quality with Arduino. If you're hoping to create some sort of an amp, learn electronics and do that directly. Maybe you should just send data via serial.&#xD;&#xA;&#xD;&#xA;Anyway, that aside, here's a chart I drew:&#xD;&#xA;&#xD;&#xA;![][1]&#xD;&#xA;(Excuse my poor image alignment, PowerPoint was being a little mean today)&#xD;&#xA;&#xD;&#xA;The bottom is all the &quot;channels&quot; the PC can send. The top is all the &quot;channels&quot; the Arduino can recieve. As you can see, there's a *huge* degradation in quality. Not to mention, I made this that 1 bit = 1 &quot;channel,&quot; yet it's very much more than that.&#xD;&#xA;&#xD;&#xA;A standard Arduino (Uno, Leonardo, etc.) has a 10 bit ADC that can read values 0-1023. The computer can output 0-4294967295! (It' exponentially grows due to permutations). You can see why I very much simplified my chart! :P&#xD;&#xA;&#xD;&#xA;DSP won't really work well, unless you are trying to do some weird alien sounding modifications or a cheesy echo to. You probably will want to add an external 32 bit ADC. I would recommend, additionally, adding a Due or Galileo that can process 32 bit integers without emulating a bigger chip, thus greatly reducing performance and giving you a low framerate.&#xD;&#xA;&#xD;&#xA;tl;dr: It'll work fine, but it'll have horrible sound quality. You can't send the same 10 bits until 32, since the computer changes that 32 bits into a voltage (sent to Arduino), and the Arduino translates that voltage into 10 bits.&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/L8BAr.png" />
  <row Id="3977" PostHistoryTypeId="2" PostId="1389" RevisionGUID="781c6ef2-c594-4cdb-b2a8-69a51d9c65b9" CreationDate="2014-05-03T17:29:19.923" UserId="46" Text="I finally found what was causing the problem: the reset signal from pin 4 (DTR - Data Terminal Ready) on the DB9-Female connector was spiking up to 10V before going to 0V and was triggering high-voltage programming on the ATmega. Below is a scope shot showing the situation:&#xD;&#xA;&#xD;&#xA;![Scope shot showing voltage spike to 10V][1]&#xD;&#xA;&#xD;&#xA;The yellow trace is `DTR` signal while the green trace is the `RESET` signal on the ATmega.&#xD;&#xA;&#xD;&#xA;According to Atmel's [Atmel AVR042: AVR Hardware Design Considerations application note](http://www.atmel.com/images/atmel-2521-avr-hardware-design-considerations_application-note_avr042.pdf), one should add an ESD diode between ATmega's `RESET` and `Vcc` to prevent the reset signal from triggering high-voltage programming mode, like so:&#xD;&#xA;&#xD;&#xA;![Recommended RESET pin connection for ATmegas][2]&#xD;&#xA;&#xD;&#xA;After adding such a small signal diode (1N4148) like the app note recommended, I got the issue fixed. See below the scope shot taken after the diode was added.&#xD;&#xA;&#xD;&#xA;![Scope shot after fixing the board][3]&#xD;&#xA;&#xD;&#xA;Now the 10V peak is gone. &#xD;&#xA;&#xD;&#xA;That was a tricky one!! But I could never find what was wrong without research and the right tools. Money on a scope is money well spent!!&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/IM3RF.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/GJuGd.png&#xD;&#xA;  [3]: http://i.stack.imgur.com/kwpzB.png" />
  <row Id="3978" PostHistoryTypeId="10" PostId="1374" RevisionGUID="ecf0d10d-e482-43be-8584-21938ad534ef" CreationDate="2014-05-03T18:29:29.080" UserId="11" Comment="101" Text="{&quot;OriginalQuestionIds&quot;:[1312],&quot;Voters&quot;:[{&quot;Id&quot;:368,&quot;DisplayName&quot;:&quot;Ignacio Vazquez-Abrams&quot;},{&quot;Id&quot;:11,&quot;DisplayName&quot;:&quot;sachleen&quot;}]}" />
  <row Id="3979" PostHistoryTypeId="2" PostId="1390" RevisionGUID="a99a806a-fbd1-474b-9c85-f49e0cfaa839" CreationDate="2014-05-03T19:28:29.243" UserId="1296" Text="How to make an input from computer using processing (like a password form) and trigger pin in arduino?&#xA;If you let some link to read more that would be very helpful." />
  <row Id="3980" PostHistoryTypeId="1" PostId="1390" RevisionGUID="a99a806a-fbd1-474b-9c85-f49e0cfaa839" CreationDate="2014-05-03T19:28:29.243" UserId="1296" Text="Processing Input" />
  <row Id="3981" PostHistoryTypeId="3" PostId="1390" RevisionGUID="a99a806a-fbd1-474b-9c85-f49e0cfaa839" CreationDate="2014-05-03T19:28:29.243" UserId="1296" Text="&lt;arduino-uno&gt;&lt;programming&gt;" />
  <row Id="3982" PostHistoryTypeId="2" PostId="1391" RevisionGUID="0eaa0705-9418-435b-8cb4-8bb53e6f2980" CreationDate="2014-05-03T19:56:33.070" UserId="667" Text="I'm using the [Pololu DRV8825 Stepper Motor Driver](http://www.pololu.com/product/2132) to control a [NEMA 17 Steppermotor](http://www.ebay.co.uk/itm/Nema-17-1-7A-2-55V-Motor-ACT-17HS4417-Rep-rap-Nema17-Bipolar-/281122696759) with an Arduino Uno.  According to the Pololu website, the circuit should be wired as follows:&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;I did, however, deviate from this exact sketch a little bit:&#xD;&#xA;&#xD;&#xA; 1. The Arduino (microcontroller) is powered by a USB cable connected to the computer&#xD;&#xA; 2. I connected the 5V pin on the arduino to the + rail on a breadboard.  I then connected two wires on this rail to the **RESET** and **SLEEP** pins on the driver.&#xD;&#xA; 3. I'm using a 9V motor power supply (8 double AA batteries).&#xD;&#xA; 4. I've connected the **DIR** and **STEP** pins to Arduino Uno pins 12 &amp; 13, respectively.&#xD;&#xA;&#xD;&#xA;Consequently, I coded and uploaded the following sketch:&#xD;&#xA;&#xD;&#xA;    int stp = 13;  //connect pin 13 to step&#xD;&#xA;    int dir = 12;  // connect pin 12 to dir&#xD;&#xA;    int a = 0;     //  gen counter&#xD;&#xA;    &#xD;&#xA;    void setup() &#xD;&#xA;    {                &#xD;&#xA;      pinMode(stp, OUTPUT);&#xD;&#xA;      pinMode(dir, OUTPUT);       &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() &#xD;&#xA;    {&#xD;&#xA;      if (a &lt;  200)  //sweep 200 step in dir 1&#xD;&#xA;       {&#xD;&#xA;        a++;&#xD;&#xA;        digitalWrite(stp, HIGH);   &#xD;&#xA;        delay(10);               &#xD;&#xA;        digitalWrite(stp, LOW);  &#xD;&#xA;        delay(10);              &#xD;&#xA;       }&#xD;&#xA;      else &#xD;&#xA;       {&#xD;&#xA;        digitalWrite(dir, HIGH);&#xD;&#xA;        a++;&#xD;&#xA;        digitalWrite(stp, HIGH);  &#xD;&#xA;        delay(10);               &#xD;&#xA;        digitalWrite(stp, LOW);  &#xD;&#xA;        delay(10);&#xD;&#xA;        &#xD;&#xA;        if (a&gt;400)    //sweep 200 in dir 2&#xD;&#xA;         {&#xD;&#xA;          a = 0;&#xD;&#xA;          digitalWrite(dir, LOW);&#xD;&#xA;         }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**RESULT**  &#xD;&#xA;The stepper motor does not turn.  Instead, it just hisses at a high pitch.  After a short while, the driver gets very hot.&#xD;&#xA;&#xD;&#xA;**THINGS I'VE TRIED**&#xD;&#xA;&#xD;&#xA; 1. I double checked to make sure that connected stepper wires pairs are properly connected to the &quot;A&quot; pins and &quot;B&quot; pins on the driver.&#xD;&#xA; 2. I tried reversing the A1-A2 pair and B1-B2 pair in all possible combinations.  All combinations produce the same result as above.&#xD;&#xA; 3. I tried increasing the motor power supply to 12V.  The same result occurs.&#xD;&#xA; 4. I double checked to make sure the 100microF radial electrolytic capacitor is connected with the long end to the positive motor supply and short end to the negative motor supply (on a different breadboard rail than the logic power supply, of course).&#xD;&#xA; 5. I tried using the 3.3V pin instead of the 5V pin to connect to SLEEP and RESET on the driver.  Again, the same result occurs.  &#xD;&#xA;&#xD;&#xA;I'm not really sure what to try next to debug my circuit.  &#xD;&#xA;&#xD;&#xA;**My Hunch:**  &#xD;&#xA;&#xD;&#xA;I do, however, have one suspicion based on a little warning box on the pololu website which reads:&#xD;&#xA;&#xD;&#xA;&gt; **Caution:** Installing the header pins so that the silkscreen side is up&#xD;&#xA;&gt; and the components are down can limit the range of motion of the&#xD;&#xA;&gt; trimpot used to set the current limit. If you plan on installing the&#xD;&#xA;&gt; header pins in this orientation, please set the current limit before&#xD;&#xA;&gt; soldering in the pins.&#xD;&#xA;&#xD;&#xA;The way I soldered the headers onto the driver looks like the bottom left corner of the picture below:&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;**My Question:**  &#xD;&#xA;Given that my stepper motor requires 1.7A current, is there anything I can do to improve this circuit to make it work?  Did I make any mistakes?  Is there anything else I should try or check?  Did I solder the header in the wrong way?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/x76EK.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/I4p4R.jpg" />
  <row Id="3983" PostHistoryTypeId="1" PostId="1391" RevisionGUID="0eaa0705-9418-435b-8cb4-8bb53e6f2980" CreationDate="2014-05-03T19:56:33.070" UserId="667" Text="Debugging my Stepper Motor Driver circuit" />
  <row Id="3984" PostHistoryTypeId="3" PostId="1391" RevisionGUID="0eaa0705-9418-435b-8cb4-8bb53e6f2980" CreationDate="2014-05-03T19:56:33.070" UserId="667" Text="&lt;motor&gt;" />
  <row Id="3985" PostHistoryTypeId="2" PostId="1392" RevisionGUID="b306f850-3be0-4532-a96a-311307f2d962" CreationDate="2014-05-03T21:06:10.007" UserId="1297" Text="We are trying to make a gesture controlled car. &#xD;&#xA;We are able to move the car using the 3-axis accelerometer. &#xD;&#xA;&#xD;&#xA;Now we wish to move it through bluetooth modules one on the car and second attached to wrist band. &#xD;&#xA;How do we connect and transmit signals. &#xD;&#xA;Help" />
  <row Id="3986" PostHistoryTypeId="1" PostId="1392" RevisionGUID="b306f850-3be0-4532-a96a-311307f2d962" CreationDate="2014-05-03T21:06:10.007" UserId="1297" Text="Connection of 2 Bluetooth modules on ATMega 328 and duemilanove" />
  <row Id="3987" PostHistoryTypeId="3" PostId="1392" RevisionGUID="b306f850-3be0-4532-a96a-311307f2d962" CreationDate="2014-05-03T21:06:10.007" UserId="1297" Text="&lt;bluetooth&gt;&lt;atmega328&gt;" />
  <row Id="3988" PostHistoryTypeId="5" PostId="1392" RevisionGUID="82637f7e-60ec-4602-9d3f-03631c6a4a26" CreationDate="2014-05-03T21:24:18.040" UserId="1297" Comment="The components in use ." Text="We are trying to make a gesture controlled car. &#xD;&#xA;We are able to move the car using the 3-axis accelerometer. &#xD;&#xA;&#xD;&#xA;Now we wish to move it through bluetooth modules one on the car and second attached to wrist band. &#xD;&#xA;How do we connect and transmit signals. &#xD;&#xA;Help&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Our bluetooth modules Xbee socket compatible RN - 42 Bluetooth Module (Blue Bee) [x2]&#xD;&#xA;The arduino board we are using are Atmega 8 and Atmega 328 duemilanove&#xD;&#xA;The accelerometer in use is 3-Axis MMA7660FC Accelerometer" />
  <row Id="3989" PostHistoryTypeId="4" PostId="1392" RevisionGUID="82637f7e-60ec-4602-9d3f-03631c6a4a26" CreationDate="2014-05-03T21:24:18.040" UserId="1297" Comment="The components in use ." Text="Connection on ATMega 328 and duemilanove Arduino boards using 2 Bluetooth modules" />
  <row Id="3990" PostHistoryTypeId="2" PostId="1393" RevisionGUID="eb903d34-48b7-453e-9da8-d90e7bdb2de4" CreationDate="2014-05-03T22:28:48.937" UserId="220" Text="**A couple things I noticed first:** This is one of the best formatted questions I've ever seen... :) Anyway, your circuit looks fine to me except for a few things:&#xD;&#xA;&#xD;&#xA;&gt; **Warning:** This carrier board uses low-ESR ceramic capacitors, which makes it susceptible to destructive LC voltage spikes, especially when using power leads longer than a few inches. Under the right conditions, these spikes can exceed the 45 V maximum voltage rating for the DRV8825 and permanently damage the board, even when the motor supply voltage is as low as 12 V. One way to protect the driver from such spikes is to put a large **(at least 47 µF) *electrolytic* capacitor across motor power (VMOT) and ground** somewhere close to the board.&#xD;&#xA;&#xD;&#xA;*(Added some italic/bold myself, quote from product page.)*&#xD;&#xA;&#xD;&#xA;Capacitors are cheap ($1.50 on eBay from US), and although new drivers are too, it's generally a good idea to build it right. There's nothing more annoying than waiting for shipping on something you shouldn't have had to fix.&#xD;&#xA;&#xD;&#xA;Additionally, battery power (especially AAs) can be bulky if not done right, and may not provide enough current. Note that in a series configuration that **it will provide the voltage of 8 AAs, but only the current of one.** You can't run a 1.7 A motor off of a single AA's current. Stab in the dark guess: you'll need ~80-100 AAs to provide enough current and voltage. I'm too lazy to measure the internal resistance and actually calculate it.&#xD;&#xA;&#xD;&#xA;**Suggested solution:** There are a million things that could go wrong. Without being there, I'm betting that your delay function is too short. What this will do is not provide enough time for the motor to move, thus it staying still. This would still use a lot of current (50% of the time it's full current to motor coils), therefore it would make the driver hot. (**Note on heat:** *...to supply more than approximately 1.5 A per coil, a heat sink or other cooling method is required...* -Product page: you'll need a heatsink to cool your chip down.) Also note that some heat is normal; a general rule of thumb is if it's too hot to hold your thumb on it for a few seconds, you need more cooling. Remember that the more it's used, the hotter it'll get, so keep this in mind when deciding if you want to add a heatsink.&#xD;&#xA;&#xD;&#xA;**tl;dr:** You need to increase the delay time and provide more current than you have currently." />
  <row Id="3991" PostHistoryTypeId="5" PostId="1391" RevisionGUID="64cd0c6d-db0d-4bc9-8377-d78d9b8d3918" CreationDate="2014-05-03T22:31:36.487" UserId="667" Comment="deleted 24 characters in body" Text="I'm using the [Pololu DRV8825 Stepper Motor Driver](http://www.pololu.com/product/2132) to control a [NEMA 17 Steppermotor](http://www.ebay.co.uk/itm/Nema-17-1-7A-2-55V-Motor-ACT-17HS4417-Rep-rap-Nema17-Bipolar-/281122696759) with an Arduino Uno.  According to the Pololu website, the circuit should be wired as follows:&#xD;&#xA;&#xD;&#xA;![enter image description here][1]&#xD;&#xA;&#xD;&#xA;I did, however, deviate from this exact sketch a little bit:&#xD;&#xA;&#xD;&#xA; 1. The Arduino (microcontroller) is powered by a USB cable connected to the computer&#xD;&#xA; 2. I connected the 5V pin on the arduino to the + rail on a breadboard.  I then connected two wires on this rail to the **RESET** and **SLEEP** pins on the driver.&#xD;&#xA; 3. I'm using a 9V motor power supply.&#xD;&#xA; 4. I've connected the **DIR** and **STEP** pins to Arduino Uno pins 12 &amp; 13, respectively.&#xD;&#xA;&#xD;&#xA;Consequently, I coded and uploaded the following sketch:&#xD;&#xA;&#xD;&#xA;    int stp = 13;  //connect pin 13 to step&#xD;&#xA;    int dir = 12;  // connect pin 12 to dir&#xD;&#xA;    int a = 0;     //  gen counter&#xD;&#xA;    &#xD;&#xA;    void setup() &#xD;&#xA;    {                &#xD;&#xA;      pinMode(stp, OUTPUT);&#xD;&#xA;      pinMode(dir, OUTPUT);       &#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    void loop() &#xD;&#xA;    {&#xD;&#xA;      if (a &lt;  200)  //sweep 200 step in dir 1&#xD;&#xA;       {&#xD;&#xA;        a++;&#xD;&#xA;        digitalWrite(stp, HIGH);   &#xD;&#xA;        delay(10);               &#xD;&#xA;        digitalWrite(stp, LOW);  &#xD;&#xA;        delay(10);              &#xD;&#xA;       }&#xD;&#xA;      else &#xD;&#xA;       {&#xD;&#xA;        digitalWrite(dir, HIGH);&#xD;&#xA;        a++;&#xD;&#xA;        digitalWrite(stp, HIGH);  &#xD;&#xA;        delay(10);               &#xD;&#xA;        digitalWrite(stp, LOW);  &#xD;&#xA;        delay(10);&#xD;&#xA;        &#xD;&#xA;        if (a&gt;400)    //sweep 200 in dir 2&#xD;&#xA;         {&#xD;&#xA;          a = 0;&#xD;&#xA;          digitalWrite(dir, LOW);&#xD;&#xA;         }&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;**RESULT**  &#xD;&#xA;The stepper motor does not turn.  Instead, it just hisses at a high pitch.  After a short while, the driver gets very hot.&#xD;&#xA;&#xD;&#xA;**THINGS I'VE TRIED**&#xD;&#xA;&#xD;&#xA; 1. I double checked to make sure that connected stepper wires pairs are properly connected to the &quot;A&quot; pins and &quot;B&quot; pins on the driver.&#xD;&#xA; 2. I tried reversing the A1-A2 pair and B1-B2 pair in all possible combinations.  All combinations produce the same result as above.&#xD;&#xA; 3. I tried increasing the motor power supply to 12V.  The same result occurs.&#xD;&#xA; 4. I double checked to make sure the 100microF radial electrolytic capacitor is connected with the long end to the positive motor supply and short end to the negative motor supply (on a different breadboard rail than the logic power supply, of course).&#xD;&#xA; 5. I tried using the 3.3V pin instead of the 5V pin to connect to SLEEP and RESET on the driver.  Again, the same result occurs.  &#xD;&#xA;&#xD;&#xA;I'm not really sure what to try next to debug my circuit.  &#xD;&#xA;&#xD;&#xA;**My Hunch:**  &#xD;&#xA;&#xD;&#xA;I do, however, have one suspicion based on a little warning box on the pololu website which reads:&#xD;&#xA;&#xD;&#xA;&gt; **Caution:** Installing the header pins so that the silkscreen side is up&#xD;&#xA;&gt; and the components are down can limit the range of motion of the&#xD;&#xA;&gt; trimpot used to set the current limit. If you plan on installing the&#xD;&#xA;&gt; header pins in this orientation, please set the current limit before&#xD;&#xA;&gt; soldering in the pins.&#xD;&#xA;&#xD;&#xA;The way I soldered the headers onto the driver looks like the bottom left corner of the picture below:&#xD;&#xA;&#xD;&#xA;![enter image description here][2]&#xD;&#xA;&#xD;&#xA;**My Question:**  &#xD;&#xA;Given that my stepper motor requires 1.7A current, is there anything I can do to improve this circuit to make it work?  Did I make any mistakes?  Is there anything else I should try or check?  Did I solder the header in the wrong way?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://i.stack.imgur.com/x76EK.png&#xD;&#xA;  [2]: http://i.stack.imgur.com/I4p4R.jpg" />
</posthistory>